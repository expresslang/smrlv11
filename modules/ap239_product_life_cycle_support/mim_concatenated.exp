(* Concatenated File produced by Express Engine
     5.2.2 (GIT eeng-5.1.4-62-gb392ac4)
     Steel Bank CL 2.4.0 (Unknown Bits)

   In Directory: /Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_product_life_cycle_support/
   Commandline:
     eengine --concat_schema
       -schema mim.exp
       -stepmod ../../..
       -mode mim_shortform
*)

(* 245 Schemata for Concatenated File

action_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/action_schema/action_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:13 GMT
   Version:   {iso standard 10303 part(41) version(9) object(1) action_schema(1)}

activity_as_realized_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/activity_as_realized/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:10:42 GMT
   Version:   <<No Schema Version String>>

activity_characterized_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/activity_characterized/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:10:42 GMT
   Version:   <<No Schema Version String>>

activity_method_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/activity_method_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:10:42 GMT
   Version:   <<No Schema Version String>>

activity_method_characterized_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/activity_method_characterized/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:10:42 GMT
   Version:   <<No Schema Version String>>

activity_method_implementation_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/activity_method_implementation/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:10:42 GMT
   Version:   <<No Schema Version String>>

activity_method_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/activity_method/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:10:42 GMT
   Version:   <<No Schema Version String>>

activity_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/activity/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:10:42 GMT
   Version:   <<No Schema Version String>>

alternative_solution_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/alternative_solution/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:10:44 GMT
   Version:   <<No Schema Version String>>

analysis_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/analysis_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:10:44 GMT
   Version:   <<No Schema Version String>>

analysis_characterized_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/analysis_characterized/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:10:44 GMT
   Version:   <<No Schema Version String>>

analysis_identification_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/analysis_identification/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:10:44 GMT
   Version:   <<No Schema Version String>>

analysis_product_relationships_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/analysis_product_relationships_schema/analysis_product_relationships_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:13 GMT
   Version:   {iso standard 10303 part(53) version(1) object(1) analysis_product_relationships_schema(1)}

analysis_representation_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/analysis_representation/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:10:44 GMT
   Version:   <<No Schema Version String>>

analysis_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/analysis_schema/analysis_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:13 GMT
   Version:   {iso standard 10303 part(53) version(1) object(1) analysis_schema(3)}

ap239_activity_recording_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_activity_recording/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:05 GMT
   Version:   <<No Schema Version String>>

ap239_document_management_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_document_management/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:05 GMT
   Version:   <<No Schema Version String>>

ap239_management_resource_information_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_management_resource_information/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:05 GMT
   Version:   <<No Schema Version String>>

ap239_part_definition_information_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_part_definition_information/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:05 GMT
   Version:   <<No Schema Version String>>

ap239_product_definition_information_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_product_definition_information/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2024-02-23 15:23:45 GMT
   Version:   <<No Schema Version String>>

ap239_product_life_cycle_support_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_product_life_cycle_support/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:07 GMT
   Version:   <<No Schema Version String>>

ap239_product_status_recording_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_product_status_recording/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:08 GMT
   Version:   <<No Schema Version String>>

ap239_properties_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_properties/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:08 GMT
   Version:   <<No Schema Version String>>

ap239_task_specification_resourced_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_task_specification_resourced/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:09 GMT
   Version:   <<No Schema Version String>>

ap239_work_definition_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_work_definition/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:09 GMT
   Version:   <<No Schema Version String>>

application_context_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/application_context_schema/application_context_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:13 GMT
   Version:   {iso standard 10303 part(41) version(8) object(1) application_context_schema(2)}

approval_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/approval/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:12 GMT
   Version:   <<No Schema Version String>>

approval_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/approval_schema/approval_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:13 GMT
   Version:   {iso standard 10303 part(41) version(7) object(1) approval_schema(3)}

assembly_structure_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/assembly_structure/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:15 GMT
   Version:   <<No Schema Version String>>

assignment_object_relationship_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/assignment_object_relationship/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:15 GMT
   Version:   <<No Schema Version String>>

attachment_slot_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/attachment_slot/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:16 GMT
   Version:   <<No Schema Version String>>

attribute_classification_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/attribute_classification/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:16 GMT
   Version:   <<No Schema Version String>>

basic_attribute_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/basic_attribute_schema/basic_attribute_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:13 GMT
   Version:   {iso standard 10303 part(41) version(9) object(1) basic_attribute_schema(4)}

certification_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/certification/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:18 GMT
   Version:   <<No Schema Version String>>

certification_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/certification_schema/certification_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:13 GMT
   Version:   {iso standard 10303 part(41) version(3) object(1) certification_schema(5)}

characterizable_object_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/characterizable_object/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:19 GMT
   Version:   <<No Schema Version String>>

classification_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/classification_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:20 GMT
   Version:   <<No Schema Version String>>

classification_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/classification_schema/classification_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:13 GMT
   Version:   {iso standard 10303 part(54) version(1) object(1) classification_schema(1)}

classification_with_attributes_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/classification_with_attributes/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:21 GMT
   Version:   <<No Schema Version String>>

class_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/class/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:19 GMT
   Version:   <<No Schema Version String>>

collection_identification_and_version_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/collection_identification_and_version/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:21 GMT
   Version:   <<No Schema Version String>>

conditional_effectivity_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/conditional_effectivity/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:22 GMT
   Version:   <<No Schema Version String>>

condition_characterized_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/condition_characterized/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:22 GMT
   Version:   <<No Schema Version String>>

condition_evaluation_characterized_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/condition_evaluation_characterized/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:22 GMT
   Version:   <<No Schema Version String>>

condition_evaluation_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/condition_evaluation/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:22 GMT
   Version:   <<No Schema Version String>>

condition_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/condition/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:22 GMT
   Version:   <<No Schema Version String>>

configuration_effectivity_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/configuration_effectivity/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:23 GMT
   Version:   <<No Schema Version String>>

configuration_item_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/configuration_item/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:23 GMT
   Version:   <<No Schema Version String>>

configuration_management_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/configuration_management_schema/configuration_management_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:13 GMT
   Version:   {iso standard 10303 part(44) version(4) object(1) configuration_management_schema(3)}

contextual_shape_positioning_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/contextual_shape_positioning/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:24 GMT
   Version:   <<No Schema Version String>>

contract_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/contract/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:24 GMT
   Version:   <<No Schema Version String>>

contract_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/contract_schema/contract_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:13 GMT
   Version:   {iso standard 10303 part(41) version(3) object(1) contract_schema(6)}

counterbore_countersink_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/counterbore_countersink_schema/counterbore_countersink_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:13 GMT
   Version:   {iso standard 10303 part(113) version(2) object(1) counterbore_countersink_schema(1)}

date_time_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/date_time_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:24 GMT
   Version:   <<No Schema Version String>>

date_time_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/date_time/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:24 GMT
   Version:   <<No Schema Version String>>

date_time_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/date_time_schema/date_time_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:13 GMT
   Version:   {iso standard 10303 part(41) version(7) object(1) date_time_schema(7)}

description_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/description_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:25 GMT
   Version:   <<No Schema Version String>>

document_and_version_identification_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/document_and_version_identification/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:27 GMT
   Version:   <<No Schema Version String>>

document_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/document_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:27 GMT
   Version:   <<No Schema Version String>>

document_definition_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/document_definition/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:27 GMT
   Version:   <<No Schema Version String>>

document_management_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/document_management/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:27 GMT
   Version:   <<No Schema Version String>>

document_properties_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/document_properties/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:27 GMT
   Version:   <<No Schema Version String>>

document_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/document_schema/document_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:14 GMT
   Version:   {iso standard 10303 part(41) version(4) object(1) document_schema(8)}

document_structure_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/document_structure/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:27 GMT
   Version:   <<No Schema Version String>>

effectivity_application_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/effectivity_application/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:28 GMT
   Version:   <<No Schema Version String>>

effectivity_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/effectivity/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:28 GMT
   Version:   <<No Schema Version String>>

effectivity_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/effectivity_schema/effectivity_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:14 GMT
   Version:   {iso standard 10303 part(41) version(8) object(1) effectivity_schema(9)}

elemental_geometric_shape_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/elemental_geometric_shape/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-12-16 13:43:46 GMT
   Version:   <<No Schema Version String>>

elementary_function_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/elementary_function/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:28 GMT
   Version:   <<No Schema Version String>>

envelope_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/envelope/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:29 GMT
   Version:   <<No Schema Version String>>

event_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/event_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:29 GMT
   Version:   <<No Schema Version String>>

event_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/event/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:29 GMT
   Version:   <<No Schema Version String>>

experience_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/experience/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:29 GMT
   Version:   <<No Schema Version String>>

experience_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/experience_schema/experience_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:14 GMT
   Version:   {iso standard 10303 part(41) version(4) object(1) experience_schema(10)}

expression_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/expression/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:29 GMT
   Version:   <<No Schema Version String>>

extended_date_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/extended_date/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:29 GMT
   Version:   <<No Schema Version String>>

extended_measure_representation_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/extended_measure_representation/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:29 GMT
   Version:   <<No Schema Version String>>

extended_person_organization_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/extended_person_organization/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:30 GMT
   Version:   <<No Schema Version String>>

external_analysis_representation_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/external_analysis_representation/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:30 GMT
   Version:   <<No Schema Version String>>

external_class_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/external_class/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:30 GMT
   Version:   <<No Schema Version String>>

external_item_identification_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/external_item_identification_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:30 GMT
   Version:   <<No Schema Version String>>

external_library_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/external_library/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:30 GMT
   Version:   <<No Schema Version String>>

external_model_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/external_model/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:30 GMT
   Version:   <<No Schema Version String>>

external_properties_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/external_properties/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:30 GMT
   Version:   <<No Schema Version String>>

external_reference_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/external_reference_schema/external_reference_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:14 GMT
   Version:   {iso standard 10303 part(41) version(7) object(1) external_reference_schema(11)}

external_representation_item_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/external_representation_item/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:30 GMT
   Version:   <<No Schema Version String>>

external_source_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/external_source/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:31 GMT
   Version:   <<No Schema Version String>>

external_unit_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/external_unit/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:31 GMT
   Version:   <<No Schema Version String>>

fea_scalar_vector_tensor_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/fea_scalar_vector_tensor_schema/fea_scalar_vector_tensor_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:14 GMT
   Version:   {iso standard 10303 part(104) version(1) object(1) fea_scalar_vector_tensor_schema(1)}

file_identification_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/file_identification/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:32 GMT
   Version:   <<No Schema Version String>>

finite_element_analysis_control_and_result_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/finite_element_analysis_control_and_result_schema/finite_element_analysis_control_and_result_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:14 GMT
   Version:   {iso standard 10303 part(104) version(3) object(1) finite_element_analysis_control_and_result_schema(2)}

foundation_representation_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/foundation_representation/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:33 GMT
   Version:   <<No Schema Version String>>

foundation_state_definition_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/foundation_state_definition/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:33 GMT
   Version:   <<No Schema Version String>>

functional_breakdown_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/functional_breakdown/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:33 GMT
   Version:   <<No Schema Version String>>

generic_expression_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/generic_expression/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:35 GMT
   Version:   <<No Schema Version String>>

geometric_model_relationship_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/geometric_model_relationship/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:36 GMT
   Version:   <<No Schema Version String>>

geometric_model_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/geometric_model_schema/geometric_model_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2024-01-22 14:56:30 GMT
   Version:   {iso standard 10303 part(42) version(11) object(1) geometric_model_schema(3)}

geometry_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/geometry_schema/geometry_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2024-02-23 14:06:25 GMT
   Version:   {iso standard 10303 part(42) version(13) object(1) geometry_schema(1)}

group_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/group/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:36 GMT
   Version:   <<No Schema Version String>>

group_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/group_schema/group_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:14 GMT
   Version:   {iso standard 10303 part(41) version(7) object(1) group_schema(12)}

identification_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/identification_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:37 GMT
   Version:   <<No Schema Version String>>

identification_relationship_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/identification_relationship/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:37 GMT
   Version:   <<No Schema Version String>>

independent_property_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/independent_property/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:37 GMT
   Version:   <<No Schema Version String>>

independent_property_representation_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/independent_property_representation/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:37 GMT
   Version:   <<No Schema Version String>>

information_rights_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/information_rights/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:38 GMT
   Version:   <<No Schema Version String>>

interface_lifecycle_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/interface_lifecycle/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:39 GMT
   Version:   <<No Schema Version String>>

interface_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/interface/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:38 GMT
   Version:   <<No Schema Version String>>

iso13584_expressions_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/iso13584_expressions_schema/iso13584_expressions_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:14 GMT
   Version:   <<No Schema Version String>>

iso13584_generic_expressions_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/iso13584_generic_expressions_schema/iso13584_generic_expressions_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:14 GMT
   Version:   <<No Schema Version String>>

item_definition_structure_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/item_definition_structure/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:39 GMT
   Version:   <<No Schema Version String>>

justification_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/justification/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:39 GMT
   Version:   <<No Schema Version String>>

language_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/language_schema/language_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:14 GMT
   Version:   {iso standard 10303 part(41) version(1) object(1) location_schema(13)}

location_assignment_characterized_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/location_assignment_characterized/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:41 GMT
   Version:   <<No Schema Version String>>

location_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/location_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:41 GMT
   Version:   <<No Schema Version String>>

location_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/location/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:41 GMT
   Version:   <<No Schema Version String>>

location_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/location_schema/location_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:14 GMT
   Version:   {iso standard 10303 part(41) version(4) object(1) location_schema(13)}

machining_feature_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/machining_feature_schema/machining_feature_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:14 GMT
   Version:   {iso standard 10303 part(113) version(1) object(1) machining_feature_schema(2)}

management_resources_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/management_resources_schema/management_resources_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:14 GMT
   Version:   {iso standard 10303 part(41) version(8) object(1) management_resources_schema(15)}

management_resource_information_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/management_resource_information/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:42 GMT
   Version:   <<No Schema Version String>>

material_property_definition_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/material_property_definition_schema/material_property_definition_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:14 GMT
   Version:   {iso standard 10303 part(45) version(4) object(1) material_property_definition_schema(1)}

material_property_representation_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/material_property_representation_schema/material_property_representation_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:15 GMT
   Version:   {iso standard 10303 part(45) version(2) object(1) material_property_representation_schema(2)}

mathematical_context_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/mathematical_context_schema/mathematical_context_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:15 GMT
   Version:   {iso standard 10303 part(51) version(1) object(1) mathematical_context_schema(1)}

mathematical_description_of_distribution_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/mathematical_description_of_distribution_schema/mathematical_description_of_distribution_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:15 GMT
   Version:   {iso standard 10303 part(51) version(1) object(1) mathematical_description_of_distribution_schema(2)}

mathematical_functions_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/mathematical_functions_schema/mathematical_functions_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:15 GMT
   Version:   {iso standard 10303 part(50) version(3) object(1) mathematical_functions_schema(1)}

maths_value_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/maths_value/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:42 GMT
   Version:   <<No Schema Version String>>

measure_representation_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/measure_representation/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:42 GMT
   Version:   <<No Schema Version String>>

measure_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/measure_schema/measure_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:15 GMT
   Version:   {iso standard 10303 part(41) version(8) object(1) measure_schema(15)}

mesh_topology_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/mesh_topology_schema/mesh_topology_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:15 GMT
   Version:   {iso standard 10303 part(52) version(4) object(1) mesh_topology_schema(3)}

message_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/message/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:43 GMT
   Version:   <<No Schema Version String>>

method_definition_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/method_definition_schema/method_definition_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:15 GMT
   Version:   {iso standard 10303 part(49) version(1) object(1) method_definition_schema(1)}

multi_linguism_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/multi_linguism/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:43 GMT
   Version:   <<No Schema Version String>>

name_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/name_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:44 GMT
   Version:   <<No Schema Version String>>

numeric_expression_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/numeric_expression/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:44 GMT
   Version:   <<No Schema Version String>>

numeric_function_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/numeric_function/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:44 GMT
   Version:   <<No Schema Version String>>

observation_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/observation/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:44 GMT
   Version:   <<No Schema Version String>>

organization_type_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/organization_type/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:44 GMT
   Version:   <<No Schema Version String>>

part_and_version_identification_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/part_and_version_identification/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:46 GMT
   Version:   <<No Schema Version String>>

part_collection_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/part_collection/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:46 GMT
   Version:   <<No Schema Version String>>

part_definition_relationship_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/part_definition_relationship/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:46 GMT
   Version:   <<No Schema Version String>>

part_shape_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/part_shape/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:47 GMT
   Version:   <<No Schema Version String>>

part_view_definition_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/part_view_definition/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:47 GMT
   Version:   <<No Schema Version String>>

person_organization_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/person_organization_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:47 GMT
   Version:   <<No Schema Version String>>

person_organization_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/person_organization/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:47 GMT
   Version:   <<No Schema Version String>>

person_organization_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/person_organization_schema/person_organization_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:15 GMT
   Version:   {iso standard 10303 part(41) version(8) object(1) person_organization_schema(16)}

physical_breakdown_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/physical_breakdown/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:47 GMT
   Version:   <<No Schema Version String>>

plib_class_reference_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/plib_class_reference/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:49 GMT
   Version:   <<No Schema Version String>>

position_in_organization_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/position_in_organization/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:49 GMT
   Version:   <<No Schema Version String>>

probability_distribution_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/probability_distribution/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:50 GMT
   Version:   <<No Schema Version String>>

probability_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/probability/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:50 GMT
   Version:   <<No Schema Version String>>

process_property_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/process_property_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:50 GMT
   Version:   <<No Schema Version String>>

process_property_representation_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/process_property_representation_schema/process_property_representation_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:15 GMT
   Version:   {iso standard 10303 part(49) version(1) object(1) process_property_representation_schema(2)}

process_property_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/process_property_schema/process_property_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:15 GMT
   Version:   {iso standard 10303 part(49) version(1) object(1) process_property_schema(3)}

product_analysis_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/product_analysis_schema/product_analysis_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:15 GMT
   Version:   {iso standard 10303 part(53) version(1) object(1) product_analysis_schema(2)}

product_as_individual_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_as_individual/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:51 GMT
   Version:   <<No Schema Version String>>

product_breakdown_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_breakdown/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:52 GMT
   Version:   <<No Schema Version String>>

product_class_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_class/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:53 GMT
   Version:   <<No Schema Version String>>

product_concept_identification_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_concept_identification/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:53 GMT
   Version:   <<No Schema Version String>>

product_concept_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/product_concept_schema/product_concept_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:15 GMT
   Version:   {iso standard 10303 part(44) version(2) object(1) product_concept_schema(2)}

product_definition_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/product_definition_schema/product_definition_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:15 GMT
   Version:   {iso standard 10303 part(41) version(10) object(1) product_definition_schema(18)}

product_environment_definition_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_environment_definition/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:54 GMT
   Version:   <<No Schema Version String>>

product_environment_observed_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_environment_observed/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:54 GMT
   Version:   <<No Schema Version String>>

product_group_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_group/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:54 GMT
   Version:   <<No Schema Version String>>

product_identification_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_identification/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:54 GMT
   Version:   <<No Schema Version String>>

product_occurrence_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_occurrence/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:54 GMT
   Version:   <<No Schema Version String>>

product_placement_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_placement/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:54 GMT
   Version:   <<No Schema Version String>>

product_property_definition_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/product_property_definition_schema/product_property_definition_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:15 GMT
   Version:   {iso standard 10303 part(41) version(10) object(1) product_property_definition_schema(19)}

product_property_representation_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/product_property_representation_schema/product_property_representation_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:15 GMT
   Version:   {iso standard 10303 part(41) version(10) object(1) product_property_representation_schema(20)}

product_relationship_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_relationship/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:54 GMT
   Version:   <<No Schema Version String>>

product_replacement_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_replacement/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:54 GMT
   Version:   <<No Schema Version String>>

product_structure_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_structure/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:55 GMT
   Version:   <<No Schema Version String>>

product_structure_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/product_structure_schema/product_structure_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:15 GMT
   Version:   {iso standard 10303 part(44) version(6) object(1) product_structure_schema(1)}

product_version_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_version/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:55 GMT
   Version:   <<No Schema Version String>>

product_version_relationship_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_version_relationship/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:55 GMT
   Version:   <<No Schema Version String>>

product_view_definition_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_view_definition/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:55 GMT
   Version:   <<No Schema Version String>>

product_view_definition_properties_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_view_definition_properties/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:55 GMT
   Version:   <<No Schema Version String>>

product_view_definition_reference_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_view_definition_reference/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:55 GMT
   Version:   <<No Schema Version String>>

product_view_definition_relationship_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/product_view_definition_relationship/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:55 GMT
   Version:   <<No Schema Version String>>

project_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/project/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:56 GMT
   Version:   <<No Schema Version String>>

property_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/property_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:57 GMT
   Version:   <<No Schema Version String>>

property_as_definition_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/property_as_definition/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:57 GMT
   Version:   <<No Schema Version String>>

qualifications_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/qualifications/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:57 GMT
   Version:   <<No Schema Version String>>

qualifications_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/qualifications_schema/qualifications_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:16 GMT
   Version:   {iso standard 10303 part(41) version(6) object(1) qualifications_schema(20)}

qualified_measure_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/qualified_measure/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:57 GMT
   Version:   <<No Schema Version String>>

qualified_measure_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/qualified_measure_schema/qualified_measure_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:16 GMT
   Version:   {iso standard 10303 part(45) version(4) object(1) qualified_measure_schema(3)}

representation_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/representation_schema/representation_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:16 GMT
   Version:   {iso standard 10303 part(43) version(7) object(1) representation_schema(1)}

required_resource_characterized_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/required_resource_characterized/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:58 GMT
   Version:   <<No Schema Version String>>

required_resource_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/required_resource/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:58 GMT
   Version:   <<No Schema Version String>>

requirement_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/requirement_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:59 GMT
   Version:   <<No Schema Version String>>

requirement_identification_and_version_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/requirement_identification_and_version/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:59 GMT
   Version:   <<No Schema Version String>>

requirement_management_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/requirement_management/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:59 GMT
   Version:   <<No Schema Version String>>

requirement_view_definition_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/requirement_view_definition/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:59 GMT
   Version:   <<No Schema Version String>>

requirement_view_definition_relationship_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/requirement_view_definition_relationship/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:59 GMT
   Version:   <<No Schema Version String>>

resource_as_realized_characterized_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/resource_as_realized_characterized/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:59 GMT
   Version:   <<No Schema Version String>>

resource_as_realized_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/resource_as_realized/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:11:59 GMT
   Version:   <<No Schema Version String>>

resource_item_characterized_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/resource_item_characterized/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:00 GMT
   Version:   <<No Schema Version String>>

resource_item_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/resource_item/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:00 GMT
   Version:   <<No Schema Version String>>

resource_management_characterized_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/resource_management_characterized/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:00 GMT
   Version:   <<No Schema Version String>>

resource_management_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/resource_management/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:00 GMT
   Version:   <<No Schema Version String>>

resource_property_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/resource_property_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:00 GMT
   Version:   <<No Schema Version String>>

retention_period_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/retention_period/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:00 GMT
   Version:   <<No Schema Version String>>

risk_definition_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/risk_definition/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:00 GMT
   Version:   <<No Schema Version String>>

risk_management_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/risk_management/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:00 GMT
   Version:   <<No Schema Version String>>

risk_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/risk_schema/risk_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:16 GMT
   Version:   {iso standard 10303 part(58) version(1) object(1) risk_schema(1)}

scan_data_3d_shape_model_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/scan_data_3d_shape_model_schema/scan_data_3d_shape_model_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:16 GMT
   Version:   {iso standard 10303 part(42) version(2) object(1) scan_data_3d_shape_model_schema(4)}

scheme_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/scheme/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:02 GMT
   Version:   <<No Schema Version String>>

security_classification_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/security_classification/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:02 GMT
   Version:   <<No Schema Version String>>

security_classification_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/security_classification_schema/security_classification_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:16 GMT
   Version:   {iso standard 10303 part(41) version(3) object(1) security_classification_schema(21)}

selected_item_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/selected_item/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:02 GMT
   Version:   <<No Schema Version String>>

shape_aspect_definition_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/shape_aspect_definition_schema/shape_aspect_definition_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-12-16 13:43:46 GMT
   Version:   {iso standard 10303 part(47) version(6) object(1) shape_aspect_definition_schema(1)}

shape_dimension_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/shape_dimension_schema/shape_dimension_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-12-16 13:43:46 GMT
   Version:   {iso standard 10303 part(47) version(4) object(1) shape_dimension_schema(2)}

shape_feature_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/shape_feature/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:03 GMT
   Version:   <<No Schema Version String>>

shape_property_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/shape_property_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:03 GMT
   Version:   <<No Schema Version String>>

shape_tolerance_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/shape_tolerance_schema/shape_tolerance_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-12-16 13:43:46 GMT
   Version:   {iso standard 10303 part(47) version(7) object(1) shape_tolerance_schema(3)}

single_part_representation_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/single_part_representation/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:04 GMT
   Version:   <<No Schema Version String>>

specification_based_configuration_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/specification_based_configuration/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:04 GMT
   Version:   <<No Schema Version String>>

specification_control_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/specification_control/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:04 GMT
   Version:   <<No Schema Version String>>

specified_product_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/specified_product/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:04 GMT
   Version:   <<No Schema Version String>>

state_characterized_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/state_characterized/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:05 GMT
   Version:   <<No Schema Version String>>

state_definition_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/state_definition/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:05 GMT
   Version:   <<No Schema Version String>>

state_observed_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/state_observed/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:05 GMT
   Version:   <<No Schema Version String>>

state_observed_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/state_observed_schema/state_observed_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:16 GMT
   Version:   {iso standard 10303 part(56) version(3) object(1) state_observed_schema(2)}

state_type_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/state_type_schema/state_type_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:16 GMT
   Version:   {iso standard 10303 part(56) version(1) object(1) state_type_schema(1)}

structural_response_definition_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/structural_response_definition_schema/structural_response_definition_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:16 GMT
   Version:   {iso standard 10303 part(104) version(1) object(1) structural_response_definition_schema(3)}

structural_response_representation_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/structural_response_representation_schema/structural_response_representation_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:16 GMT
   Version:   {iso standard 10303 part(104) version(4) object(1) structural_response_representation_schema(4)}

support_resource_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/support_resource/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:05 GMT
   Version:   <<No Schema Version String>>

support_resource_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/support_resource_schema/support_resource_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:16 GMT
   Version:   {iso standard 10303 part(41) version(7) object(1) support_resource_schema(22)}

systems_engineering_representation_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/systems_engineering_representation_schema/systems_engineering_representation_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:16 GMT
   Version:   {iso standard 10303 part(61) version(2) object(1) systems_engineering_representation_schema(1)}

system_breakdown_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/system_breakdown/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:06 GMT
   Version:   <<No Schema Version String>>

system_identification_and_version_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/system_identification_and_version/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:06 GMT
   Version:   <<No Schema Version String>>

system_view_definition_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/system_view_definition/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:07 GMT
   Version:   <<No Schema Version String>>

task_element_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/task_element/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:07 GMT
   Version:   <<No Schema Version String>>

task_specification_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/task_specification/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:07 GMT
   Version:   <<No Schema Version String>>

time_interval_assignment_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/time_interval_assignment/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:08 GMT
   Version:   <<No Schema Version String>>

time_interval_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/time_interval/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:08 GMT
   Version:   <<No Schema Version String>>

topology_schema
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/resources/topology_schema/topology_schema.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2024-01-22 14:56:30 GMT
   Version:   {iso standard 10303 part(42) version(12) object(1) topology_schema(2)}

type_of_person_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/type_of_person/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:08 GMT
   Version:   <<No Schema Version String>>

value_with_unit_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/value_with_unit/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:08 GMT
   Version:   <<No Schema Version String>>

verification_and_validation_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/verification_and_validation/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:09 GMT
   Version:   <<No Schema Version String>>

work_order_characterized_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/work_order_characterized/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:09 GMT
   Version:   <<No Schema Version String>>

work_order_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/work_order/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:09 GMT
   Version:   <<No Schema Version String>>

work_output_characterized_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/work_output_characterized/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:09 GMT
   Version:   <<No Schema Version String>>

work_output_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/work_output/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:09 GMT
   Version:   <<No Schema Version String>>

work_request_characterized_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/work_request_characterized/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:10 GMT
   Version:   <<No Schema Version String>>

work_request_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/work_request/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:10 GMT
   Version:   <<No Schema Version String>>

zonal_breakdown_mim
   Filename: /Users/klt/git/wg12-stepdev/stepmod/data/modules/zonal_breakdown/mim.exp
   CVS Rev:   NIL
   File Status: not-vcs-controlled
   Timestamp: 2023-05-12 11:12:10 GMT
   Version:   <<No Schema Version String>>

 *)

--
-- ACTION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/action_schema/action_schema.exp)
--
(*
Id: action_schema.exp,v 1.36 2021/05/06 16:23:00 kevin Exp 
ISO 10303 TC184/SC4/WG12 N10693

EXPRESS Source:
ISO 10303-41 ed7 Fundamentals of product description and support - Action schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2021  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed7 Fundamentals of product description and support - Action schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA action_schema '{iso standard 10303 part(41) version(9) object(1) action_schema(1)}';
  REFERENCE FROM basic_attribute_schema (	-- ISO 10303-41
    description_attribute, 
    description_attribute_select,
    get_description_value, 
    get_id_value, 
    get_name_value,
    get_role, 
    id_attribute, 
    id_attribute_select,
    name_attribute,
    name_attribute_select,
    object_role,
    role_select,
    role_association);
    
  REFERENCE FROM support_resource_schema ( -- ISO 10303-41
    bag_to_set, 
    identifier, 
    label, 
    text);
  
  TYPE as_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    action_request_solution);
  END_TYPE;
  TYPE as_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    action);
  END_TYPE;
  TYPE as_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    action_request_solution);
  END_TYPE;
  TYPE as_role_select = SELECT BASED_ON role_select WITH (
    directed_action_assignment);
  END_TYPE;
  
  TYPE supported_item = SELECT (action_directive, action, action_method);
  END_TYPE;

  ENTITY action;
    name : label;
    description : OPTIONAL text;
    chosen_method : action_method;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY action_directive;
    name : label;
    description : OPTIONAL text;
    analysis : text;
    comment : text;
    requests : SET [1:?] OF versioned_action_request;
  END_ENTITY;

  ENTITY action_method;
    name : label;
    description : OPTIONAL text;
    consequence : text;
    purpose : text;
  END_ENTITY;

  ENTITY action_method_relationship;
    name : label;
    description : OPTIONAL text;
    relating_method : action_method;
    related_method : action_method;
  END_ENTITY;

  ENTITY action_relationship;
    name : label;
    description : OPTIONAL text;
    relating_action : action;
    related_action : action;
  END_ENTITY;

  ENTITY action_request_solution;
    method : action_method;
    request : versioned_action_request;
  DERIVE
    description : text := get_description_value(SELF);
    name : label := get_name_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY action_request_status;
    status : label;
    assigned_request : versioned_action_request;
  END_ENTITY;

  ENTITY action_resource;
    name : label;
    description : OPTIONAL text;
    usage : SET [1:?] OF supported_item;
    kind : action_resource_type;
  END_ENTITY;

  ENTITY action_resource_relationship;
    name : label;
    description : OPTIONAL text;
    relating_resource : action_resource;
    related_resource : action_resource;
  END_ENTITY;

  ENTITY action_resource_type;
    name : label;
  END_ENTITY;

  ENTITY action_status;
    status : label;
    assigned_action : executed_action;
  END_ENTITY;

  ENTITY directed_action
    SUBTYPE OF (executed_action);
    directive : action_directive;
  END_ENTITY;
  
  	ENTITY directed_action_assignment
		ABSTRACT SUPERTYPE ;
		assigned_directed_action : directed_action;
	  DERIVE
		role : object_role := get_role(SELF);
	  WHERE
		WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
	  END_ENTITY;

  ENTITY executed_action
    SUBTYPE OF (action);
  END_ENTITY;

  ENTITY versioned_action_request;
    id : identifier;
    version : OPTIONAL label;
    purpose : text;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY versioned_action_request_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_versioned_action_request : versioned_action_request;
    related_versioned_action_request : versioned_action_request;
  END_ENTITY;

ENTITY action_directive_relationship;
	name			: label; 	
	description 	: OPTIONAL STRING; 					
	relating 		: action_directive;	
	related 		: action_directive;										
	relation_type 	: STRING; 									
 WHERE
	WR1 : acyclic_action_directive_relationship(SELF, [related], 'ACTION_SCHEMA.ACTION_DIRECTIVE_RELATIONSHIP');
END_ENTITY;

  FUNCTION acyclic_action_method_relationship (relation : action_method_relationship; relatives : SET [1:?] OF action_method; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_method_relationship;
    END_LOCAL;

    IF relation.relating_method IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(am <* bag_to_set(USEDIN(relation.relating_method, 'ACTION_SCHEMA.' + 'ACTION_METHOD_RELATIONSHIP.' + 'RELATED_METHOD')) | specific_relation IN TYPEOF(am));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_method_relationship(x[i], relatives + relation.relating_method, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_action_relationship (relation : action_relationship; relatives : SET [1:?] OF action; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_relationship;
    END_LOCAL;

    IF relation.relating_action IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(actn <* bag_to_set(USEDIN(relation.relating_action, 'ACTION_SCHEMA.' + 'ACTION_RELATIONSHIP.' + 'RELATED_ACTION')) | specific_relation IN TYPEOF(actn));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_relationship(x[i], relatives + relation.relating_action, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_action_resource_relationship (relation : action_resource_relationship; relatives : SET [1:?] OF action_resource; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_resource_relationship;
    END_LOCAL;

    IF relation.relating_resource IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ar <* bag_to_set(USEDIN(relation.relating_resource, 'ACTION_SCHEMA.' + 'ACTION_RESOURCE_RELATIONSHIP.' + 'RELATED_RESOURCE')) | specific_relation IN TYPEOF(ar));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_resource_relationship(x[i], relatives + relation.relating_resource, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_versioned_action_request_relationship (relation : versioned_action_request_relationship; relatives : SET OF versioned_action_request; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF versioned_action_request_relationship;
    END_LOCAL;

    IF relation.relating_versioned_action_request IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(varr <* bag_to_set(USEDIN(relation.relating_versioned_action_request, 'ACTION_SCHEMA.' + 'VERSIONED_ACTION_REQUEST_RELATIONSHIP.' + 'RELATED_VERSIONED_ACTION_REQUEST')) | specific_relation IN TYPEOF(varr));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_versioned_action_request_relationship(x[i], relatives + relation.relating_versioned_action_request, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;
  
FUNCTION acyclic_action_directive_relationship (relation : action_directive_relationship; relatives : SET [1:?] of action_directive; specific_relation : STRING):BOOLEAN;
	LOCAL 
		x : SET of action_directive_relationship;
	END_LOCAL;
	IF relation.relating IN relatives THEN 
		RETURN (FALSE);
	END_IF;
	x := QUERY(adr <* bag_to_set(USEDIN(relation.relating, 'ACTION_SCHEMA.' + 'ACTION_DIRECTIVE_RELATIONSHIP.' + 'RELATED')) | specific_relation IN TYPEOF(adr));
	REPEAT i := 1 TO HIINDEX(x);
		IF NOT acyclic_action_directive_relationship(x[i], relatives + relation.relating, specific_relation) THEN 
	 		RETURN (FALSE);
		END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_FUNCTION;

END_SCHEMA;


--
-- ACTIVITY_AS_REALIZED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/activity_as_realized/mim.exp)
--
(*
 $Id: mim.exp,v 1.9 2009/04/29 15:56:56 robbod Exp 
 ISO TC184/SC4/WG12 N6106 - ISO/TS 10303-1259 Activity as realized - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2993
*) 


SCHEMA Activity_as_realized_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_relationship,
   executed_action); 

USE FROM Activity_mim;    -- ISO/TS 10303-1047


ENTITY action_actual
  SUBTYPE OF (executed_action);
END_ENTITY;

ENTITY action_happening
  SUBTYPE OF (action_relationship);
END_ENTITY;

END_SCHEMA;  -- Activity_as_realized_mim


--
-- ACTIVITY_CHARACTERIZED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/activity_characterized/mim.exp)
--
(*
 $Id: mim.exp,v 1.8 2004/11/19 21:37:33 robbod Exp 
 ISO TC184/SC4/WG12 N2996 - ISO/TS 10303-1272 Activity characterized - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2373
*) 


SCHEMA Activity_characterized_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_relationship,
   executed_action); 

USE FROM Activity_mim;    -- ISO/TS 10303-1047

USE FROM Ap239_management_resource_information_mim;    -- ISO/TS 10303-1289

USE FROM Management_resource_information_mim;    -- ISO/TS 10303-1288

USE FROM Process_property_assignment_mim;    -- ISO/TS 10303-1040

USE FROM process_property_schema   -- ISO 10303-49
  (action_property); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object); 

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030


TYPE actchar_ap239_mri_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON ap239_mri_attribute_classification_item WITH 
   (action_property, 
    action_relationship, 
    applied_action_assignment, 
    executed_action);
END_TYPE; 

TYPE actchar_ap239_mri_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON ap239_mri_classification_item WITH 
   (action_property, 
    action_relationship, 
    applied_action_assignment, 
    executed_action);
END_TYPE; 

TYPE actchar_mri_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_approval_item WITH 
   (action_property, 
    applied_action_assignment, 
    executed_action);
END_TYPE; 

TYPE actchar_mri_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_multi_language_attribute_item WITH 
   (action_property, 
    action_relationship, 
    applied_action_assignment, 
    executed_action);
END_TYPE; 

TYPE actchar_mri_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_and_time_item WITH 
   (action_property, 
    action_relationship, 
    applied_action_assignment, 
    executed_action);
END_TYPE; 

TYPE actchar_mri_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_item WITH 
   (action_property, 
    action_relationship, 
    applied_action_assignment, 
    executed_action);
END_TYPE; 

TYPE actchar_mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_identification_item WITH 
   (action_property, 
    applied_action_assignment, 
    executed_action);
END_TYPE; 

TYPE actchar_mri_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_attribute_language_item WITH 
   (action_property, 
    action_relationship, 
    applied_action_assignment, 
    executed_action);
END_TYPE; 

TYPE actchar_mri_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_organization_item WITH 
   (action_property, 
    action_relationship, 
    applied_action_assignment, 
    executed_action);
END_TYPE; 

TYPE actchar_mri_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_person_and_organization_item WITH 
   (action_property, 
    action_relationship, 
    applied_action_assignment, 
    executed_action);
END_TYPE; 

ENTITY characterizable_applied_action_assignment
  SUBTYPE OF (applied_action_assignment, characterized_object);
END_ENTITY;

END_SCHEMA;  -- Activity_characterized_mim



--
-- ACTIVITY_METHOD_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/activity_method_assignment/mim.exp)
--
(*
 $Id: mim.exp,v 1.5 2004/11/19 21:37:33 robbod Exp 
 ISO TC184/SC4/WG12 N2999 - ISO/TS 10303-1249 Activity method assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2307
*) 


SCHEMA Activity_method_assignment_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method_relationship); 

USE FROM Activity_method_mim;    -- ISO/TS 10303-1049

USE FROM management_resources_schema   -- ISO 10303-41
  (action_method_assignment); 


TYPE action_method_items = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY applied_action_method_assignment
  SUBTYPE OF (action_method_assignment);
  items : SET[1:?] OF action_method_items;
END_ENTITY;

END_SCHEMA;  -- Activity_method_assignment_mim



--
-- ACTIVITY_METHOD_CHARACTERIZED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/activity_method_characterized/mim.exp)
--
(*
 $Id: mim.exp,v 1.8 2004/11/19 21:37:33 robbod Exp 
 ISO TC184/SC4/WG12 N3002 - ISO/TS 10303-1298 Activity method characterized - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2376
*) 


SCHEMA Activity_method_characterized_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method); 

USE FROM Activity_method_mim;    -- ISO/TS 10303-1049

USE FROM Ap239_management_resource_information_mim;    -- ISO/TS 10303-1289

USE FROM Management_resource_information_mim;    -- ISO/TS 10303-1288


TYPE actmethchar_ap239_mri_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON ap239_mri_attribute_classification_item WITH 
   (action_method);
END_TYPE; 

TYPE actmethchar_ap239_mri_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON ap239_mri_classification_item WITH 
   (action_method);
END_TYPE; 

TYPE actmethchar_mri_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_approval_item WITH 
   (action_method);
END_TYPE; 

TYPE actmethchar_mri_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_attribute_language_item WITH 
   (action_method);
END_TYPE; 

TYPE actmethchar_mri_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_and_time_item WITH 
   (action_method);
END_TYPE; 

TYPE actmethchar_mri_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_item WITH 
   (action_method);
END_TYPE; 

TYPE actmethchar_mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_identification_item WITH 
   (action_method);
END_TYPE; 

TYPE actmethchar_mri_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_multi_language_attribute_item WITH 
   (action_method);
END_TYPE; 

TYPE actmethchar_mri_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_organization_item WITH 
   (action_method);
END_TYPE; 

TYPE actmethchar_mri_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_person_and_organization_item WITH 
   (action_method);
END_TYPE; 

END_SCHEMA;  -- Activity_method_characterized_mim



--
-- ACTIVITY_METHOD_IMPLEMENTATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/activity_method_implementation/mim.exp)
--
(*
Id: mim.exp,v 1.8 2010/06/09 22:23:16 philsp Exp 
ISO TC184/SC4/WG12 N7100 - ISO/TS 10303-1261 Activity method implementation - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N3005
*) 


SCHEMA Activity_method_implementation_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method_relationship); 

USE FROM Activity_method_mim;    -- ISO/TS 10303-1049

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Group_mim;    -- ISO/TS 10303-1113

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021


TYPE action_method_implementation_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
   (action_method_relationship);
END_TYPE; 

TYPE action_method_implementation_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (action_method_relationship);
END_TYPE; 

TYPE activity_method_implementation_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (action_method_relationship, 
    group);
END_TYPE; 

END_SCHEMA;  -- Activity_method_implementation_mim


--
-- ACTIVITY_METHOD_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/activity_method/mim.exp)
--
(*
 $Id: mim.exp,v 1.13 2004/10/21 14:45:33 darla Exp 
 ISO TC184/SC4/WG12 N1163 - ISO/TS 10303-1049 Activity method - EXPRESS MIM
*)

SCHEMA Activity_method_mim;

USE FROM action_schema    -- ISO 10303-41
(action_method );

END_SCHEMA;


--
-- ACTIVITY_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/activity/mim.exp)
--
(*
Id: mim.exp,v 1.17 2009/12/11 13:39:31 mikeward Exp 
ISO TC184/SC4/WG12 N1157 - ISO/TS 10303-1047 Activity - EXPRESS MIM
*) 


SCHEMA Activity_mim;

USE FROM action_schema   -- ISO 10303-41
  (action,
   action_relationship,
   action_status,
   executed_action); 

USE FROM Activity_method_mim;    -- ISO/TS 10303-1049

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute,
   object_role); 

USE FROM management_resources_schema   -- ISO 10303-41
  (action_assignment); 


TYPE action_items = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_action_assignment
  SUBTYPE OF (action_assignment);
  items : SET[1:?] OF action_items;
END_ENTITY;

END_SCHEMA;  -- Activity_mim


--
-- ALTERNATIVE_SOLUTION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/alternative_solution/mim.exp)
--
(*
 $Id: mim.exp,v 1.25 2019/01/23 17:49:41 brandon Exp 
 ISO TC184/SC4/WG12 N10274 - ISO/TS 10303-1109 Alternative solution - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N7727
*)

SCHEMA Alternative_solution_mim;

USE FROM Functional_breakdown_mim;  			--ISO/TS 10303-1216
USE FROM measure_schema							--ISO 10303-41
	(ratio_measure_with_unit);  
USE FROM Part_view_definition_mim; 				--ISO-TS 103030-1023
USE FROM Person_organization_assignment_mim; 	--ISO-TS 103030-1013
USE FROM Physical_breakdown_mim; 				--ISO-TS 10303-1215
USE FROM Product_as_individual_mim;	 			--ISO-TS 103030-1164
USE FROM product_definition_schema				--ISO 10303-41
	(final_solution);
USE FROM Product_occurrence_mim; 				--ISO/TS 10303-1063
USE FROM qualified_measure_schema				--ISO 10303-45
	(measure_representation_item);
USE FROM Requirement_view_definition_mim; 		--ISO-TS 103030-1141



  

  TYPE organization_item_solution = SELECT BASED_ON organization_item WITH (product_definition_formation);
  END_TYPE;

  RULE alternative_solution_requires_solution_definition FOR (product_definition_formation);
    LOCAL
      solution_versions: SET OF product_definition_formation := [];
    END_LOCAL;
    solution_versions :=  QUERY( pdf <* product_definition_formation |
	  SIZEOF( QUERY( prpc <* USEDIN(pdf.of_product, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
      prpc.name = 'alternative solution')) = 1);
    WHERE 
      WR1: SIZEOF( QUERY( pdf <* solution_versions |
        SIZEOF( QUERY( pd <* USEDIN(pdf, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION.FORMATION') | 
        pd.frame_of_reference.name = 'alternative definition')) <> 1))= 0; 
  END_RULE;

  RULE restrict_alternative_definition FOR (product_definition);
    LOCAL
      solution_definitions: SET OF product_definition := [];
    END_LOCAL;
      solution_definitions :=  QUERY( pd <* product_definition |
	 (pd.frame_of_reference.name = 'alternative definition'));
    WHERE
      WR1: SIZEOF ( QUERY ( pd <* solution_definitions | 
	    ( SIZEOF ( QUERY ( pdr <* USEDIN ( pd ,
	    'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | 
	    pdr.name = 'solution alternative definition' ) ) <>1 ) ) ) = 0;
      WR2: SIZEOF ( QUERY ( pd <* solution_definitions | 
	    NOT ( pd.name IN ['technical' , 'supplier' , 'technical supplier' , ''] ) ) ) = 0;
      WR3: SIZEOF ( QUERY ( pd <* solution_definitions | 
	    ( pd.name IN ['supplier' , 'technical supplier'] ) AND (
	    SIZEOF ( QUERY ( aoa <* USEDIN ( pd.formation ,
	    'PERSON_ORGANIZATION_ASSIGNMENT_MIM.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS' ) | 
	    aoa.role.name = 'supplier' )) <>1 ) )) = 0;
  END_RULE; 

  RULE restrict_product_definitions_for_base_element FOR
    (product_definition_relationship);
    WHERE
      WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
       ( pdr. name = 'solution alternative definition' ) AND 
       ( NOT( pdr. relating_product_definition.frame_of_reference.name
        IN [ 'alternative definition' , 'functional definition' , 'conceptual definition' ] ) OR 
       ( pdr.related_product_definition.frame_of_reference.name<>'alternative definition' ) ) ) ) =0;
  END_RULE;

  RULE solution_definition_requires_solution_category FOR (product_definition);
    LOCAL
      solution_definitions: SET OF product_definition := [];
    END_LOCAL;
      solution_definitions :=  QUERY( pd <* product_definition |
        (pd.frame_of_reference.name = 'alternative definition'));
    WHERE
      WR1: SIZEOF( QUERY( pd <* solution_definitions | 
        (SIZEOF( QUERY( prpc <* USEDIN(pd.formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
	     prpc.name = 'alternative solution')) = 0 ) )) = 0;
  END_RULE;

END_SCHEMA;



--
-- ANALYSIS_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/analysis_assignment/mim.exp)
--
(*
 $Id: mim.exp,v 1.16 2009/07/28 16:38:49 philsp Exp 
 ISO TC184/SC4/WG12 N6109 - ISO/TS 10303-1474 Analysis assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N5828
*) 


SCHEMA Analysis_assignment_mim;

USE FROM Analysis_identification_mim;    -- ISO/TS 10303-1476

USE FROM group_schema   -- ISO 10303-41
  (group); 

USE FROM management_resources_schema   -- ISO 10303-41
  (group_assignment); 


TYPE analysed_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY analysis_assignment
  SUBTYPE OF (group);
END_ENTITY;

ENTITY analysis_item
  SUBTYPE OF (group_assignment);
  items : SET[1:1] OF analysed_item;
  SELF\group_assignment.assigned_group : analysis_assignment;
END_ENTITY;

ENTITY assigned_analysis
  SUBTYPE OF (group_assignment);
  items : SET[1:1] OF product_definition_formation;
  SELF\group_assignment.assigned_group : analysis_assignment;
END_ENTITY;

END_SCHEMA;  -- Analysis_assignment_mim







--
-- ANALYSIS_CHARACTERIZED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/analysis_characterized/mim.exp)
--
(*
   $Id: mim.exp,v 1.11 2008/10/11 10:52:51 abhpf Exp 
   ISO TC184/SC4/WG12 N5831 - ISO/TS 10303-1475 Analysis characterized - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4545
*)

SCHEMA Analysis_characterized_mim;

USE FROM Analysis_identification_mim;

USE FROM Approval_mim;

USE FROM Classification_assignment_mim;

USE FROM Contract_mim;

USE FROM Date_time_assignment_mim;

USE FROM Person_organization_assignment_mim;

USE FROM Security_classification_mim;

TYPE analysis_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH
  (product_definition,
   product_definition_formation);
END_TYPE;

TYPE analysis_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH
  (product,
   product_definition,
   product_definition_formation);
END_TYPE;

TYPE analysis_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH
  (product_definition_formation);
END_TYPE;

TYPE analysis_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH
  (product_definition);
END_TYPE;

TYPE analysis_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH
  (product_definition);
END_TYPE;

TYPE analysis_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH
  (product,
   product_definition,
   product_definition_formation);
END_TYPE;

TYPE analysis_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH
  (product,
   product_definition,
   product_definition_formation);
END_TYPE;

TYPE analysis_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH
  (product_definition_formation);
END_TYPE;

END_SCHEMA;



--
-- ANALYSIS_IDENTIFICATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/analysis_identification/mim.exp)
--
(*
Id: mim.exp,v 1.14 2009/12/16 10:25:23 mikeward Exp 
ISO TC184/SC4/WG12 N6813 - ISO/TS 10303-1476 Analysis identification - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6570
*) 


SCHEMA Analysis_identification_mim;

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_category,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_related_product_category); 

USE FROM Product_identification_mim;    -- ISO/TS 10303-1017

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

USE FROM Product_version_relationship_mim;    -- ISO/TS 10303-1020

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019


TYPE analysis_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (product, 
    product_definition_formation);
END_TYPE; 

END_SCHEMA;  -- Analysis_identification_mim



--
-- ANALYSIS_PRODUCT_RELATIONSHIPS_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/analysis_product_relationships_schema/analysis_product_relationships_schema.exp)
--
(*
Id: analysis_product_relationships_schema.exp,v 1.13 2014/03/04 00:30:29 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N6003

EXPRESS Source:
ISO 10303-53 ed1 Numerical analysis - Analysis product relationships schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-53 ed1 Numerical analysis - Analysis product relationships schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA analysis_product_relationships_schema '{iso standard 10303 part(53) version(1) object(1) analysis_product_relationships_schema(1)}';

  REFERENCE FROM analysis_schema -- ISO 10303-53
    (numerical_model);

  REFERENCE FROM product_analysis_schema -- ISO 10303-53
    (temporal_spatial_domain);

  REFERENCE FROM product_definition_schema -- ISO 10303-41
    (product_definition);

  REFERENCE FROM support_resource_schema -- ISO 10303-41
    (identifier,
     label,
     text);
 
ENTITY idealisation_relationship;
  id  : identifier;
  name : label;
  description : text;
  idealised : product_definition;
  idealisation : temporal_spatial_domain;
END_ENTITY;
 
ENTITY view_relationship;
  id : identifier;
  name :label;
  description : text;
  viewed : temporal_spatial_domain;
  view : numerical_model;
END_ENTITY;
 
END_SCHEMA; -- analysis_product_relationships_schema



--
-- ANALYSIS_REPRESENTATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/analysis_representation/mim.exp)
--
(*
   $Id: mim.exp,v 1.11 2009/07/21 21:55:32 thomasrthurman Exp 
   ISO TC184/SC4/WG12 N5837 - ISO/TS 10303-1785 Analysis representation - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4551
*)

SCHEMA Analysis_representation_mim;

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM systems_engineering_representation_schema   -- ISO 10303-61
  (analysis_model,
   analysis_representation_context); 


END_SCHEMA;  -- Analysis_representation_mim



--
-- ANALYSIS_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/analysis_schema/analysis_schema.exp)
--
(*
Id: analysis_schema.exp,v 1.15 2014/03/04 00:30:29 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N6003

EXPRESS Source:
ISO 10303-53 ed1 Numerical analysis - Analysis schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-53 ed1 Numerical analysis - Analysis schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA analysis_schema '{iso standard 10303 part(53) version(1) object(1) analysis_schema(3)}';

REFERENCE FROM analysis_product_relationships_schema -- ISO 10303-53
  (view_relationship);

REFERENCE FROM mesh_topology_schema  -- ISO 10303-52
  (mesh);

REFERENCE FROM product_property_definition_schema -- ISO 10303-41
  (general_property);

REFERENCE FROM support_resource_schema  --ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);

ENTITY behavioural_decomposition_of_numerical_model;
  parts : SET [2 : ?] OF numerical_model;
  whole : numerical_model;
END_ENTITY;

ENTITY model_action_domain
SUBTYPE OF (numerical_model);
  initial : model_state_domain;
  final : model_state_domain;
END_ENTITY;

ENTITY model_product_domain
SUBTYPE OF (numerical_model);
  temporal_parts : LIST [0 : ?] OF model_action_domain;
END_ENTITY;

ENTITY model_product_domain_with_mesh
SUBTYPE OF (model_product_domain);
  model_mesh : mesh;
END_ENTITY;

ENTITY model_property_distribution;
  creating_software : text;
  domain : numerical_model;
  range : general_property;
END_ENTITY;

ENTITY model_state_domain
SUBTYPE OF (numerical_model);
END_ENTITY;

ENTITY numerical_model;
  id : identifier;
  name : label;
  description : text;
  creating_software : text;
  intended_analysis_code : SET [1 : ?] OF text;
  analysis_type : text;
WHERE
    wr1: temporal_spatial_domain_for_model(SELF);
END_ENTITY;

ENTITY simulation_run;
  id : identifier;
  name : label;
  description : text;
  simulated : numerical_model;
  results : SET [0 : ?] OF model_property_distribution;
END_ENTITY;

ENTITY spatial_decomposition_of_numerical_model;
  parts : SET [2 : ?] OF numerical_model;
  whole : numerical_model;
END_ENTITY;

ENTITY temporal_decomposition_of_model_action;
  parts : LIST [2 : ?] OF model_action_domain;
  whole : model_action_domain;
END_ENTITY;

SUBTYPE_CONSTRAINT sc1_numerical_model FOR numerical_model;
  ABSTRACT SUPERTYPE;
END_SUBTYPE_CONSTRAINT;

  FUNCTION temporal_spatial_domain_for_model (domain : numerical_model): BOOLEAN;
    LOCAL
      spatial_set : SET OF spatial_decomposition_of_numerical_model;
      behavioural_set : SET OF behavioural_decomposition_of_numerical_model;
      domains : SET OF numerical_model := [];
      viewing : BAG OF view_relationship;
      spatial_bag : BAG OF spatial_decomposition_of_numerical_model;
      behavioural_bag : BAG OF behavioural_decomposition_of_numerical_model;
    END_LOCAL;

    viewing := USEDIN(domain, 'ANALYSIS_PRODUCT_RELATIONSHIPS_SCHEMA.VIEW_RELATIONSHIP.VIEW');
    IF SIZEOF(viewing) > 0 THEN
      RETURN (TRUE);
    END_IF;
    spatial_bag := USEDIN(domain, 'ANALYSIS_SCHEMA.SPATIAL_DECOMPOSITION_OF_NUMERICAL_MODEL.PARTS');
    IF SIZEOF(spatial_bag) > 0 THEN
      spatial_set := bag_to_set(spatial_bag);
      REPEAT i := 1 TO HIINDEX(spatial_set);
        domains := domains + spatial_set[i].whole;
      END_REPEAT;
    END_IF;
    behavioural_bag := USEDIN(domain, 'ANALYSIS_SCHEMA.BEHAVIOURAL_DECOMPOSITION_OF_NUMERICAL_MODEL.PARTS');
    IF SIZEOF(behavioural_bag) > 0 THEN
      behavioural_set := bag_to_set(behavioural_bag);
      REPEAT i := 1 TO HIINDEX(behavioural_set);
        domains := domains + behavioural_set[i].whole;
      END_REPEAT;
    END_IF;
    IF SIZEOF(domains) > 0 THEN
      REPEAT i := 1 TO HIINDEX(domains);
        IF temporal_spatial_domain_for_model(domains[i]) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (FALSE);
  END_FUNCTION;



END_SCHEMA;



--
-- AP239_ACTIVITY_RECORDING_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_activity_recording/mim.exp)
--
(*
Id: mim.exp,v 1.27 2010/11/16 16:40:48 mikeward Exp 
ISO TC184/SC4/WG12 N7242 - ISO/TS 10303-1287 AP239 activity recording - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6094
*) 


SCHEMA Ap239_activity_recording_mim;

USE FROM Ap239_work_definition_mim;    -- ISO/TS 10303-1307

USE FROM Resource_as_realized_characterized_mim;    -- ISO/TS 10303-1283


TYPE ar_action_method_items = SELECT BASED_ON action_method_items WITH 
   (action_actual, 
    applied_action_assignment, 
    event_occurrence);
END_TYPE; 

TYPE ar_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (event_occurrence, 
    observation, 
    observation_consequence);
END_TYPE; 

TYPE ar_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (observation_consequence);
END_TYPE; 

TYPE ar_condition_evaluation_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON condition_evaluation_action_items WITH 
   (action, 
    action_method, 
    action_method_relationship, 
    action_property, 
    action_property_representation, 
    action_relationship, 
    action_resource, 
    action_resource_relationship, 
    action_resource_requirement, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    group, 
    product_group, 
    product_group_membership, 
    product_group_relationship, 
    property_definition_representation, 
    resource_property, 
    resource_property_representation);
END_TYPE; 

TYPE ar_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (observation, 
    observation_consequence);
END_TYPE; 

TYPE ar_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (observation, 
    observation_consequence);
END_TYPE; 

TYPE ar_justification_support_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON justification_support_item WITH 
   (observation);
END_TYPE; 

TYPE ar_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (event_occurrence, 
    observation, 
    observation_consequence);
END_TYPE; 

TYPE ar_observed_context_item = SELECT BASED_ON observed_context_item WITH 
   (action, 
    action_directive, 
    action_method, 
    action_resource, 
    action_resource_requirement, 
    applied_action_assignment, 
    event_occurrence, 
    interface_connector_occurrence, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_group, 
    versioned_action_request);
END_TYPE; 

END_SCHEMA;  -- Ap239_activity_recording_mim


--
-- AP239_DOCUMENT_MANAGEMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_document_management/mim.exp)
--
(*
 ISO TC184/SC4/WG12 N10773 - ISO/TS 10303-1297 AP239 document management - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N3008
*) 

SCHEMA Ap239_document_management_mim;

USE FROM Ap239_management_resource_information_mim;    -- ISO/TS 10303-1289

USE FROM Document_management_mim;    -- ISO/TS 10303-1290

USE FROM Envelope_mim;    -- ISO/TS 10303-1265

USE FROM Information_rights_mim;    -- ISO/TS 10303-1241

USE FROM State_characterized_mim;    -- ISO/TS 10303-1271

TYPE ap239_dm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    descriptive_representation_item, 
    measure_representation_item);
END_TYPE; 

TYPE ap239_dm_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_classification_item WITH 
   (descriptive_representation_item, 
    document_relationship, 
    document_type, 
    document_usage_role, 
    envelope, 
    envelope_relationship, 
    identification_role, 
    information_right, 
    information_usage_right, 
    measure_representation_item, 
    message_relationship, 
    object_role, 
    product_definition_relationship, 
    representation, 
    representation_item, 
    structured_message, 
    usage_association);
END_TYPE; 

TYPE ap239_dm_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (envelope, 
    envelope_relationship, 
    information_right, 
    information_usage_right, 
    message_relationship, 
    structured_message);
END_TYPE; 

TYPE ap239_dm_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    applied_usage_right, 
    descriptive_representation_item, 
    document_file, 
    document_relationship, 
    envelope, 
    envelope_relationship, 
    information_right, 
    information_usage_right, 
    measure_representation_item, 
    message_relationship, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship, 
    representation, 
    structured_message, 
    usage_association);
END_TYPE; 

TYPE ap239_dm_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH 
   (product, 
    structured_message);
END_TYPE; 

TYPE ap239_dm_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_usage_right, 
    descriptive_representation_item, 
    measure_representation_item, 
    product);
END_TYPE; 

TYPE ap239_dm_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_usage_right, 
    descriptive_representation_item, 
    measure_representation_item, 
    product);
END_TYPE; 

TYPE ap239_dm_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (applied_approval_assignment, 
    applied_certification_assignment, 
    applied_contract_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval, 
    certification, 
    contract, 
    descriptive_representation_item, 
    information_right, 
    information_usage_right, 
    measure_representation_item, 
    organization, 
    person, 
    structured_message);
END_TYPE; 

TYPE ap239_dm_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    structured_message);
END_TYPE; 

TYPE ap239_dm_ir_usage_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH 
   (applied_certification_assignment, 
    certification, 
    document_file, 
    document_relationship, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship, 
    structured_message);
END_TYPE; 

TYPE ap239_dm_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (envelope, 
    envelope_relationship, 
    information_right, 
    information_usage_right, 
    message_relationship, 
    structured_message);
END_TYPE; 

TYPE ap239_dm_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    descriptive_representation_item, 
    measure_representation_item, 
    structured_message);
END_TYPE; 

TYPE ap239_dm_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    descriptive_representation_item, 
    measure_representation_item, 
    structured_message);
END_TYPE; 

TYPE ap239_dm_security_classification_item = EXTENSIBLE SELECT BASED_ON security_classification_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment);
END_TYPE; 

TYPE ap239_dm_state_observed_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_observed_of_item WITH 
   (applied_external_identification_assignment, 
    document_file, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE ap239_dm_state_type_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_type_of_item WITH 
   (applied_external_identification_assignment, 
    document_file, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

ENTITY characterized_applied_document_reference
  SUBTYPE OF (applied_document_reference, characterized_object);
END_ENTITY;

ENTITY characterized_applied_document_usage_constraint_assignment
  SUBTYPE OF (applied_document_usage_constraint_assignment, characterized_object);
END_ENTITY;

END_SCHEMA;  -- Ap239_document_management_mim


--
-- AP239_MANAGEMENT_RESOURCE_INFORMATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_management_resource_information/mim.exp)
--
(*
 ISO TC184/SC4/WG12 N11169 - ISO/TS 10303-1289 AP239 management resource information - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N6855
*)


SCHEMA Ap239_management_resource_information_mim;

USE FROM Attribute_classification_mim;    -- ISO/TS 10303-1246

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM contract_schema   -- ISO 10303-41
  (contract_type); 

USE FROM date_time_schema   -- ISO 10303-41
  (event_occurrence_context_role,
   local_time); 

USE FROM External_class_mim;    -- ISO/TS 10303-1275

USE FROM Management_resource_information_mim;    -- ISO/TS 10303-1288

USE FROM Time_interval_assignment_mim;    -- ISO/TS 10303-1365


TYPE ap239_mri_approval_item = SELECT BASED_ON approval_item WITH 
   (applied_certification_assignment, 
    applied_classification_assignment, 
    applied_contract_assignment, 
    applied_date_and_time_assignment, 
    applied_date_assignment, 
    applied_event_occurrence_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_organizational_project_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    event_occurrence, 
    organization_relationship, 
    organizational_address, 
    organizational_project, 
    person_and_organization,
    person_and_organization_address,  
    security_classification);
END_TYPE; 

TYPE ap239_mri_approval_scope_item = SELECT BASED_ON approval_scope_item WITH 
   (contract, 
    organization, 
    organizational_project, 
    person_and_organization);
END_TYPE; 

TYPE ap239_mri_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_classification_item WITH 
   (approval, 
    approval_relationship, 
    approval_role, 
    approval_status, 
    certification, 
    certification_type, 
    contract_type, 
    date_role, 
    date_time_role, 
    event_occurrence_context_role, 
    event_occurrence_relationship, 
    group, 
    identification_role, 
    name_attribute, 
    object_role, 
    organization_relationship, 
    organization_role, 
    organizational_address, 
    organizational_project_relationship, 
    organizational_project_role, 
    person_and_organization_address, 
    person_and_organization_role, 
    security_classification_level, 
    time_interval_relationship);
END_TYPE; 

TYPE ap239_mri_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (event_occurrence);
END_TYPE; 

TYPE ap239_mri_certification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON certification_item WITH 
   (organizational_project);
END_TYPE; 

TYPE ap239_mri_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (address, 
    applied_approval_assignment, 
    applied_certification_assignment, 
    applied_contract_assignment, 
    applied_date_and_time_assignment, 
    applied_date_assignment, 
    applied_event_occurrence_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_organizational_project_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    approval, 
    approval_person_organization, 
    approval_relationship, 
    approval_status, 
    attribute_language_assignment, 
    calendar_date, 
    certification, 
    class, 
    contract, 
    date_and_time, 
    event_occurrence, 
    event_occurrence_relationship, 
    external_class_library, 
    language, 
    local_time, 
    multi_language_attribute_assignment, 
    organization, 
    organization_relationship, 
    organizational_address, 
    organizational_project, 
    organizational_project_relationship, 
    person, 
    person_and_organization, 
    person_and_organization_address, 
    security_classification, 
    time_interval_relationship);
END_TYPE; 

TYPE ap239_mri_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH 
   (external_class_library, 
    externally_defined_class, 
    security_classification);
END_TYPE; 

TYPE ap239_mri_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (applied_certification_assignment, 
    applied_classification_assignment, 
    applied_contract_assignment, 
    applied_date_and_time_assignment, 
    applied_date_assignment, 
    applied_event_occurrence_assignment, 
    applied_identification_assignment, 
    approval, 
    organization_relationship, 
    organizational_address, 
    person, 
    person_and_organization, 
    person_and_organization_address, 
    security_classification);
END_TYPE; 

TYPE ap239_mri_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (applied_certification_assignment, 
    applied_classification_assignment, 
    applied_contract_assignment, 
    applied_date_and_time_assignment, 
    applied_date_assignment, 
    applied_event_occurrence_assignment, 
    applied_identification_assignment, 
    approval, 
    organization_relationship, 
    organizational_address, 
    person, 
    person_and_organization, 
    person_and_organization_address, 
    security_classification);
END_TYPE; 

TYPE ap239_mri_event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON event_occurrence_item WITH 
   (certification, 
    organizational_project);
END_TYPE; 

TYPE ap239_mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (address, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    approval, 
    approval_status, 
    certification, 
    event_occurrence, 
    external_class_library, 
    organization, 
    organizational_project, 
    person, 
    person_and_organization, 
    security_classification);
END_TYPE; 

TYPE ap239_mri_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (event_occurrence);
END_TYPE; 

TYPE ap239_mri_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (applied_certification_assignment, 
    applied_classification_assignment, 
    applied_contract_assignment, 
    applied_date_and_time_assignment, 
    applied_date_assignment, 
    applied_event_occurrence_assignment, 
    applied_organization_assignment, 
    applied_organizational_project_assignment, 
    applied_person_and_organization_assignment, 
    certification, 
    event_occurrence, 
    organizational_address, 
    organizational_project, 
    person_and_organization, 
    person_and_organization_address, 
    security_classification);
END_TYPE; 

TYPE ap239_mri_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (applied_certification_assignment, 
    applied_classification_assignment, 
    applied_contract_assignment, 
    applied_date_and_time_assignment, 
    applied_date_assignment, 
    applied_event_occurrence_assignment, 
    applied_organization_assignment, 
    applied_organizational_project_assignment, 
    applied_person_and_organization_assignment, 
    certification, 
    event_occurrence, 
    organizational_address, 
    organizational_project, 
    person_and_organization, 
    person_and_organization_address, 
    security_classification);
END_TYPE; 

TYPE ap239_mri_time_interval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON time_interval_item WITH 
   (applied_certification_assignment, 
    applied_classification_assignment, 
    applied_contract_assignment, 
    applied_date_and_time_assignment, 
    applied_date_assignment, 
    applied_event_occurrence_assignment, 
    applied_identification_assignment, 
    approval, 
    organization_relationship, 
    organizational_address, 
    person, 
    person_and_organization, 
    person_and_organization_address, 
    security_classification);
END_TYPE; 

END_SCHEMA;  -- Ap239_management_resource_information_mim


--
-- AP239_PART_DEFINITION_INFORMATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_part_definition_information/mim.exp)
--
(*
ISO TC184/SC4/WG12 N10768 - ISO/TS 10303-1293 AP239 part definition information - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N7247
*) 


SCHEMA Ap239_part_definition_information_mim;

USE FROM Ap239_document_management_mim;    -- ISO/TS 10303-1297

USE FROM Ap239_properties_mim;    -- ISO/TS 10303-1295

USE FROM application_context_schema   -- ISO 10303-41
  (application_context); 

USE FROM Interface_lifecycle_mim;    -- ISO/TS 10303-1294

USE FROM Justification_mim;    -- ISO/TS 10303-1263

USE FROM management_resources_schema   -- ISO 10303-41
  (effectivity_context_assignment); 

USE FROM Part_view_definition_mim;    -- ISO/TS 10303-1023

USE FROM Product_as_individual_mim;    -- ISO/TS 10303-1164

USE FROM Product_concept_identification_mim;    -- ISO/TS 10303-1060

USE FROM Requirement_management_mim;    -- ISO/TS 10303-1348


TYPE ap239_padi_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (applied_effectivity_assignment, 
    applied_state_observed_assignment, 
    applied_state_type_assignment, 
    effectivity, 
    interface_connection, 
    interface_connector_as_planned, 
    interface_connector_as_realized, 
    interface_connector_definition, 
    interface_connector_design, 
    interface_connector_design_to_planned, 
    interface_connector_design_to_realized, 
    interface_connector_occurrence, 
    interface_connector_planned_to_realized, 
    interface_connector_version, 
    interface_definition_for, 
    interface_specification_definition, 
    interface_specification_version, 
    justification_group_assignment, 
    justification_support_assignment, 
    product, 
    product_as_planned, 
    product_concept, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    product_design_to_individual, 
    product_design_version_to_individual, 
    product_planned_to_realized, 
    product_related_product_category, 
    product_relationship);
END_TYPE; 

TYPE ap239_padi_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_classification_item WITH 
   (application_context, 
    application_context_element, 
    effectivity, 
    effectivity_relationship, 
    group, 
    interface_connection, 
    interface_connector_definition, 
    interface_definition_connection, 
    interface_specification_definition, 
    object_role, 
    product, 
    product_category, 
    product_concept, 
    product_concept_context, 
    product_context, 
    product_definition, 
    product_definition_context, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    product_design_version_to_individual);
END_TYPE; 

TYPE ap239_padi_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (interface_connection, 
    interface_connector_occurrence, 
    interface_definition_connection, 
    interface_definition_for, 
    justification_group_assignment, 
    justification_support_assignment, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_relationship);
END_TYPE; 

TYPE ap239_padi_certification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON certification_item WITH 
   (interface_connection, 
    interface_connector_version, 
    interface_definition_connection, 
    interface_specification_version, 
    product, 
    product_as_planned, 
    product_definition_formation, 
    product_definition_formation_relationship);
END_TYPE; 

TYPE ap239_padi_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (applied_effectivity_assignment, 
    ascribable_state, 
    ascribable_state_relationship, 
    effectivity, 
    effectivity_relationship, 
    interface_connection, 
    interface_connector_as_planned, 
    interface_connector_as_realized, 
    interface_connector_design, 
    interface_connector_design_to_planned, 
    interface_connector_design_to_realized, 
    interface_connector_occurrence, 
    interface_connector_planned_to_realized, 
    interface_definition_connection, 
    interface_definition_for, 
    justification_group_assignment, 
    justification_support_assignment, 
    product, 
    product_category, 
    product_concept, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    product_design_to_individual, 
    product_design_version_to_individual, 
    product_planned_to_realized, 
    product_relationship, 
    requirement_assignment, 
    requirement_source);
END_TYPE; 

TYPE ap239_padi_condition_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON condition_action_method_items WITH 
   (applied_approval_assignment, 
    applied_certification_assignment, 
    applied_classification_assignment, 
    applied_contract_assignment, 
    applied_date_and_time_assignment, 
    applied_date_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval, 
    calendar_date, 
    date_and_time, 
    hierarchical_interface_connection, 
    interface_connection, 
    interface_connector_occurrence, 
    interface_definition_connection, 
    product, 
    product_concept, 
    product_definition, 
    product_definition_formation, 
    product_related_product_category, 
    property_definition, 
    property_definition_representation, 
    representation, 
    state_observed, 
    state_type);
END_TYPE; 

TYPE ap239_padi_condition_evaluation_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON condition_evaluation_action_items WITH 
   (applied_approval_assignment, 
    applied_certification_assignment, 
    applied_classification_assignment, 
    applied_contract_assignment, 
    applied_date_and_time_assignment, 
    applied_date_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval, 
    calendar_date, 
    date_and_time, 
    hierarchical_interface_connection, 
    interface_connection, 
    interface_connector_occurrence, 
    interface_definition_connection, 
    product, 
    product_concept, 
    product_definition, 
    product_definition_formation, 
    product_related_product_category, 
    property_definition, 
    property_definition_representation, 
    representation, 
    state_observed, 
    state_type);
END_TYPE; 

TYPE ap239_padi_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH 
   (interface_connector_as_planned, 
    interface_connector_as_realized, 
    interface_connector_design, 
    organizational_project, 
    product, 
    product_as_planned, 
    product_definition_formation);
END_TYPE; 

TYPE ap239_padi_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (applied_effectivity_assignment, 
    applied_organizational_project_assignment, 
    effectivity, 
    hierarchical_interface_connection, 
    interface_connection, 
    interface_connector_as_planned, 
    interface_connector_as_realized, 
    interface_connector_design_to_planned, 
    interface_connector_design_to_realized, 
    interface_connector_occurrence, 
    interface_connector_planned_to_realized, 
    interface_definition_connection, 
    interface_definition_for, 
    justification_group_assignment, 
    justification_support_assignment, 
    organizational_project, 
    product, 
    product_concept, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_design_to_individual, 
    product_design_version_to_individual, 
    product_planned_to_realized, 
    product_related_product_category, 
    product_relationship);
END_TYPE; 

TYPE ap239_padi_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (applied_effectivity_assignment, 
    applied_organizational_project_assignment, 
    effectivity, 
    hierarchical_interface_connection, 
    interface_connection, 
    interface_connector_as_planned, 
    interface_connector_as_realized, 
    interface_connector_design_to_planned, 
    interface_connector_design_to_realized, 
    interface_connector_occurrence, 
    interface_connector_planned_to_realized, 
    interface_definition_connection, 
    interface_definition_for, 
    justification_group_assignment, 
    justification_support_assignment, 
    organizational_project, 
    product, 
    product_concept, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_design_to_individual, 
    product_design_version_to_individual, 
    product_planned_to_realized, 
    product_related_product_category, 
    product_relationship);
END_TYPE; 

TYPE ap239_padi_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (action, 
    action_method, 
    applied_effectivity_assignment, 
    applied_security_classification_assignment, 
    ascribable_state, 
    effectivity, 
    interface_connection, 
    interface_connector_as_planned, 
    interface_connector_as_realized, 
    interface_connector_design, 
    interface_connector_design_to_planned, 
    interface_connector_design_to_realized, 
    interface_connector_occurrence, 
    interface_connector_planned_to_realized, 
    interface_definition_connection, 
    organizational_project, 
    product, 
    product_concept, 
    product_concept_context, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_design_to_individual, 
    product_design_version_to_individual, 
    product_planned_to_realized, 
    requirement_assignment, 
    requirement_source, 
    security_classification, 
    state_observed, 
    state_type);
END_TYPE; 

TYPE ap239_padi_effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON effectivity_item WITH 
   (applied_approval_assignment, 
    applied_certification_assignment, 
    applied_contract_assignment, 
    applied_date_and_time_assignment, 
    applied_date_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_effectivity_assignment, 
    applied_external_identification_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_organizational_project_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    applied_usage_right, 
    document_relationship, 
    document_type, 
    interface_connection, 
    interface_connector_design_to_planned, 
    interface_connector_design_to_realized, 
    interface_connector_occurrence, 
    interface_connector_planned_to_realized, 
    interface_definition_for, 
    justification_group_assignment, 
    justification_support_assignment, 
    organization_relationship, 
    organizational_address, 
    person_and_organization, 
    person_and_organization_address, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    product_design_to_individual, 
    product_design_version_to_individual, 
    product_planned_to_realized, 
    product_relationship, 
    property_definition, 
    requirement_assignment, 
    requirement_source);
END_TYPE; 

TYPE ap239_padi_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (effectivity, 
    information_right, 
    information_usage_right, 
    interface_connection, 
    interface_connector_as_planned, 
    interface_connector_as_realized, 
    interface_connector_design, 
    interface_connector_occurrence, 
    interface_definition_connection, 
    justification_group_assignment, 
    justification_support_assignment, 
    product, 
    product_as_planned, 
    product_concept, 
    product_concept_context, 
    product_definition_formation, 
    product_relationship);
END_TYPE; 

TYPE ap239_padi_ir_usage_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH 
   (applied_security_classification_assignment, 
    interface_connection, 
    interface_connector_as_planned, 
    interface_connector_as_realized, 
    interface_connector_design, 
    interface_connector_occurrence, 
    interface_definition_connection, 
    interface_definition_for, 
    product, 
    product_as_planned, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    requirement_assignment, 
    security_classification);
END_TYPE; 

TYPE ap239_padi_justification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON justification_item WITH 
   (applied_approval_assignment, 
    applied_classification_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    approval, 
    ascribable_state, 
    descriptive_representation_item, 
    document_relationship, 
    effectivity, 
    general_property, 
    general_property_relationship, 
    interface_connection, 
    interface_connector_occurrence, 
    interface_definition_connection, 
    measure_representation_item, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    structured_message);
END_TYPE; 

TYPE ap239_padi_justification_support_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON justification_support_item WITH 
   (applied_state_observed_assignment, 
    applied_state_type_assignment, 
    approval, 
    ascribable_state, 
    certification, 
    contract, 
    descriptive_representation_item, 
    document_relationship, 
    effectivity, 
    general_property, 
    general_property_relationship, 
    interface_connection, 
    interface_connector_occurrence, 
    interface_definition_connection, 
    measure_representation_item, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    state_observed, 
    state_observed_relationship, 
    state_type, 
    state_type_relationship, 
    structured_message);
END_TYPE; 

TYPE ap239_padi_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (interface_connection, 
    interface_connector_occurrence, 
    interface_definition_connection, 
    interface_definition_for, 
    justification_group_assignment, 
    justification_support_assignment, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_relationship);
END_TYPE; 

TYPE ap239_padi_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (applied_effectivity_assignment, 
    applied_identification_assignment, 
    effectivity, 
    interface_connection, 
    interface_connector_as_planned, 
    interface_connector_as_realized, 
    interface_connector_occurrence, 
    interface_definition_connection, 
    interface_definition_for, 
    justification_group_assignment, 
    justification_support_assignment, 
    product, 
    product_category, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_related_product_category, 
    product_relationship);
END_TYPE; 

TYPE ap239_padi_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (applied_effectivity_assignment, 
    applied_identification_assignment, 
    effectivity, 
    interface_connection, 
    interface_connector_as_planned, 
    interface_connector_as_realized, 
    interface_connector_occurrence, 
    interface_definition_connection, 
    interface_definition_for, 
    justification_group_assignment, 
    justification_support_assignment, 
    product, 
    product_category, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_related_product_category, 
    product_relationship);
END_TYPE; 

TYPE ap239_padi_project_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON project_item WITH 
   (general_property, 
    product, 
    product_concept, 
    product_definition_formation);
END_TYPE; 

TYPE ap239_padi_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
   (interface_connector_occurrence, 
    organizational_project, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE ap239_padi_requirement_source_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_source_item WITH 
   (interface_connector_occurrence, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE ap239_padi_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH 
   (hierarchical_interface_connection, 
    interface_connection, 
    interface_connector_as_planned, 
    interface_connector_as_realized, 
    interface_connector_design, 
    interface_connector_occurrence, 
    interface_definition_connection, 
    interface_definition_for, 
    product, 
    product_as_planned, 
    product_definition, 
    product_definition_formation, 
    product_design_to_individual, 
    product_design_version_to_individual);
END_TYPE; 

TYPE ap239_padi_state_observed_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_observed_of_item WITH 
   (certification, 
    contract, 
    interface_connection, 
    interface_connector_as_planned, 
    interface_connector_as_realized, 
    interface_connector_definition, 
    interface_connector_design, 
    interface_connector_occurrence, 
    interface_connector_version, 
    interface_definition_connection, 
    interface_specification_definition, 
    interface_specification_version, 
    organization, 
    organizational_project, 
    person_and_organization, 
    product, 
    product_as_planned, 
    product_category, 
    product_definition, 
    product_definition_formation, 
    security_classification);
END_TYPE; 

TYPE ap239_padi_state_type_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_type_of_item WITH 
   (certification, 
    contract, 
    interface_connection, 
    interface_connector_as_planned, 
    interface_connector_as_realized, 
    interface_connector_definition, 
    interface_connector_design, 
    interface_connector_occurrence, 
    interface_connector_version, 
    interface_definition_connection, 
    interface_specification_definition, 
    interface_specification_version, 
    organization, 
    organizational_project, 
    person_and_organization, 
    product, 
    product_as_planned, 
    product_category, 
    product_definition, 
    product_definition_formation, 
    security_classification);
END_TYPE; 

ENTITY applied_effectivity_context_assignment
  SUBTYPE OF (effectivity_context_assignment);
  items : SET[1:?] OF product;
END_ENTITY;

ENTITY characterized_address
  SUBTYPE OF (address, characterized_object);
END_ENTITY;

ENTITY characterized_applied_organization_assignment
  SUBTYPE OF (applied_organization_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_person_and_organization_assignment
  SUBTYPE OF (applied_person_and_organization_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_interface_connection
  SUBTYPE OF (characterized_object, interface_connection);
END_ENTITY;

ENTITY characterized_interface_connector_occurrence
  SUBTYPE OF (characterized_object, interface_connector_occurrence);
END_ENTITY;

ENTITY characterized_interface_definition_connection
  SUBTYPE OF (characterized_object, interface_definition_connection);
END_ENTITY;

ENTITY characterized_organizational_project
  SUBTYPE OF (characterized_object, organizational_project);
END_ENTITY;

ENTITY characterized_person
  SUBTYPE OF (characterized_object, person);
END_ENTITY;

ENTITY characterized_person_and_organization
  SUBTYPE OF (characterized_object, person_and_organization);
END_ENTITY;

END_SCHEMA;  -- Ap239_part_definition_information_mim


--
-- AP239_PRODUCT_DEFINITION_INFORMATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_product_definition_information/mim.exp)
--
(*
ISO TC184/SC4/WG12 N10766 - ISO/TS 10303-1292 AP239 product definition information - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N7252
*) 


SCHEMA Ap239_product_definition_information_mim;

USE FROM Alternative_solution_mim;    -- ISO/TS 10303-1109 

USE FROM Ap239_part_definition_information_mim;    -- ISO/TS 10303-1293

USE FROM Assembly_structure_mim;    -- ISO/TS 10303-1026

USE FROM Attachment_slot_mim;    -- ISO/TS 10303-1250

USE FROM Classification_with_attributes_mim;    -- ISO/TS 10303-1111

USE FROM Configuration_effectivity_mim;    -- ISO/TS 10303-1058

USE FROM Configuration_item_mim;    -- ISO/TS 10303-1056

USE FROM Functional_breakdown_mim;    -- ISO/TS 10303-1216

USE FROM Item_definition_structure_mim;    -- ISO/TS 10303-1345

USE FROM Part_definition_relationship_mim;    -- ISO/TS 10303-1055

USE FROM Physical_breakdown_mim;    -- ISO/TS 10303-1215

USE FROM Product_breakdown_mim;    -- ISO/TS 10303-1248

USE FROM Product_relationship_mim;    -- ISO/TS 10303-1024

USE FROM Product_replacement_mim;    -- ISO/TS 10303-1046

USE FROM Product_structure_mim;    -- ISO/TS 10303-1134

USE FROM Selected_item_mim;    -- ISO/TS 10303-1357

USE FROM Shape_property_assignment_mim;    -- ISO/TS 10303-1032

USE FROM Specification_control_mim;    -- ISO/TS 10303-1112

USE FROM System_breakdown_mim;    -- ISO/TS 10303-1214

USE FROM Zonal_breakdown_mim;    -- ISO/TS 10303-1217


TYPE ap239_prdi_approval_scope_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_scope_item WITH 
   (configuration_item, 
    product_concept);
END_TYPE; 

TYPE ap239_prdi_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (alternate_product_relationship, 
    assembly_component_usage, 
    assembly_component_usage_substitute, 
    attachment_slot_as_planned, 
    attachment_slot_as_realized, 
    attachment_slot_design, 
    attachment_slot_design_to_planned, 
    attachment_slot_design_to_realized, 
    attachment_slot_on_product, 
    attachment_slot_planned_to_realized, 
    breakdown_element_group_assignment, 
    breakdown_element_usage, 
    configuration_item, 
    effectivity, 
    in_zone, 
    product, 
    product_definition, 
    product_definition_element_relationship, 
    product_definition_formation, 
    product_definition_group_assignment, 
    product_in_attachment_slot, 
    product_relationship, 
    selected_item_assignment);
END_TYPE; 

TYPE ap239_prdi_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_classification_item WITH 
   (alternate_product_relationship, 
    breakdown_context, 
    breakdown_element_group_assignment, 
    breakdown_element_usage, 
    product_definition_group_assignment, 
    product_relationship);
END_TYPE; 

TYPE ap239_prdi_certification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON certification_item WITH 
   (configuration_item, 
    product, 
    product_definition_relationship);
END_TYPE; 

TYPE ap239_prdi_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (alternate_product_relationship, 
    assembly_component_usage_substitute, 
    attachment_slot_design_to_planned, 
    attachment_slot_design_to_realized, 
    attachment_slot_on_product, 
    attachment_slot_planned_to_realized, 
    breakdown_context, 
    breakdown_element_group_assignment, 
    breakdown_element_usage, 
    breakdown_of, 
    characterized_object, 
    configuration_design, 
    configuration_effectivity, 
    configuration_item, 
    in_zone, 
    product, 
    product_definition_formation, 
    product_definition_group_assignment, 
    product_definition_relationship, 
    product_definition_shape, 
    product_relationship, 
    selected_item, 
    selected_item_assignment);
END_TYPE; 

TYPE ap239_prdi_condition_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON condition_action_method_items WITH 
   (product_definition_element_relationship, 
    product_definition_relationship);
END_TYPE; 

TYPE ap239_prdi_condition_evaluation_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON condition_evaluation_action_items WITH 
   (product_definition_element_relationship, 
    product_definition_relationship);
END_TYPE; 

TYPE ap239_prdi_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH 
   (configuration_item, 
    product, 
    product_definition_formation);
END_TYPE; 

TYPE ap239_prdi_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (alternate_product_relationship, 
    assembly_component_usage, 
    assembly_component_usage_substitute, 
    attachment_slot_design_to_planned, 
    attachment_slot_design_to_realized, 
    attachment_slot_planned_to_realized, 
    breakdown_element_group_assignment, 
    breakdown_element_usage, 
    configuration_item, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_group_assignment, 
    product_in_attachment_slot, 
    product_relationship, 
    selected_item, 
    selected_item_assignment);
END_TYPE; 

TYPE ap239_prdi_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (alternate_product_relationship, 
    assembly_component_usage, 
    assembly_component_usage_substitute, 
    attachment_slot_design_to_planned, 
    attachment_slot_design_to_realized, 
    attachment_slot_planned_to_realized, 
    breakdown_element_group_assignment, 
    breakdown_element_usage, 
    configuration_item, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_group_assignment, 
    product_in_attachment_slot, 
    product_relationship, 
    selected_item, 
    selected_item_assignment);
END_TYPE; 

TYPE ap239_prdi_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (alternate_product_relationship, 
    assembly_component_usage, 
    assembly_component_usage_substitute, 
    attachment_slot_design_to_planned, 
    attachment_slot_design_to_realized, 
    attachment_slot_planned_to_realized, 
    breakdown_context, 
    breakdown_element_group_assignment, 
    breakdown_element_usage, 
    configuration_item, 
    product, 
    product_definition_formation, 
    product_definition_group_assignment, 
    product_definition_relationship, 
    product_relationship, 
    selected_item, 
    shape_aspect, 
    shape_aspect_relationship);
END_TYPE; 

TYPE ap239_prdi_effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON effectivity_item WITH 
   (alternate_product_relationship, 
    applied_certification_assignment, 
    applied_contract_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    applied_identification_assignment, 
    applied_organizational_project_assignment, 
    applied_security_classification_assignment, 
    applied_usage_right, 
    assembly_component_usage, 
    assembly_component_usage_substitute, 
    attachment_slot_as_planned, 
    attachment_slot_as_realized, 
    attachment_slot_design, 
    attachment_slot_design_to_planned, 
    attachment_slot_design_to_realized, 
    attachment_slot_on_product, 
    attachment_slot_planned_to_realized, 
    breakdown_element_group_assignment, 
    breakdown_element_usage, 
    configuration_item, 
    document_relationship, 
    document_type, 
    interface_connection, 
    interface_connector_design_to_planned, 
    interface_connector_design_to_realized, 
    interface_connector_planned_to_realized, 
    make_from_usage_option, 
    organizational_address, 
    person_and_organization_address, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_group_assignment, 
    product_definition_relationship, 
    product_design_to_individual, 
    product_in_attachment_slot, 
    product_planned_to_realized, 
    product_relationship, 
    property_definition, 
    requirement_assignment, 
    requirement_source, 
    selected_item_assignment);
END_TYPE; 

TYPE ap239_prdi_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (configuration_item, 
    product, 
    product_definition_formation, 
    product_definition_relationship, 
    product_definition_shape, 
    product_relationship, 
    shape_aspect_relationship);
END_TYPE; 

TYPE ap239_prdi_in_zone_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON in_zone_groupable_item WITH 
   (interface_definition_connection);
END_TYPE; 

TYPE ap239_prdi_ir_usage_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH 
   (alternate_product_relationship, 
    applied_usage_right, 
    assembly_component_usage, 
    assembly_component_usage_substitute, 
    attachment_slot_design_to_planned, 
    attachment_slot_design_to_realized, 
    attachment_slot_on_product, 
    breakdown_element_group_assignment, 
    breakdown_element_usage, 
    configuration_item, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_group_assignment);
END_TYPE; 

TYPE ap239_prdi_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (alternate_product_relationship, 
    assembly_component_usage, 
    assembly_component_usage_substitute, 
    attachment_slot_design_to_planned, 
    attachment_slot_design_to_realized, 
    attachment_slot_on_product, 
    attachment_slot_planned_to_realized, 
    breakdown_element_group_assignment, 
    breakdown_element_usage, 
    configuration_item, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_group_assignment, 
    product_relationship);
END_TYPE; 

TYPE ap239_prdi_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (alternate_product_relationship, 
    approval, 
    assembly_component_usage, 
    assembly_component_usage_substitute, 
    breakdown_element_group_assignment, 
    breakdown_element_usage, 
    configuration_item, 
    product, 
    product_definition_formation, 
    product_definition_group_assignment, 
    product_relationship, 
    selected_item, 
    selected_item_assignment);
END_TYPE; 

TYPE ap239_prdi_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (alternate_product_relationship, 
    approval, 
    assembly_component_usage, 
    assembly_component_usage_substitute, 
    breakdown_element_group_assignment, 
    breakdown_element_usage, 
    configuration_item, 
    product, 
    product_definition_formation, 
    product_definition_group_assignment, 
    product_relationship, 
    selected_item, 
    selected_item_assignment);
END_TYPE; 

TYPE ap239_prdi_product_definition_or_product_definition_relationship = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON product_definition_or_product_definition_relationship WITH 
   (interface_connector_occurrence);
END_TYPE; 

TYPE ap239_prdi_project_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON project_item WITH 
   (configuration_item, 
    product);
END_TYPE; 

TYPE ap239_prdi_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
   (alternate_product_relationship, 
    assembly_component_usage, 
    assembly_component_usage_substitute, 
    breakdown_element_group_assignment, 
    breakdown_element_usage, 
    configuration_item, 
    product, 
    product_definition_formation, 
    product_definition_group_assignment, 
    product_in_attachment_slot);
END_TYPE; 

TYPE ap239_prdi_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH 
   (alternate_product_relationship, 
    assembly_component_usage, 
    assembly_component_usage_substitute, 
    attachment_slot_design_to_planned, 
    attachment_slot_design_to_realized, 
    attachment_slot_on_product, 
    attachment_slot_planned_to_realized, 
    breakdown_element_group_assignment, 
    breakdown_element_usage, 
    configuration_item, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_group_assignment, 
    product_relationship);
END_TYPE; 

TYPE ap239_prdi_selected_item_context_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON selected_item_context_items WITH 
   (configuration_item, 
    contract, 
    organizational_project, 
    product, 
    product_definition_formation, 
    product_concept);
END_TYPE; 

TYPE ap239_prdi_selected_item_select = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON selected_item_select WITH 
   (interface_connection, 
    interface_connector_definition, 
    interface_connector_occurrence, 
    interface_definition_connection, 
    product, 
    product_definition_formation);
END_TYPE; 

TYPE ap239_prdi_state_observed_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_observed_of_item WITH 
   (alternate_product_relationship, 
    assembly_component_usage, 
    assembly_component_usage_substitute, 
    attachment_slot_design_to_planned, 
    attachment_slot_design_to_realized, 
    attachment_slot_on_product, 
    attachment_slot_planned_to_realized, 
    breakdown_element_group_assignment, 
    breakdown_element_usage, 
    configuration_item, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_group_assignment, 
    product_in_attachment_slot);
END_TYPE; 

TYPE ap239_prdi_state_type_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_type_of_item WITH 
   (alternate_product_relationship, 
    assembly_component_usage, 
    assembly_component_usage_substitute, 
    attachment_slot_design_to_planned, 
    attachment_slot_design_to_realized, 
    attachment_slot_on_product, 
    attachment_slot_planned_to_realized, 
    breakdown_element_group_assignment, 
    breakdown_element_usage, 
    configuration_item, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_group_assignment, 
    product_in_attachment_slot);
END_TYPE; 

SUBTYPE_CONSTRAINT ap239_prdi_restrict_breakdown_context_subtypes FOR breakdown_context;
  ONEOF (functional_breakdown_context,
         physical_breakdown_context,
         system_breakdown_context,
         zone_breakdown_context);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT ap239_prdi_restrict_breakdown_element_usage_subtypes FOR breakdown_element_usage;
  ONEOF (functional_element_usage,
         physical_element_usage,
         system_element_usage,
         zone_element_usage);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT ap239_prdi_restrict_product_definition_relationship_subtypes FOR product_definition_relationship;
  ONEOF (attachment_slot_on_product,
         breakdown_context,
         breakdown_element_usage,
         breakdown_of,
         interface_definition_connection,
         interface_definition_for,
         product_in_attachment_slot);
END_SUBTYPE_CONSTRAINT;

RULE ap239_prdi_restrict_product_category_for_product FOR 
(product);
WHERE
  WR1: SIZEOF(QUERY(p <* product | SIZEOF(QUERY(prpc <* USEDIN(p, 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name IN ['assembly', 'attachment slot', 'breakdown', 'breakdown element', 'conceptual product', 'detail', 'document', 'envelope', 'functional breakdown', 'functionality', 'interface connector', 'interface specification', 'justification', 'message', 'part', 'physical breakdown', 'physically realized product', 'prototype part', 'raw material', 'requirement', 'spare part', 'standard', 'system breakdown', 'system element', 'tool', 'zone breakdown', 'zone element'])) <> 1)) = 0;
END_RULE; 

END_SCHEMA;  -- Ap239_product_definition_information_mim


--
-- AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_product_life_cycle_support/mim.exp)
--
(*
 ISO TC184/SC4/WG3 N11069 - ISO/TS 10303-439 AP239 product life cycle support - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG3 N2789
*)


SCHEMA Ap239_product_life_cycle_support_mim;

USE FROM Analysis_assignment_mim;    -- ISO/TS 10303-1474

USE FROM Analysis_characterized_mim;    -- ISO/TS 10303-1475

USE FROM Ap239_activity_recording_mim;    -- ISO/TS 10303-1287

USE FROM Ap239_product_status_recording_mim;    -- ISO/TS 10303-1304

USE FROM application_context_schema   -- ISO 10303-41
  (application_context,
   application_protocol_definition);

USE FROM Assignment_object_relationship_mim;    -- ISO/TS 10303-1847

USE FROM Conditional_effectivity_mim;    -- ISO/TS 10303-1397

USE FROM Description_assignment_mim;    -- ISO/TS 10303-1473

USE FROM Extended_person_organization_mim;    -- ISO/TS 10303-1825

USE FROM External_analysis_representation_mim;    -- ISO/TS 10303-1784

USE FROM External_representation_item_mim;    -- ISO/TS 10303-1779

USE FROM material_property_definition_schema --ISO 10303-45
  (generic_property_relationship);

USE FROM product_definition_schema -- ISO 10303-41
  (characterized_product,
   product_definition_or_reference);

USE FROM Product_environment_observed_mim;    -- ISO/TS 10303-1401

USE FROM Property_as_definition_mim;    -- ISO/TS 10303-1399

USE FROM Retention_period_mim;    -- ISO/TS 10303-1852

USE FROM Risk_management_mim;    -- ISO/TS 10303-1467

USE FROM System_view_definition_mim;    -- ISO/TS 10303-1485

USE FROM Verification_and_validation_mim;    -- ISO/TS 10303-1488

TYPE plcs_action_items = SELECT BASED_ON action_items WITH
  (action_directive,
   action_directive_relationship,
   action_method,
   action_method_relationship,
   action_property,
   action_relationship,
   action_resource_relationship,
   action_resource_requirement_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_classification_assignment,
   applied_classification_assignment_relationship,
   applied_contract_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_identification_assignment,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_organization_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_position_in_organization_group_assignment,
   applied_position_in_organization_type_assignment,
   applied_qualification_type_assignment,
   applied_time_interval_assignment,
   approval,
   approval_relationship,
   ascribable_state,
   ascribable_state_relationship,
   assignment_object_relationship,
   assumption_assignment,
   assumption_relationship,
   attachment_slot_planned_to_realized,
   collection_assignment,
   collection_membership,
   configuration_design,
   configuration_effectivity,
   configuration_item_relationship,
   contract_relationship,
   date_and_time_assignment,
   date_assignment,
   effectivity_relationship,
   environment_definition_view,
   event_occurrence_relationship,
   evidence,
   experience_type_relationship,
   general_property_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   item_assumed,
   location_relationship,
   observed_environment_to_definition_version,
   observed_environment_view,
   organization_relationship,
   organizational_address,
   organizational_project_relationship,
   person_type_definition_relationship,
   position_in_organization_relationship,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition_formation,
   product_definition_relationship,
   product_design_version_to_individual,
   product_group_membership,
   product_planned_to_realized,
   product_relationship,
   property_definition_representation,
   qualification_type_relationship,
   representation,
   representation_item,
   representation_relationship,
   retention,
   state_type_relationship,
   time_interval_relationship,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE plcs_action_method_items = SELECT BASED_ON action_method_items WITH
  (applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_contract_assignment,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_ineffectivity_assignment,
   applied_organization_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_security_classification_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   date_and_time_assignment,
   date_assignment,
   general_property_relationship,
   group,
   group_relationship,
   organizational_address,
   position_in_organization,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_definition_relationship,
   product_group_membership,
   product_planned_to_realized,
   property_definition_representation,
   representation_relationship,
   versioned_action_request);
END_TYPE;

TYPE plcs_action_request_item = SELECT BASED_ON action_request_item WITH
  (action,
   action_resource,
   applied_action_assignment,
   group,
   group_relationship,
   organizational_project,
   position_in_organization,
   product_definition_formation,
   product_definition_relationship,
   product_group_membership,
   product_identification,
   state_observed,
   state_type);
END_TYPE;

TYPE plcs_analysed_item = SELECT BASED_ON analysed_item WITH
  (action,
   action_method,
   action_method_assignment,
   action_method_relationship,
   action_property,
   action_relationship,
   action_resource_relationship,
   alternate_product_relationship,
   ascribable_state,
   assembly_component_usage_substitute,
   evidence,
   group_relationship,
   interface_connection,
   interface_connector_occurrence,
   observation_consequence,
   organization,
   organization_relationship,
   organizational_project_relationship,
   product,
   product_concept,
   product_definition,
   product_definition_context,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_relationship,
   property_definition,
   requirement_assignment,
   resource_property,
   state_observed,
   state_observed_role,
   state_type,
   validation,
   verification);
END_TYPE;

TYPE plcs_approval_item = SELECT BASED_ON approval_item WITH
  (action_directive_relationship,
   action_method_relationship,
   action_property,
   action_relationship,
   action_resource_relationship,
   applied_action_assignment,
   applied_approval_assignment,
   applied_classification_assignment_relationship,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_ineffectivity_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_time_interval_assignment,
   approval_relationship,
   ascribable_state,
   ascribable_state_relationship,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   collection_assignment,
   collection_membership,
   configuration_design,
   configuration_effectivity,
   configuration_item_relationship,
   contract_relationship,
   document_file,
   document_relationship,
   effectivity_relationship,
   envelope_relationship,
   event_occurrence_relationship,
   evidence,
   experience_type_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   item_assumed,
   location_relationship,
   message_relationship,
   observed_environment_to_definition,
   observed_environment_to_definition_version,
   organizational_project_relationship,
   person_type_definition_relationship,
   position_in_organization_relationship,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition_formation,
   product_definition_relationship,
   property_definition_representation,
   qualification_type_relationship,
   representation,
   representation_item,
   representation_relationship,
   time_interval_relationship,
   versioned_action_request_relationship);
END_TYPE;

TYPE plcs_assignment_object_select = SELECT BASED_ON assignment_object_select WITH
  (action_method,
   action_request_solution,
   analysis_assignment,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_contract_assignment,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_organization_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_position_in_organization_assignment,
   applied_position_in_organization_group_assignment,
   applied_position_in_organization_type_assignment,
   applied_qualification_type_assignment,
   applied_security_classification_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   ascribable_state,
   collection_assignment,
   date_and_time_assignment,
   date_assignment,
   environment_assignment,
   justification_assignment,
   justification_support_assignment,
   observed_environment_assignment,
   organizational_address,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   property_definition,
   property_definition_representation,
   requirement_assignment,
   risk_impact_assignment,
   risk_perception_source_assignment,
   state_observed_assignment);
END_TYPE;

TYPE plcs_attribute_language_item = SELECT BASED_ON attribute_language_item WITH
  (action_directive_relationship,
   action_relationship,
   applied_classification_assignment_relationship,
   applied_description_text_assignment_relationship,
   applied_external_identification_assignment_relationship,
   applied_person_and_organization_assignment,
   ascribable_state,
   ascribable_state_relationship,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   class,
   compound_address,
   description_text,
   effectivity,
   effectivity_relationship,
   event_occurrence_relationship,
   evidence,
   external_class_library,
   generic_property_relationship,
   group_relationship,
   in_zone,
   item_assumed,
   location_representation_relationship,
   measure_qualification,
   organization,
   product,
   product_concept,
   product_concept_context,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category,
   product_concept_relationship,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   property_definition,
   property_definition_representation,
   representation,
   representation_context,
   representation_relationship,
   retention,
   satisfies_requirement,
   security_classification,
   time_interval,
   time_interval_relationship,
   uncertainty_qualifier,
   validation,
   verification,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE plcs_certification_item = SELECT BASED_ON certification_item WITH
  (alternate_product_relationship,
   analysis_assignment,
   assembly_component_usage,
   evidence,
   group_relationship,
   product_definition,
   product_definition_formation,
   product_definition_occurrence,
   product_definition_occurrence_reference,
   product_planned_to_realized,
   product_relationship);
END_TYPE;

TYPE plcs_classification_item = SELECT BASED_ON classification_item WITH
  (action_directive_relationship,
   action_relationship,
   analysis_assignment,
   applied_action_assignment,
   applied_classification_assignment,
   applied_classification_assignment_relationship,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_external_identification_assignment_relationship,
   applied_ineffectivity_assignment,
   applied_organization_type_assignment,
   applied_person_and_organization_assignment,
   applied_time_interval_assignment,
   ascribable_state,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   collection_assignment,
   collection_membership,
   configuration_design,
   configuration_item_relationship,
   connection_definition_to_connection,
   date_and_time_assignment,
   date_assignment,
   document_file,
   effectivity_relationship,
   evidence,
   experience_type_relationship,
   generic_property_relationship,
   group_relationship,
   identification_assignment_relationship,
   inclusion_product_concept_feature,
   item_assumed,
   measure_qualification,
   observed_environment_to_definition,
   observed_environment_to_definition_version,
   product,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition_formation,
   product_definition_relationship,
   product_group_membership,
   product_planned_to_realized,
   property_definition_representation,
   representation_relationship,
   retention,
   satisfies_requirement,
   validation,
   verification,
   versioned_action_request_relationship);
END_TYPE;

TYPE plcs_collection_assignment_groupable_item = SELECT BASED_ON collection_assignment_groupable_item WITH
  (action,
   action_directive,
   action_method,
   action_resource,
   action_resource_requirement,
   applied_experience_assignment,
   applied_position_in_organization_assignment,
   assumption,
   configuration_item,
   contract,
   evidence,
   experience,
   experience_type,
   general_property,
   group,
   organization,
   organizational_project,
   person_type,
   person_type_definition,
   position_in_organization,
   position_in_organization_type,
   product,
   product_concept,
   product_definition,
   product_definition_formation,
   qualification_type,
   versioned_action_request);
END_TYPE;

TYPE plcs_collection_membership_groupable_item = SELECT BASED_ON collection_membership_groupable_item WITH
  (action,
   action_directive,
   action_method,
   action_method_assignment,
   action_method_relationship,
   action_property,
   action_property_representation,
   action_relationship,
   action_request_solution,
   action_request_status,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   action_status,
   address,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_attribute_classification_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_contract_assignment,
   applied_description_text_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_experience_assignment,
   applied_external_identification_assignment,
   applied_group_assignment,
   applied_identification_assignment,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_location_representation_assignment,
   applied_name_assignment,
   applied_organization_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_group_assignment,
   applied_qualification_type_assignment,
   applied_security_classification_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval,
   approval_person_organization,
   approval_relationship,
   approval_status,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage_substitute,
   attribute_language_assignment,
   calendar_date,
   certification,
   configuration_design,
   configuration_item,
   configuration_item_relationship,
   context_dependent_shape_representation,
   contract,
   contract_relationship,
   coordinated_universal_time_offset,
   date_and_time,
   date_and_time_assignment,
   date_assignment,
   derived_unit,
   derived_unit_element,
   description_text,
   document_file,
   document_relationship,
   effectivity,
   effectivity_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   experience,
   experience_type,
   experience_type_relationship,
   external_source,
   general_property,
   general_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   item_defined_transformation,
   item_identified_representation_usage,
   local_time,
   location,
   location_relationship,
   measure_qualification,
   measure_with_unit,
   multi_language_attribute_assignment,
   named_unit,
   organization,
   organization_relationship,
   organization_type,
   organizational_project,
   organizational_project_relationship,
   person,
   person_and_organization,
   person_type,
   person_type_definition,
   person_type_definition_relationship,
   position_in_organization,
   position_in_organization_assignment,
   position_in_organization_relationship,
   position_in_organization_type,
   position_in_organization_type_assignment,
   precision_qualifier,
   product,
   product_concept,
   product_concept_context,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_group_membership,
   product_relationship,
   property_definition,
   property_definition_representation,
   qualification_type,
   qualification_type_relationship,
   representation,
   representation_context,
   representation_item,
   representation_relationship,
   resource_property,
   resource_property_representation,
   security_classification,
   shape_aspect,
   shape_aspect_relationship,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_observed_role,
   state_type,
   state_type_relationship,
   state_type_role,
   time_interval,
   time_interval_relationship,
   time_interval_role,
   type_qualifier,
   uncertainty_qualifier,
   value_function,
   versioned_action_request);
END_TYPE;

TYPE plcs_condition_action_method_items = SELECT BASED_ON condition_action_method_items WITH
  (action_resource_requirement_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_description_text_assignment,
   applied_directed_action_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_ineffectivity_assignment,
   applied_organizational_project_assignment,
   applied_security_classification_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   condition,
   configuration_item,
   effectivity,
   evidence,
   general_property,
   general_property_relationship,
   group_relationship,
   organization,
   organization_type,
   organizational_address,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_relationship,
   property_definition_representation,
   representation_item,
   representation_relationship,
   requirement_assignment,
   validation,
   verification,
   versioned_action_request);
END_TYPE;

TYPE plcs_condition_evaluation_action_items = SELECT BASED_ON condition_evaluation_action_items WITH
  (action_method,
   action_resource,
   action_resource_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_description_text_assignment,
   assembly_component_usage,
   evidence,
   group_relationship,
   validation,
   verification);
END_TYPE;

TYPE plcs_contract_item = SELECT BASED_ON contract_item WITH
  (action_directive,
   applied_classification_assignment,
   applied_description_text_assignment,
   applied_external_identification_assignment,
   applied_identification_assignment,
   dependent_product_definition_exchange_context,
   organization,
   person_and_organization,
   product,
   product_definition,
   product_definition_formation,
   requirement_view_definition_relationship,
   validation,
   verification,
   versioned_action_request);
END_TYPE;

TYPE plcs_date_and_time_item = SELECT BASED_ON date_and_time_item WITH
  (action_directive_relationship,
   action_method_relationship,
   action_property,
   action_relationship,
   action_resource_relationship,
   action_resource_requirement_relationship,
   address,
   applied_action_assignment,
   applied_approval_assignment,
   applied_classification_assignment_relationship,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_ineffectivity_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_time_interval_assignment,
   approval_person_organization,
   approval_relationship,
   ascribable_state,
   ascribable_state_relationship,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   collection_assignment,
   collection_membership,
   configuration_design,
   configuration_effectivity,
   configuration_item_relationship,
   contract_relationship,
   document_file,
   document_relationship,
   effectivity_relationship,
   envelope_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   experience_type_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   information_right,
   item_assumed,
   location,
   location_relationship,
   message_relationship,
   observed_environment_to_definition,
   observed_environment_to_definition_version,
   organization,
   organizational_project_relationship,
   person_type_definition_relationship,
   position_in_organization_relationship,
   product,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition_formation,
   product_definition_relationship,
   property_definition_representation,
   qualification_type_relationship,
   representation_item,
   representation_relationship,
   time_interval_relationship,
   versioned_action_request_relationship);
END_TYPE;

TYPE plcs_date_item = SELECT BASED_ON date_item WITH
  (action_directive_relationship,
   action_method_relationship,
   action_property,
   action_relationship,
   action_resource_relationship,
   action_resource_requirement_relationship,
   address,
   applied_action_assignment,
   applied_approval_assignment,
   applied_classification_assignment_relationship,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_ineffectivity_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_time_interval_assignment,
   approval_person_organization,
   approval_relationship,
   ascribable_state,
   ascribable_state_relationship,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   collection_assignment,
   collection_membership,
   configuration_design,
   configuration_effectivity,
   configuration_item_relationship,
   contract_relationship,
   document_file,
   document_relationship,
   effectivity_relationship,
   envelope_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   experience_type_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   information_right,
   item_assumed,
   location,
   location_relationship,
   message_relationship,
   observed_environment_to_definition,
   observed_environment_to_definition_version,
   organization,
   organizational_project_relationship,
   person_type_definition_relationship,
   position_in_organization_relationship,
   product,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition_formation,
   product_definition_relationship,
   property_definition_representation,
   qualification_type_relationship,
   representation_item,
   representation_relationship,
   time_interval_relationship,
   versioned_action_request_relationship);
END_TYPE;

TYPE plcs_description_item = SELECT BASED_ON description_item WITH
  (action,
   action_directive,
   action_directive_relationship,
   action_method,
   action_method_relationship,
   action_property,
   action_property_representation,
   action_relationship,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   address,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_classification_assignment_relationship,
   applied_contract_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_identification_assignment,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_location_representation_assignment,
   applied_organization_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_group_assignment,
   applied_qualification_type_assignment,
   applied_security_classification_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval,
   approval_relationship,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage_substitute,
   assignment_object_relationship,
   certification,
   collection_assignment,
   collection_membership,
   configuration_design,
   configuration_item,
   configuration_item_relationship,
   contract,
   contract_relationship,
   date_and_time_assignment,
   date_assignment,
   document_file,
   document_relationship,
   effectivity,
   effectivity_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   experience,
   experience_type,
   experience_type_relationship,
   external_source,
   general_property,
   general_property_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   item_identified_representation_usage,
   location,
   location_relationship,
   measure_qualification,
   organization,
   organization_relationship,
   organization_type,
   organizational_project,
   organizational_project_relationship,
   person,
   person_and_organization,
   person_type,
   person_type_definition,
   person_type_definition_relationship,
   position_in_organization,
   position_in_organization_assignment,
   position_in_organization_relationship,
   position_in_organization_type,
   position_in_organization_type_assignment,
   product,
   product_concept,
   product_concept_context,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_group_membership,
   product_relationship,
   property_definition,
   property_definition_representation,
   qualification_type,
   qualification_type_relationship,
   representation,
   representation_context,
   representation_item,
   representation_relationship,
   resource_property,
   resource_property_representation,
   risk_impact_assignment,
   risk_perception_source_assignment,
   security_classification,
   shape_aspect,
   shape_aspect_relationship,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_observed_role,
   state_type,
   state_type_relationship,
   state_type_role,
   time_interval,
   time_interval_relationship,
   uncertainty_measure_with_unit,
   uncertainty_qualifier,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE plcs_document_reference_item = SELECT BASED_ON document_reference_item WITH
  (action_method,
   action_method_relationship,
   action_property,
   action_relationship,
   action_resource_relationship,
   address,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_classification_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_ineffectivity_assignment,
   applied_location_representation_assignment,
   applied_organizational_project_assignment,
   applied_person_type_assignment,
   applied_position_in_organization_group_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval_relationship,
   ascribable_state_relationship,
   assumption,
   configuration_design,
   date_and_time_assignment,
   date_assignment,
   document_relationship,
   effectivity_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   external_source,
   group,
   group_relationship,
   identification_assignment_relationship,
   item_identified_representation_usage,
   location,
   location_relationship,
   measure_qualification,
   observed_environment_to_definition,
   observed_environment_to_definition_version,
   organizational_project_relationship,
   person_type_definition_relationship,
   position_in_organization_assignment,
   position_in_organization_relationship,
   position_in_organization_type_assignment,
   product,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_definition_context,
   product_definition_formation,
   product_definition_relationship,
   property_definition,
   property_definition_representation,
   qualification_type_relationship,
   representation,
   representation_item,
   representation_relationship,
   retention,
   state_observed_assignment,
   state_observed_relationship,
   state_observed_role,
   state_type_relationship,
   state_type_role,
   time_interval,
   time_interval_relationship,
   uncertainty_measure_with_unit,
   uncertainty_qualifier);
END_TYPE;

TYPE plcs_effectivity_item = SELECT BASED_ON effectivity_item WITH
  (action_directive_relationship,
   action_method,
   action_method_relationship,
   action_property,
   action_property_representation,
   action_relationship,
   action_resource_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_classification_assignment,
   applied_classification_assignment_relationship,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_ineffectivity_assignment,
   applied_organization_type_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_qualification_type_assignment,
   applied_time_interval_assignment,
   approval,
   approval_relationship,
   ascribable_state,
   ascribable_state_relationship,
   assignment_object_relationship,
   assumption,
   collection_assignment,
   collection_membership,
   compound_person_name,
   configuration_design,
   configuration_item_relationship,
   contract,
   contract_relationship,
   effectivity_relationship,
   envelope_relationship,
   event_occurrence_relationship,
   evidence,
   experience_type_relationship,
   general_property,
   general_property_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   location_relationship,
   message_relationship,
   observed_environment_to_definition,
   observed_environment_to_definition_version,
   organization,
   organizational_project,
   organizational_project_relationship,
   position_in_organization_relationship,
   product_class,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition_formation,
   product_definition_relationship,
   property_definition_representation,
   qualification_type_relationship,
   representation,
   representation_item,
   representation_relationship,
   resource_property_representation,
   risk_impact_assignment,
   risk_perception_source_assignment,
   security_classification,
   state_observed_assignment,
   state_observed_relationship,
   time_interval_relationship,
   versioned_action_request_relationship);
END_TYPE;

TYPE plcs_event_occurrence_item = SELECT BASED_ON event_occurrence_item WITH
  (action,
   action_directive,
   action_directive_relationship,
   action_method,
   action_method_relationship,
   action_property,
   action_relationship,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   address,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_classification_assignment_relationship,
   applied_contract_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_location_representation_assignment,
   applied_organization_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_position_in_organization_group_assignment,
   applied_position_in_organization_type_assignment,
   applied_qualification_type_assignment,
   applied_security_classification_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval,
   approval_relationship,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage_substitute,
   assignment_object_relationship,
   assumption,
   collection_assignment,
   collection_membership,
   configuration_design,
   configuration_item_relationship,
   contract,
   contract_relationship,
   date_and_time_assignment,
   date_assignment,
   document_file,
   document_relationship,
   effectivity,
   effectivity_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   experience,
   experience_type_relationship,
   general_property,
   general_property_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   location,
   location_relationship,
   organization,
   organization_relationship,
   organizational_project_relationship,
   person,
   person_and_organization,
   person_type_definition_relationship,
   position_in_organization_relationship,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_group_membership,
   product_identification,
   product_relationship,
   property_definition,
   property_definition_representation,
   qualification_type_relationship,
   representation,
   representation_item,
   representation_relationship,
   risk_impact_assignment,
   risk_perception_source_assignment,
   security_classification,
   state_observed_assignment,
   state_observed_relationship,
   state_type_relationship,
   time_interval_relationship,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE plcs_evidence_item = SELECT BASED_ON evidence_item WITH
  (action_actual,
   action_method,
   action_relationship,
   action_status,
   analysis_assignment,
   applied_action_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_contract_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_ineffectivity_assignment,
   applied_organization_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_security_classification_assignment,
   applied_usage_right,
   date_and_time_assignment,
   date_assignment,
   group_relationship,
   justification_assignment,
   justification_support_assignment,
   person_and_organization,
   product,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_relationship,
   property_definition,
   property_definition_representation,
   representation,
   representation_item,
   risk_impact_assignment);
END_TYPE;

TYPE plcs_external_identification_item = SELECT BASED_ON external_identification_item WITH
  (action,
   action_directive,
   action_resource,
   action_resource_requirement,
   address,
   applied_action_assignment,
   applied_experience_assignment,
   applied_location_representation_assignment,
   applied_position_in_organization_assignment,
   assumption,
   breakdown_context,
   certification,
   collection_assignment,
   collection_membership,
   contract,
   effectivity,
   evidence,
   experience,
   experience_type,
   external_class_library,
   group,
   information_right,
   information_usage_right,
   interface_definition_connection,
   interface_definition_for,
   location,
   organization,
   organization_type,
   organizational_project,
   person_and_organization,
   person_type,
   position_in_organization,
   position_in_organization_type,
   precision_qualifier,
   product,
   product_category,
   product_concept,
   product_concept_context,
   product_concept_feature,
   product_definition,
   product_definition_formation,
   product_identification,
   property_definition,
   qualification_type,
   representation,
   representation_item,
   task_objective,
   type_qualifier,
   uncertainty_qualifier,
   value_format_type_qualifier,
   versioned_action_request);
END_TYPE;

TYPE plcs_groupable_item = SELECT BASED_ON groupable_item WITH
  (action_method, 
   applied_organization_assignment, 
   applied_person_and_organization_assignment, 
   group_relationship, 
   product_definition_formation, 
   state_type);
END_TYPE;

TYPE plcs_identification_item = SELECT BASED_ON identification_item WITH
  (action_directive_relationship,
   action_method,
   action_method_relationship,
   action_property,
   action_relationship,
   action_resource_relationship,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_classification_assignment_relationship,
   applied_contract_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_position_in_organization_group_assignment,
   applied_position_in_organization_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval_relationship,
   ascribable_state,
   assembly_component_usage_substitute,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   collection_assignment,
   collection_membership,
   configuration_design,
   configuration_effectivity,
   configuration_item_relationship,
   contract_relationship,
   date_and_time_assignment,
   date_assignment,
   dependent_product_definition_exchange_context,
   derived_unit,
   document_relationship,
   effectivity_relationship,
   envelope_relationship,
   event_occurrence_relationship,
   evidence,
   experience_type_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   item_assumed,
   location_relationship,
   message_relationship,
   named_unit,
   observed_environment_to_definition,
   organization_relationship,
   organizational_address,
   organizational_project_relationship,
   person_type_definition,
   person_type_definition_relationship,
   position_in_organization_relationship,
   position_in_organization_type,
   product,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_design_to_individual,
   property_definition,
   property_definition_representation,
   qualification_type_relationship,
   representation,
   representation_context,
   representation_relationship,
   retention,
   time_interval,
   time_interval_relationship,
   versioned_action_request_relationship);
END_TYPE;

TYPE plcs_in_zone_groupable_item = SELECT BASED_ON in_zone_groupable_item WITH
  (action_method,
   applied_action_method_assignment);
END_TYPE;

TYPE plcs_instance_usage_context_select = SELECT BASED_ON instance_usage_context_select WITH
  (breakdown_element_realization);
END_TYPE;

TYPE plcs_ir_usage_item = SELECT BASED_ON action_items WITH
  (analysis_assignment,
   applied_description_text_assignment,
   evidence,
   interface_definition_for,
   validation,
   verification);
END_TYPE;

TYPE plcs_justification_item = SELECT BASED_ON justification_item WITH
  (analysis_assignment,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_description_text_assignment,
   applied_state_type_assignment,
   ascribable_state,
   collection_membership,
   configuration_design,
   evidence,
   group_relationship,
   organizational_project,
   product_definition_formation,
   product_definition_relationship,
   product_planned_to_realized,
   representation,
   validation,
   verification);
END_TYPE;

TYPE plcs_justification_support_item = SELECT BASED_ON justification_support_item WITH
  (analysis_assignment,
   assembly_component_usage,
   evidence,
   group_relationship,
   product_definition_formation,
   product_planned_to_realized,
   risk_impact_assignment,
   validation,
   verification);
END_TYPE;

TYPE plcs_location_item = SELECT BASED_ON location_item WITH
  (applied_certification_assignment,
   applied_contract_assignment,
   assembly_component_usage,
   certification,
   collection_assignment,
   contract,
   contract_relationship,
   environment_definition_view,
   group_relationship,
   information_usage_right,
   observation_consequence,
   observed_environment_view);
END_TYPE;

TYPE plcs_message_content_groupable_item = SELECT BASED_ON groupable_item WITH
  (action, 
   action_directive, 
   action_directive_relationship, 
   action_method, 
   action_method_relationship, 
   action_property, 
   action_relationship, 
   action_resource, 
   action_resource_relationship, 
   action_resource_requirement, 
   action_resource_requirement_relationship, 
   address, 
   alternate_product_relationship, 
   applied_action_assignment, 
   applied_action_method_assignment, 
   applied_action_request_assignment, 
   applied_approval_assignment, 
   applied_certification_assignment, 
   applied_classification_assignment, 
   applied_classification_assignment_relationship, 
   applied_contract_assignment, 
   applied_description_text_assignment, 
   applied_description_text_assignment_relationship, 
   applied_directed_action_assignment, 
   applied_document_reference, 
   applied_document_usage_constraint_assignment, 
   applied_effectivity_assignment, 
   applied_event_occurrence_assignment, 
   applied_experience_assignment, 
   applied_external_identification_assignment, 
   applied_external_identification_assignment_relationship, 
   applied_identification_assignment, 
   applied_ineffectivity_assignment, 
   applied_location_assignment, 
   applied_location_representation_assignment, 
   applied_organization_assignment, 
   applied_organization_type_assignment, 
   applied_organizational_project_assignment, 
   applied_person_and_organization_assignment, 
   applied_person_type_assignment, 
   applied_person_type_definition_assignment, 
   applied_position_in_organization_assignment, 
   applied_position_in_organization_group_assignment, 
   applied_position_in_organization_type_assignment, 
   applied_qualification_type_assignment, 
   applied_security_classification_assignment, 
   applied_state_type_assignment, 
   applied_time_interval_assignment, 
   applied_usage_right, 
   approval, 
   approval_relationship, 
   ascribable_state, 
   ascribable_state_relationship, 
   assembly_component_usage_substitute, 
   assignment_object_relationship, 
   certification, 
   collection_assignment, 
   collection_membership, 
   compound_person_name, 
   configuration_design, 
   configuration_item, 
   configuration_item_relationship, 
   contract, 
   contract_relationship, 
   date_and_time_assignment, 
   date_assignment, 
   derived_unit, 
   document_file, 
   document_relationship, 
   effectivity, 
   effectivity_relationship, 
   event_occurrence, 
   event_occurrence_relationship, 
   evidence, 
   experience, 
   experience_type, 
   experience_type_relationship, 
   external_class_library, 
   general_property, 
   general_property_relationship, 
   generic_attribute, 
   generic_property_relationship, 
   group, 
   group_relationship, 
   identification_assignment_relationship, 
   location, 
   location_relationship, 
   measure_qualification, 
   named_unit, 
   organization, 
   organization_relationship, 
   organization_type, 
   organizational_project, 
   organizational_project_relationship, 
   person, 
   person_and_organization, 
   person_type, 
   person_type_definition, 
   person_type_definition_relationship, 
   position_in_organization_relationship, 
   position_in_organization_type, 
   precision_qualifier, 
   product, 
   product_category, 
   product_concept, 
   product_concept_context, 
   product_concept_feature, 
   product_concept_feature_association, 
   product_concept_feature_category_usage, 
   product_concept_relationship, 
   product_definition, 
   product_definition_context, 
   product_definition_formation, 
   product_definition_formation_relationship, 
   product_definition_relationship, 
   product_group_membership, 
   product_relationship, 
   property_definition, 
   property_definition_representation, 
   qualification_type, 
   qualification_type_relationship, 
   representation, 
   representation_context, 
   representation_item, 
   representation_relationship, 
   risk_impact_assignment, 
   risk_perception_source_assignment, 
   security_classification, 
   state_observed, 
   state_observed_assignment, 
   state_observed_relationship, 
   state_type, 
   state_type_relationship, 
   time_interval, 
   time_interval_relationship, 
   type_qualifier, 
   uncertainty_qualifier, 
   value_format_type_qualifier, 
   versioned_action_request, 
   versioned_action_request_relationship);
END_TYPE;

TYPE plcs_multi_language_attribute_item = SELECT BASED_ON multi_language_attribute_item WITH
  (action_directive_relationship,
   action_relationship,
   applied_classification_assignment_relationship,
   applied_description_text_assignment_relationship,
   applied_external_identification_assignment_relationship,
   applied_person_and_organization_assignment,
   applied_position_in_organization_assignment,
   ascribable_state,
   ascribable_state_relationship,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   compound_address,
   description_text,
   effectivity,
   effectivity_relationship,
   event_occurrence_relationship,
   evidence,
   experience,
   generic_property_relationship,
   group,
   group_relationship,
   item_assumed,
   measure_qualification,
   organization,
   product,
   product_concept,
   product_concept_context,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_relationship,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   property_definition,
   property_definition_representation,
   qualification_type_relationship,
   representation,
   representation_context,
   representation_relationship,
   retention,
   security_classification,
   time_interval,
   time_interval_relationship,
   uncertainty_qualifier,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE plcs_observation_item = SELECT BASED_ON action_items WITH
  (action,
   action_directive,
   action_directive_relationship,
   action_method,
   action_method_assignment,
   action_method_relationship,
   action_property,
   action_property_representation,
   action_relationship,
   action_request_solution,
   action_request_status,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   action_status,
   address,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_attribute_classification_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_classification_assignment_relationship,
   applied_contract_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_experience_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_group_assignment,
   applied_identification_assignment,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_location_representation_assignment,
   applied_name_assignment,
   applied_organization_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_group_assignment,
   applied_qualification_type_assignment,
   applied_security_classification_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval,
   approval_person_organization,
   approval_relationship,
   approval_status,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage_substitute,
   assignment_object_relationship,
   attribute_language_assignment,
   calendar_date,
   certification,
   compound_person_name,
   configuration_design,
   configuration_item,
   configuration_item_relationship,
   context_dependent_shape_representation,
   contract,
   contract_relationship,
   coordinated_universal_time_offset,
   date_and_time,
   date_and_time_assignment,
   date_assignment,
   derived_unit,
   derived_unit_element,
   description_text,
   document_file,
   document_relationship,
   effectivity,
   effectivity_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   experience,
   experience_type,
   experience_type_relationship,
   external_source,
   general_property,
   general_property_relationship,
   generic_attribute,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   item_defined_transformation,
   item_identified_representation_usage,
   local_time,
   location,
   location_relationship,
   measure_qualification,
   measure_with_unit,
   multi_language_attribute_assignment,
   named_unit,
   organization,
   organization_relationship,
   organization_type,
   organizational_project,
   organizational_project_relationship,
   person,
   person_and_organization,
   person_type,
   person_type_definition,
   person_type_definition_relationship,
   position_in_organization,
   position_in_organization_assignment,
   position_in_organization_relationship,
   position_in_organization_type,
   position_in_organization_type_assignment,
   precision_qualifier,
   product,
   product_category,
   product_concept,
   product_concept_context,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_group_membership,
   product_relationship,
   property_definition,
   property_definition_representation,
   qualification_type,
   qualification_type_relationship,
   representation,
   representation_context,
   representation_item,
   representation_relationship,
   resource_property,
   resource_property_representation,
   risk_impact_assignment,
   risk_perception_source_assignment,
   security_classification,
   shape_aspect,
   shape_aspect_relationship,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_observed_role,
   state_type,
   state_type_relationship,
   state_type_role,
   time_interval,
   time_interval_relationship,
   time_interval_role,
   type_qualifier,
   uncertainty_qualifier,
   value_format_type_qualifier,
   value_function,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE plcs_observed_context_item = SELECT BASED_ON observed_context_item WITH
  (analysis_assignment,
   assembly_component_usage);
END_TYPE;

TYPE plcs_organization_item = SELECT BASED_ON organization_item WITH
  (action_directive_relationship,
   action_method_relationship,
   action_property,
   action_relationship,
   action_resource_relationship,
   action_resource_requirement_relationship,
   address,
   applied_action_assignment,
   applied_approval_assignment,
   applied_classification_assignment_relationship,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_ineffectivity_assignment,
   applied_location_representation_assignment,
   applied_organization_type_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval_relationship,
   ascribable_state,
   ascribable_state_relationship,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   collection_assignment,
   collection_membership,
   configuration_design,
   configuration_effectivity,
   configuration_item_relationship,
   contract_relationship,
   document_file,
   document_relationship,
   effectivity_relationship,
   envelope_relationship,
   event_occurrence_relationship,
   evidence,
   experience_type_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   information_right,
   item_assumed,
   location,
   location_relationship,
   message_relationship,
   observed_environment_to_definition,
   organization_relationship,
   organizational_project_relationship,
   person,
   person_type,
   person_type_definition_relationship,
   position_in_organization_relationship,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_design_to_individual,
   property_definition_representation,
   qualification_type_relationship,
   representation,
   representation_item,
   representation_relationship,
   time_interval_relationship,
   versioned_action_request_relationship);
END_TYPE;

TYPE plcs_person_and_organization_item = SELECT BASED_ON person_and_organization_item WITH
  (action_directive_relationship,
   action_method_relationship,
   action_property,
   action_relationship,
   action_resource_relationship,
   action_resource_requirement_relationship,
   address,
   applied_action_assignment,
   applied_approval_assignment,
   applied_classification_assignment_relationship,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_ineffectivity_assignment,
   applied_location_representation_assignment,
   applied_organization_type_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval_relationship,
   ascribable_state,
   ascribable_state_relationship,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   collection_assignment,
   collection_membership,
   configuration_design,
   configuration_effectivity,
   configuration_item_relationship,
   contract_relationship,
   document_file,
   document_relationship,
   effectivity_relationship,
   envelope_relationship,
   event_occurrence_relationship,
   evidence,
   experience_type_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   information_right,
   item_assumed,
   location,
   location_relationship,
   message_relationship,
   observed_environment_to_definition,
   organization_relationship,
   organizational_project_relationship,
   person,
   person_type,
   person_type_definition_relationship,
   position_in_organization_relationship,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_design_to_individual,
   property_definition_representation,
   qualification_type_relationship,
   representation,
   representation_item,
   representation_relationship,
   time_interval_relationship,
   versioned_action_request_relationship);
END_TYPE;

TYPE plcs_person_type_item = SELECT BASED_ON person_type_item WITH
  (analysis_assignment);
END_TYPE;

TYPE plcs_position_in_organization_group_item = SELECT BASED_ON position_in_organization_group_item WITH
  (product_definition_formation);
END_TYPE;

TYPE plcs_position_in_organization_item = SELECT BASED_ON position_in_organization_item WITH
  (action_directive,
   action_resource,
   action_resource_requirement,
   product_definition_formation,
   product_group,
   requirement_view_definition_relationship,
   versioned_action_request);
END_TYPE;

TYPE plcs_position_in_organization_type_item = SELECT BASED_ON position_in_organization_type_item WITH
  (action_directive,
   action_resource,
   action_resource_requirement,
   product_definition_formation,
   product_group,
   requirement_view_definition_relationship,
   versioned_action_request);
END_TYPE;

TYPE plcs_product_definition_or_breakdown_element_usage = SELECT BASED_ON product_definition_or_breakdown_element_usage WITH
  (product,
   product_definition_formation);
END_TYPE;

TYPE plcs_product_definition_or_product_definition_relationship = SELECT BASED_ON product_definition_or_product_definition_relationship WITH
  (action_method,
   action_resource,
   executed_action,
   product,
   product_definition_formation);
END_TYPE;

TYPE plcs_product_definition_or_reference = SELECT BASED_ON product_definition_or_reference WITH
  (product_class,
   product_definition_formation,
   product_specification);
END_TYPE;

TYPE plcs_product_select = SELECT BASED_ON product_select WITH
  (action_method,
   environment_definition_view,
   executed_action,
   location,
   organization,
   organization_type,
   person,
   person_and_organization);
END_TYPE;

TYPE plcs_project_item = SELECT BASED_ON project_item WITH
  (assembly_component_usage,
   product_definition,
   product_definition_formation,
   product_definition_occurrence,
   product_definition_occurrence_reference,
   representation_item);
END_TYPE;

TYPE plcs_representation_proxy_select = SELECT BASED_ON requirement_representation_proxy_select WITH
  (action_method,
   state_type,
   state_type_relationship);
END_TYPE;

TYPE plcs_requirement_assigned_item = SELECT BASED_ON requirement_assigned_item WITH
  (collection_membership,
   interface_connection,
   product_definition,
   product_definition_formation,
   product_group,
   product_group_membership,
   product_relationship,
   validation,
   verification,
   versioned_action_request);
END_TYPE;

TYPE plcs_requirement_source_item = SELECT BASED_ON requirement_source_item WITH
  (applied_action_assignment,
   contract,
   executed_action,
   organization,
   organizational_project,
   person_and_organization,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_usage,
   validation,
   verification);
END_TYPE;

TYPE plcs_risk_perception_source_item = SELECT BASED_ON risk_perception_source_item WITH
  (applied_action_assignment);
END_TYPE;

TYPE plcs_scheme_entry_item = SELECT BASED_ON action_method_items WITH
  (action_method,
   action_resource,
   property_definition_representation);
END_TYPE;

TYPE plcs_scheme_subject_item = SELECT BASED_ON action_method_items WITH
  (action_method,
   action_resource,
   action_resource_requirement,
   applied_action_assignment,
   contract,
   executed_action,
   location,
   organization,
   organization_type,
   organizational_project,
   person,
   person_and_organization,
   person_type,
   product,
   product_definition,
   product_definition_formation,
   product_group,
   property_definition,
   property_definition_representation);
END_TYPE;

TYPE plcs_scheme_version_item = SELECT BASED_ON action_method_items WITH
  (action_resource,
   action_resource_requirement,
   location,
   organization,
   organization_type,
   person_type,
   product,
   product_definition,
   product_definition_formation,
   product_group,
   property_definition,
   property_definition_representation);
END_TYPE;

TYPE plcs_security_classification_item = SELECT BASED_ON security_classification_item WITH
  (action_directive,
   applied_action_assignment,
   applied_classification_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_external_identification_assignment,
   applied_identification_assignment,
   conditional_configuration,
   configuration_design,
   configuration_effectivity,
   connection_definition_to_connection,
   document_file,
   evidence,
   general_property,
   group_relationship,
   identification_assignment_relationship,
   observation,
   organizational_project,
   product,
   product_class,
   product_concept_feature,
   product_concept_feature_category,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   property_definition,
   property_definition_representation,
   representation,
   validation,
   verification,
   versioned_action_request);
END_TYPE;

TYPE plcs_state_observed_of_item = SELECT BASED_ON state_observed_of_item WITH
  (action,
   action_directive,
   action_method,
   action_property,
   action_resource,
   action_resource_requirement,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_approval_assignment,
   applied_contract_assignment,
   applied_directed_action_assignment,
   applied_location_assignment,
   applied_organizational_project_assignment,
   approval,
   collection_membership,
   configuration_design,
   configuration_item,
   contract,
   document_file,
   evidence,
   group_relationship,
   location,
   organizational_project,
   product,
   product_concept,
   product_definition,
   product_definition_element_relationship,
   product_definition_formation,
   product_definition_relationship,
   property_definition,
   requirement_assignment,
   resource_property,
   state_observed_assignment,
   versioned_action_request);
END_TYPE;

TYPE plcs_state_type_of_item = SELECT BASED_ON state_type_of_item WITH
  (action_directive,
   approval,
   contract,
   evidence,
   executed_action,
   group_relationship,
   location,
   organizational_project,
   product,
   product_concept,
   product_definition,
   product_definition_formation,
   validation,
   verification,
   versioned_action_request);
END_TYPE;

TYPE plcs_time_interval_item = SELECT BASED_ON time_interval_item WITH
  (action,
   action_directive,
   action_method,
   action_resource,
   action_resource_requirement,
   address,
   analysis_assignment,
   applied_action_assignment,
   applied_description_text_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_location_representation_assignment,
   approval_person_organization,
   assumption,
   assumption_assignment,
   assumption_relationship,
   certification,
   class,
   contract,
   document_file,
   effectivity,
   event_occurrence,
   evidence,
   general_property,
   group_relationship,
   identification_assignment_relationship,
   interface_connection,
   interface_connector_occurrence,
   interface_definition_connection,
   item_assumed,
   location,
   organization,
   organizational_project,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_category,
   product_definition,
   product_definition_formation,
   product_identification,
   representation,
   representation_item,
   requirement_source,
   satisfies_requirement,
   validation,
   verification,
   versioned_action_request);
END_TYPE;

ENTITY characterized_action
SUBTYPE OF (action, characterized_object);
END_ENTITY;

ENTITY characterized_action_directive
SUBTYPE OF (action_directive, characterized_object);
END_ENTITY;

ENTITY characterized_action_directive_relationship
SUBTYPE OF (action_directive_relationship, characterized_object);
END_ENTITY;

ENTITY characterized_action_method
SUBTYPE OF (action_method, characterized_object);
END_ENTITY;

ENTITY characterized_action_method_relationship
SUBTYPE OF (action_method_relationship, characterized_object);
END_ENTITY;

ENTITY characterized_action_property
SUBTYPE OF (action_property, characterized_object);
END_ENTITY;

ENTITY characterized_action_relationship
SUBTYPE OF (action_relationship, characterized_object);
END_ENTITY;

ENTITY characterized_action_resource
SUBTYPE OF (action_resource, characterized_object);
END_ENTITY;

ENTITY characterized_action_resource_relationship
SUBTYPE OF (action_resource_relationship, characterized_object);
END_ENTITY;

ENTITY characterized_action_resource_requirement
SUBTYPE OF (action_resource_requirement, characterized_object);
END_ENTITY;

ENTITY characterized_action_resource_requirement_relationship
SUBTYPE OF (action_resource_requirement_relationship, characterized_object);
END_ENTITY;

ENTITY characterized_alternate_product_relationship
SUBTYPE OF (alternate_product_relationship, characterized_object);
END_ENTITY;

ENTITY characterized_applied_action_request_assignment
SUBTYPE OF (applied_action_request_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_approval_assignment
SUBTYPE OF (applied_approval_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_certification_assignment
SUBTYPE OF (applied_certification_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_contract_assignment
SUBTYPE OF (applied_contract_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_directed_action_assignment
SUBTYPE OF (applied_directed_action_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_effectivity_assignment
SUBTYPE OF (applied_effectivity_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_event_occurrence_assignment
SUBTYPE OF (applied_event_occurrence_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_ineffectivity_assignment
SUBTYPE OF (applied_ineffectivity_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_organizational_project_assignment
SUBTYPE OF (applied_organizational_project_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_person_type_assignment
SUBTYPE OF (applied_person_type_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_position_in_organization_assignment
SUBTYPE OF (applied_position_in_organization_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_position_in_organization_group_assignment
SUBTYPE OF (applied_position_in_organization_group_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_position_in_organization_type_assignment
SUBTYPE OF (applied_position_in_organization_type_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_qualification_type_assignment
SUBTYPE OF (applied_qualification_type_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_security_classification_assignment
SUBTYPE OF (applied_security_classification_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_time_interval_assignment
SUBTYPE OF (applied_time_interval_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_usage_right
SUBTYPE OF (applied_usage_right, characterized_object);
END_ENTITY;

ENTITY characterized_approval
SUBTYPE OF (approval, characterized_object);
END_ENTITY;

ENTITY characterized_collection_assignment
SUBTYPE OF (characterized_object, collection_assignment);
END_ENTITY;

ENTITY characterized_configuration_item_relationship
SUBTYPE OF (characterized_object, configuration_item_relationship);
END_ENTITY;

ENTITY characterized_contract
SUBTYPE OF (characterized_object, contract);
END_ENTITY;

ENTITY characterized_contract_relationship
SUBTYPE OF (characterized_object, contract_relationship);
END_ENTITY;

ENTITY characterized_date_and_time_assignment
SUBTYPE OF (characterized_object, date_and_time_assignment);
END_ENTITY;

ENTITY characterized_date_assignment
SUBTYPE OF (characterized_object, date_assignment);
END_ENTITY;

ENTITY characterized_document_relationship
SUBTYPE OF (characterized_object, document_relationship);
END_ENTITY;

ENTITY characterized_evidence
SUBTYPE OF (characterized_object, evidence);
END_ENTITY;

ENTITY characterized_general_property_relationship
SUBTYPE OF (characterized_object, general_property_relationship);
END_ENTITY;

ENTITY characterized_group
SUBTYPE OF (characterized_object, group);
END_ENTITY;

ENTITY characterized_group_relationship
SUBTYPE OF (characterized_object, group_relationship);
END_ENTITY;

ENTITY characterized_organization
SUBTYPE OF (characterized_object, organization);
END_ENTITY;

ENTITY characterized_organization_relationship
SUBTYPE OF (characterized_object, organization_relationship);
END_ENTITY;

ENTITY characterized_organizational_address
SUBTYPE OF (characterized_object, organizational_address);
END_ENTITY;

ENTITY characterized_organizational_project_relationship
SUBTYPE OF (characterized_object, organizational_project_relationship);
END_ENTITY;

ENTITY characterized_person_type_definition_relationship
SUBTYPE OF (characterized_object, person_type_definition_relationship);
END_ENTITY;

ENTITY characterized_product_concept
SUBTYPE OF (characterized_object, product_concept);
END_ENTITY;

ENTITY characterized_product_concept_feature_association
SUBTYPE OF (characterized_object, product_concept_feature_association);
END_ENTITY;

ENTITY characterized_product_concept_feature_category_usage
SUBTYPE OF (characterized_object, product_concept_feature_category_usage);
END_ENTITY;

ENTITY characterized_product_definition_formation
SUBTYPE OF (characterized_object, product_definition_formation);
END_ENTITY;

ENTITY characterized_product_definition_formation_relationship
SUBTYPE OF (characterized_object, product_definition_formation_relationship);
END_ENTITY;

ENTITY characterized_product_relationship
SUBTYPE OF (characterized_object, product_relationship);
END_ENTITY;

ENTITY characterized_representation_relationship
SUBTYPE OF (characterized_object, representation_relationship);
END_ENTITY;

ENTITY characterized_risk_perception_source_assignment
SUBTYPE OF (characterized_object, risk_perception_source_assignment);
END_ENTITY;

ENTITY characterized_versioned_action_request
SUBTYPE OF (characterized_object, versioned_action_request);
END_ENTITY;

ENTITY characterized_versioned_action_request_relationship
SUBTYPE OF (characterized_object, versioned_action_request_relationship);
END_ENTITY;

RULE application_protocol_definition_required FOR (application_context);

  WHERE
  WR1: SIZEOF(QUERY(ac <* application_context | (SIZEOF(QUERY(apd <* USEDIN(ac, 'APPLICATION_CONTEXT_SCHEMA.APPLICATION_PROTOCOL_DEFINITION.APPLICATION') | apd.application_interpreted_model_schema_name = 'ap239_product_life_cycle_support')) > 0))) > 0;

END_RULE;

END_SCHEMA;



--
-- AP239_PRODUCT_STATUS_RECORDING_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_product_status_recording/mim.exp)
--
(*
 ISO TC184/SC4/WG3 N11087 - ISO/TS 10303-1304 AP239 product status recording - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG3 N1565
*) 

SCHEMA Ap239_product_status_recording_mim;

USE FROM Ap239_product_definition_information_mim;    -- ISO/TS 10303-1292

USE FROM Location_assignment_mim;    -- ISO/TS 10303-1277

USE FROM Observation_mim;    -- ISO/TS 10303-1258

USE FROM Product_group_mim;    -- ISO/TS 10303-1278


TYPE ap239_psr_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH 
   (state_observed_assignment, 
    ascribable_state);
END_TYPE; 

TYPE ap239_psr_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (observation, 
    observation_consequence);
END_TYPE; 

TYPE ap239_psr_justification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON justification_item WITH 
   (applied_state_observed_assignment);
END_TYPE; 

TYPE ap239_psr_location_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON location_item WITH 
   (product, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship, 
    product_group);
END_TYPE; 

TYPE ap239_psr_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (observation, 
    observation_consequence);
END_TYPE; 

TYPE ap239_psr_observed_context_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON observed_context_item WITH 
   (product, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship, 
    product_group);
END_TYPE; 

TYPE ap239_psr_state_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_observed_of_item WITH 
   (product, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship, 
    product_group);
END_TYPE; 

END_SCHEMA;  -- Ap239_product_status_recording_mim


--
-- AP239_PROPERTIES_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_properties/mim.exp)
--
(*
 ISO TC184/SC4/WG12 N10771 - ISO/TS 10303-1295 AP239 properties - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N3014
*) 


SCHEMA Ap239_properties_mim;

USE FROM Ap239_management_resource_information_mim;    -- ISO/TS 10303-1289

USE FROM Document_assignment_mim;    -- ISO/TS 10303-1122

USE FROM Extended_measure_representation_mim;    -- ISO/TS 10303-1106

USE FROM External_properties_mim;    -- ISO/TS 10303-1129

USE FROM External_unit_mim;    -- ISO/TS 10303-1780

USE FROM Independent_property_representation_mim;    -- ISO/TS 10303-1038

USE FROM Product_view_definition_properties_mim;    -- ISO/TS 10303-1034


TYPE ap239_props_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (general_property, 
    general_property_relationship, 
    property_definition, 
    property_definition_relationship);
END_TYPE; 

TYPE ap239_props_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_classification_item WITH 
   (context_dependent_unit, 
    conversion_based_unit, 
    derived_unit, 
    general_property, 
    general_property_relationship, 
    measure_with_unit, 
    named_unit, 
    property_definition, 
    property_definition_relationship, 
    property_definition_representation, 
    representation, 
    representation_context, 
    representation_item, 
    uncertainty_measure_with_unit);
END_TYPE; 

TYPE ap239_props_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (general_property, 
    general_property_relationship, 
    property_definition, 
    property_definition_relationship, 
    representation_item);
END_TYPE; 

TYPE ap239_props_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (context_dependent_unit, 
    conversion_based_unit, 
    derived_unit, 
    general_property, 
    general_property_relationship, 
    measure_with_unit, 
    named_unit, 
    property_definition, 
    property_definition_relationship, 
    property_definition_representation, 
    representation, 
    representation_context, 
    representation_item, 
    uncertainty_measure_with_unit);
END_TYPE; 

TYPE ap239_props_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (general_property, 
    general_property_relationship, 
    property_definition, 
    property_definition_relationship, 
    property_definition_representation, 
    representation);
END_TYPE; 

TYPE ap239_props_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (general_property, 
    general_property_relationship, 
    property_definition, 
    property_definition_relationship, 
    property_definition_representation, 
    representation);
END_TYPE; 

TYPE ap239_props_document_reference_item = SELECT BASED_ON document_reference_item WITH 
   (general_property, 
    general_property_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    representation_item);
END_TYPE; 

TYPE ap239_props_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (general_property, 
    general_property_relationship, 
    property_definition, 
    property_definition_relationship);
END_TYPE; 

TYPE ap239_props_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (general_property, 
    general_property_relationship, 
    property_definition, 
    property_definition_relationship, 
    representation_item);
END_TYPE; 

TYPE ap239_props_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (general_property, 
    general_property_relationship, 
    property_definition, 
    property_definition_relationship, 
    property_definition_representation, 
    representation);
END_TYPE; 

TYPE ap239_props_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (general_property, 
    general_property_relationship, 
    property_definition, 
    property_definition_relationship, 
    property_definition_representation, 
    representation);
END_TYPE; 

END_SCHEMA;  -- Ap239_properties_mim




--
-- AP239_TASK_SPECIFICATION_RESOURCED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_task_specification_resourced/mim.exp)
--
(*
ISO TC184/SC4/WG12 N11089 - ISO/TS 10303-1306 AP239 task specification resourced - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N7259
*) 


SCHEMA Ap239_task_specification_resourced_mim;

USE FROM Ap239_product_definition_information_mim;    -- ISO/TS 10303-1292

USE FROM Location_assignment_characterized_mim;    -- ISO/TS 10303-1358

USE FROM Observation_mim;    -- ISO/TS 10303-1258

USE FROM Organization_type_mim;    -- ISO/TS 10303-1240

USE FROM Position_in_organization_mim;    -- ISO/TS 10303-1242

USE FROM Probability_distribution_mim;    -- ISO/TS 10303-1274

USE FROM Product_group_mim;    -- ISO/TS 10303-1278

USE FROM Required_resource_characterized_mim;    -- ISO/TS 10303-1280

USE FROM Task_specification_mim;    -- ISO/TS 10303-1262

USE FROM Type_of_person_mim;    -- ISO/TS 10303-1245

USE FROM Work_output_characterized_mim;    -- ISO/TS 10303-1301


TYPE tsr_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH 
   (action_method, 
    action_method_assignment, 
    action_property, 
    action_resource, 
    action_resource_requirement, 
    applied_action_method_assignment, 
    applied_location_representation_assignment, 
    applied_state_type_assignment, 
    breakdown_element_usage, 
    configuration_item, 
    contract, 
    document_file, 
    envelope, 
    group, 
    interface_connection, 
    interface_connector_occurrence, 
    interface_definition_connection, 
    location, 
    observation_consequence, 
    organization, 
    organization_role, 
    organization_type, 
    person, 
    person_and_organization, 
    person_type, 
    person_type_definition, 
    position_in_organization, 
    position_in_organization_type, 
    product, 
    product_concept, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    product_group, 
    property_definition, 
    resource_property, 
    state_observed_relationship, 
    structured_message);
END_TYPE; 

TYPE tsr_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (action_method, 
    action_method_relationship, 
    applied_action_method_assignment, 
    applied_experience_assignment, 
    applied_organization_type_assignment, 
    applied_person_type_assignment, 
    applied_position_in_organization_assignment, 
    applied_position_in_organization_group_assignment, 
    applied_position_in_organization_type_assignment, 
    applied_qualification_type_assignment, 
    applied_state_observed_assignment, 
    applied_state_type_assignment, 
    experience_type, 
    group, 
    person_type, 
    position_in_organization, 
    position_in_organization_type, 
    product_group, 
    product_group_membership, 
    product_group_relationship, 
    qualification_type, 
    resource_property);
END_TYPE; 

TYPE tsr_attribute_classification_item = SELECT BASED_ON attribute_classification_item WITH 
   (action_property, 
    action_property_representation, 
    address, 
    applied_location_representation_assignment, 
    location, 
    location_relationship, 
    measure_representation_item, 
    representation, 
    resource_property, 
    resource_property_representation);
END_TYPE; 

TYPE tsr_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (action_method, 
    action_method_relationship, 
    address, 
    applied_action_method_assignment, 
    applied_experience_assignment, 
    applied_location_representation_assignment, 
    applied_person_type_assignment, 
    experience_type, 
    group, 
    location, 
    location_relationship, 
    measure_representation_item, 
    organization_type, 
    person_type, 
    person_type_definition, 
    person_type_definition_relationship, 
    position_in_organization, 
    position_in_organization_assignment, 
    position_in_organization_relationship, 
    position_in_organization_type, 
    product_group, 
    product_group_relationship, 
    qualification_type, 
    representation, 
    resource_property);
END_TYPE; 

TYPE tsr_certification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON certification_item WITH 
   (action_method, 
    product_group, 
    product_group_relationship);
END_TYPE; 

TYPE tsr_classification_item = SELECT BASED_ON classification_item WITH 
   (action_property, 
    action_property_representation, 
    action_status, 
    address, 
    applied_experience_assignment, 
    applied_location_representation_assignment, 
    applied_position_in_organization_assignment, 
    applied_position_in_organization_group_assignment, 
    applied_position_in_organization_type_assignment, 
    applied_qualification_type_assignment, 
    experience, 
    measure_representation_item, 
    organization_type, 
    qualification_type_relationship, 
    representation, 
    resource_property, 
    resource_property_representation);
END_TYPE; 

TYPE tsr_condition_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON condition_action_method_items WITH 
   (action, 
    action_method, 
    action_method_relationship, 
    action_property, 
    action_property_representation, 
    action_resource, 
    action_resource_relationship, 
    action_resource_requirement, 
    action_resource_requirement_relationship, 
    applied_action_method_assignment, 
    product_group, 
    product_group_membership, 
    product_group_relationship, 
    property_definition_representation, 
    resource_property, 
    resource_property_representation);
END_TYPE; 

TYPE tsr_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH 
   (action_method, 
    action_method_relationship, 
    applied_action_method_assignment, 
    product_group, 
    product_group_relationship);
END_TYPE; 

TYPE tsr_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (action_method, 
    action_method_relationship, 
    action_property, 
    action_property_representation, 
    address, 
    applied_action_method_assignment, 
    applied_location_representation_assignment, 
    applied_organization_type_assignment, 
    applied_person_and_organization_assignment, 
    applied_person_type_assignment, 
    applied_position_in_organization_assignment, 
    applied_position_in_organization_group_assignment, 
    applied_position_in_organization_type_assignment, 
    applied_state_observed_assignment, 
    applied_state_type_assignment, 
    product_group, 
    product_group_membership, 
    product_group_relationship, 
    property_definition_representation, 
    representation, 
    resource_property, 
    resource_property_representation);
END_TYPE; 

TYPE tsr_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (action_method, 
    action_method_relationship, 
    action_property, 
    action_property_representation, 
    address, 
    applied_action_method_assignment, 
    applied_location_representation_assignment, 
    applied_organization_type_assignment, 
    applied_person_and_organization_assignment, 
    applied_person_type_assignment, 
    applied_position_in_organization_assignment, 
    applied_position_in_organization_group_assignment, 
    applied_position_in_organization_type_assignment, 
    applied_state_observed_assignment, 
    applied_state_type_assignment, 
    product_group, 
    product_group_membership, 
    product_group_relationship, 
    property_definition_representation, 
    representation, 
    resource_property, 
    resource_property_representation);
END_TYPE; 

TYPE tsr_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (action_method, 
    action_method_relationship, 
    action_property, 
    action_property_representation, 
    action_resource, 
    action_resource_relationship, 
    action_resource_requirement, 
    action_resource_requirement_relationship, 
    address, 
    applied_action_method_assignment, 
    applied_location_assignment, 
    applied_location_representation_assignment, 
    applied_position_in_organization_assignment, 
    applied_position_in_organization_type_assignment, 
    applied_state_observed_assignment, 
    applied_state_type_assignment, 
    experience, 
    experience_type, 
    group, 
    location, 
    organization_type, 
    person_type, 
    person_type_definition, 
    position_in_organization, 
    position_in_organization_type, 
    product_group, 
    product_group_membership, 
    product_group_relationship, 
    qualification_type, 
    qualified_representation_item, 
    representation, 
    resource_property, 
    resource_property_representation);
END_TYPE; 

TYPE tsr_effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON effectivity_item WITH 
   (action_method, 
    action_method_assignment, 
    action_method_relationship, 
    action_property, 
    action_resource_relationship, 
    action_resource_requirement_relationship, 
    applied_action_method_assignment, 
    applied_person_type_assignment, 
    applied_position_in_organization_assignment, 
    applied_position_in_organization_group_assignment, 
    applied_position_in_organization_type_assignment, 
    group, 
    multi_language_attribute_assignment, 
    person_type_definition_relationship, 
    resource_property, 
    state_type_assignment, 
    state_type_relationship);
END_TYPE; 

TYPE tsr_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (action_method, 
    action_method_relationship, 
    address, 
    applied_action_method_assignment, 
    applied_location_representation_assignment, 
    applied_position_in_organization_assignment, 
    applied_position_in_organization_type_assignment, 
    applied_qualification_type_assignment, 
    applied_state_observed_assignment, 
    applied_state_type_assignment, 
    descriptive_representation_item, 
    experience, 
    experience_type, 
    group, 
    location, 
    measure_representation_item, 
    organization_type, 
    person_type, 
    position_in_organization, 
    product_group, 
    product_group_membership, 
    product_group_relationship, 
    qualification_type, 
    qualified_representation_item, 
    representation, 
    resource_property);
END_TYPE; 

TYPE tsr_ir_usage_right_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH 
   (task_element, 
    task_method, 
    task_method_version, 
    task_objective);
END_TYPE; 

TYPE tsr_justification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON justification_item WITH 
   (action_method, 
    action_method_relationship, 
    action_property, 
    applied_action_method_assignment, 
    applied_location_assignment, 
    applied_state_observed_assignment, 
    applied_state_type_assignment, 
    property_definition, 
    resource_property);
END_TYPE; 

TYPE tsr_justification_support_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON justification_support_item WITH 
   (action_method, 
    action_method_relationship, 
    action_property, 
    applied_action_method_assignment, 
    applied_location_assignment, 
    applied_state_observed_assignment, 
    applied_state_type_assignment, 
    contract, 
    location, 
    product, 
    product_definition, 
    product_definition_formation, 
    property_definition, 
    resource_property, 
    state_observed, 
    state_observed_relationship, 
    state_type, 
    state_type_relationship);
END_TYPE; 

TYPE tsr_location_item = SELECT BASED_ON location_item WITH 
   (action_method, 
    action_resource, 
    action_resource_requirement, 
    applied_action_method_assignment, 
    document_file, 
    interface_connection, 
    interface_connector_occurrence, 
    interface_definition_connection, 
    organization, 
    organization_type, 
    organizational_project, 
    person, 
    person_and_organization, 
    person_type, 
    person_type_definition, 
    position_in_organization, 
    position_in_organization_type, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_group);
END_TYPE; 

TYPE tsr_location_representation_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON location_representation_item WITH 
   (interface_connection, 
    interface_connector_occurrence, 
    interface_definition_connection);
END_TYPE; 

TYPE tsr_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (action_method, 
    action_method_relationship, 
    address, 
    applied_action_method_assignment, 
    applied_experience_assignment, 
    applied_location_representation_assignment, 
    applied_person_type_assignment, 
    experience_type, 
    group, 
    location, 
    location_relationship, 
    measure_representation_item, 
    organization_type, 
    person_type, 
    person_type_definition, 
    person_type_definition_relationship, 
    position_in_organization, 
    position_in_organization_assignment, 
    position_in_organization_relationship, 
    position_in_organization_type, 
    product_group, 
    product_group_relationship, 
    qualification_type, 
    representation, 
    resource_property);
END_TYPE; 

TYPE tsr_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (action_method, 
    action_method_relationship, 
    action_property_representation, 
    applied_action_method_assignment, 
    applied_person_type_assignment, 
    applied_position_in_organization_assignment, 
    applied_position_in_organization_group_assignment, 
    applied_position_in_organization_type_assignment, 
    applied_state_observed_assignment, 
    applied_state_type_assignment, 
    general_property, 
    position_in_organization_type, 
    product_group, 
    product_group_membership, 
    product_group_relationship, 
    resource_property, 
    resource_property_representation);
END_TYPE; 

TYPE tsr_person_and_organization_item = SELECT BASED_ON person_and_organization_item WITH 
   (action_method, 
    action_method_relationship, 
    action_property_representation, 
    applied_action_method_assignment, 
    applied_person_type_assignment, 
    applied_position_in_organization_assignment, 
    applied_position_in_organization_group_assignment, 
    applied_position_in_organization_type_assignment, 
    applied_state_observed_assignment, 
    applied_state_type_assignment, 
    general_property, 
    position_in_organization_type, 
    product_group, 
    product_group_membership, 
    product_group_relationship, 
    resource_property, 
    resource_property_representation);
END_TYPE; 

TYPE tsr_person_type_item = SELECT BASED_ON person_type_item WITH 
   (group, 
    person, 
    person_and_organization, 
    position_in_organization, 
    position_in_organization_type);
END_TYPE; 

TYPE tsr_position_in_organization_group_item = SELECT BASED_ON position_in_organization_group_item WITH 
   (applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval_person_organization, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE tsr_position_in_organization_item = SELECT BASED_ON position_in_organization_item WITH 
   (applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval_person_organization, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE tsr_position_in_organization_type_item = SELECT BASED_ON position_in_organization_type_item WITH 
   (applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval_person_organization, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE tsr_project_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON project_item WITH 
   (action_method, 
    applied_action_method_assignment, 
    product_group, 
    product_group_membership, 
    product_group_relationship);
END_TYPE; 

TYPE tsr_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
   (action_method, 
    applied_action_method_assignment, 
    applied_state_observed_assignment, 
    applied_state_type_assignment, 
    state_observed, 
    state_type);
END_TYPE; 

TYPE tsr_requirement_source_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_source_item WITH 
   (action_method, 
    applied_action_method_assignment, 
    applied_state_observed_assignment, 
    applied_state_type_assignment, 
    state_observed, 
    state_type);
END_TYPE; 

TYPE tsr_resource_assignment_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH 
   (contract, 
    location, 
    organizational_project, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_group);
END_TYPE; 

TYPE tsr_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH 
   (action_method, 
    action_method_relationship, 
    applied_action_method_assignment, 
    applied_state_observed_assignment, 
    applied_state_type_assignment, 
    product_group, 
    product_group_membership, 
    product_group_relationship);
END_TYPE; 

TYPE tsr_state_observed_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_observed_of_item WITH 
   (task_method_version);
END_TYPE; 

TYPE tsr_state_type_of_item = SELECT BASED_ON state_type_of_item WITH 
   (action_method, 
    action_resource, 
    applied_action_method_assignment, 
    location, 
    product, 
    product_concept, 
    product_definition_formation, 
    product_definition_relationship, 
    product_group);
END_TYPE; 

ENTITY characterized_applied_action_method_assignment
  SUBTYPE OF (applied_action_method_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_state_assignment
  SUBTYPE OF (applied_state_observed_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_state_type_assignment
  SUBTYPE OF (applied_state_type_assignment, characterized_object);
END_ENTITY;

END_SCHEMA;  -- Ap239_task_specification_resourced_mim


--
-- AP239_WORK_DEFINITION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_work_definition/mim.exp)
--
(*
ISO TC184/SC4/WG12 N10779 - ISO/TS 10303-1307 AP239 work definition - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N7262
*) 


SCHEMA Ap239_work_definition_mim;

USE FROM Activity_characterized_mim;    -- ISO/TS 10303-1272

USE FROM Activity_method_characterized_mim;    -- ISO/TS 10303-1298

USE FROM Activity_method_implementation_mim;    -- ISO/TS 10303-1261

USE FROM Ap239_task_specification_resourced_mim;    -- ISO/TS 10303-1306

USE FROM Resource_management_characterized_mim;    -- ISO/TS 10303-1282

USE FROM Scheme_mim;    -- ISO/TS 10303-1260

USE FROM state_type_schema;    -- ISO 10303-56

USE FROM Work_order_characterized_mim;    -- ISO/TS 10303-1286

USE FROM Work_request_characterized_mim;    -- ISO/TS 10303-1285


TYPE wd_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH 
   (action, 
    action_method, 
    action_property, 
    action_resource, 
    address, 
    applied_action_assignment, 
    applied_location_representation_assignment, 
    configuration_item, 
    contract, 
    descriptive_representation_item, 
    document_file, 
    effectivity, 
    envelope, 
    event_occurrence, 
    general_property, 
    group, 
    interface_connection, 
    interface_connector_occurrence, 
    interface_definition_connection, 
    location, 
    measure_representation_item, 
    observation_consequence, 
    organization, 
    organizational_project, 
    person, 
    person_and_organization, 
    position_in_organization, 
    product, 
    product_concept, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    product_group, 
    property_definition, 
    representation, 
    resource_property, 
    state_observed, 
    state_observed_assignment, 
    state_observed_relationship, 
    structured_message, 
    task_method, 
    task_method_version);
END_TYPE; 

TYPE wd_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH 
   (action, 
    action_method, 
    action_resource, 
    action_resource_requirement, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    contract, 
    event_occurrence, 
    location, 
    organization, 
    organization_type, 
    organizational_project, 
    person, 
    person_and_organization, 
    person_type, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_group);
END_TYPE; 

TYPE wd_action_request_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_request_item WITH 
   (action_method, 
    action_property, 
    action_resource, 
    contract, 
    document_file, 
    interface_connection, 
    interface_connector_occurrence, 
    interface_definition_connection, 
    organization, 
    person, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship, 
    product_group, 
    property_definition, 
    resource_property);
END_TYPE; 

TYPE wd_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (action_method, 
    action_method_relationship, 
    applied_action_method_assignment, 
    group);
END_TYPE; 

TYPE wd_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (action_method, 
    action_method_relationship, 
    applied_action_method_assignment, 
    group);
END_TYPE; 

TYPE wd_certification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON certification_item WITH 
   (action, 
    action_method, 
    applied_action_method_assignment);
END_TYPE; 

TYPE wd_condition_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON condition_action_method_items WITH 
   (action, 
    action_method_relationship, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    group);
END_TYPE; 

TYPE wd_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH 
   (action, 
    action_method, 
    action_method_relationship, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    group);
END_TYPE; 

TYPE wd_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (action_method, 
    action_method_relationship, 
    applied_action_method_assignment, 
    group);
END_TYPE; 

TYPE wd_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (action_method, 
    action_method_relationship, 
    applied_action_method_assignment, 
    group);
END_TYPE; 

TYPE wd_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (action, 
    action_method, 
    action_method_relationship, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    group);
END_TYPE; 

TYPE wd_effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON effectivity_item WITH 
   (action, 
    action_directive, 
    action_method, 
    applied_action_assignment);
END_TYPE; 

TYPE wd_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (action, 
    action_method, 
    action_method_relationship, 
    applied_action_method_assignment, 
    group);
END_TYPE; 

TYPE wd_justification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON justification_item WITH 
   (action, 
    action_method, 
    action_method_relationship, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    group);
END_TYPE; 

TYPE wd_justification_support_item = SELECT BASED_ON justification_support_item WITH 
   (action, 
    action_directive, 
    action_method, 
    action_request_solution, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    applied_state_observed_assignment, 
    applied_state_type_assignment, 
    contract, 
    event_occurrence, 
    organizational_project, 
    product, 
    product_definition, 
    product_definition_formation, 
    state_observed, 
    state_type, 
    versioned_action_request);
END_TYPE; 

TYPE wd_location_item = SELECT BASED_ON location_item WITH 
   (action, 
    action_request_solution, 
    applied_action_assignment, 
    applied_action_method_assignment);
END_TYPE; 

TYPE wd_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (action_method, 
    action_method_relationship, 
    applied_action_method_assignment, 
    group);
END_TYPE; 

TYPE wd_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (action_method_relationship, 
    applied_action_method_assignment, 
    group);
END_TYPE; 

TYPE wd_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (action_method_relationship, 
    applied_action_method_assignment, 
    group);
END_TYPE; 

TYPE wd_product_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON product_definition_or_product_definition_relationship WITH 
   (product_group);
END_TYPE; 

TYPE wd_project_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON project_item WITH 
   (action, 
    action_method, 
    action_method_relationship, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    group);
END_TYPE; 

TYPE wd_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH 
   (action, 
    action_method, 
    action_method_relationship, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    group);
END_TYPE; 

TYPE wd_state_of_item = SELECT BASED_ON state_observed_of_item WITH 
   (action, 
    action_directive, 
    action_method, 
    action_resource, 
    applied_action_assignment, 
    location, 
    product_concept, 
    versioned_action_request);
END_TYPE; 

TYPE wd_state_type_of_item = SELECT BASED_ON state_type_of_item WITH 
   (action, 
    action_directive, 
    action_method, 
    applied_action_assignment, 
    versioned_action_request);
END_TYPE; 

ENTITY characterized_applied_action_assignment
  SUBTYPE OF (applied_action_assignment, characterized_object);
END_ENTITY;

END_SCHEMA;  -- Ap239_work_definition_mim


--
-- APPLICATION_CONTEXT_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/application_context_schema/application_context_schema.exp)
--
(*
Id: application_context_schema.exp,v 1.21 2019/06/04 18:52:23 tom Exp 
ISO 10303 TC184/SC4/WG12 N10231

EXPRESS Source:
ISO 10303-41 ed6 Fundamentals of product description and support - Application context schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2019  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Application context schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA application_context_schema '{iso standard 10303 part(41) version(8) object(1) application_context_schema(2)}';

  REFERENCE FROM basic_attribute_schema ( -- ISO 10303-41
    description_attribute, 
    description_attribute_select,
    get_description_value, 
    get_id_value, 
    id_attribute,
    id_attribute_select);
  REFERENCE FROM date_time_schema (	-- ISO 10303-41
    year_number);
  REFERENCE FROM language_schema (language);	-- ISO 10303-41
  REFERENCE FROM management_resources_schema (identification_assignment);	-- ISO 10303-41
  REFERENCE FROM person_organization_schema (organization);	-- ISO 10303-41
  REFERENCE FROM support_resource_schema (	-- ISO 10303-41
    identifier, 
    label, 
    text);		
		


  TYPE acs_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    application_context);
  END_TYPE;
  
  TYPE acs_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    application_context);
  END_TYPE;
  
   TYPE exchange_identification_context_select  = SELECT (identification_assignment,organization);
	END_TYPE;


		
  ENTITY application_context;
    application : label;
  DERIVE
    description : text := get_description_value(SELF);
    id : identifier := get_id_value(SELF);
  INVERSE
    context_elements : SET [1:?] OF application_context_element FOR frame_of_reference;
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY application_context_element
    SUPERTYPE OF (ONEOF(library_context, product_concept_context, product_context, product_definition_context));
    name : label;
    frame_of_reference : application_context;
  END_ENTITY;

  ENTITY application_context_relationship;
    name : label;
    description : OPTIONAL text;
    relating_context : application_context;
    related_context : application_context;
  END_ENTITY;

  ENTITY application_protocol_definition;
    status : label;
    application_interpreted_model_schema_name : label;
    application_protocol_year : year_number;
    application : application_context;
  END_ENTITY;

  ENTITY library_context
    SUBTYPE OF (application_context_element);
    library_reference : label;
  END_ENTITY;

  ENTITY product_concept_context
    SUBTYPE OF (application_context_element);
    market_segment_type : label;
  END_ENTITY;

  ENTITY product_context
    SUBTYPE OF (application_context_element);
    discipline_type : label;
  END_ENTITY;

  ENTITY product_definition_context
    SUBTYPE OF (application_context_element);
    life_cycle_stage : label;
  END_ENTITY;
  
  ENTITY dependent_product_definition_exchange_context
    ABSTRACT SUPERTYPE
    SUBTYPE OF (product_definition_context);
   WHERE
	  WR1: SIZEOF (TYPEOF(SELF) * ['APPLICATION_CONTEXT_SCHEMA.INDENTIFICATION_DEPENDENT_PRODUCT_DEFINITION_EXCHANGE_CONTEXT','APPLICATION_CONTEXT_SCHEMA.LANGUAGE_DEPENDENT_PRODUCT_DEFINITION_EXCHANGE_CONTEXT']) > 0;
	END_ENTITY;

	ENTITY identification_dependent_product_definition_exchange_context
	  SUBTYPE OF (dependent_product_definition_exchange_context);
	  identification_context   : exchange_identification_context_select;
	END_ENTITY;

	ENTITY language_dependent_product_definition_exchange_context
	  SUBTYPE OF (dependent_product_definition_exchange_context);
	  language              : language;
	END_ENTITY;

END_SCHEMA;


--
-- APPROVAL_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/approval/mim.exp)
--
(*
 ISO TC184/SC4/WG12 N10733 - ISO/TS 10303-1012 Approval - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N6023
*)


SCHEMA Approval_mim;

USE FROM approval_schema   -- ISO 10303-41
  (approval,
   approval_date_time,
   approval_person_organization,
   approval_relationship,
   approval_role,
   approval_status,
   apps_description_attribute_select,
   apps_role_select);

USE FROM basic_attribute_schema   -- ISO 10303-41
  (object_role,
   role_association,
   role_select);

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM management_resources_schema   -- ISO 10303-41
  (approval_assignment);

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011

TYPE approval_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

TYPE approval_scope_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

TYPE date_and_time_item_approval = SELECT BASED_ON date_and_time_item WITH
  (approval_person_organization);
END_TYPE;

TYPE date_item_approval = SELECT BASED_ON date_item WITH
  (approval_person_organization);
END_TYPE;

ENTITY applied_approval_assignment
SUBTYPE OF (approval_assignment);
  items : SET [1 : ?] OF approval_item;
END_ENTITY;

ENTITY applied_approval_scope
SUBTYPE OF (approval_assignment);
  items : SET [1 : ?] OF approval_scope_item;
END_ENTITY;

END_SCHEMA;  -- Approval_mim



--
-- APPROVAL_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/approval_schema/approval_schema.exp)
--
(*
Id: approval_schema.exp,v 1.15 2014/03/04 00:30:30 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Approval schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Approval schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA approval_schema '{iso standard 10303 part(41) version(7) object(1) approval_schema(3)}';
  REFERENCE FROM basic_attribute_schema (
    description_attribute, 
    description_attribute_select,
    get_description_value, 
    get_role, 
    object_role, 
    role_association,
    role_select);
  REFERENCE FROM date_time_schema (
    date_time_select);
  REFERENCE FROM person_organization_schema (
    person_organization_select);
  REFERENCE FROM support_resource_schema (
    bag_to_set, 
    label, 
    text);
    
  TYPE apps_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    approval_role);
  END_TYPE;
  
  TYPE apps_role_select = SELECT BASED_ON role_select WITH (
    approval_date_time);
  END_TYPE;
  
    
  ENTITY approval;
    status : approval_status;
    level : label;
  END_ENTITY;

  ENTITY approval_date_time;
    date_time : date_time_select;
    dated_approval : approval;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY approval_person_organization;
    person_organization : person_organization_select;
    authorized_approval : approval;
    role : approval_role;
  END_ENTITY;

  ENTITY approval_relationship;
    name : label;
    description : OPTIONAL text;
    relating_approval : approval;
    related_approval : approval;
  END_ENTITY;

  ENTITY approval_role;
    role : label;
  DERIVE
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY approval_status;
    name : label;
  END_ENTITY;

  FUNCTION acyclic_approval_relationship (relation : approval_relationship; relatives : SET [1:?] OF approval; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF approval_relationship;
    END_LOCAL;

    IF relation.relating_approval IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(app <* bag_to_set(USEDIN(relation.relating_approval, 'APPROVAL_SCHEMA.' + 'APPROVAL_RELATIONSHIP.' + 'RELATED_APPROVAL')) | specific_relation IN TYPEOF(app));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_approval_relationship(x[i], relatives + relation.relating_approval, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;


--
-- ASSEMBLY_STRUCTURE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/assembly_structure/mim.exp)
--
(*
ISO TC184/SC4/WG12 N10735 - ISO/TS 10303-1026 Assembly structure - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N7730
*) 

SCHEMA Assembly_structure_mim;

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019

USE FROM Product_view_definition_reference_mim; -- ISO/TS 10303-1738

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054

USE FROM product_structure_schema   -- ISO 10303-44
  (assembly_component_usage,
   multi_level_reference_designator,
   next_assembly_usage_occurrence,
   product_definition_occurrence, 
   promissory_usage_occurrence,
   quantified_assembly_component_usage,
   specified_higher_usage_occurrence); 


END_SCHEMA;  -- Assembly_structure_mim






--
-- ASSIGNMENT_OBJECT_RELATIONSHIP_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/assignment_object_relationship/mim.exp)
--
(*
   ISO TC184/SC4/WG12 N10799 - ISO/TS 10303-1847 assignment_object_relationship - EXPRESS MIM
*)

SCHEMA Assignment_object_relationship_mim;

USE FROM management_resources_schema   -- ISO 10303-41
  (assignment_object_relationship,
   assignment_object_select);

END_SCHEMA;  -- Assignment_object_relationship_mim



--
-- ATTACHMENT_SLOT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/attachment_slot/mim.exp)
--
(*
 $Id: mim.exp,v 1.9 2004/11/19 21:37:34 robbod Exp 
 ISO TC184/SC4/WG12 N3017 - ISO/TS 10303-1250 Attachment slot - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2253
*) 


SCHEMA Attachment_slot_mim;

USE FROM Interface_mim;    -- ISO/TS 10303-1251

USE FROM product_definition_schema   -- ISO 10303-41
  (product_category,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_related_product_category); 

USE FROM Product_identification_mim;    -- ISO/TS 10303-1017

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041


ENTITY attachment_slot_as_planned
  SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY attachment_slot_as_realized
  SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY attachment_slot_design
  SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY attachment_slot_design_to_planned
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : attachment_slot_design;
  SELF\product_definition_formation_relationship.related_product_definition_formation : attachment_slot_as_planned;
WHERE
  WR1: SELF.relating_product_definition_formation.of_product :=: SELF.related_product_definition_formation.of_product;
END_ENTITY;

ENTITY attachment_slot_design_to_realized
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : attachment_slot_design;
  SELF\product_definition_formation_relationship.related_product_definition_formation : attachment_slot_as_realized;
WHERE
  WR1: SELF.relating_product_definition_formation.of_product :=: SELF.related_product_definition_formation.of_product;
END_ENTITY;

ENTITY attachment_slot_on_product
  SUBTYPE OF (product_definition_relationship);
END_ENTITY;

ENTITY attachment_slot_planned_to_realized
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : attachment_slot_as_planned;
  SELF\product_definition_formation_relationship.related_product_definition_formation : attachment_slot_as_realized;
WHERE
  WR1: SELF.relating_product_definition_formation.of_product :=: SELF.related_product_definition_formation.of_product;
END_ENTITY;

ENTITY product_in_attachment_slot
  SUBTYPE OF (product_definition_relationship);
END_ENTITY;

END_SCHEMA;  -- Attachment_slot_mim




--
-- ATTRIBUTE_CLASSIFICATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/attribute_classification/mim.exp)
--
(*
 $Id: mim.exp,v 1.12 2004/11/19 21:37:34 robbod Exp 
 ISO TC184/SC4/WG12 N3020 - ISO/TS 10303-1246 Attribute classification - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2256
*) 


SCHEMA Attribute_classification_mim;

USE FROM Class_mim;    -- ISO/TS 10303-1070

USE FROM classification_schema   -- ISO 10303-54
  (class); 

USE FROM management_resources_schema   -- ISO 10303-41
  (attribute_classification_assignment); 


TYPE attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_attribute_classification_assignment
  SUBTYPE OF (attribute_classification_assignment);
  SELF\attribute_classification_assignment.assigned_class : class;
  items : SET[1:?] OF attribute_classification_item;
END_ENTITY;

END_SCHEMA;  -- Attribute_classification_mim



--
-- BASIC_ATTRIBUTE_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/basic_attribute_schema/basic_attribute_schema.exp)
--
(*
Id: basic_attribute_schema.exp,v 1.26 2019/04/03 14:35:04 kevin Exp 
ISO 10303 TC184/SC4/WG12 N10466

EXPRESS Source:
ISO 10303-41 ed6 Fundamentals of product description and support - Basic attribute schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2019  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed6 Fundamentals of product description and support - Basic attribute schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA basic_attribute_schema '{iso standard 10303 part(41) version(9) object(1) basic_attribute_schema(4)}';

  REFERENCE FROM support_resource_schema (identifier, label, text);   -- ISO 10303-41
 
  TYPE description_attribute_select = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  TYPE generic_attribute_list_select = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE; 

  TYPE generic_attribute_select = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  TYPE id_attribute_select = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  TYPE name_attribute_select = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;
 
  TYPE role_select = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  ENTITY aggregate_id_attribute;
    attribute_value : identifier;
    identified_item : SET [1:?] OF id_attribute_select;
  END_ENTITY;

  ENTITY description_attribute;
    attribute_value : text;
    described_item : description_attribute_select;
  END_ENTITY;

  ENTITY generic_attribute;
    attribute_name : label;
    attribute_value : text;
  END_ENTITY;

  ENTITY generic_attribute_assignment;
    attribute : generic_attribute;
    item_with_attribute : generic_attribute_select;
  END_ENTITY;

  ENTITY generic_attribute_list_assignment;
    attribute_name : label;
    attributes : LIST [1:?] OF generic_attribute;
    item_with_attribute : generic_attribute_list_select;
  END_ENTITY;

  ENTITY id_attribute;
    attribute_value : identifier;
    identified_item : id_attribute_select;
  END_ENTITY;

  ENTITY name_attribute;
    attribute_value : label;
    named_item : name_attribute_select;
  END_ENTITY;

  ENTITY object_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY role_association;
    role : object_role;
    item_with_role : role_select;
  END_ENTITY;

  FUNCTION get_description_value (obj : description_attribute_select):text;
    LOCAL
      description_bag : BAG OF description_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));
    END_LOCAL;

    IF SIZEOF(description_bag) = 1 THEN
      RETURN (description_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

  FUNCTION get_id_value (obj : id_attribute_select):identifier;
    LOCAL
      id_bag : BAG OF id_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));
    END_LOCAL;

    IF SIZEOF(id_bag) = 1 THEN
      RETURN (id_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

  FUNCTION get_aggregate_id_value (obj : id_attribute_select):identifier;
    LOCAL
      aggregate_id_bag : BAG OF aggregate_id_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'AGGREGATE_ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));
    END_LOCAL;

    IF SIZEOF(aggregate_id_bag) = 1 THEN
      RETURN (aggregate_id_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

  FUNCTION get_name_value (obj : name_attribute_select):label;
    LOCAL
      name_bag : BAG OF name_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));
    END_LOCAL;

    IF SIZEOF(name_bag) = 1 THEN
      RETURN (name_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

  FUNCTION get_role (obj : role_select):object_role;
    LOCAL
      role_bag : BAG OF role_association := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));
    END_LOCAL;

    IF SIZEOF(role_bag) = 1 THEN
      RETURN (role_bag[1].role);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

END_SCHEMA;


--
-- CERTIFICATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/certification/mim.exp)
--
(*
 $Id: mim.exp,v 1.9 2004/10/31 20:37:09 thendrix Exp 
ISO TC184/SC4/WG12 N1148 - ISO/TS 10303-1044 Certification - EXPRESS MIM
*) 


SCHEMA Certification_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (role_association,
   role_select); 

USE FROM certification_schema   -- ISO 10303-41
  (certification,
   certification_type); 

USE FROM management_resources_schema   -- ISO 10303-41
  (certification_assignment); 


TYPE certification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_certification_assignment
  SUBTYPE OF (certification_assignment);
  items : SET[1:?] OF certification_item;
END_ENTITY;

END_SCHEMA;  -- Certification_mim


--
-- CERTIFICATION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/certification_schema/certification_schema.exp)
--
(*
Id: certification_schema.exp,v 1.14 2014/03/04 00:30:31 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Certification schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Certification schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA certification_schema '{iso standard 10303 part(41) version(3) object(1) certification_schema(5)}';
  REFERENCE FROM support_resource_schema (label, text);
  ENTITY certification;
    name : label;
    purpose : text;
    kind : certification_type;
  END_ENTITY;

  ENTITY certification_type;
    description : label;
  END_ENTITY;

END_SCHEMA;


--
-- CHARACTERIZABLE_OBJECT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/characterizable_object/mim.exp)
--
(*
   $Id: mim.exp,v 1.11 2019/06/10 20:32:27 kevin Exp 
   ISO TC184/SC4/WG12 N10538 - ISO/TS 10303-1765 Characterizable object - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N9294
*)

SCHEMA Characterizable_object_mim;

USE FROM Activity_mim;      -- ISO/TS 10303-1047
USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object);
USE FROM Shape_property_assignment_mim; -- ISO/TS 10303-1032
USE FROM Support_resource_mim;   -- ISO 10303-41

TYPE co_action_items = SELECT BASED_ON action_items WITH
  (characterized_object);
END_TYPE;

END_SCHEMA;


--
-- CLASSIFICATION_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/classification_assignment/mim.exp)
--
(* 
 $Id: mim.exp,v 1.18 2019/01/10 22:45:29 brandon Exp 
 ISO TC184/SC4/WG12 N10277 - ISO/TS 10303-1114 Classification assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N3249 
*)

SCHEMA Classification_assignment_mim;

USE FROM Class_mim;    -- ISO/TS 10303-1070

USE FROM management_resources_schema   -- ISO 10303-41
  (classification_assignment); 

REFERENCE FROM management_resources_schema   -- ISO 10303-41
  (classification_assignment_relationship);


TYPE classification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_classification_assignment
  SUBTYPE OF (classification_assignment);
  items : SET[1:?] OF classification_item;
END_ENTITY;

ENTITY applied_classification_assignment_relationship
	SUBTYPE of (classification_assignment_relationship);			
	SELF\classification_assignment_relationship.related 	: applied_classification_assignment;									
	SELF\classification_assignment_relationship.relating 	: applied_classification_assignment;																
END_ENTITY;

END_SCHEMA;  -- Classification_assignment_mim



--
-- CLASSIFICATION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/classification_schema/classification_schema.exp)
--
(*
Id: classification_schema.exp,v 1.11 2014/03/04 00:30:32 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N3213

EXPRESS Source:
ISO 10303-54 ed1 Classification and set theory - Classification schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-54 ed1 Classification and set theory - Classification schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA classification_schema '{iso standard 10303 part(54) version(1) object(1) classification_schema(1)}';

REFERENCE FROM group_schema   -- ISO 10303-41
  (group); 

REFERENCE FROM management_resources_schema   -- ISO 10303-41
  (classification_assignment); 


TYPE classification_select = EXTENSIBLE SELECT;
END_TYPE; 

TYPE complete_membership_select = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY class
  SUBTYPE OF (group);
END_ENTITY;

ENTITY class_by_extension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY class_by_intension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY classification
  SUBTYPE OF (classification_assignment);
  classified : classification_select;
DERIVE
  classifier : class := SELF\classification_assignment.assigned_class;
END_ENTITY;

ENTITY complete_membership
  SUBTYPE OF (classification_assignment);
DERIVE
  containing_set : class := SELF\classification_assignment.assigned_class;
END_ENTITY;

ENTITY complete_membership_of_empty_set
  SUBTYPE OF (complete_membership);
END_ENTITY;

ENTITY complete_membership_of_non_empty_set
  SUBTYPE OF (complete_membership);
  members : SET[1:?] OF complete_membership_select;
END_ENTITY;

SUBTYPE_CONSTRAINT classification_or_complete_membership FOR classification_assignment;
  ONEOF (classification,
         complete_membership);
END_SUBTYPE_CONSTRAINT;

END_SCHEMA;  -- classification_schema


--
-- CLASSIFICATION_WITH_ATTRIBUTES_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/classification_with_attributes/mim.exp)
--
(*
 ISO TC184/SC4/WG12 N10406 - ISO/CD-TS 10303-1111 Classification with attributes - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N9582
*)


SCHEMA Classification_with_attributes_mim;

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Extended_measure_representation_mim;    -- ISO/TS 10303-1106

USE FROM group_schema   -- ISO 10303-41
  (group,
   group_relationship);

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM Independent_property_mim;    -- ISO/TS 10303-1036

USE FROM management_resources_schema   -- ISO 10303-41
  (classification_role);

USE FROM Plib_class_reference_mim;    -- ISO/TS 10303-1291

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object,
   general_property,
   general_property_association,
   property_definition);

USE FROM product_property_representation_schema   -- ISO 10303-41
  (property_definition_representation);

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019

USE FROM representation_schema   -- ISO 10303-43
  (set_representation_item);

TYPE classification_item_extended = SELECT BASED_ON classification_item WITH
  (class,
   classified_item);
END_TYPE;

TYPE classified_item = SELECT 
  (product,
   product_definition,
   product_definition_formation);
END_TYPE;

TYPE cwa_identification_item = SELECT BASED_ON identification_item WITH
  (class);
END_TYPE;

ENTITY characterized_class
SUBTYPE OF (characterized_object, class);
END_ENTITY;

ENTITY class_system
SUBTYPE OF (group);
END_ENTITY;

  FUNCTION class_assignment_is_valid (aia : applied_classification_assignment): BOOLEAN;
    LOCAL
      item : classification_item;
      role : classification_role;
    END_LOCAL;

    role := aia\classification_assignment.role;
    IF ('CLASSIFICATION_WITH_ATTRIBUTES_MIM.CLASS_SYSTEM' IN TYPEOF(aia\classification_assignment.assigned_class)) THEN
      IF (role\classification_role.name <> 'class system membership') THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := LOINDEX(aia\applied_classification_assignment.items) TO HIINDEX(aia\applied_classification_assignment.items);
        item := aia\applied_classification_assignment.items[i];
        IF (SIZEOF(['CLASSIFICATION_WITH_ATTRIBUTES_MIM.CHARACTERIZED_CLASS'] * TYPEOF(item)) = 0) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    IF ('CLASSIFICATION_WITH_ATTRIBUTES_MIM.CHARACTERIZED_CLASS' IN TYPEOF(aia\classification_assignment.assigned_class)) THEN
      IF  NOT (role\classification_role.name IN ['definitional', 'non-definitional', '']) THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := LOINDEX(aia\applied_classification_assignment.items) TO HIINDEX(aia\applied_classification_assignment.items);
        item := aia\applied_classification_assignment.items[i];
        IF (SIZEOF(['CLASSIFICATION_WITH_ATTRIBUTES_MIM.CLASSIFIED_ITEM'] * TYPEOF(item)) = 0) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    IF (role\classification_role.name = 'definitional') THEN
      IF  NOT (SIZEOF(QUERY(it <* aia\applied_classification_assignment.items |  NOT (SIZEOF(['PRODUCT_DEFINITION_SCHEMA.PRODUCT', 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_FORMATION', 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION'] * TYPEOF(it)) = 1))) = 0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    RETURN (TRUE);
  END_FUNCTION;



  RULE restrict_classification_assignments FOR (applied_classification_assignment);

  WHERE
  WR1: SIZEOF(QUERY(aia <* applied_classification_assignment |  NOT class_assignment_is_valid(aia))) = 0;

  END_RULE;

  (* item invalid if item does not belong to the types that may have a characterized_class*)
  RULE restrict_group_relationship_for_classification_hierarchy FOR (group_relationship);

  WHERE
  WR1: SIZEOF(QUERY(gr <* group_relationship | (gr\group_relationship.name = 'class hierarchy') AND ( NOT ('CLASSIFICATION_WITH_ATTRIBUTES_MIM.CLASS' IN TYPEOF(gr\group_relationship.related_group)) OR  NOT ('CLASSIFICATION_WITH_ATTRIBUTES_MIM.CLASS' IN TYPEOF(gr\group_relationship.relating_group))))) = 0;

  END_RULE;



END_SCHEMA;



--
-- CLASS_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/class/mim.exp)
--
(*
 $Id: mim.exp,v 1.9 2004/11/19 21:37:34 robbod Exp 
 ISO TC184/SC4/WG12 N3023 - ISO/TS 10303-1070 Class - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2259
*) 


SCHEMA Class_mim;

USE FROM classification_schema   -- ISO 10303-54
  (class,
   class_by_extension,
   class_by_intension); 

USE FROM group_schema   -- ISO 10303-41
  (group); 


END_SCHEMA;  -- Class_mim



--
-- COLLECTION_IDENTIFICATION_AND_VERSION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/collection_identification_and_version/mim.exp)
--
(*
 $Id: mim.exp,v 1.8 2009/08/11 07:44:35 robbod Exp 
 ISO TC184/SC4/WG12 N6026 - ISO/TS 10303-1396 Collection identification and version - EXPRESS MIM
*) 


SCHEMA Collection_identification_and_version_mim;

USE FROM Group_mim;    -- ISO/TS 10303-1113

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_relationship); 

USE FROM Product_relationship_mim;    -- ISO/TS 10303-1024

USE FROM Product_version_relationship_mim;    -- ISO/TS 10303-1020

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019


TYPE collection_assignment_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item;
END_TYPE; 

TYPE collection_membership_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item;
END_TYPE; 

ENTITY collection
  SUBTYPE OF (product);
END_ENTITY;

ENTITY collection_assignment
  SUBTYPE OF (applied_group_assignment);
END_ENTITY;

ENTITY collection_membership
  SUBTYPE OF (applied_group_assignment);
END_ENTITY;

ENTITY collection_relationship
  SUBTYPE OF (product_relationship);
  SELF\product_relationship.relating_product RENAMED relating_collection : collection;
  SELF\product_relationship.related_product RENAMED related_collection : collection;
END_ENTITY;

ENTITY collection_version
  SUBTYPE OF (product_definition_formation);
  SELF\product_definition_formation.of_product RENAMED of_collection : collection;
END_ENTITY;

ENTITY collection_version_relationship
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation RENAMED relating_version : collection_version;
  SELF\product_definition_formation_relationship.related_product_definition_formation RENAMED related_version : collection_version;
END_ENTITY;

ENTITY collection_version_sequence_relationship
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation RENAMED predecessor : collection_version;
  SELF\product_definition_formation_relationship.related_product_definition_formation RENAMED successor : collection_version;
END_ENTITY;

ENTITY collection_view_definition
  SUBTYPE OF (product_definition);
  SELF\product_definition.formation RENAMED defined_version : collection_version;
END_ENTITY;

END_SCHEMA;  -- Collection_identification_and_version_mim


--
-- CONDITIONAL_EFFECTIVITY_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/conditional_effectivity/mim.exp)
--
(*
 ISO TC184/SC4/WG12 N11091 - ISO/TS 10303-1397 Conditional effectivity - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N10290
*) 


SCHEMA Conditional_effectivity_mim;

USE FROM Condition_mim;    -- ISO/TS 10303-1253

USE FROM Effectivity_mim;    -- ISO/TS 10303-1057

USE FROM effectivity_schema   -- ISO 10303-41
  (conditional_configuration,
   conditional_effectivity,
   effectivity);

END_SCHEMA;  -- Conditional_effectivity_mim


--
-- CONDITION_CHARACTERIZED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/condition_characterized/mim.exp)
--
(*
 $Id: mim.exp,v 1.7 2004/11/19 21:37:34 robbod Exp 
 ISO TC184/SC4/WG12 N3029 - ISO/TS 10303-1257 Condition characterized - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2322
*) 


SCHEMA Condition_characterized_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method,
   action_method_relationship); 

USE FROM Activity_method_assignment_mim;    -- ISO/TS 10303-1249

USE FROM Approval_mim;    -- ISO/TS 10303-1012

USE FROM Attribute_classification_mim;    -- ISO/TS 10303-1246

USE FROM Condition_mim;    -- ISO/TS 10303-1253

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM Multi_linguism_mim;    -- ISO/TS 10303-1105

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Process_property_assignment_mim;    -- ISO/TS 10303-1040


TYPE condition_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (action_method, 
    applied_action_method_assignment);
END_TYPE; 

TYPE condition_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_classification_item WITH 
   (action_method, 
    action_method_relationship, 
    applied_action_method_assignment);
END_TYPE; 

TYPE condition_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (action_method, 
    action_method_relationship, 
    applied_action_method_assignment);
END_TYPE; 

TYPE condition_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (action_method, 
    applied_action_method_assignment);
END_TYPE; 

TYPE condition_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (action_method, 
    applied_action_method_assignment);
END_TYPE; 

TYPE condition_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (action_method);
END_TYPE; 

TYPE condition_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (action_method, 
    action_method_relationship, 
    applied_action_method_assignment);
END_TYPE; 

TYPE condition_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (action_method, 
    applied_action_method_assignment);
END_TYPE; 

TYPE condition_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (action_method, 
    applied_action_method_assignment);
END_TYPE; 

END_SCHEMA;  -- Condition_characterized_mim



--
-- CONDITION_EVALUATION_CHARACTERIZED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/condition_evaluation_characterized/mim.exp)
--
(*
 $Id: mim.exp,v 1.6 2004/11/19 21:37:35 robbod Exp 
 ISO TC184/SC4/WG12 N3035 - ISO/TS 10303-1296 Condition evaluation characterized - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2328
*) 


SCHEMA Condition_evaluation_characterized_mim;

USE FROM action_schema   -- ISO 10303-41
  (action); 

USE FROM Activity_mim;    -- ISO/TS 10303-1047

USE FROM Approval_mim;    -- ISO/TS 10303-1012

USE FROM Attribute_classification_mim;    -- ISO/TS 10303-1246

USE FROM Condition_evaluation_mim;    -- ISO/TS 10303-1254

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM group_schema;    -- ISO 10303-41

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM Multi_linguism_mim;    -- ISO/TS 10303-1105

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Process_property_assignment_mim;    -- ISO/TS 10303-1040


TYPE condition_evaluation_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (action, 
    applied_action_assignment);
END_TYPE; 

TYPE condition_evaluation_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_classification_item WITH 
   (action, 
    applied_action_assignment, 
    group);
END_TYPE; 

TYPE condition_evaluation_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (action, 
    applied_action_assignment, 
    group);
END_TYPE; 

TYPE condition_evaluation_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (action, 
    applied_action_assignment);
END_TYPE; 

TYPE condition_evaluation_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (action, 
    applied_action_assignment);
END_TYPE; 

TYPE condition_evaluation_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (action);
END_TYPE; 

TYPE condition_evaluation_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (action, 
    applied_action_assignment, 
    group);
END_TYPE; 

TYPE condition_evaluation_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (action, 
    applied_action_assignment);
END_TYPE; 

TYPE condition_evaluation_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (action, 
    applied_action_assignment);
END_TYPE; 

END_SCHEMA;  -- Condition_evaluation_characterized_mim



--
-- CONDITION_EVALUATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/condition_evaluation/mim.exp)
--
(*
 ISO TC184/SC4/WG12 N10747 - ISO/TS 10303-1254 Condition evaluation - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N3032
*) 


SCHEMA Condition_evaluation_mim;

USE FROM action_schema   -- ISO 10303-41
  (action,
   action_relationship);

USE FROM Activity_mim;    -- ISO/TS 10303-1047

USE FROM Condition_mim;    -- ISO/TS 10303-1253

USE FROM Group_mim;    -- ISO/TS 10303-1113

TYPE condition_evaluation_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items;
END_TYPE;

TYPE condition_evaluation_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH
  (action,
   applied_action_assignment,
   group);
END_TYPE;

TYPE condition_evaluation_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH
  (applied_action_assignment,
   applied_action_method_assignment);
END_TYPE;

TYPE condition_evaluation_name_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON name_item WITH
  (applied_action_assignment);
END_TYPE;

END_SCHEMA;  -- Condition_evaluation_mim



--
-- CONDITION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/condition/mim.exp)
--
(*
 ISO TC184/SC4/WG12 N10282 - ISO/TS 10303-1253 Condition - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N3026
*) 


SCHEMA Condition_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method,
   action_method_relationship,
   action_directive_relationship); 

USE FROM Activity_method_assignment_mim;    -- ISO/TS 10303-1249

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM effectivity_schema -- ISO 10303-41
			(condition); 

USE FROM management_resources_schema   -- ISO 10303-41
  (action_method_assignment,
   action_method_role,
   name_assignment); 

USE FROM Name_assignment_mim;    -- ISO/TS 10303-1340


TYPE condition_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH 
   (action_method_relationship);
END_TYPE; 

TYPE condition_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (action_method, 
    action_method_relationship, 
    applied_action_method_assignment);
END_TYPE; 

TYPE condition_name_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON name_item WITH 
   (applied_action_method_assignment);
END_TYPE; 

END_SCHEMA;  -- Condition_mim




--
-- CONFIGURATION_EFFECTIVITY_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/configuration_effectivity/mim.exp)
--
(*
 $Id: mim.exp,v 1.13 2018/12/11 11:33:54 brandon Exp 
 ISO TC184/SC4/WG12 N6118 - ISO/TS 10303-1058 Configuration effectivity - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2950
*)

SCHEMA Configuration_effectivity_mim;

USE FROM Assembly_structure_mim;    -- ISO/TS 10303-1026

USE FROM Configuration_item_mim;    -- ISO/TS 10303-1056

USE FROM configuration_management_schema   -- ISO 10303-44
  (configuration_effectivity); 

USE FROM Effectivity_mim;    -- ISO/TS 10303-1057
USE FROM Part_shape_mim; -- ISO/TS 10303-1807

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041


END_SCHEMA;  -- Configuration_effectivity_mim






--
-- CONFIGURATION_ITEM_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/configuration_item/mim.exp)
--
(*
 $Id: mim.exp,v 1.9 2009/08/11 07:45:42 robbod Exp 
 ISO TC184/SC4/WG12 N6032 - ISO/TS 10303-1056 Configuration item - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2533
*) 


SCHEMA Configuration_item_mim;

USE FROM configuration_management_schema   -- ISO 10303-44
  (configuration_design,
   configuration_item,
   configuration_item_relationship); 

USE FROM Product_concept_identification_mim;    -- ISO/TS 10303-1060

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019


ENTITY configuration_item_hierarchical_relationship
  SUBTYPE OF (configuration_item_relationship);
END_ENTITY;

ENTITY configuration_item_revision_sequence
  SUBTYPE OF (configuration_item_relationship);
END_ENTITY;

END_SCHEMA;  -- Configuration_item_mim


--
-- CONFIGURATION_MANAGEMENT_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/configuration_management_schema/configuration_management_schema.exp)
--
(*
Id: configuration_management_schema.exp,v 1.14 2017/10/09 12:26:21 verodub Exp 
ISO 10303 TC184/SC4/WG12 N9736

EXPRESS Source:
ISO 10303-44 ed4 Product structure configuration - Configuration management schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2017  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-44 ed4 Product structure configuration - Configuration management schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA configuration_management_schema '{iso standard 10303 part(44) version(4) object(1) configuration_management_schema(3)}';

    REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
    (description_attribute_select,
     get_description_value,
     get_name_value,
     name_attribute_select);
     
  REFERENCE FROM effectivity_schema (   -- ISO 10303-41
    effectivity);
   
   REFERENCE FROM product_concept_schema   -- ISO 10303-44
    (product_concept,
     product_concept_feature_association);
     
  REFERENCE FROM product_definition_schema   -- ISO 10303-41
    (product_definition,
     product_definition_effectivity,
     product_definition_formation);

  REFERENCE FROM product_structure_schema   -- ISO 10303-44
    (product_definition_occurrence,
     product_definition_usage);

  REFERENCE FROM support_resource_schema   -- ISO 10303-41
    (bag_to_set,
     identifier,
     label,
     text);
    
  TYPE cms_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    configuration_design);
  END_TYPE;
  TYPE cms_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    configuration_design);
  END_TYPE;

TYPE configuration_design_item = SELECT
   (product_definition,
    product_definition_formation,
    product_definition_occurrence);
END_TYPE;

ENTITY configurable_item
  SUBTYPE OF (configuration_item);
  item_concept_feature : SET[1:?] OF product_concept_feature_association;
END_ENTITY;

ENTITY configuration_design;
  configuration : configuration_item;
  design        : configuration_design_item;
DERIVE
  name          : label := get_name_value (SELF);
  description   : text := get_description_value (SELF);
UNIQUE
  UR1: configuration, design;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY configuration_effectivity
  SUBTYPE OF (product_definition_effectivity);
  configuration : configuration_design;
UNIQUE
  UR1: configuration,
       SELF\product_definition_effectivity.usage,
       SELF\effectivity.id;
WHERE
  WR1: 'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE' IN
        TYPEOF (SELF\product_definition_effectivity.usage);
END_ENTITY;

ENTITY configuration_item;
   id                  :  identifier;
   name                :  label;
   description         :  OPTIONAL text;
   item_concept        :  product_concept;
   purpose             :  OPTIONAL label;
END_ENTITY;

ENTITY configuration_item_relationship;
  name                        : label;
  description                 : OPTIONAL text;
  relating_configuration_item : configuration_item;
  related_configuration_item  : configuration_item;
END_ENTITY;

END_SCHEMA; -- configuration_management_schema


--
-- CONTEXTUAL_SHAPE_POSITIONING_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/contextual_shape_positioning/mim.exp)
--
(*
 $Id: mim.exp,v 1.21 2020/08/27 15:21:34 kevin Exp 
 ISO TC184/SC4/WG12 N10699 - ISO/TS 10303-1027 Contextual shape positioning - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N7976
*)
SCHEMA Contextual_shape_positioning_mim;

USE FROM Geometric_model_relationship_mim;   -- ISO 10303-1403

USE FROM product_property_representation_schema -- ISO 10303-41
  (context_dependent_shape_representation);

USE FROM representation_schema (	-- ISO 10303-43
  item_defined_transformation,
  representation_relationship_with_transformation,
  transformation);

USE FROM Shape_property_assignment_mim; --  ISO/TS 10303-1032

END_SCHEMA;






--
-- CONTRACT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/contract/mim.exp)
--
(*
Id: mim.exp,v 1.13 2010/06/10 20:34:11 philsp Exp 
ISO TC184/SC4/WG12 N7146 - ISO/TS 10303-1062 Contract - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6035
*) 


SCHEMA Contract_mim;

USE FROM contract_schema   -- ISO 10303-41
  (contract,
   contract_relationship); 

USE FROM management_resources_schema   -- ISO 10303-41
  (contract_assignment); 


TYPE contract_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_contract_assignment
  SUBTYPE OF (contract_assignment);
  items : SET[1:?] OF contract_item;
END_ENTITY;

END_SCHEMA;  -- Contract_mim


--
-- CONTRACT_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/contract_schema/contract_schema.exp)
--
(*
Id: contract_schema.exp,v 1.12 2014/03/04 00:30:32 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Contract schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Contract schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA contract_schema '{iso standard 10303 part(41) version(3) object(1) contract_schema(6)}';
  REFERENCE FROM support_resource_schema (bag_to_set, identifier, label, text);
  ENTITY contract;
    name : label;
    purpose : text;
    kind : contract_type;
  END_ENTITY;

  ENTITY contract_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_contract : contract;
    related_contract : contract;
  END_ENTITY;

  ENTITY contract_type;
    description : label;
  END_ENTITY;

  FUNCTION acyclic_contract_relationship (relation : contract_relationship; relatives : SET [1:?] OF contract; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF contract_relationship;
    END_LOCAL;

    IF relation.relating_contract IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(cont <* bag_to_set(USEDIN(relation.relating_contract, 'CONTRACT_SCHEMA.' + 'CONTRACT_RELATIONSHIP.' + 'RELATED_CONTRACT')) | specific_relation IN TYPEOF(cont));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_contract_relationship(x[i], relatives + relation.relating_contract, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;


--
-- COUNTERBORE_COUNTERSINK_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/counterbore_countersink_schema/counterbore_countersink_schema.exp)
--
(*
Id: counterbore_countersink_schema.exp,v 1.50 2021/07/20 14:18:46 kevin Exp 
ISO 10303 TC184/SC4/WG12 10931

EXPRESS Source:
ISO/DIS 10303-113 ed2 Mechanical features - Counterbore countersink schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
and derivations of the Schema:

Copyright ISO 2021  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO/FDIS 10303-113 ed2 Mechanical features - Counterbore countersink schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)
SCHEMA counterbore_countersink_schema '{iso standard 10303 part(113) version(2) object(1) counterbore_countersink_schema(1)}';

REFERENCE FROM geometry_schema --ISO 10303-42
      (axis2_placement_3d);

REFERENCE FROM machining_feature_schema -- ISO 10303-113
      (composite_hole,
       round_hole);

REFERENCE FROM measure_schema   --ISO 10303-41
         (length_measure_with_unit,
          plane_angle_measure_with_unit,
          positive_length_measure_with_unit,
          positive_plane_angle_measure_with_unit);

REFERENCE FROM product_definition_schema --ISO 10303-41
          (product_definition);

REFERENCE FROM product_property_definition_schema --ISO 10303-41
         (characterized_object,
          property_definition,
          shape_aspect,
          shape_aspect_occurrence);

REFERENCE FROM product_property_representation_schema --ISO 10303-41
		(item_identified_representation_usage,
		 item_identified_representation_usage_definition,
		 shape_representation);

REFERENCE FROM product_structure_schema --ISO 10303-44
          (multi_level_reference_designator);

REFERENCE FROM representation_schema --ISO 10303-43
		(representation);

REFERENCE FROM shape_tolerance_schema   --ISO 10303-47
         (limits_and_fits,
         tolerance_value);

TYPE ccs_item_identified_representation_usage_definition = SELECT BASED_ON item_identified_representation_usage_definition WITH(
    characterized_object);
END_TYPE;

TYPE tolerance_value_or_limits_and_fits = SELECT (tolerance_value, -- modified
               limits_and_fits);
END_TYPE;


ENTITY basic_round_hole
  SUBTYPE OF (round_hole);
  depth              : OPTIONAL positive_length_measure_with_unit;
  depth_tolerance    : OPTIONAL tolerance_value;
  diameter           : positive_length_measure_with_unit;
  diameter_tolerance : OPTIONAL tolerance_value_or_limits_and_fits;
  placement          : shape_representation;
  through_hole       : BOOLEAN;
WHERE
  WR1: SIZEOF(placement\representation.items) = 1;
  WR2: SIZEOF(QUERY( ri <* placement\representation.items |
               ('GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF (ri))
               )) = 1;
  WR3: 'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(depth_tolerance\tolerance_value.lower_bound);
  WR4: 'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(depth_tolerance\tolerance_value.upper_bound);
  WR5: NOT('SHAPE_TOLERANCE_SCHEMA.TOLERANCE_VALUE' IN TYPEOF(diameter_tolerance)) OR
    ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(diameter_tolerance\tolerance_value.lower_bound));
  WR6: NOT('SHAPE_TOLERANCE_SCHEMA.TOLERANCE_VALUE' IN TYPEOF(diameter_tolerance)) OR
     ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(diameter_tolerance\tolerance_value.upper_bound));
  WR7: through_hole XOR EXISTS(depth);
END_ENTITY;

ENTITY basic_round_hole_occurrence
  SUBTYPE OF (shape_aspect_occurrence);
   SELF\shape_aspect_occurrence.definition : basic_round_hole;
  WHERE
   WR1: 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(SELF\shape_aspect.of_shape\property_definition.definition);
   WR2: SELF\shape_aspect.product_definitional = TRUE;
   --desc: The placement of the hole shall be on the surface of the item.
END_ENTITY;

ENTITY basic_round_hole_occurrence_in_assembly
  SUBTYPE OF (basic_round_hole_occurrence);
  modified_components : LIST [1:?] OF UNIQUE multi_level_reference_designator;
-- Informal proposition:
--- The placement of the hole shall be on the surface of the first member of modified_components.
END_ENTITY;

SUBTYPE_CONSTRAINT round_hole_subtypes FOR round_hole;
  ONEOF (  
    basic_round_hole,
    explicit_round_hole);
END_SUBTYPE_CONSTRAINT;

ENTITY explicit_round_hole
  SUBTYPE OF (round_hole);
  depth              : positive_length_measure_with_unit;
  depth_tolerance    : OPTIONAL tolerance_value; -- modified
  diameter           : positive_length_measure_with_unit;
  diameter_tolerance : OPTIONAL tolerance_value_or_limits_and_fits;
  placement          : shape_representation;
 WHERE
    WR1: SIZEOF(QUERY( ri <* placement\representation.items |
               ('GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF (ri))
               )) = 1;
    --One item in the placement shall be an axis2_placement_3d
    --There is no explicit shape needed for an explicit round hole.
    WR2: 'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(depth_tolerance\tolerance_value.lower_bound);
    WR3: 'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(depth_tolerance\tolerance_value.upper_bound);
    WR4: NOT('SHAPE_TOLERANCE_SCHEMA.TOLERANCE_VALUE' IN TYPEOF(diameter_tolerance)) OR
    ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(diameter_tolerance\tolerance_value.lower_bound));
    WR5: NOT('SHAPE_TOLERANCE_SCHEMA.TOLERANCE_VALUE' IN TYPEOF(diameter_tolerance)) OR
     ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(diameter_tolerance\tolerance_value.upper_bound));
END_ENTITY;

ENTITY explicit_composite_hole
  SUBTYPE OF (composite_hole);
  	   placement                  : shape_representation;
  INVERSE
    explicit_shape                : SET [0:?] OF item_identified_representation_usage for definition;
  WHERE
    WR1: SIZEOF(QUERY( ri <* placement\representation.items |
               ('GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF (ri))
               )) = 1;
    --One item in the placement shall be an axis2_placement_3d
    WR2: (SIZEOF(explicit_shape) = 0) OR 
         (SIZEOF(QUERY(es <* explicit_shape |
            NOT (placement = es\item_identified_representation_usage.used_representation)
               )) = 0);
    --The placement shall be the used_representation for each member of explicit_shape.
-- Informal proposition
--- IP1: The axis2_placement_3d in the placement shall define the reference position and orientation for the counterbore_hole_definition.
--- IP2: The z axis of the axis2_placement_3d shall point into the material of the item being machined.
--- IP3: The placement of the axis2_placement_3d shall be on the surface of the item being machined.
--- IP4: The drill axis and each bore axis shall be congruent with the z axis of the placement.
END_ENTITY;

ENTITY counterbore_hole_definition
  SUBTYPE OF (explicit_composite_hole);
       counterbore                : LIST [1:?] OF UNIQUE explicit_round_hole;
  	   drilled_hole_depth         : OPTIONAL positive_length_measure_with_unit;
   drilled_hole_depth_tolerance   : OPTIONAL tolerance_value;
  	   drilled_hole_diameter      : positive_length_measure_with_unit;
  drilled_hole_diameter_tolerance : OPTIONAL tolerance_value_or_limits_and_fits;
  	   through_hole				  : Boolean;
  WHERE
    WR1: through_hole XOR EXISTS(drilled_hole_depth);
    WR2: 'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(drilled_hole_depth_tolerance\tolerance_value.lower_bound);
    WR3: 'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(drilled_hole_depth_tolerance\tolerance_value.upper_bound);
    WR4: NOT('SHAPE_TOLERANCE_SCHEMA.TOLERANCE_VALUE' IN TYPEOF(drilled_hole_diameter_tolerance)) OR
    ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(drilled_hole_diameter_tolerance\tolerance_value.lower_bound));
    WR5: NOT('SHAPE_TOLERANCE_SCHEMA.TOLERANCE_VALUE' IN TYPEOF(drilled_hole_diameter_tolerance)) OR
     ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(drilled_hole_diameter_tolerance\tolerance_value.upper_bound));
-- Informal proposition
--- IP1: counterbore members shall in ascending order in the list organized according to their drilled_hole_diameter
--- IP2: counterbore[1] shall have a larger diameter than drilled_hole_diameter.
--- IP3: The axis2_placement_3d in the inherited placement shall define the reference position and orientation for the counterbore_hole_definition.
--- IP4: The z axis of the axis2_placement_3d shall point into the material of the item being machined.
--- IP5: The placement of the axis2_placement_3d shall be on the surface of the item being machined.
--- IP6: The drill axis and each bore axis shall be congruent with the z axis of the placement.
--- IP7: If a limits_and_fits is provided for the diameter tolerance the limits_and_fits shall be for a hole.
--- IP8: counterbore_hole_definitin and explicit_round_hole geometry are defined in the same context.
END_ENTITY;

ENTITY simplified_counterbore_hole_definition
	SUBTYPE OF (counterbore_hole_definition);
  WHERE
    WR1: SIZEOF(SELF\explicit_composite_hole.placement\representation.items) = 1;
    --There shall be exactly one item in the representation.
END_ENTITY;

ENTITY counterbore_hole_occurrence
  SUBTYPE OF (shape_aspect_occurrence);
   SELF\shape_aspect_occurrence.definition : counterbore_hole_definition;
  WHERE
   WR1: 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(SELF\shape_aspect.of_shape\property_definition.definition);
   WR2: SELF\shape_aspect.product_definitional = TRUE;
   --desc: The placement of the hole shall be on the surface of the item.
END_ENTITY;

ENTITY counterbore_hole_occurrence_in_assembly
  SUBTYPE OF (counterbore_hole_occurrence);
  modified_components : LIST [1:?] OF UNIQUE multi_level_reference_designator;
-- Informal proposition:
--- IP1: The placement of the hole shall be on the surface of the first member of modified_components.
END_ENTITY;

ENTITY countersink_hole_definition
  SUBTYPE OF (explicit_composite_hole);
     countersink_angle            : positive_plane_angle_measure_with_unit;
     countersink_angle_tolerance  : OPTIONAL tolerance_value;
     countersink_diameter         : positive_length_measure_with_unit;
 countersink_diameter_tolerance   : OPTIONAL tolerance_value_or_limits_and_fits;
 	   drilled_hole_depth         : OPTIONAL positive_length_measure_with_unit;
   drilled_hole_depth_tolerance   : OPTIONAL tolerance_value;
  	   drilled_hole_diameter      : positive_length_measure_with_unit;
  drilled_hole_diameter_tolerance : OPTIONAL tolerance_value_or_limits_and_fits;
     through_hole				  : Boolean;
  WHERE
    WR1: through_hole XOR EXISTS(drilled_hole_depth);
    WR2: 'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT' IN TYPEOF(countersink_angle_tolerance\tolerance_value.lower_bound);
    WR3: 'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT' IN TYPEOF(countersink_angle_tolerance\tolerance_value.upper_bound);
    WR4: NOT('SHAPE_TOLERANCE_SCHEMA.TOLERANCE_VALUE' IN TYPEOF(countersink_diameter_tolerance)) OR
    ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(countersink_diameter_tolerance\tolerance_value.lower_bound));
    WR5: NOT('SHAPE_TOLERANCE_SCHEMA.TOLERANCE_VALUE' IN TYPEOF(countersink_diameter_tolerance)) OR
     ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(countersink_diameter_tolerance\tolerance_value.upper_bound));
    WR6: 'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(drilled_hole_depth_tolerance\tolerance_value.lower_bound);
    WR7: 'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(drilled_hole_depth_tolerance\tolerance_value.upper_bound);
    WR8: NOT('SHAPE_TOLERANCE_SCHEMA.TOLERANCE_VALUE' IN TYPEOF(drilled_hole_diameter_tolerance)) OR
    ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(drilled_hole_diameter_tolerance\tolerance_value.lower_bound));
    WR9: NOT('SHAPE_TOLERANCE_SCHEMA.TOLERANCE_VALUE' IN TYPEOF(drilled_hole_diameter_tolerance)) OR
     ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(drilled_hole_diameter_tolerance\tolerance_value.upper_bound));
-- Informal proposition
--- IP1: countersink_diameter shall have a larger diameter than the drilled_hole_diameter.
--- IP2: The axis2_placement_3d in the inherited placement shall define the reference position and orientation for the counterbore_hole_definition.
--- IP3: The z axis of the axis2_placement_3d shall point into the material of the item being machined.
--- IP4: The placement of the axis2_placement_3d shall be on the surface of the item being machined.
--- IP5: The drill axis and the countersink axis shall be congruent with the z axis of the placement.
--- IP6: If a limits_and_fits is provided for the diameter tolerance the limits_and_fits shall be for a hole.
--- IP7: countersink_hole_definition and explicit_round_hole geometry are defined in the same context.
END_ENTITY;

ENTITY simplified_countersink_hole_definition
	SUBTYPE OF (countersink_hole_definition);
  WHERE
    WR1: SIZEOF(SELF\explicit_composite_hole.placement\representation.items) = 1;
    --There shall be exactly one item in the representation.
END_ENTITY;

ENTITY countersink_hole_occurrence
 SUBTYPE OF (shape_aspect_occurrence);
   SELF\shape_aspect_occurrence.definition : countersink_hole_definition;
  WHERE
   WR1: 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(SELF\shape_aspect.of_shape\property_definition.definition);
   WR2: SELF\shape_aspect.product_definitional = TRUE;
   ---desc. The placement of the hole shall be on the surface of the item.
END_ENTITY;

ENTITY countersink_hole_occurrence_in_assembly
  SUBTYPE OF (countersink_hole_occurrence);
  modified_components : LIST [1:?] OF UNIQUE multi_level_reference_designator;
-- Informal proposition:
--- IP1: The placement of the hole shall be on the surface of the first member of modified_components.
END_ENTITY;

ENTITY counterdrill_hole_definition
  SUBTYPE OF (explicit_composite_hole);
     counterbore                  : explicit_round_hole;
     counterdrill_angle           : positive_plane_angle_measure_with_unit;
     counterdrill_angle_tolerance : OPTIONAL tolerance_value;
 	   drilled_hole_depth     : OPTIONAL positive_length_measure_with_unit;
   drilled_hole_depth_tolerance   : OPTIONAL tolerance_value;
  	   drilled_hole_diameter  : positive_length_measure_with_unit;
  drilled_hole_diameter_tolerance : OPTIONAL tolerance_value_or_limits_and_fits;
     through_hole                 : Boolean;
  WHERE
    WR1: through_hole XOR EXISTS(drilled_hole_depth);
    WR2: 'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT' IN TYPEOF(counterdrill_angle_tolerance\tolerance_value.lower_bound);
    WR3: 'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT' IN TYPEOF(counterdrill_angle_tolerance\tolerance_value.upper_bound);
    WR4: 'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(drilled_hole_depth_tolerance\tolerance_value.lower_bound);
    WR5: 'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(drilled_hole_depth_tolerance\tolerance_value.upper_bound);
    WR6: NOT('SHAPE_TOLERANCE_SCHEMA.TOLERANCE_VALUE' IN TYPEOF(drilled_hole_diameter_tolerance)) OR
    ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(drilled_hole_diameter_tolerance\tolerance_value.lower_bound));
    WR7: NOT('SHAPE_TOLERANCE_SCHEMA.TOLERANCE_VALUE' IN TYPEOF(drilled_hole_diameter_tolerance)) OR
     ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(drilled_hole_diameter_tolerance\tolerance_value.upper_bound));
-- Informal proposition
--- IP1: The counterbore shall have a larger diameter than the drilled_hole_diameter.
--- IP2: The axis2_placement_3d in the inherited placement shall define the reference position and orientation for the counterbore_hole_definition.
--- IP3: The z axis of the axis2_placement_3d shall point into the material of the item being machined.
--- IP4: The placement of the axis2_placement_3d shall be on the surface of the item being machined.
--- IP5: The drill axis and the counterdrill axis and each bore axis shall be congruent with the z axis of the placement.
--- IP6: counterdrill_hole_definition and explicit_round_hole geometry are defined in the same context.
 END_ENTITY;

ENTITY simplified_counterdrill_hole_definition
	SUBTYPE OF (counterdrill_hole_definition);
  WHERE
    WR1: SIZEOF(SELF\explicit_composite_hole.placement\representation.items) = 1;
    --There shall be exactly one item in the representation.
END_ENTITY;

ENTITY counterdrill_hole_occurrence
 SUBTYPE OF (shape_aspect_occurrence);
   SELF\shape_aspect_occurrence.definition : counterdrill_hole_definition;
  WHERE
   WR1: 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(SELF\shape_aspect.of_shape\property_definition.definition);
   WR2: SELF\shape_aspect.product_definitional = TRUE;
---desc: The placement shall be on the surface of the item.
END_ENTITY;

ENTITY counterdrill_hole_occurrence_in_assembly
  SUBTYPE OF (counterdrill_hole_occurrence);
  modified_components : LIST [1:?] OF UNIQUE multi_level_reference_designator;
-- Informal proposition:
--- IP1: The placement of the hole shall be on the surface of the first member of modified_components.
END_ENTITY;

ENTITY spotface_definition
  SUBTYPE OF (explicit_round_hole);
        spotface_radius : positive_length_measure_with_unit;
        spotface_radius_tolerance : OPTIONAL tolerance_value;
 WHERE
    WR1: 'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(spotface_radius_tolerance\tolerance_value.lower_bound);
    WR2: 'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(spotface_radius_tolerance\tolerance_value.upper_bound);
END_ENTITY;

ENTITY spotface_hole_definition
  SUBTYPE OF (counterbore_hole_definition);
  SELF\counterbore_hole_definition.counterbore RENAMED spotface : LIST [1:?] OF UNIQUE spotface_definition;
END_ENTITY;

ENTITY simplified_spotface_hole_definition
	SUBTYPE OF (spotface_hole_definition, simplified_counterbore_hole_definition);
END_ENTITY;

ENTITY spotface_occurrence
  SUBTYPE OF (counterbore_hole_occurrence);
   SELF\counterbore_hole_occurrence.definition   : spotface_hole_definition;
END_ENTITY;

ENTITY spotface_occurrence_in_assembly
  SUBTYPE OF (counterbore_hole_occurrence_in_assembly);
   SELF\counterbore_hole_occurrence.definition   : spotface_hole_definition;
END_ENTITY;



 END_SCHEMA;


--
-- DATE_TIME_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/date_time_assignment/mim.exp)
--
(*
 $Id: mim.exp,v 1.9 2014/01/21 15:30:37 darla Exp 
 ISO TC184/SC4/WG12 N8401 - ISO/TS 10303-1014 Date time assignment - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1094
*)     
SCHEMA Date_time_assignment_mim;

USE FROM Extended_date_mim; 	-- 10303-1776

USE FROM date_time_schema 	-- ISO 10303-41
  (date,
   date_role,
   date_time_role);
USE FROM management_resources_schema -- ISO 10303-41
  (date_and_time_assignment,
   date_assignment);

   
TYPE date_item = EXTENSIBLE SELECT; 
END_TYPE;
   
TYPE date_and_time_item = EXTENSIBLE SELECT; 
END_TYPE;
   
ENTITY applied_date_and_time_assignment
  SUBTYPE OF (date_and_time_assignment);
  items : SET [1:?] OF date_and_time_item;
END_ENTITY;
   
ENTITY applied_date_assignment
  SUBTYPE OF (date_assignment);
  items : SET [1:?] OF date_item;
END_ENTITY;

END_SCHEMA;



--
-- DATE_TIME_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/date_time/mim.exp)
--
(*
 $Id: mim.exp,v 1.10 2013/11/19 16:12:42 darla Exp 
 ISO TC184/SC4/WG12 N8395 - ISO/TS 10303-1010 Date time - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N7979
*)       
SCHEMA Date_time_mim;
USE FROM date_time_schema -- ISO 10303-41
  (calendar_date,
   date_and_time,
   coordinated_universal_time_offset,
   local_time);

END_SCHEMA;



--
-- DATE_TIME_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/date_time_schema/date_time_schema.exp)
--
(*
Id: date_time_schema.exp,v 1.24 2014/03/04 00:30:32 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Date time schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Date time schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA date_time_schema '{iso standard 10303 part(41) version(7) object(1) date_time_schema(7)}';

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   description_attribute_select,
   get_description_value);

REFERENCE FROM measure_schema   -- ISO 10303-41
  (measure_with_unit,
   time_measure_with_unit);

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);

  TYPE dts_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    date_role,
    date_time_role,
    time_role);
  END_TYPE;

TYPE ahead_or_behind = ENUMERATION OF
   (ahead,
    exact,
    behind);
END_TYPE;

TYPE date_time_or_event_occurrence = SELECT
   (date_time_select,
    event_occurrence);
END_TYPE;

TYPE date_time_select = SELECT
   (date,
    date_and_time,
    local_time);
END_TYPE;

TYPE day_in_month_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 31};
END_TYPE;

TYPE day_in_week_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 7 };
END_TYPE;

TYPE day_in_year_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 366};
END_TYPE;

TYPE hour_in_day = INTEGER;
WHERE
  WR1: { 0 <= SELF < 24 };
END_TYPE;

TYPE minute_in_hour = INTEGER;
WHERE
  WR1: { 0 <= SELF <= 59 };
END_TYPE;

TYPE month_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 12 };
END_TYPE;

TYPE second_in_minute = REAL;
WHERE
  WR1: { 0 <= SELF < 60.0 };
END_TYPE;

TYPE week_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 53 };
END_TYPE;

TYPE year_number = INTEGER;
WHERE
  WR1: (SELF > 1581);
END_TYPE;

ENTITY calendar_date
  SUBTYPE OF (date);
  day_component : day_in_month_number;
  month_component : month_in_year_number;
WHERE
  WR1: valid_calendar_date (SELF);
END_ENTITY;

ENTITY coordinated_universal_time_offset;
  hour_offset : INTEGER;
  minute_offset : OPTIONAL INTEGER;
  sense : ahead_or_behind;
DERIVE
  actual_minute_offset : INTEGER := NVL(minute_offset,0);
WHERE
  WR1: { 0 <= hour_offset < 24 };
  WR2: { 0 <= actual_minute_offset <= 59 };
  WR3: NOT (((hour_offset <> 0) OR (actual_minute_offset <>0)) AND (sense = exact));
END_ENTITY;

ENTITY date
  SUPERTYPE OF (ONEOF (calendar_date,
                       ordinal_date,
                       week_of_year_and_day_date,
                       year_month));
  year_component : year_number;
END_ENTITY;

ENTITY date_and_time;
  date_component : date;
  time_component : local_time;
END_ENTITY;

ENTITY date_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY date_time_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY event_occurrence;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_relationship;
  name : label;
  description : OPTIONAL text;
  relating_event : event_occurrence;
  related_event : event_occurrence;
END_ENTITY;

ENTITY event_occurrence_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY local_time;
  hour_component : hour_in_day;
  minute_component : OPTIONAL minute_in_hour;
  second_component : OPTIONAL second_in_minute;
  zone : coordinated_universal_time_offset;
WHERE
  WR1: valid_time (SELF);
END_ENTITY;

ENTITY ordinal_date
  SUBTYPE OF (date);
  day_component : day_in_year_number;
WHERE
  WR1: (NOT leap_year(SELF.year_component) AND { 1 <= day_component <= 365 }) OR (leap_year(SELF.year_component) AND { 1 <= day_component <= 366 });
END_ENTITY;

ENTITY relative_event_occurrence
  SUBTYPE OF (event_occurrence);
  base_event : event_occurrence;
  offset : time_measure_with_unit;
END_ENTITY;

ENTITY time_interval;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_relationship;
  name : label;
  description : OPTIONAL text;
  relating_time_interval : time_interval;
  related_time_interval : time_interval;
END_ENTITY;

ENTITY time_interval_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_with_bounds
  SUBTYPE OF (time_interval);
  primary_bound : OPTIONAL date_time_or_event_occurrence;
  secondary_bound : OPTIONAL date_time_or_event_occurrence;
  duration : OPTIONAL time_measure_with_unit;
WHERE
  WR1: EXISTS(primary_bound) OR EXISTS(secondary_bound);
  WR2: NOT (EXISTS(primary_bound) AND EXISTS(secondary_bound) AND EXISTS(duration));
  WR3: EXISTS(primary_bound) AND NOT EXISTS(secondary_bound) AND (NOT EXISTS(duration) OR duration_is_positive(duration));
  WR4: EXISTS(secondary_bound) AND NOT EXISTS(primary_bound) AND EXISTS(duration) AND duration_is_negative(duration);
END_ENTITY;

ENTITY time_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY week_of_year_and_day_date
  SUBTYPE OF (date);
  week_component : week_in_year_number;
  day_component : OPTIONAL day_in_week_number;
WHERE
 WR1: NOT(leap_year(SELF\date.year_component)) OR { 1<= (day_component + (7 * (week_component - 1))) <= 366 };
 WR2: leap_year(SELF\date.year_component) OR { 1<= (day_component + (7 * (week_component - 1))) <= 365 };
END_ENTITY;

ENTITY year_month
  SUBTYPE OF (date);
  month_component : month_in_year_number;
END_ENTITY;

FUNCTION acyclic_event_occurrence_relationship
 (relation : event_occurrence_relationship; relatives : SET[1:?] OF event_occurrence; specific_relation : STRING) : BOOLEAN;
 LOCAL
      x : SET OF event_occurrence_relationship;
    END_LOCAL;

    IF relation.relating_event IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(evnt <* bag_to_set(USEDIN(relation.relating_event, 'DATE_TIME_SCHEMA.' + 'EVENT_OCCURRENCE_RELATIONSHIP.' + 'RELATED_EVENT')) | specific_relation IN TYPEOF(evnt));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_event_occurrence_relationship(x[i], relatives + relation.relating_event, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION;

FUNCTION acyclic_time_interval_relationship
 (relation : time_interval_relationship; relatives : SET[1:?] OF time_interval; specific_relation : STRING) : BOOLEAN;
  LOCAL
      x : SET OF time_interval_relationship;
    END_LOCAL;

    IF relation.relating_time_interval IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ti <* bag_to_set(USEDIN(relation.relating_time_interval, 'DATE_TIME_SCHEMA.' + 'TIME_INTERVAL_RELATIONSHIP.' + 'RELATED_TIME_INTERVAL')) | specific_relation IN TYPEOF(ti));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_time_interval_relationship(x[i], relatives + relation.relating_time_interval, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION;


FUNCTION duration_is_positive
 (duration : time_measure_with_unit) : BOOLEAN;
  IF (duration\measure_with_unit.value_component > 0.0) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION;

FUNCTION duration_is_negative
 (duration : time_measure_with_unit) : BOOLEAN;
  IF (duration\measure_with_unit.value_component < 0.0) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION;

FUNCTION leap_year
 (year : year_number) : BOOLEAN;
  IF ((((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) = 0)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION;

FUNCTION valid_calendar_date
 (date : calendar_date) : LOGICAL;
  CASE date.month_component OF
    1  : RETURN({ 1 <= date.day_component <= 31 });
    2  : BEGIN
           IF (leap_year(date.year_component)) THEN
             RETURN({ 1 <= date.day_component <= 29 });
           ELSE
             RETURN({ 1 <= date.day_component <= 28 });
           END_IF;
         END;
    3  : RETURN({ 1 <= date.day_component <= 31 });
    4  : RETURN({ 1 <= date.day_component <= 30 });
    5  : RETURN({ 1 <= date.day_component <= 31 });
    6  : RETURN({ 1 <= date.day_component <= 30 });
    7  : RETURN({ 1 <= date.day_component <= 31 });
    8  : RETURN({ 1 <= date.day_component <= 31 });
    9  : RETURN({ 1 <= date.day_component <= 30 });
    10 : RETURN({ 1 <= date.day_component <= 31 });
    11 : RETURN({ 1 <= date.day_component <= 30 });
    12 : RETURN({ 1 <= date.day_component <= 31 });
  END_CASE;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION valid_time
 (time : local_time) : BOOLEAN;
  IF EXISTS(time.second_component) THEN
    RETURN (EXISTS(time.minute_component));
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION;

END_SCHEMA;


--
-- DESCRIPTION_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/description_assignment/mim.exp)
--
(*
   $Id: mim.exp,v 1.17 2018/11/29 20:44:30 brandon Exp 
   ISO TC184/SC4/WG12 N10293 - ISO/TS 10303-1473 Description assignment - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5849
*) 

SCHEMA Description_assignment_mim;

USE FROM systems_engineering_representation_schema   -- ISO 10303-61
  (description_text,
   description_text_assignment,
   description_text_assignment_relationship);


TYPE description_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

ENTITY applied_description_text_assignment
SUBTYPE OF (description_text_assignment);
  items : SET [1 : ?] OF description_item;
END_ENTITY;

ENTITY applied_description_text_assignment_relationship
	SUBTYPE of (description_text_assignment_relationship);
	SELF\description_text_assignment_relationship.related 		: applied_description_text_assignment;					
	SELF\description_text_assignment_relationship.relating 		: applied_description_text_assignment;						
END_ENTITY;

END_SCHEMA;  -- Description_assignment_mim



--
-- DOCUMENT_AND_VERSION_IDENTIFICATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/document_and_version_identification/mim.exp)
--
(*
Id: mim.exp,v 1.18 2012/10/06 20:09:56 liutkuviene Exp 
ISO TC184/SC4/WG12 N7709 - ISO/TS 10303-1121 Document and version identification - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6577
*) 


SCHEMA Document_and_version_identification_mim;

USE FROM Product_identification_mim;    -- ISO/TS 10303-1017

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

USE FROM product_definition_schema   -- ISO 10303-41
  (product_category,
   product_related_product_category); 

END_SCHEMA;  -- Document_and_version_identification_mim



--
-- DOCUMENT_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/document_assignment/mim.exp)
--
(*
Id: mim.exp,v 1.25 2015/10/20 20:37:44 lothartklein Exp 
ISO TC184/SC4/WG12 N8680 - ISO/TS 10303-1122 Document assignment - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N7715
*)



SCHEMA Document_assignment_mim;

USE FROM Document_and_version_identification_mim;    -- ISO/TS 10303-1121

USE FROM Document_definition_mim;    -- ISO/TS 10303-1123

USE FROM document_schema   -- ISO 10303-41
  (document_product_association); 

USE FROM File_identification_mim;    -- ISO/TS 10303-1127

USE FROM management_resources_schema   -- ISO 10303-41
  (document_reference,
   document_usage_constraint_assignment); 
   
USE FROM basic_attribute_schema(role_association, object_role);  -- ISO 10303-41


TYPE document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_document_reference
  SUBTYPE OF (document_reference);
  items : SET[1:?] OF document_reference_item;
END_ENTITY;

ENTITY applied_document_usage_constraint_assignment
  SUBTYPE OF (document_usage_constraint_assignment);
  items : SET[1:?] OF document_reference_item;
END_ENTITY;

ENTITY document_product_equivalence
  SUBTYPE OF (document_product_association);
WHERE
  WR1: SELF\document_product_association.name = 'equivalence';
  WR2: NOT ('PRODUCT_DEFINITION_SCHEMA.PRODUCT' IN TYPEOF(SELF\document_product_association.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document') AND (SIZEOF(QUERY(prpc <* USEDIN(SELF\document_product_association.related_product, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1));
  WR3: NOT ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document version') AND (SIZEOF(QUERY(prpc <* USEDIN(SELF.related_product\product_definition_formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1));
  WR4: NOT ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document definition') AND (SIZEOF(QUERY(prpc <* USEDIN(SELF\document_product_association.related_product\product_definition.formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1));
END_ENTITY;


SUBTYPE_CONSTRAINT subtype_mandatory_document_product_association FOR document_product_association;
  ABSTRACT SUPERTYPE;
END_SUBTYPE_CONSTRAINT;

END_SCHEMA;  -- Document_assignment_mim


--
-- DOCUMENT_DEFINITION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/document_definition/mim.exp)
--
(*
 $Id: mim.exp,v 1.19 2004/10/28 18:51:31 darla Exp 
 ISO TC184/SC4/WG12 N2961 - ISO/TS 10303-1123 Document definition - EXPRESS MIM
*) 


SCHEMA Document_definition_mim;

USE FROM Document_and_version_identification_mim;    -- ISO/TS 10303-1121

USE FROM External_item_identification_assignment_mim;    -- ISO/TS 10303-1128

USE FROM File_identification_mim;    -- ISO/TS 10303-1127

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition,
   product_definition_with_associated_documents); 

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019


TYPE document_location_select = SELECT BASED_ON external_identification_item WITH 
   (product_definition);
END_TYPE; 

END_SCHEMA;  -- Document_definition_mim


--
-- DOCUMENT_MANAGEMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/document_management/mim.exp)
--
(*
 ISO TC184/SC4/WG12 N10763 - ISO/TS 10303-1290 Document management - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N10414
*) 


SCHEMA Document_management_mim;

USE FROM Document_assignment_mim;    -- ISO/TS 10303-1122

USE FROM Document_properties_mim;    -- ISO/TS 10303-1126

USE FROM Document_structure_mim;    -- ISO/TS 10303-1124

USE FROM external_reference_schema   -- ISO 10303-41
  (external_source); 

USE FROM Management_resource_information_mim;    -- ISO/TS 10303-1288

USE FROM management_resources_schema   -- ISO 10303-41
  (document_usage_role); 

TYPE dm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_approval_item WITH
  (product_definition,
   product_definition_formation,
   product_definition_relationship);
END_TYPE;

TYPE dm_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_attribute_language_item WITH
  (applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_external_identification_assignment,
   document_relationship,
   document_usage_role,
   external_source,
   object_role,
   product,
   product_definition,
   product_definition_formation,
   product_definition_relationship);
END_TYPE;

TYPE dm_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH
  (product_definition_formation);
END_TYPE;

TYPE dm_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_and_time_item WITH
  (document_file,
   product_definition,
   product_definition_formation,
   product_definition_relationship);
END_TYPE;

TYPE dm_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_item WITH
  (document_file,
   product_definition,
   product_definition_formation,
   product_definition_relationship);
END_TYPE;

TYPE dm_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_identification_item WITH
  (document_file,
   product,
   product_definition,
   product_definition_formation);
END_TYPE;

TYPE dm_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_multi_language_attribute_item WITH
  (applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_external_identification_assignment,
   document_relationship,
   document_usage_role,
   external_source,
   object_role,
   product,
   product_definition,
   product_definition_formation,
   product_definition_relationship);
END_TYPE;

TYPE dm_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_organization_item WITH
  (document_file,
   product,
   product_definition,
   product_definition_formation);
END_TYPE;

TYPE dm_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_person_and_organization_item WITH
  (document_file,
   product,
   product_definition,
   product_definition_formation);
END_TYPE;

TYPE dm_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH
  (document_file,
   product,
   product_definition,
   product_definition_formation);
END_TYPE;

END_SCHEMA;  -- Document_management_mim



--
-- DOCUMENT_PROPERTIES_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/document_properties/mim.exp)
--
(*
 $Id: mim.exp,v 1.15 2012/10/11 05:49:13 liutkuviene Exp 
 ISO TC184/SC4/WG12 N7997 - ISO/TS 10303-1126 Document properties - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N7431
*) 


SCHEMA Document_properties_mim;

USE FROM Document_definition_mim;    -- ISO/TS 10303-1123

USE FROM File_identification_mim;    -- ISO/TS 10303-1127

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Measure_representation_mim;    -- ISO/TS 10303-1118

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_product_definition); 


END_SCHEMA;  -- Document_properties_mim


--
-- DOCUMENT_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/document_schema/document_schema.exp)
--
(*
Id: document_schema.exp,v 1.15 2014/03/04 00:30:33 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Document schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Document schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA document_schema '{iso standard 10303 part(41) version(4) object(1) document_schema(8)}';
  REFERENCE FROM product_definition_schema (product, product_definition, product_definition_formation);
  REFERENCE FROM support_resource_schema (bag_to_set, identifier, label, text);
  TYPE product_or_formation_or_definition = SELECT (product, product_definition_formation, product_definition);
  END_TYPE;

  ENTITY document;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    kind : document_type;
  INVERSE
    representation_types : SET [0:?] OF document_representation_type FOR represented_document;
  END_ENTITY;

  ENTITY document_product_association;
    name : label;
    description : OPTIONAL text;
    relating_document : document;
    related_product : product_or_formation_or_definition;
  END_ENTITY;

  ENTITY document_relationship;
    name : label;
    description : OPTIONAL text;
    relating_document : document;
    related_document : document;
  END_ENTITY;

  ENTITY document_representation_type;
    name : label;
    represented_document : document;
  END_ENTITY;

  ENTITY document_type;
    product_data_type : label;
  END_ENTITY;

  ENTITY document_usage_constraint;
    source : document;
    subject_element : label;
    subject_element_value : text;
  END_ENTITY;

  ENTITY document_with_class
    SUBTYPE OF (document);
    class : identifier;
  END_ENTITY;

  FUNCTION acyclic_document_relationship (relation : document_relationship; relatives : SET [1:?] OF document; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF document_relationship;
    END_LOCAL;

    IF relation.relating_document IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(doc <* bag_to_set(USEDIN(relation.relating_document, 'DOCUMENT_SCHEMA.' + 'DOCUMENT_RELATIONSHIP.' + 'RELATED_DOCUMENT')) | specific_relation IN TYPEOF(doc));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_document_relationship(x[i], relatives + relation.relating_document, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;


--
-- DOCUMENT_STRUCTURE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/document_structure/mim.exp)
--
(*
 $Id: mim.exp,v 1.9 2004/10/21 17:26:29 darla Exp 
 ISO TC184/SC4/WG12 N1196 - ISO/TS 10303-1124 Document structure - EXPRESS MIM
*)



SCHEMA Document_structure_mim;
USE FROM Document_definition_mim; -- ISO/CD TS 10303-1123
USE FROM File_identification_mim; -- ISO/CD TS 10303-1127
USE FROM document_schema (document_relationship); -- ISO 10303-41
USE FROM product_definition_schema -- ISO 10303-41
	(product_definition_formation_relationship,
         product_definition_relationship);
END_SCHEMA;



--
-- EFFECTIVITY_APPLICATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/effectivity_application/mim.exp)
--
(*
 $Id: mim.exp,v 1.10 2012/07/18 09:01:07 lothartklein Exp 
ISO TC184/SC4/WG12 N3224 - ISO/TS 10303-1059 Effectivity application - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1175
*) 


SCHEMA Effectivity_application_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (object_role,
   role_association,
   role_select); 

USE FROM Effectivity_mim;    -- ISO/TS 10303-1057

USE FROM management_resources_schema   -- ISO 10303-41
  (effectivity_assignment); 


TYPE effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_effectivity_assignment
  SUBTYPE OF (effectivity_assignment);
  items : SET[1:?] OF effectivity_item;
END_ENTITY;

ENTITY applied_ineffectivity_assignment
  SUBTYPE OF (effectivity_assignment);
  items : SET [1:?] OF effectivity_item;
WHERE
  WR1:  SIZEOF(['EFFECTIVITY_SCHEMA.LOT_EFFECTIVITY',
                'EFFECTIVITY_SCHEMA.SERIAL_NUMBERED_EFFECTIVITY',
                'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_EFFECTIVITY'] *
                     TYPEOF(SELF.assigned_effectivity)
              ) = 0;   
END_ENTITY;

END_SCHEMA;  -- Effectivity_application_mim


--
-- EFFECTIVITY_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/effectivity/mim.exp)
--
(*
 $Id: mim.exp,v 1.9 2012/11/09 21:40:58 thomasrthurman Exp 
 ISO TC184/SC4/WG12 N8260 - ISO/TS 10303-1057 Effectivity - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N8003
*)
  
SCHEMA Effectivity_mim;

USE FROM Time_interval_mim; -- ISO 10303-1065
USE FROM Value_with_unit_mim ; -- ISO 10303-1054

USE FROM effectivity_schema -- ISO 10303-41
  (	dated_effectivity,
	effectivity,
   	effectivity_relationship,
	lot_effectivity,
   	serial_numbered_effectivity,
      time_interval_based_effectivity);

END_SCHEMA;


--
-- EFFECTIVITY_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/effectivity_schema/effectivity_schema.exp)
--
(*
Id: effectivity_schema.exp,v 1.19 2019/05/08 19:31:23 sjohnston Exp 
ISO 10303 TC184/SC4/WG12 N10232

EXPRESS Source:
ISO 10303-41 ed6 Fundamentals of product description and support - Effectivity schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2019  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Effectivity schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA effectivity_schema '{iso standard 10303 part(41) version(8) object(1) effectivity_schema(9)}';

  REFERENCE FROM action_schema   -- ISO 10303-41
  	(action_method);
  REFERENCE FROM basic_attribute_schema ( -- ISO 10303-41
    description_attribute, 
    description_attribute_select,
    get_description_value, 
    get_name_value, 
    name_attribute,
    name_attribute_select);
  REFERENCE FROM date_time_schema (	-- ISO 10303-41
    date_time_or_event_occurrence, 
    time_interval);
  REFERENCE FROM measure_schema (	-- ISO 10303-41
    measure_with_unit);
  REFERENCE FROM support_resource_schema (	-- ISO 10303-41
    bag_to_set, 
    identifier, 
    label, 
    text);
  
  TYPE effs_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    effectivity);
  END_TYPE;

  TYPE effs_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    effectivity);
  END_TYPE;
 
 ENTITY condition
		  	SUBTYPE OF (action_method);
		  END_ENTITY;
ENTITY conditional_effectivity
		  	SUBTYPE OF (condition, effectivity);
END_ENTITY;
ENTITY conditional_configuration											
			SUBTYPE OF (conditional_effectivity);
			configuration_type	: STRING;									
			inheritance_type	: STRING;									
END_ENTITY;  
    
  ENTITY dated_effectivity
    SUBTYPE OF (effectivity);
    effectivity_end_date : OPTIONAL date_time_or_event_occurrence;
    effectivity_start_date : OPTIONAL date_time_or_event_occurrence;
  WHERE
    WR1: EXISTS(effectivity_end_date) OR EXISTS(effectivity_start_date);
  END_ENTITY;

  ENTITY effectivity
    SUPERTYPE OF (ONEOF(serial_numbered_effectivity, dated_effectivity, lot_effectivity, time_interval_based_effectivity));
    id : identifier;
  DERIVE
    name : label := get_name_value(SELF);
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY effectivity_relationship;
    name : label;
    description : OPTIONAL text;
    related_effectivity : effectivity;
    relating_effectivity : effectivity;
  END_ENTITY;

  ENTITY lot_effectivity
    SUBTYPE OF (effectivity);
    effectivity_lot_id : identifier;
    effectivity_lot_size : measure_with_unit;
  END_ENTITY;

  ENTITY serial_numbered_effectivity
    SUBTYPE OF (effectivity);
    effectivity_start_id : identifier;
    effectivity_end_id : OPTIONAL identifier;
  END_ENTITY;

  ENTITY time_interval_based_effectivity
    SUBTYPE OF (effectivity);
    effectivity_period : time_interval;
  END_ENTITY;

  FUNCTION acyclic_effectivity_relationship (relation : effectivity_relationship; relatives : SET [1:?] OF effectivity; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF effectivity_relationship;
    END_LOCAL;

    IF relation.relating_effectivity IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(eff <* bag_to_set(USEDIN(relation.relating_effectivity, 'EFFECTIVITY_SCHEMA.' + 'EFFECTIVITY_RELATIONSHIP.' + 'RELATED_EFFECTIVITY')) | specific_relation IN TYPEOF(eff));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_effectivity_relationship(x[i], relatives + relation.relating_effectivity, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;


--
-- ELEMENTAL_GEOMETRIC_SHAPE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/elemental_geometric_shape/mim.exp)
--
(*
ISO TC184/SC4/WG12 N11240 - ISO/TS 10303-1004 Elemental geometric shape - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N10667
*)

   
SCHEMA Elemental_geometric_shape_mim;

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006
USE FROM Shape_property_assignment_mim; -- ISO/TS 10303-1032


USE FROM geometry_schema   -- ISO 10303-42
  (axis1_placement,
   axis2_placement_2d,
   axis2_placement_3d,
   cartesian_point,
   cartesian_transformation_operator_2d,
   cartesian_transformation_operator_3d,
   direction,
   geometric_representation_context,
   geometric_representation_item,
   placement,
   point); 

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM product_property_representation_schema   -- ISO 10303-41
  (shape_representation); 

USE FROM qualified_measure_schema   -- ISO 10303-45
  (measure_representation_item); 

USE FROM representation_schema   -- ISO 10303-43
  (mapped_item,
   representation_map,
   value_representation_item); 


TYPE representation_identification_item = SELECT BASED_ON identification_item WITH 
   (shape_representation);
END_TYPE; 

END_SCHEMA;  -- Elemental_geometric_shape_mim


--
-- ELEMENTARY_FUNCTION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/elementary_function/mim.exp)
--
(*
 $Id: mim.exp,v 1.4 2017/10/26 15:52:17 verodub Exp 
 ISO TC184/SC4/WG12 N7859 - ISO/TS 10303-1527 Elementary function - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N7224
*)

SCHEMA Elementary_function_mim;

USE FROM Numeric_expression_mim;   -- ISO/TS 10303-1526

USE FROM iso13584_expressions_schema(   -- ISO 13584-20
	abs_function,
	acos_function,	
	asin_function,
	atan_function,	
	cos_function,
	exp_function,
	integer_defined_function,	
	log_function,
	log10_function,
	log2_function,
	maximum_function,
	minimum_function,	
	minus_function,		
	numeric_defined_function,	
	real_defined_function,	
	sin_function,	
	square_root_function,	
	tan_function,	
	unary_function_call);
	
END_SCHEMA;


--
-- ENVELOPE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/envelope/mim.exp)
--
(*
 ISO TC184/SC4/WG12 N10752 - ISO/TS 10303-1265 Envelope - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N3041
*) 

SCHEMA Envelope_mim;

USE FROM Message_mim;    -- ISO/TS 10303-1270

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object);

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

TYPE envelope_approval = SELECT BASED_ON approval_item WITH
  (envelope);
END_TYPE;

TYPE envelope_date = SELECT BASED_ON date_item WITH
  (envelope);
END_TYPE;

TYPE envelope_date_and_time = SELECT BASED_ON date_and_time_item WITH
  (envelope);
END_TYPE;

TYPE envelope_organization_item = SELECT BASED_ON organization_item WITH
  (envelope);
END_TYPE;

TYPE envelope_person_organization_item = SELECT BASED_ON person_and_organization_item WITH
  (envelope);
END_TYPE;

ENTITY envelope
SUBTYPE OF (characterized_object, product);
END_ENTITY;

ENTITY envelope_relationship
SUBTYPE OF (product_relationship);
END_ENTITY;

END_SCHEMA;  -- Envelope_mim



--
-- EVENT_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/event_assignment/mim.exp)
--
(*
 $Id: mim.exp,v 1.4 2004/10/21 17:52:41 darla Exp 
 ISO TC184/SC4/WG12 N2117 - ISO/TS 10303-1364 Event assignment - EXPRESS MIM
*)



SCHEMA Event_assignment_mim; 

USE FROM Event_mim;    -- ISO/TS 10303-1064

USE FROM management_resources_schema   -- ISO 10303-41
  (event_occurrence_assignment); 


TYPE event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_event_occurrence_assignment
  SUBTYPE OF (event_occurrence_assignment);
  items : SET[1:?] OF event_occurrence_item;
END_ENTITY;

END_SCHEMA;  -- Event_assignment_mim


--
-- EVENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/event/mim.exp)
--
(*
 $Id: mim.exp,v 1.12 2004/10/21 17:51:16 darla Exp 
 ISO TC184/SC4/WG12 N2115 - ISO/TS 10303-1064 Event - EXPRESS MIM
*)

SCHEMA Event_mim; 

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Date_time_mim;    -- ISO/TS 10303-1010

USE FROM date_time_schema   -- ISO 10303-41
  (event_occurrence,
   event_occurrence_relationship,
   relative_event_occurrence); 

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


TYPE event_occurrence_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (event_occurrence);
END_TYPE; 

TYPE event_occurrence_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (event_occurrence);
END_TYPE; 

END_SCHEMA;  -- Event_mim



--
-- EXPERIENCE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/experience/mim.exp)
--
(*
 $Id: mim.exp,v 1.12 2004/11/19 21:37:35 robbod Exp 
 ISO TC184/SC4/WG12 N3044 - ISO/TS 10303-1243 Experience - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2382
*) 


SCHEMA Experience_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method,
   action_resource,
   executed_action); 

USE FROM Activity_as_realized_mim;    -- ISO/TS 10303-1259

USE FROM Activity_method_mim;    -- ISO/TS 10303-1049

USE FROM Activity_mim;    -- ISO/TS 10303-1047

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM experience_schema   -- ISO 10303-41
  (experience,
   experience_type,
   experience_type_relationship); 

USE FROM management_resources_schema   -- ISO 10303-41
  (experience_assignment,
   experience_type_assignment); 

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011

USE FROM person_organization_schema   -- ISO 10303-41
  (organization,
   person,
   person_and_organization); 

USE FROM process_property_schema   -- ISO 10303-49
  (action_resource_requirement); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object); 

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

USE FROM Required_resource_mim;    -- ISO/TS 10303-1267

USE FROM Resource_as_realized_mim;    -- ISO/TS 10303-1269


TYPE experience_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (applied_experience_assignment, 
    experience);
END_TYPE; 

TYPE experience_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (applied_experience_assignment, 
    experience);
END_TYPE; 

TYPE experience_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (action_actual, 
    action_resource, 
    experience_type, 
    experience_type_classification_item);
END_TYPE; 

TYPE experience_type_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (experience_type);
END_TYPE; 

TYPE experience_type_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (action_method, 
    action_resource_requirement, 
    executed_action, 
    organization, 
    person, 
    person_and_organization);
END_TYPE; 

ENTITY applied_experience_assignment
  SUBTYPE OF (experience_assignment);
  items : SET[1:?] OF experience_item;
END_ENTITY;

ENTITY applied_experience_type_assignment
  SUBTYPE OF (experience_type_assignment);
  items : SET[1:?] OF experience_type_item;
END_ENTITY;

ENTITY characterized_experience
  SUBTYPE OF (characterized_object, experience);
END_ENTITY;

END_SCHEMA;  -- Experience_mim



--
-- EXPERIENCE_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/experience_schema/experience_schema.exp)
--
(*
Id: experience_schema.exp,v 1.19 2014/03/04 00:30:35 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Experience schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Experience schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA experience_schema '{iso standard 10303 part(41) version(4) object(1) experience_schema(10)}';
  REFERENCE FROM support_resource_schema (identifier, label, text, bag_to_set);
  ENTITY experience;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY experience_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_experience : experience;
    related_experience : experience;
  END_ENTITY;

  ENTITY experience_type;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY experience_type_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_experience_type : experience_type;
    related_experience_type : experience_type;
  END_ENTITY;

  FUNCTION acyclic_experience_relationship (relation : experience_relationship; relatives : SET OF experience; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF experience_relationship;
    END_LOCAL;

    IF relation.relating_experience IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(expr <* bag_to_set(USEDIN(relation.relating_experience, 'EXPERIENCE_SCHEMA.' + 'EXPERIENCE_RELATIONSHIP.' + 'RELATED_EXPERIENCE')) | specific_relation IN TYPEOF(expr));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_experience_relationship(x[i], relatives + relation.relating_experience, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_experience_type_relationship (relation : experience_type_relationship; relatives : SET OF experience_type; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF experience_type_relationship;
    END_LOCAL;

    IF relation.relating_experience_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(exptyp <* bag_to_set(USEDIN(relation.relating_experience_type, 'EXPERIENCE_SCHEMA.' + 'EXPERIENCE_TYPE_RELATIONSHIP.' + 'RELATED_EXPERIENCE_TYPE')) | specific_relation IN TYPEOF(exptyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_experience_type_relationship(x[i], relatives + relation.relating_experience_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;


--
-- EXPRESSION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/expression/mim.exp)
--
(*
   $Id: mim.exp,v 1.25 2014/01/24 14:58:54 darla Exp 
   ISO TC184/SC4/WG12 N8414 - ISO/TS 10303-1342 Expression - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N7862
*)

SCHEMA Expression_mim;

USE FROM Generic_expression_mim;
USE FROM Numeric_expression_mim;

USE FROM iso13584_expressions_schema(
	concat_expression,
	format_function,
	index_expression,
	interval_expression,
	like_expression,
	simple_string_expression,
	SQL_mappable_defined_function,
	string_defined_function,
	string_expression,
	string_literal,
	string_variable,
	substring_expression
);
	
END_SCHEMA;


--
-- EXTENDED_DATE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/extended_date/mim.exp)
--
(*
   $Id: mim.exp,v 1.7 2012/10/11 05:49:26 liutkuviene Exp 
   ISO TC184/SC4/WG12 N8012 - ISO/TS 10303-1776 Extended date - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5369
*)
SCHEMA Extended_date_mim; 

USE FROM Date_time_mim; 

USE FROM date_time_schema -- ISO 10303-41
	(date,
	day_in_month_number,
	ordinal_date,
	week_of_year_and_day_date,
	year_month);

REFERENCE FROM date_time_schema -- ISO 10303-41
	(leap_year);

END_SCHEMA; 


--
-- EXTENDED_MEASURE_REPRESENTATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/extended_measure_representation/mim.exp)
--
(*
 $Id: mim.exp,v 1.33 2012/11/09 21:40:58 thomasrthurman Exp 
ISO TC184/SC4/WG12 N8266 - ISO/TS 10303-1106 Extended measure representation - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N5372
*) 


SCHEMA Extended_measure_representation_mim;

USE FROM Qualified_measure_mim; -- ISO/CD-TS 10303-1782

USE FROM representation_schema   -- ISO 10303-43
  (compound_item_definition,
   compound_representation_item,
   list_representation_item,
   set_representation_item); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (type_check_function); 


  ENTITY value_range
    SUBTYPE OF (compound_representation_item);
    WHERE
      WR1: ( 'REPRESENTATION_SCHEMA.'+ 'SET_REPRESENTATION_ITEM' IN TYPEOF ( item_element ) ) AND value_range_wr1 ( item_element );
      WR2: value_range_wr2 ( item_element );
      WR3: value_range_wr3 ( item_element );
  END_ENTITY;

  RULE subtype_exclusiveness_representation_item FOR 
      (representation_item);
    WHERE
      WR1: SIZEOF(QUERY (cri <* representation_item | 
      NOT (type_check_function(cri,['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
                                    'REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM',
                                    'REPRESENTATION_SCHEMA.COMPOUND_REPRESENTATION_ITEM'] , 3)))) = 0;
  END_RULE; 

  FUNCTION value_range_wr1
     (agg : compound_item_definition) : BOOLEAN; 
    BEGIN
      IF (SIZEOF(agg) = 2) AND ((SIZEOF(QUERY (i1 <* agg | (
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF
        (i1)))) = 2) OR
        (SIZEOF(QUERY (i2 <* agg | (
        'REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM' IN TYPEOF
        (i2)))) = 2)) 
      THEN
        RETURN(TRUE);
      ELSE
        RETURN(FALSE);
      END_IF;
    END;
  END_FUNCTION; 

  FUNCTION value_range_wr2
      (agg : compound_item_definition) : BOOLEAN; 
    BEGIN
      IF ((SIZEOF(QUERY (i <* agg | (i\representation_item.name = 'upper limit'))) = 1)
        AND (SIZEOF(QUERY (i <* agg | (i\representation_item.name = 'lower limit'))) = 1))
      THEN
        RETURN(TRUE);
      ELSE
        RETURN(FALSE);
      END_IF;
    END;
  END_FUNCTION; 

  FUNCTION value_range_wr3
      (agg : compound_item_definition) : BOOLEAN; 
    BEGIN
      IF (SIZEOF(QUERY(i1 <* agg |
        ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i1)) AND
        (SIZEOF (QUERY (i2 <* agg |
        ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i2)) AND
        (i1 :<>: i2) AND (i1\measure_with_unit.unit_component :=: i2\measure_with_unit.unit_component))) = 1))) = 2)
      THEN
        RETURN (TRUE);
      ELSE
        RETURN (FALSE);
      END_IF;
    END;
  END_FUNCTION; 

END_SCHEMA; 


--
-- EXTENDED_PERSON_ORGANIZATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/extended_person_organization/mim.exp)
--
(*
   ISO TC184/SC4/WG12 N11207 - ISO/TS 10303-1825 extended_person_organization - EXPRESS MIM
*)

SCHEMA Extended_person_organization_mim;

USE FROM basic_attribute_schema  -- ISO 10303-41
  (description_attribute_select,
   generic_attribute,
   generic_attribute_list_assignment,
   generic_attribute_list_select,
   generic_attribute_select,
   name_attribute,
   name_attribute_select,
   role_select);

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Description_assignment_mim;    -- ISO/TS 10303-1473

USE FROM External_item_identification_assignment_mim;    -- ISO/TS 10303-1128

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM Multi_linguism_mim;    -- ISO/TS 10303-1105

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011

USE FROM person_organization_schema  -- ISO 10303-41
(address,
   organization,
   person,
   person_and_organization);

TYPE epo_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH
  (generic_attribute);
END_TYPE;

TYPE epo_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH
  (address,
   compound_person_name,
   compound_person_name_assignment,
   generic_attribute);
END_TYPE;

TYPE epo_description_attribute_select = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON description_attribute_select WITH
  (generic_attribute);
END_TYPE;

TYPE epo_description_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON description_item WITH
  (address_component,
   compound_address);
END_TYPE;

TYPE epo_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH
  (address_component,
   compound_address);
END_TYPE;

TYPE epo_generic_attribute_list_select = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON generic_attribute_list_select WITH
  (name_attribute);
END_TYPE;

TYPE epo_generic_attribute_select = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON generic_attribute_select WITH
  (address,
   generic_attribute);
END_TYPE;

TYPE epo_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH
  (address_component,
   compound_address);
END_TYPE;

TYPE epo_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH
  (generic_attribute);
END_TYPE;

TYPE epo_name_attribute_select = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON name_attribute_select WITH
  (person);
END_TYPE;

TYPE epo_role_select = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON role_select WITH
  (generic_attribute);
END_TYPE;

ENTITY address_component
SUBTYPE OF (generic_attribute);
END_ENTITY;

ENTITY compound_address
SUBTYPE OF (address);
END_ENTITY;

ENTITY compound_person_name
SUBTYPE OF (generic_attribute_list_assignment);
END_ENTITY;

ENTITY compound_person_name_assignment
SUBTYPE OF (name_attribute);
END_ENTITY;

ENTITY person_name_component
SUBTYPE OF (generic_attribute);
END_ENTITY;

END_SCHEMA;  -- Extended_person_organization_mim



--
-- EXTERNAL_ANALYSIS_REPRESENTATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/external_analysis_representation/mim.exp)
--
(*
   $Id: mim.exp,v 1.9 2008/10/11 11:02:23 abhpf Exp 
   ISO TC184/SC4/WG12 N5861 - ISO/TS 10303-1784 External analysis representation - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4575
*)

SCHEMA External_analysis_representation_mim;

USE FROM Analysis_representation_mim;    -- ISO/CD-TS 10303-1785

USE FROM File_identification_mim;    -- ISO/TS 10303-1127

USE FROM product_property_definition_schema   -- ISO 10303-41
  (property_definition); 

USE FROM product_property_representation_schema   -- ISO 10303-41
  (property_definition_representation); 


END_SCHEMA;  -- External_analysis_representation_mim



--
-- EXTERNAL_CLASS_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/external_class/mim.exp)
--
(*
 $Id: mim.exp,v 1.17 2008/09/12 12:13:34 liutkuviene Exp 
 ISO TC184/SC4/WG12 N5375 - ISO/TS 10303-1275 External class - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4733
*)


SCHEMA External_class_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   description_attribute_select); 

USE FROM Class_mim;    -- ISO/TS 10303-1070

USE FROM External_source_mim; -- ISO/CD-TS 10303-1331

USE FROM classification_schema   -- ISO 10303-54
  (class); 

USE FROM external_reference_schema   -- ISO 10303-41
  (external_source,
   externally_defined_item); 

USE FROM Name_assignment_mim;    -- ISO/TS 10303-1340


  TYPE external_class_name_item = SELECT BASED_ON name_item WITH 
    (external_class_library);
  END_TYPE; 

  ENTITY external_class_library
    SUBTYPE OF (external_source);
  END_ENTITY;

  ENTITY externally_defined_class
    SUBTYPE OF (class, externally_defined_item);
  END_ENTITY;

END_SCHEMA;




--
-- EXTERNAL_ITEM_IDENTIFICATION_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/external_item_identification_assignment/mim.exp)
--
(*
 $Id: mim.exp,v 1.19 2019/05/09 18:02:10 kevin Exp 
 ISO TC184/SC4/WG12 N10280 - ISO/TS 10303-1128 External item identification assignment - EXPRESS MIM
*)


SCHEMA External_item_identification_assignment_mim;

USE FROM management_resources_schema   	-- ISO 10303-41
  (external_identification_assignment,
   external_identification_assignment_relationship); 

USE FROM support_resource_schema		-- ISO 10303-41
  (identifier);

TYPE external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT
	(applied_external_identification_assignment);
END_TYPE;

ENTITY applied_external_identification_assignment
SUBTYPE OF (external_identification_assignment);
  items : SET [1 : ?] OF external_identification_item;
END_ENTITY;

ENTITY applied_external_identification_assignment_relationship
	SUBTYPE of (external_identification_assignment_relationship);
	SELF\external_identification_assignment_relationship.related  : applied_external_identification_assignment;
	SELF\external_identification_assignment_relationship.relating : applied_external_identification_assignment;	
END_ENTITY;

END_SCHEMA;


--
-- EXTERNAL_LIBRARY_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/external_library/mim.exp)
--
(*
   $Id: mim.exp,v 1.7 2009/04/22 20:07:48 liutkuviene Exp 
   ISO TC184/SC4/WG12 N6235 - ISO/TS 10303-1778 External library - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5381
*)
SCHEMA External_library_mim;

USE FROM External_source_mim;  -- ISO/TS 10303-1331

USE FROM Plib_class_reference_mim; -- ISO/TS 10303-1291

  TYPE el_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH  
    (external_source);
  END_TYPE;

END_SCHEMA;


--
-- EXTERNAL_MODEL_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/external_model/mim.exp)
--
(*
 $Id: mim.exp,v 1.4 2012/10/06 20:09:56 liutkuviene Exp 
 ISO TC184/SC4/WG12 N7679 - ISO/TS 10303-1033 External model - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1229
*)

SCHEMA External_model_mim;
  
USE FROM Elemental_geometric_shape_mim; -- ISO 10303-1004
  
USE FROM File_identification_mim;

USE FROM product_property_definition_schema
  (property_definition);

USE FROM product_property_representation_schema
  (property_definition_representation);

END_SCHEMA;



--
-- EXTERNAL_PROPERTIES_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/external_properties/mim.exp)
--
(*
 $Id: mim.exp,v 1.26 2012/10/11 19:02:51 thomasrthurman Exp 
 ISO TC184/SC4/WG12 N8015 - ISO/TS 10303-1129 External properties - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N7440
*)

SCHEMA External_properties_mim;

USE FROM External_library_mim; -- ISO/TS 10303-1778

USE FROM Identification_assignment_mim; -- ISO/TS 10303-1021

USE FROM Independent_property_mim; -- ISO/TS 10303-1036

USE FROM Plib_class_reference_mim; -- ISO/TS 10303-1291

USE FROM external_reference_schema(
	externally_defined_item,
	externally_defined_item_with_multiple_references,
	externally_defined_item_relationship);

USE FROM support_resource_schema(
	identifier);

REFERENCE FROM management_resources_schema(identification_role); 

  TYPE external_identification_for_plib_property = SELECT BASED_ON external_identification_item WITH 
    (externally_defined_general_property);
  END_TYPE;

  ENTITY externally_defined_general_property 
    SUBTYPE OF (general_property, externally_defined_item); 
  END_ENTITY; 

  FUNCTION external_version_assignment_is_valid (aia: applied_external_identification_assignment): BOOLEAN;
    LOCAL
      item: external_identification_item;
      role: identification_role;
    END_LOCAL;
      role:= aia.role;
      IF role.name='version' THEN
        REPEAT i := LOINDEX(aia\applied_external_identification_assignment.items) TO HIINDEX(aia\applied_external_identification_assignment.items);
          item:= aia\applied_external_identification_assignment.items[i];
          IF (SIZEOF(['EXTERNAL_PROPERTIES_MIM.EXTERNALLY_DEFINED_GENERAL_PROPERTY']*TYPEOF(item))=0) THEN
            -- item invalid if item does not belong to versionable types
	        RETURN(FALSE);
          END_IF;
        END_REPEAT;
        RETURN(TRUE);
      ELSE		-- case where aia does not convey a version id
        RETURN(TRUE);
      END_IF;
  END_FUNCTION;

  RULE external_version_assignments_are_valid FOR (applied_external_identification_assignment);
    WHERE
      WR1: SIZEOF(QUERY(aia <* applied_external_identification_assignment | 
        NOT external_version_assignment_is_valid(aia)))=0;
  END_RULE;

  RULE plib_property_reference_requires_name_scope FOR (
      externally_defined_general_property);
    LOCAL
      known_sourced_properties : SET OF externally_defined_general_property;
    END_LOCAL;
      known_sourced_properties := QUERY( edc <* externally_defined_general_property | 
	    'PLIB_CLASS_REFERENCE_MIM.KNOWN_SOURCE' IN TYPEOF(edc.source) );
    WHERE
      WR1: SIZEOF ( QUERY ( edgp <* known_sourced_properties | 
        ( SIZEOF ( QUERY ( edir <* USEDIN ( edgp, 'EXTERNAL_REFERENCE_SCHEMA.EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.RELATING_ITEM' )| 
        ( edir.name =  'name scope' ) AND 
        ('EXTERNAL_CLASS_MIM.EXTERNALLY_DEFINED_CLASS' IN  TYPEOF ( edir.related_item ) ) AND 
        ( 'PLIB_CLASS_REFERENCE_MIM.KNOWN_SOURCE' IN TYPEOF ( edir.related_item.source ) ) ) ) <>1 ) ) ) =  0;
  END_RULE; 

  RULE plib_property_reference_requires_version FOR (externally_defined_general_property); 
	LOCAL
	  plib_properties : SET OF externally_defined_general_property := [];
	END_LOCAL;
	  plib_properties := QUERY ( edgp <* externally_defined_general_property | 
		( 'EXTERNAL_PROPERTIES_MIM.KNOWN_SOURCE' IN TYPEOF ( edgp.source ) ) AND
		( 'EXTERNAL_PROPERTIES_MIM.KNOWN_SOURCE' + '.NAME' = 'ISO 13584 library' ) ); --tt found real problem here
	WHERE 
	  WR1: SIZEOF( QUERY( edgp <* plib_properties | 
		(SIZEOF( QUERY( edir <* USEDIN(edgp, 'EXTERNAL_ITEM_IDENTIFICATION_ASSIGNMENT_MIM.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS') | 
		(edir.role.name = 'version') )) <> 1) )) = 0; 
  END_RULE;

END_SCHEMA;


--
-- EXTERNAL_REFERENCE_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/external_reference_schema/external_reference_schema.exp)
--
(*
Id: external_reference_schema.exp,v 1.13 2014/03/04 00:30:36 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - External reference schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - External reference schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA external_reference_schema '{iso standard 10303 part(41) version(7) object(1) external_reference_schema(11)}';

  REFERENCE FROM basic_attribute_schema (
    description_attribute, 
    description_attribute_select,
    get_description_value);
  REFERENCE FROM support_resource_schema (
    label, 
    text, 
    identifier, 
    bag_to_set);
    
  TYPE ers_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    external_source);
  END_TYPE;
    
  TYPE message = STRING;
  END_TYPE;

  TYPE source_item = SELECT (identifier, message);
  END_TYPE;

  ENTITY external_source;
    source_id : source_item;
  DERIVE
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY external_source_relationship;
    name : label;
    description : OPTIONAL text;
    relating_source : external_source;
    related_source : external_source;
  END_ENTITY;

  ENTITY externally_defined_item;
    item_id : source_item;
    source : external_source;
  END_ENTITY;

  ENTITY externally_defined_item_relationship;
    name : label;
    description : OPTIONAL text;
    relating_item : externally_defined_item;
    related_item : externally_defined_item;
  END_ENTITY;
  
  ENTITY externally_defined_item_with_multiple_references
    SUBTYPE OF (externally_defined_item);
    references : LIST[1:?] OF UNIQUE source_item;
  UNIQUE
    UR1: references;
  WHERE
    WR1: NOT(SELF\externally_defined_item.item_id IN references);
  END_ENTITY;  

  ENTITY pre_defined_item;
    name : label;
  END_ENTITY;

  FUNCTION acyclic_external_source_relationship (relation : external_source_relationship; relatives : SET [1:?] OF external_source; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF external_source_relationship;
    END_LOCAL;

    IF relation.relating_source IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(es <* bag_to_set(USEDIN(relation.relating_source, 'EXTERNAL_REFERENCE_SCHEMA.' + 'EXTERNAL_SOURCE_RELATIONSHIP.' + 'RELATED_SOURCE')) | specific_relation IN TYPEOF(es));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_external_source_relationship(x[i], relatives + relation.relating_source, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_externally_defined_item_relationship (relation : externally_defined_item_relationship; relatives : SET [1:?] OF externally_defined_item; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF externally_defined_item_relationship;
    END_LOCAL;

    IF relation.relating_item IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(edi <* bag_to_set(USEDIN(relation.relating_item, 'EXTERNAL_REFERENCE_SCHEMA.' + 'EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.' + 'RELATED_ITEM')) | specific_relation IN TYPEOF(edi));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_externally_defined_item_relationship(x[i], relatives + relation.relating_item, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;


--
-- EXTERNAL_REPRESENTATION_ITEM_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/external_representation_item/mim.exp)
--
(*
   $Id: mim.exp,v 1.6 2012/10/11 19:09:51 thomasrthurman Exp 
   ISO TC184/SC4/WG12 N7778 - ISO/TS 10303-1779 External representation item - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5384
*)

SCHEMA External_representation_item_mim;

USE FROM External_library_mim; -- ISO/TS 10303-1778

USE FROM Foundation_representation_mim; -- ISO/TS 10303-1006

  TYPE eri_external_identification = SELECT BASED_ON external_identification_item WITH 
    (externally_defined_representation_item);
  END_TYPE;

  ENTITY externally_defined_representation_item
    SUBTYPE OF (representation_item, externally_defined_item);
  END_ENTITY;

  ENTITY externally_defined_string
    SUBTYPE OF (externally_defined_representation_item);
  END_ENTITY;
  
  
  ENTITY externally_defined_representation
    SUBTYPE OF (representation, externally_defined_item);
    SELF\representation.items : SET [1:?] OF externally_defined_representation_item;
  END_ENTITY;

END_SCHEMA;


--
-- EXTERNAL_SOURCE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/external_source/mim.exp)
--
(*
   $Id: mim.exp,v 1.4 2008/09/12 12:28:23 liutkuviene Exp 
   ISO TC184/SC4/WG12 N5387 - ISO/TS 10303-1331 External source - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4744
 *)

SCHEMA External_source_mim;

USE FROM external_reference_schema;

END_SCHEMA;


--
-- EXTERNAL_UNIT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/external_unit/mim.exp)
--
(*
   $Id: mim.exp,v 1.5 2017/04/28 15:09:07 verodub Exp 
   ISO TC184/SC4/WG12 N5390 - ISO/TS 10303-1780 External unit - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4748
*)

SCHEMA External_unit_mim;

USE FROM External_library_mim; -- ISO/CD-TS 10303-1778

USE FROM Value_with_unit_mim; -- ISO/TS 10303-1054

USE FROM measure_schema;   -- ISO 10303-41


  TYPE eu_external_identification_item = SELECT BASED_ON external_identification_item WITH 
    (externally_defined_conversion_based_unit,
    externally_defined_context_dependent_unit);
  END_TYPE;

  ENTITY externally_defined_context_dependent_unit
    SUBTYPE OF (context_dependent_unit,externally_defined_item);
  END_ENTITY;

  ENTITY externally_defined_conversion_based_unit
    SUBTYPE OF (conversion_based_unit,externally_defined_item);
  END_ENTITY;

END_SCHEMA;


--
-- FEA_SCALAR_VECTOR_TENSOR_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/fea_scalar_vector_tensor_schema/fea_scalar_vector_tensor_schema.exp)
--
(*

Id: fea_scalar_vector_tensor_schema.exp,v 1.3 2015/06/29 18:54:56 dgnedwards Exp 
ISO 10303 TC184/SC4/WG12 N0550

EXPRESS Source:
ISO 10303-104 ed1 Finite element analysis - Fea scalar vector tensor schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-104 ed1 Finite element analysis - Fea scalar vector tensor schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA fea_scalar_vector_tensor_schema '{iso standard 10303 part(104) version(1) object(1) fea_scalar_vector_tensor_schema(1)}';

  REFERENCE FROM measure_schema 
      (context_dependent_measure);

  REFERENCE FROM representation_schema
      (representation_item);

TYPE angular_value = 
     context_dependent_measure;
END_TYPE;

TYPE scalar = 
     context_dependent_measure;
END_TYPE;

TYPE tensor1 = SELECT
  (tensor1_2d,
   tensor1_3d);
END_TYPE;

TYPE tensor1_2d = 
     ARRAY [1:2] OF context_dependent_measure;
END_TYPE;

TYPE tensor1_3d = 
  ARRAY [1:3] OF context_dependent_measure;
END_TYPE;

TYPE symmetric_tensor2_2d = SELECT
  (anisotropic_symmetric_tensor2_2d);
END_TYPE;

TYPE anisotropic_symmetric_tensor2_2d = 
  ARRAY [1:3] OF context_dependent_measure;
END_TYPE;

TYPE symmetric_tensor2_3d = SELECT
  (isotropic_symmetric_tensor2_3d,
   orthotropic_symmetric_tensor2_3d,
   anisotropic_symmetric_tensor2_3d);
END_TYPE;

TYPE isotropic_symmetric_tensor2_3d = 
     context_dependent_measure;
END_TYPE;

TYPE orthotropic_symmetric_tensor2_3d = 
     ARRAY [1:3] OF context_dependent_measure;
END_TYPE;

TYPE anisotropic_symmetric_tensor2_3d = 
     ARRAY [1:6] OF context_dependent_measure;
END_TYPE;

TYPE symmetric_tensor4_2d = SELECT
  (anisotropic_symmetric_tensor4_2d);
END_TYPE;

TYPE anisotropic_symmetric_tensor4_2d = 
     ARRAY [1:6] OF context_dependent_measure;
END_TYPE;

TYPE tensor_type = SELECT 
  (scalar,
   angular_value,
   tensor1_2d,
   tensor1_3d,
   anisotropic_symmetric_tensor2_2d,
   isotropic_symmetric_tensor2_3d,
   orthotropic_symmetric_tensor2_3d,
   anisotropic_symmetric_tensor2_3d,
   anisotropic_symmetric_tensor4_2d,
   anisotropic_symmetric_tensor4_3d,
   fea_isotropic_symmetric_tensor4_3d,
   fea_iso_orthotropic_symmetric_tensor4_3d,
   fea_transverse_isotropic_symmetric_tensor4_3d,
   fea_column_normalised_orthotropic_symmetric_tensor4_3d,
   fea_column_normalised_monoclinic_symmetric_tensor4_3d);
END_TYPE;

TYPE symmetric_tensor4_3d = SELECT
 (anisotropic_symmetric_tensor4_3d,
  fea_isotropic_symmetric_tensor4_3d,
  fea_iso_orthotropic_symmetric_tensor4_3d,
  fea_transverse_isotropic_symmetric_tensor4_3d,
  fea_column_normalised_orthotropic_symmetric_tensor4_3d,
  fea_column_normalised_monoclinic_symmetric_tensor4_3d);
END_TYPE;

TYPE anisotropic_symmetric_tensor4_3d = 
     ARRAY [1:21] OF context_dependent_measure;
END_TYPE;

TYPE fea_isotropic_symmetric_tensor4_3d = 
     ARRAY [1:2] OF context_dependent_measure;
END_TYPE;

TYPE fea_iso_orthotropic_symmetric_tensor4_3d = 
     ARRAY [1:3] OF context_dependent_measure;
END_TYPE;

TYPE fea_transverse_isotropic_symmetric_tensor4_3d = 
     ARRAY [1:5] OF context_dependent_measure;
END_TYPE;

TYPE fea_column_normalised_orthotropic_symmetric_tensor4_3d = 
     ARRAY [1:9] OF context_dependent_measure;
END_TYPE;

TYPE fea_column_normalised_monoclinic_symmetric_tensor4_3d = 
     ARRAY [1:13] OF context_dependent_measure;
END_TYPE;

ENTITY tensor_representation_item
  SUBTYPE OF (representation_item);
  tensor_value              : tensor_type;
END_ENTITY;

END_SCHEMA; -- fea_scalar_vector_tensor_schema


--
-- FILE_IDENTIFICATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/file_identification/mim.exp)
--
(*
Id: mim.exp,v 1.20 2019/06/10 20:32:29 kevin Exp 
ISO TC184/SC4/WG12 N10544 - ISO/TS 10303-1127 File identification - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N7112
*)

SCHEMA File_identification_mim;

USE FROM Activity_mim; -- ISO/TS 10303-1047
USE FROM document_schema   -- ISO 10303-41
  (document,
   document_type,
   document_representation_type); 

USE FROM External_item_identification_assignment_mim;    -- ISO/TS 10303-1128

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object); 

TYPE fi_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH 
     (document_type);
END_TYPE;

TYPE file_identification_item = SELECT BASED_ON identification_item WITH 
   (document_file);
END_TYPE; 

TYPE file_location_select = SELECT BASED_ON external_identification_item WITH 
   (document_file);
END_TYPE; 

ENTITY document_file
  SUBTYPE OF (document, characterized_object);
WHERE
  WR1: SELF\characterized_object.name = '';
  WR2: NOT EXISTS(SELF\characterized_object.description);
  WR3: SIZEOF(QUERY(drt <* SELF\document.representation_types | drt.name IN ['digital', 'physical'])) = 1;
END_ENTITY;

END_SCHEMA;  -- File_identification_mim


--
-- FINITE_ELEMENT_ANALYSIS_CONTROL_AND_RESULT_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/finite_element_analysis_control_and_result_schema/finite_element_analysis_control_and_result_schema.exp)
--
(*
Id: finite_element_analysis_control_and_result_schema.exp,v 1.4 2015/06/29 18:56:09 dgnedwards Exp 
ISO 10303 TC184/SC4/WG12 N0550

EXPRESS Source:
ISO 10303-104 ed1 Finite element analysis - Finite element analysis control and result schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-104 ed1 Finite element analysis - Finite element analysis control and result schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA finite_element_analysis_control_and_result_schema '{iso standard 10303 part(104) version(3) object(1) finite_element_analysis_control_and_result_schema(2)}';

  REFERENCE FROM fea_scalar_vector_tensor_schema
      (anisotropic_symmetric_tensor2_2d,
       anisotropic_symmetric_tensor2_3d,
       anisotropic_symmetric_tensor4_2d,
       isotropic_symmetric_tensor2_3d,
       orthotropic_symmetric_tensor2_3d,
       scalar,
       symmetric_tensor2_2d,
       symmetric_tensor2_3d,
       symmetric_tensor4_2d,
       tensor1,
       tensor1_2d,
       tensor1_3d);

  REFERENCE FROM geometric_model_schema 
      (solid_model);

  REFERENCE FROM geometry_schema 
      (curve,
       point,
       surface);

  REFERENCE FROM measure_schema 
      (context_dependent_measure,
       count_measure,
       length_measure,
       plane_angle_measure);

  REFERENCE FROM structural_response_representation_schema 
      (analysis_item_within_representation,
       axisymmetric_curve_2d_element_descriptor,
       axisymmetric_curve_2d_element_representation,
       axisymmetric_surface_2d_element_descriptor,
       axisymmetric_surface_2d_element_representation,
       axisymmetric_volume_2d_element_descriptor,
       axisymmetric_volume_2d_element_representation,
       curve_2d_element_coordinate_system,
       curve_2d_element_descriptor,
       curve_2d_element_group,
       curve_2d_element_representation,
       curve_3d_element_coordinate_system,
       curve_3d_element_descriptor,
       curve_3d_element_group,
       curve_3d_element_representation,
       curve_element_location,
       curve_section_element_location,
       curve_volume_element_location,
       degree_of_freedom,
       directionally_explicit_element_representation,
       element_descriptor,
       element_group,
       element_representation,
       explicit_element_representation,
       fea_axis2_placement_3d,
       fea_model,      
       node_group,
       node_representation,
       plane_curve_2d_element_descriptor,
       plane_curve_2d_element_representation,
       plane_surface_2d_element_descriptor,
       plane_surface_2d_element_representation,
       plane_volume_2d_element_descriptor,
       plane_volume_2d_element_representation,
       point_element_representation,
       substructure_element_representation,
       surface_2d_element_coordinate_system,
       surface_2d_element_descriptor,
       surface_2d_element_group,
       surface_2d_element_representation,
       surface_3d_element_coordinate_system,
       surface_3d_element_descriptor,
       surface_3d_element_group,
       surface_3d_element_representation,
       surface_element_location,
       surface_section_element_location,
       surface_volume_element_location,
       volume_2d_element_coordinate_system,
       volume_2d_element_descriptor,
       volume_2d_element_group,
       volume_2d_element_representation,
       volume_3d_element_coordinate_system,
       volume_3d_element_group,
       volume_3d_element_descriptor,
       volume_3d_element_representation,
       volume_element_location);

  REFERENCE FROM support_resource_schema 
      (identifier,
       label,
       text);

TYPE model_or_control_element = SELECT
     (element_representation,
      constraint_element);
END_TYPE;

TYPE cylindrical_harmonic_number = INTEGER;
WHERE
  WR1: SELF >= 0;
END_TYPE;

TYPE volume_3d_face = INTEGER;
WHERE
  WR1: (SELF >= 1) AND (SELF <= 6);
END_TYPE;

TYPE volume_2d_face = INTEGER;
WHERE
  WR1: (SELF >= 1) AND (SELF <= 4);
END_TYPE;

TYPE volume_3d_edge = INTEGER;
WHERE
  WR1: (SELF >= 1) AND (SELF <= 12);
END_TYPE;

TYPE volume_2d_edge = INTEGER;
WHERE
  WR1: (SELF >= 1) AND (SELF <= 4);
END_TYPE;

TYPE surface_3d_face = INTEGER;
WHERE
  WR1: (SELF >= 1) AND (SELF <= 2);
END_TYPE;

TYPE surface_3d_edge = INTEGER;
WHERE
  WR1: (SELF >= 1) AND (SELF <= 4);
END_TYPE;

TYPE surface_2d_face = INTEGER;
WHERE
  WR1: (SELF >= 1) AND (SELF <= 2);
END_TYPE;

TYPE surface_2d_edge = INTEGER;
WHERE
  WR1: (SELF >= 1) AND (SELF <= 2);
END_TYPE;

TYPE field_value = SELECT 
  (unspecified_value,
   scalar,
   tensor1_2d,
   tensor1_3d,
   anisotropic_symmetric_tensor2_2d,
   isotropic_symmetric_tensor2_3d,
   orthotropic_symmetric_tensor2_3d,
   anisotropic_symmetric_tensor2_3d);
END_TYPE;

TYPE unspecified_value = ENUMERATION OF
  (unspecified);
END_TYPE;

TYPE measure_or_unspecified_value = SELECT
  (context_dependent_measure,
   unspecified_value);
END_TYPE;

TYPE boundary_variable = SELECT
   (boundary_surface_scalar_variable,
   boundary_surface_vector_3d_variable,
   application_defined_scalar_variable,
   application_defined_vector_3d_variable);
END_TYPE;

TYPE boundary_aggregated_variable = SELECT
   (aggregated_vector_3d_variable,
   application_defined_vector_3d_variable);
END_TYPE;

TYPE volume_variable = SELECT 
  (volume_scalar_variable,
   volume_angular_variable,
   volume_vector_3d_variable,
   volume_tensor2_3d_variable,
   application_defined_scalar_variable,
   application_defined_vector_3d_variable,
   application_defined_tensor2_3d_variable);
END_TYPE;

TYPE volume_aggregated_variable = SELECT 
  (aggregated_scalar_variable,
   aggregated_angular_variable,
   aggregated_vector_3d_variable,
   aggregated_tensor2_3d_variable,
   application_defined_scalar_variable,
   application_defined_vector_3d_variable,
   application_defined_tensor2_3d_variable);
END_TYPE;

TYPE surface_element_variable = SELECT
  (volume_variable,
   surface_scalar_variable,
   surface_vector_2d_variable,
   surface_vector_3d_variable,
   surface_tensor2_2d_variable,
   application_defined_tensor2_2d_variable);
END_TYPE;

TYPE boundary_edge_variable = SELECT
   (boundary_curve_scalar_variable,
    boundary_curve_vector_3d_variable,
    application_defined_scalar_variable,
    application_defined_vector_3d_variable);
END_TYPE;

TYPE curve_element_variable = SELECT
  (volume_variable,
   curve_scalar_variable,
   curve_vector_2d_variable,
   application_defined_vector_2d_variable,
   curve_vector_3d_variable);
END_TYPE;

TYPE curve_scalar_variable = ENUMERATION OF 
     (curve_axial_force,
      curve_axial_strain,
      torque,
      curve_warping,
      bi_moment,
      twist);
END_TYPE;

TYPE surface_scalar_variable = ENUMERATION OF 
     (thickness,
      surface_thermal_gradient,
      reference_surface_thermal_gradient);
END_TYPE;

TYPE volume_scalar_variable = ENUMERATION OF 
     (temperature,
      moisture,
      reference_temperature,
      strain_energy_per_unit_volume);
END_TYPE;

TYPE boundary_curve_scalar_variable = ENUMERATION OF 
     (normal_force_per_unit_length);
END_TYPE;

TYPE boundary_surface_scalar_variable = ENUMERATION OF 
     (pressure);
END_TYPE;

TYPE aggregated_scalar_variable = ENUMERATION OF 
     (total_strain_energy,
      mass,
      volume);
END_TYPE;

TYPE volume_angular_variable = ENUMERATION OF 
     (constant_angular_acceleration,
      application_defined_angular_scalar_variable);
END_TYPE;

TYPE aggregated_angular_variable = ENUMERATION OF 
      (total_applied_moment,
       application_defined_aggregated_angular_scalar_variable);
END_TYPE;

TYPE application_defined_scalar_variable = STRING;
END_TYPE;

TYPE curve_vector_2d_variable = ENUMERATION OF 
     (curve_shear_force,
      curve_bending_moment,
      curve_element_curvature,
      curve_thermal_gradient,
      reference_curve_thermal_gradient);
END_TYPE;

TYPE surface_vector_2d_variable = ENUMERATION OF 
     (surface_out_of_plane_shear_force,
      surface_out_of_plane_shear_strain);
END_TYPE;

TYPE application_defined_vector_2d_variable = STRING;
END_TYPE;

TYPE curve_vector_3d_variable = ENUMERATION OF 
     (applied_force_per_unit_length,
      applied_moment_per_unit_length);
END_TYPE;

TYPE surface_vector_3d_variable = ENUMERATION OF 
     (applied_force_per_unit_area,
      applied_moment_per_unit_area);
END_TYPE;

TYPE volume_vector_3d_variable = ENUMERATION OF 
     (position,
      applied_force_per_unit_volume,
      applied_moment_per_unit_volume,
      displacement,
      infinitesimal_rotation,
      acceleration);
END_TYPE;

TYPE boundary_curve_vector_3d_variable = ENUMERATION OF 
     (applied_force_per_unit_length,
      applied_moment_per_unit_length);
END_TYPE;

TYPE boundary_surface_vector_3d_variable = ENUMERATION OF 
     (applied_force_per_unit_area,
      applied_moment_per_unit_area);
END_TYPE;

TYPE aggregated_vector_3d_variable = ENUMERATION OF 
     (total_applied_force,
      centre_of_mass_offset);
END_TYPE;

TYPE application_defined_vector_3d_variable = STRING;
END_TYPE;

TYPE surface_tensor2_2d_variable = ENUMERATION OF 
     (surface_membrane_force,
      surface_membrane_strain,
      surface_bending_moment,
      surface_curvature);
END_TYPE;

TYPE application_defined_tensor2_2d_variable = STRING;
END_TYPE;

TYPE volume_tensor2_3d_variable = ENUMERATION OF 
     (total_strain,
      stress);
END_TYPE;

TYPE aggregated_tensor2_3d_variable = ENUMERATION OF 
     (rotational_inertia);
END_TYPE;

TYPE application_defined_tensor2_3d_variable = STRING;
END_TYPE;

TYPE message_level = ENUMERATION OF 
     (error,
      warning,
      note);
END_TYPE;

TYPE surface_3d_state_coordinate_system = SELECT
     (fea_axis2_placement_3d,
      surface_3d_element_coordinate_system);
END_TYPE;

TYPE surface_2d_state_coordinate_system = SELECT
     (fea_axis2_placement_3d,
      surface_2d_element_coordinate_system);
END_TYPE;

TYPE curve_3d_state_coordinate_system = SELECT
     (fea_axis2_placement_3d,
      curve_3d_element_coordinate_system);
END_TYPE;

TYPE curve_2d_state_coordinate_system = SELECT
     (fea_axis2_placement_3d,
      curve_2d_element_coordinate_system);
END_TYPE;

TYPE action_type = ENUMERATION OF
     (applied_loads,
      residual_loads);
END_TYPE;

TYPE volume_3d_element_output_reference = SELECT
     (volume_3d_element_representation,
      volume_3d_element_descriptor,
      volume_3d_element_group,
      volume_3d_substructure_element_reference,
      analysis_item_within_representation);
END_TYPE;

TYPE volume_2d_element_output_reference = SELECT
     (volume_2d_element_representation,
      volume_2d_element_descriptor,
      volume_2d_element_group,
      volume_2d_substructure_element_reference,
      analysis_item_within_representation);
END_TYPE;

TYPE surface_3d_element_output_reference = SELECT
     (surface_3d_element_representation,
      surface_3d_element_descriptor,
      surface_3d_element_group,
      surface_3d_substructure_element_reference,
      analysis_item_within_representation);
END_TYPE;

TYPE surface_2d_element_output_reference = SELECT
     (surface_2d_element_representation,
      surface_2d_element_descriptor,
      surface_2d_element_group,
      surface_2d_substructure_element_reference,
      analysis_item_within_representation);
END_TYPE;

TYPE curve_3d_element_output_reference = SELECT
     (curve_3d_element_representation,
      curve_3d_element_descriptor,
      curve_3d_element_group,
      curve_3d_substructure_element_reference,
      analysis_item_within_representation);
END_TYPE;

TYPE curve_2d_element_output_reference = SELECT
     (curve_2d_element_representation,
      curve_2d_element_descriptor,
      curve_2d_element_group,
      curve_2d_substructure_element_reference,
      analysis_item_within_representation);
END_TYPE;

TYPE node_output_reference = SELECT
     (node_representation,
      node_group,
      substructure_node_reference,
      analysis_item_within_representation);
END_TYPE;

ENTITY control;                             
  model_ref                 : fea_model;
  control_id                : identifier;
  creating_software         : text;  
  description               : text;
  user_defined_control      : SET [1:?] OF text;
  intended_analysis_code    : SET [1:?] of text;
UNIQUE
  UR1: model_ref, control_id;
END_ENTITY;      

ENTITY analysis_step
  SUPERTYPE OF (ONEOF (control_analysis_step,
                       result_analysis_step));
  analysis_control          : control;
END_ENTITY;

ENTITY control_analysis_step
  SUPERTYPE OF (ONEOF(control_linear_static_analysis_step,
                control_linear_modes_and_frequencies_analysis_step))
  SUBTYPE OF (analysis_step);
  step_id                   : identifier;
  sequence                  : integer;
  initial_state             : state;
  description               : text;
UNIQUE
  UR1: SELF\analysis_step.analysis_control, sequence;
  UR2: SELF\analysis_step.analysis_control, step_id;
END_ENTITY;    

ENTITY symmetry_control
  SUPERTYPE OF (ONEOF (no_symmetry_control,
                       cylindrical_symmetry_control));
END_ENTITY;    

ENTITY no_symmetry_control
  SUBTYPE OF (symmetry_control);
END_ENTITY;    

ENTITY cylindrical_symmetry_control
  SUBTYPE OF (symmetry_control);
  harmonic                  : cylindrical_harmonic_number;
  phase                     : measure_or_unspecified_value;
END_ENTITY;    

ENTITY control_linear_static_analysis_step
  SUBTYPE OF (control_analysis_step);
  process                   : control_linear_static_load_increment_process;   
END_ENTITY;    

ENTITY control_linear_static_analysis_step_with_harmonic
  SUBTYPE OF (control_linear_static_analysis_step);
  symmetry                  : cylindrical_symmetry_control;
END_ENTITY;    

ENTITY control_linear_modes_and_frequencies_analysis_step
  SUBTYPE OF (control_analysis_step);
  process                   : control_linear_modes_and_frequencies_process;
  number_of_modes           : count_measure;
  frequency_range           : ARRAY [1:2] OF context_dependent_measure;
END_ENTITY;    

ENTITY constraint_element
  SUPERTYPE OF (ONEOF (single_point_constraint_element,
                       linear_constraint_equation_element,
                       nodal_dof_reduction,
                       point_constraint,
                       curve_constraint,
                       surface_constraint,
                       solid_constraint));
  element_id                : identifier;
  steps                     : SET [1:?] OF control_analysis_step;
END_ENTITY;                              

ENTITY single_point_constraint_element
  SUBTYPE OF (constraint_element);
  required_node             : node_output_reference;
  coordinate_system         : fea_axis2_placement_3d;  
  freedoms_and_values       : SET [1:?] OF freedom_and_coefficient;
  description               : text;
END_ENTITY;

ENTITY linear_constraint_equation_element
  SUBTYPE OF (constraint_element);
  freedoms_and_coefficients : SET [1:?] OF 
                                 linear_constraint_equation_nodal_term;
  description               : text;
END_ENTITY;

ENTITY linear_constraint_equation_nodal_term;
  node                      : node_representation;
  coordinate_system         : fea_axis2_placement_3d;
  freedom_and_coefficient_term : freedom_and_coefficient;
  dependent                 : LOGICAL;
END_ENTITY;

ENTITY freedom_and_coefficient;
  freedom                   : degree_of_freedom;
  a                         : measure_or_unspecified_value;
END_ENTITY;

ENTITY nodal_dof_reduction
  SUBTYPE OF (constraint_element);
  required_node             : node_output_reference;
  coordinate_system         : fea_axis2_placement_3d;  
  freedoms                  : SET [1:?] OF degree_of_freedom;
  description               : text;
END_ENTITY;

ENTITY point_constraint
  SUBTYPE OF (constraint_element);
  required_point            : analysis_item_within_representation;
  coordinate_system         : fea_axis2_placement_3d;
  freedoms_and_coefficients : SET [1:?] OF freedom_and_coefficient;
  description               : text;
WHERE
  WR1: ('GEOMETRY_SCHEMA.POINT' IN TYPEOF (required_point.item)) OR
       ('TOPOLOGY_SCHEMA.VERTEX_POINT' IN TYPEOF (required_point.item));
END_ENTITY;

ENTITY curve_constraint
  SUBTYPE OF (constraint_element);
  required_curve            : analysis_item_within_representation;
  coordinate_system         : fea_axis2_placement_3d;
  freedoms_and_coefficients : SET [1:?] OF freedom_and_coefficient;
  description               : text;
WHERE
  WR1: ('GEOMETRY_SCHEMA.CURVE' IN TYPEOF (required_curve.item)) OR
       ('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF (required_curve.item));
END_ENTITY;

ENTITY surface_constraint
  SUBTYPE OF (constraint_element);
  required_surface          : analysis_item_within_representation;
  coordinate_system         : fea_axis2_placement_3d;
  freedoms_and_coefficients : SET [1:?] OF freedom_and_coefficient;
  description               : text;
WHERE
  WR1: ('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF (required_surface.item)) OR
       ('TOPOLOGY_SCHEMA.FACE_SURFACE' IN TYPEOF (required_surface.item));
END_ENTITY;

ENTITY solid_constraint
  SUBTYPE OF (constraint_element);
  required_solid            : analysis_item_within_representation;
  coordinate_system         : fea_axis2_placement_3d;
  freedoms_and_coefficients : SET [1:?] OF freedom_and_coefficient;
  description               : text;
WHERE
  WR1: 'GEOMETRIC_MODEL_SCHEMA.SOLID_MODEL' IN TYPEOF (required_solid.item);
END_ENTITY;

ENTITY control_process
  SUPERTYPE OF (ONEOF (control_linear_static_load_increment_process,
                       control_linear_modes_and_frequencies_process));
  process_id                : identifier;
  description               : text;
END_ENTITY;

ENTITY control_linear_static_load_increment_process
  SUBTYPE OF (control_process);
  final_input_state         : state;
END_ENTITY;

ENTITY control_linear_modes_and_frequencies_process
  SUBTYPE OF (control_process);
  final_input_state         : state;
END_ENTITY;

ENTITY element_sequence;
  order_id                  : identifier;
  control_ref               : control;
  purpose                   : text;
  elements                  : LIST [1:?] OF model_or_control_element;
UNIQUE
  UR1: order_id, control_ref;
END_ENTITY;

ENTITY node_sequence;
  order_id                  : identifier;
  control_ref               : control;
  purpose                   : text;
  nodes                     : LIST [1:?] OF node_representation;
UNIQUE
  UR1: order_id, control_ref;
END_ENTITY;

ENTITY result;                             
  result_id                 : identifier;
  creating_software         : text;  
  description               : text;
END_ENTITY;      

ENTITY result_analysis_step
  SUPERTYPE OF (ONEOF (result_linear_static_analysis_sub_step,
                result_linear_modes_and_frequencies_analysis_sub_step))
  SUBTYPE OF (analysis_step);
  analysis_result           : result;
UNIQUE
  UR1: SELF\analysis_step.analysis_control, analysis_result;
END_ENTITY;

ENTITY result_linear_static_analysis_sub_step
  SUBTYPE OF (result_analysis_step);
  state                     : calculated_state;
END_ENTITY;

ENTITY result_linear_modes_and_frequencies_analysis_sub_step
  SUBTYPE OF (result_analysis_step);
  states                    : SET [1:?] OF calculated_state;
END_ENTITY;

ENTITY control_result_relationship;
  control                   : control_analysis_step;
  result                    : result_analysis_step;
END_ENTITY;

ENTITY state
  SUPERTYPE OF (ONEOF (specified_state,
                       calculated_state,
                       linearly_superimposed_state,
                       output_request_state));
  state_id                  : identifier;
  description               : text;
END_ENTITY;    

ENTITY state_with_harmonic
  SUBTYPE OF (state);
  symmetry                  : cylindrical_symmetry_control;
END_ENTITY;    

ENTITY specified_state
  SUBTYPE OF (state);
END_ENTITY;

ENTITY calculated_state
  SUBTYPE OF (state);
END_ENTITY;

ENTITY linearly_superimposed_state
  SUBTYPE OF (state);
INVERSE
  components                : SET [1:?] OF state_component FOR state;
END_ENTITY;

ENTITY state_component
  SUBTYPE OF (state);
  state                     : linearly_superimposed_state;
  factor                    : context_dependent_measure;
END_ENTITY;

ENTITY output_request_state
  SUBTYPE OF (state);
  steps                     : SET [1:?] OF control_analysis_step;
END_ENTITY;

ENTITY state_relationship;
  name                      : label;
  description               : text;
  relating_state            : state;
  related_state             : state;
END_ENTITY;

ENTITY state_definition
  SUPERTYPE OF (ONEOF (field_variable_definition,
                       nodal_freedom_and_value_definition,
                       element_nodal_freedom_actions,
                       point_freedom_and_value_definition,
                       curve_freedom_and_value_definition,
                       surface_freedom_and_value_definition,
                       solid_freedom_and_value_definition,
                       linear_constraint_equation_element_value,
                       single_point_constraint_element_values,
                       analysis_message));
  defined_state             : state;
END_ENTITY;

ENTITY field_variable_definition
  SUPERTYPE OF (ONEOF (field_variable_element_definition,
                       field_variable_element_group_value,
                       field_variable_whole_model_value,
                       field_variable_node_definition))
  SUBTYPE OF (state_definition);
END_ENTITY;

ENTITY field_variable_element_definition
  SUPERTYPE OF (ONEOF (volume_3d_element_field_variable_definition,
                       volume_2d_element_field_variable_definition,
                       surface_3d_element_field_variable_definition,
                       surface_2d_element_field_variable_definition,
                       curve_3d_element_field_variable_definition,
                       curve_2d_element_field_variable_definition))
  SUBTYPE OF (field_variable_definition);
END_ENTITY;

ENTITY volume_3d_element_field_variable_definition
  SUPERTYPE OF (ONEOF (
   volume_3d_element_location_point_variable_values,
   volume_3d_whole_element_variable_value,
   volume_3d_element_constant_specified_variable_value,
   volume_3d_element_nodal_specified_variable_values,
   volume_3d_element_boundary_location_point_variable_values,
   volume_3d_element_boundary_whole_face_variable_value,
   volume_3d_element_boundary_constant_specified_variable_value,
   volume_3d_element_boundary_nodal_specified_variable_values,
   volume_3d_element_boundary_edge_location_point_volume_variable_values,
   volume_3d_element_boundary_edge_whole_edge_variable_value,
   volume_3d_element_boundary_edge_constant_specified_volume_variable_value,
   volume_3d_element_boundary_edge_nodal_specified_variable_values))

  SUBTYPE OF (field_variable_element_definition);
  element                   : volume_3d_element_output_reference;
END_ENTITY;

ENTITY volume_3d_element_location_point_variable_values
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              volume_3d_element_value_and_location;
  variable                  : volume_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_value_and_location;
  simple_value              : field_value;
  location                  : volume_element_location;
  coordinate_system         : OPTIONAL volume_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY volume_3d_whole_element_variable_value
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL volume_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_constant_specified_variable_value
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_variable;
  coordinate_system         : OPTIONAL volume_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_nodal_specified_variable_values
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : volume_variable;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_boundary_location_point_variable_values
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              volume_3d_element_value_and_location;
  variable                  : boundary_variable;
  element_face              : volume_3d_face;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_boundary_whole_face_variable_value
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_face              : volume_3d_face;
  coordinate_system         : OPTIONAL volume_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_boundary_constant_specified_variable_value
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_variable;
  element_face              : volume_3d_face;
  coordinate_system         : OPTIONAL volume_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_boundary_nodal_specified_variable_values
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : boundary_variable;
  element_face              : volume_3d_face;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 volume_3d_element_boundary_edge_location_point_volume_variable_values
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              volume_3d_element_value_and_location;
  variable                  : boundary_edge_variable;
  element_edge              : volume_3d_edge;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_boundary_edge_whole_edge_variable_value
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_edge              : volume_3d_edge;
  coordinate_system         : OPTIONAL volume_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 volume_3d_element_boundary_edge_constant_specified_volume_variable_value
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_edge_variable;
  element_edge              : volume_3d_edge;
  coordinate_system         : OPTIONAL volume_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_boundary_edge_nodal_specified_variable_values
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : boundary_edge_variable;
  element_edge              : volume_3d_edge;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_field_variable_definition
  SUPERTYPE OF (ONEOF (
   volume_2d_element_location_point_variable_values,
   volume_2d_whole_element_variable_value,
   volume_2d_element_constant_specified_variable_value,
   volume_2d_element_nodal_specified_variable_values,
   volume_2d_element_boundary_location_point_variable_values,
   volume_2d_element_boundary_whole_face_variable_value,
   volume_2d_element_boundary_constant_specified_variable_value,
   volume_2d_element_boundary_nodal_specified_variable_values,
   volume_2d_element_boundary_edge_location_point_volume_variable_values,
   volume_2d_element_boundary_edge_whole_edge_variable_value,
   volume_2d_element_boundary_edge_constant_specified_volume_variable_value,
   volume_2d_element_boundary_edge_nodal_specified_variable_values))

  SUBTYPE OF (field_variable_element_definition);
  element                   : volume_2d_element_output_reference;
END_ENTITY;

ENTITY volume_2d_element_location_point_variable_values
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              volume_2d_element_value_and_location;
  variable                  : volume_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_value_and_location;
  simple_value              : field_value;
  location                  : volume_element_location;
  coordinate_system         : OPTIONAL volume_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY volume_2d_whole_element_variable_value
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL volume_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_constant_specified_variable_value
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_variable;
  coordinate_system         : OPTIONAL volume_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_nodal_specified_variable_values
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value; 
  additional_node_values    : BOOLEAN;
  variable                  : volume_variable;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_boundary_location_point_variable_values
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              volume_2d_element_value_and_location;
  variable                  : boundary_variable;
  element_face              : volume_2d_face;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_boundary_whole_face_variable_value
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_face              : volume_2d_face;
  coordinate_system         : OPTIONAL volume_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_boundary_constant_specified_variable_value
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_variable;
  element_face              : volume_2d_face;
  coordinate_system         : OPTIONAL volume_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_boundary_nodal_specified_variable_values
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  variable                  : boundary_variable;
  additional_node_values    : BOOLEAN;
  element_face              : volume_2d_face;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 volume_2d_element_boundary_edge_location_point_volume_variable_values
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              volume_2d_element_value_and_location;
  variable                  : boundary_edge_variable;
  element_edge              : volume_2d_edge;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_boundary_edge_whole_edge_variable_value
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_edge              : volume_2d_edge;
  coordinate_system         : OPTIONAL volume_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 volume_2d_element_boundary_edge_constant_specified_volume_variable_value
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_edge_variable;
  element_edge              : volume_2d_edge;
  coordinate_system         : OPTIONAL volume_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_boundary_edge_nodal_specified_variable_values
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : boundary_edge_variable;
  element_edge              : volume_2d_edge;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_field_variable_definition
  SUPERTYPE OF (ONEOF (
  surface_3d_element_location_point_volume_variable_values,
  surface_3d_element_location_point_variable_values,
  surface_3d_whole_element_variable_value,
  surface_3d_element_constant_specified_variable_value,
  surface_3d_element_constant_specified_volume_variable_value,
  surface_3d_element_nodal_specified_variable_values,
  surface_3d_element_boundary_location_point_surface_variable_values,
  surface_3d_element_boundary_whole_face_variable_value,
  surface_3d_element_boundary_constant_specified_variable_value,
  surface_3d_element_boundary_constant_specified_surface_variable_value,
  surface_3d_element_boundary_nodal_specified_variable_values,
  surface_3d_element_boundary_edge_location_point_surface_variable_values,
  surface_3d_element_boundary_edge_location_point_variable_values,
  surface_3d_element_boundary_edge_whole_edge_variable_value,
  surface_3d_element_boundary_edge_constant_specified_variable_value,
  surface_3d_element_boundary_edge_constant_specified_surface_variable_value,
  surface_3d_element_boundary_edge_nodal_specified_variable_values))

  SUBTYPE OF (field_variable_element_definition);
  element                   : surface_3d_element_output_reference;
END_ENTITY;

ENTITY surface_3d_element_location_point_volume_variable_values
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_3d_element_value_and_volume_location;
  variable                  : volume_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));

END_ENTITY;

ENTITY surface_3d_element_value_and_location;
  simple_value              : field_value;
  location                  : surface_element_location;
  coordinate_system         : OPTIONAL surface_3d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY surface_3d_element_value_and_volume_location;
  simple_value              : field_value;
  location                  : surface_volume_element_location;
  coordinate_system         : OPTIONAL surface_3d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY surface_3d_element_location_point_variable_values
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_3d_element_value_and_location;
  variable                  : surface_element_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_whole_element_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_constant_specified_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : surface_element_variable;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_constant_specified_volume_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_variable;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_nodal_specified_variable_values
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : surface_element_variable;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_3d_element_boundary_location_point_surface_variable_values
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_3d_element_value_and_location;
  variable                  : boundary_variable;
  element_face              : surface_3d_face;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_boundary_whole_face_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_face              : surface_3d_face;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_3d_element_boundary_constant_specified_surface_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_variable;
  element_face              : surface_3d_face;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_boundary_constant_specified_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_face              : surface_3d_face;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_boundary_nodal_specified_variable_values
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : boundary_variable;
  element_face              : surface_3d_face;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_3d_element_boundary_edge_location_point_surface_variable_values
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_3d_element_value_and_volume_location;
  variable                  : boundary_edge_variable;
  element_edge              : surface_3d_edge;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_3d_element_boundary_edge_location_point_variable_values
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_3d_element_value_and_location;
  variable                  : boundary_edge_variable;
  element_edge              : surface_3d_edge;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_boundary_edge_whole_edge_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_edge              : surface_3d_edge;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_3d_element_boundary_edge_constant_specified_surface_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_edge_variable;
  element_edge              : surface_3d_edge;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_boundary_edge_constant_specified_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_edge_variable;
  element_edge              : surface_3d_edge;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_boundary_edge_nodal_specified_variable_values
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : boundary_edge_variable;
  element_edge              : surface_3d_edge;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_field_variable_definition
  SUPERTYPE OF (ONEOF (
  surface_2d_element_location_point_volume_variable_values,
  surface_2d_element_location_point_variable_values,
  surface_2d_whole_element_variable_value,
  surface_2d_element_constant_specified_variable_value,
  surface_2d_element_constant_specified_volume_variable_value,
  surface_2d_element_nodal_specified_variable_values,
  surface_2d_element_boundary_location_point_surface_variable_values,
  surface_2d_element_boundary_whole_face_variable_value,
  surface_2d_element_boundary_constant_specified_variable_value,
  surface_2d_element_boundary_constant_specified_surface_variable_value,
  surface_2d_element_boundary_nodal_specified_variable_values,
  surface_2d_element_boundary_edge_location_point_surface_variable_values,
  surface_2d_element_boundary_edge_location_point_variable_values,
  surface_2d_element_boundary_edge_whole_edge_variable_value,
  surface_2d_element_boundary_edge_constant_specified_variable_value,
  surface_2d_element_boundary_edge_constant_specified_surface_variable_value,
  surface_2d_element_boundary_edge_nodal_specified_variable_values))

  SUBTYPE OF (field_variable_element_definition);
  element                   : surface_2d_element_output_reference;
END_ENTITY;

ENTITY surface_2d_element_location_point_volume_variable_values
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_2d_element_value_and_volume_location;
  variable                  : volume_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_value_and_location;
  simple_value              : field_value;
  location                  : surface_element_location;
  coordinate_system         : OPTIONAL surface_2d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY surface_2d_element_value_and_volume_location;
  simple_value              : field_value;
  location                  : surface_volume_element_location;
  coordinate_system         : OPTIONAL surface_2d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY surface_2d_element_location_point_variable_values
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_2d_element_value_and_location;
  variable                  : surface_element_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_whole_element_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_constant_specified_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : surface_element_variable;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_constant_specified_volume_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_variable;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_nodal_specified_variable_values
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : surface_element_variable;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_2d_element_boundary_location_point_surface_variable_values
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_2d_element_value_and_location;
  variable                  : boundary_variable;
  element_face              : surface_2d_face;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_boundary_whole_face_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_face              : surface_2d_face;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_2d_element_boundary_constant_specified_surface_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_variable;
  element_face              : surface_2d_face;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_boundary_constant_specified_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_face              : surface_2d_face;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_boundary_nodal_specified_variable_values
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : boundary_variable;
  element_face              : surface_2d_face;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_2d_element_boundary_edge_location_point_surface_variable_values
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_2d_element_value_and_volume_location;
  variable                  : boundary_edge_variable;
  element_edge              : surface_2d_edge;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_2d_element_boundary_edge_location_point_variable_values
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_2d_element_value_and_location;
  variable                  : boundary_edge_variable;
  element_edge              : surface_2d_edge;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_boundary_edge_whole_edge_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_edge              : surface_2d_edge;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_2d_element_boundary_edge_constant_specified_surface_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_edge_variable;
  element_edge              : surface_2d_edge;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_boundary_edge_constant_specified_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_edge_variable;
  element_edge              : surface_2d_edge;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_boundary_edge_nodal_specified_variable_values
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : boundary_edge_variable;
  element_edge              : surface_2d_edge;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_3d_element_field_variable_definition
  SUPERTYPE OF (ONEOF (
            curve_3d_element_location_point_volume_variable_values,
            curve_3d_element_location_point_variable_values,
            curve_3d_whole_element_variable_value,
            curve_3d_element_constant_specified_variable_value,
            curve_3d_element_constant_specified_volume_variable_value,
            curve_3d_element_nodal_specified_variable_values))

  SUBTYPE OF (field_variable_element_definition);
  element                   : curve_3d_element_output_reference;
END_ENTITY;

ENTITY curve_3d_element_location_point_volume_variable_values
  SUBTYPE OF (curve_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              curve_3d_element_value_and_volume_location;
  variable                  : volume_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_3d_element_value_and_location;
  simple_value              : field_value;
  location                  : curve_element_location;
  coordinate_system         : OPTIONAL curve_3d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY curve_3d_element_value_and_volume_location;
  simple_value              : field_value;
  location                  : curve_volume_element_location;
  coordinate_system         : OPTIONAL curve_3d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY curve_3d_element_location_point_variable_values
  SUBTYPE OF (curve_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              curve_3d_element_value_and_location;
  variable                  : curve_element_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_3d_whole_element_variable_value
  SUBTYPE OF (curve_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL curve_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_3d_element_constant_specified_variable_value
  SUBTYPE OF (curve_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : curve_element_variable;
  coordinate_system         : OPTIONAL curve_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_3d_element_constant_specified_volume_variable_value
  SUBTYPE OF (curve_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_variable;
  coordinate_system         : OPTIONAL curve_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_3d_element_nodal_specified_variable_values
  SUBTYPE OF (curve_3d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : curve_element_variable;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_2d_element_field_variable_definition
  SUPERTYPE OF (ONEOF (
            curve_2d_element_location_point_volume_variable_values,
            curve_2d_element_location_point_variable_values,
            curve_2d_whole_element_variable_value,
            curve_2d_element_constant_specified_variable_value,
            curve_2d_element_constant_specified_volume_variable_value))
  SUBTYPE OF (field_variable_element_definition);
  element                   : curve_2d_element_output_reference;
END_ENTITY;

ENTITY curve_2d_element_location_point_volume_variable_values
  SUBTYPE OF (curve_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              curve_2d_element_value_and_volume_location;
  variable                  : curve_element_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_2d_element_value_and_location;
  simple_value              : field_value;
  location                  : curve_section_element_location;
  coordinate_system         : OPTIONAL curve_2d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY curve_2d_element_value_and_volume_location;
  simple_value              : field_value;
  location                  : curve_volume_element_location;
  coordinate_system         : OPTIONAL curve_2d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY curve_2d_element_location_point_variable_values
  SUBTYPE OF (curve_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              curve_2d_element_value_and_location;
  variable                  : curve_element_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_2d_whole_element_variable_value
  SUBTYPE OF (curve_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL curve_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_2d_element_constant_specified_variable_value
  SUBTYPE OF (curve_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : surface_element_variable;
  coordinate_system         : OPTIONAL curve_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_2d_element_constant_specified_volume_variable_value
  SUBTYPE OF (curve_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_variable;
  coordinate_system         : OPTIONAL curve_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY field_variable_element_group_value
  SUBTYPE OF (field_variable_definition);
  group                     : element_group;
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL fea_axis2_placement_3d;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY field_variable_whole_model_value
  SUBTYPE OF (field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL fea_axis2_placement_3d;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY field_variable_node_definition
  SUPERTYPE OF (ONEOF (volume_3d_node_field_variable_definition,
                       volume_2d_node_field_variable_definition,
                       surface_3d_node_field_variable_definition,
                       surface_2d_node_field_variable_definition,
                       curve_3d_node_field_variable_definition,
                       curve_2d_node_field_variable_definition))
  SUBTYPE OF (field_variable_definition);
  node                      : node_output_reference;
  group                     : OPTIONAL element_group;
END_ENTITY;

ENTITY volume_3d_node_field_variable_definition
  SUBTYPE OF (field_variable_node_definition);
  simple_value              : field_value;
  variable                  : volume_variable;
  coordinate_system         : OPTIONAL volume_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_node_field_variable_definition
  SUBTYPE OF (field_variable_node_definition);
  simple_value              : field_value;
  variable                  : volume_variable;
  coordinate_system         : OPTIONAL volume_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_node_field_variable_definition
  SUPERTYPE OF (ONEOF (
            surface_3d_node_field_section_variable_values,
            surface_3d_node_field_aggregated_variable_values))
  SUBTYPE OF (field_variable_node_definition);
END_ENTITY;

ENTITY surface_3d_node_field_section_variable_values
  SUBTYPE OF (surface_3d_node_field_variable_definition);
  simple_value              : field_value;
  variable                  : surface_element_variable;
  location                  : surface_section_element_location;
  coordinate_system         : OPTIONAL surface_3d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_node_field_aggregated_variable_values
  SUBTYPE OF (surface_3d_node_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL surface_3d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_node_field_variable_definition
  SUPERTYPE OF (ONEOF (
            surface_2d_node_field_section_variable_values,
            surface_2d_node_field_aggregated_variable_values))
  SUBTYPE OF (field_variable_node_definition);
END_ENTITY;

ENTITY surface_2d_node_field_section_variable_values
  SUBTYPE OF (surface_2d_node_field_variable_definition);
  simple_value              : field_value;
  variable                  : surface_element_variable;
  location                  : surface_section_element_location;
  coordinate_system         : OPTIONAL surface_2d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_node_field_aggregated_variable_values
  SUBTYPE OF (surface_2d_node_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL surface_2d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_3d_node_field_variable_definition
  SUPERTYPE OF (ONEOF (
            curve_3d_node_field_section_variable_values,
            curve_3d_node_field_aggregated_variable_values))
  SUBTYPE OF (field_variable_node_definition);
END_ENTITY;

ENTITY curve_3d_node_field_section_variable_values
  SUBTYPE OF (curve_3d_node_field_variable_definition);
  simple_value              : field_value;
  variable                  : curve_element_variable;
  location                  : curve_section_element_location;
  coordinate_system         : OPTIONAL curve_3d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_3d_node_field_aggregated_variable_values
  SUBTYPE OF (curve_3d_node_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL curve_3d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_2d_node_field_variable_definition
  SUPERTYPE OF (ONEOF (
            curve_2d_node_field_section_variable_values,
            curve_2d_node_field_aggregated_variable_values))
  SUBTYPE OF (field_variable_node_definition);
END_ENTITY;

ENTITY curve_2d_node_field_section_variable_values
  SUBTYPE OF (curve_2d_node_field_variable_definition);
  simple_value              : field_value;
  variable                  : curve_element_variable;
  location                  : curve_section_element_location;
  coordinate_system         : OPTIONAL curve_2d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_2d_node_field_aggregated_variable_values
  SUBTYPE OF (curve_2d_node_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL curve_2d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY nodal_freedom_and_value_definition
  SUPERTYPE OF (ONEOF (nodal_freedom_values,
                       nodal_freedom_action_definition))
  SUBTYPE OF (state_definition);
  node                      : node_output_reference;    
  coordinate_system         : fea_axis2_placement_3d;
  degrees_of_freedom        : freedoms_list;
  values                    : LIST [1:?] OF measure_or_unspecified_value;
WHERE
  WR1: SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
END_ENTITY;

ENTITY nodal_freedom_values
  SUBTYPE OF (nodal_freedom_and_value_definition);
END_ENTITY;

ENTITY nodal_freedom_action_definition
  SUBTYPE OF (nodal_freedom_and_value_definition);
  action                    : action_type;
END_ENTITY;

ENTITY element_nodal_freedom_actions
  SUBTYPE OF (state_definition);
  element                   : model_or_control_element;
  nodal_action              : LIST [1:?] OF 
                                 element_nodal_freedom_terms;
END_ENTITY;

ENTITY element_nodal_freedom_terms;
  coordinate_system         : fea_axis2_placement_3d;
  degrees_of_freedom        : freedoms_list;
  values                    : LIST [1:?] OF measure_or_unspecified_value;
WHERE
  WR1: SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
END_ENTITY;

ENTITY point_freedom_and_value_definition
  SUPERTYPE OF (ONEOF (point_freedom_values,
                       point_freedom_action_definition))
  SUBTYPE OF (state_definition);
  required_point            : analysis_item_within_representation;
  coordinate_system         : fea_axis2_placement_3d;
  degrees_of_freedom        : freedoms_list;
  values                    : LIST [1:?] OF measure_or_unspecified_value;
WHERE
  WR1: SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
  WR2: ('GEOMETRY_SCHEMA.POINT' IN TYPEOF (required_point.item)) OR
       ('TOPOLOGY_SCHEMA.VERTEX_POINT' IN TYPEOF (required_point.item));
END_ENTITY;

ENTITY point_freedom_values
  SUBTYPE OF (point_freedom_and_value_definition);
END_ENTITY;

ENTITY point_freedom_action_definition
  SUBTYPE OF (point_freedom_and_value_definition);
  action                    : action_type;
END_ENTITY;

ENTITY curve_freedom_and_value_definition
  SUPERTYPE OF (ONEOF (curve_freedom_values,
                       curve_freedom_action_definition))
  SUBTYPE OF (state_definition);
  required_curve            : analysis_item_within_representation;
  coordinate_system         : fea_axis2_placement_3d;
  degrees_of_freedom        : freedoms_list;
  values                    : LIST [1:?] OF measure_or_unspecified_value;
WHERE
  WR1: SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
  WR2: ('GEOMETRY_SCHEMA.CURVE' IN TYPEOF (required_curve.item)) OR
       ('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF (required_curve.item));
END_ENTITY;

ENTITY curve_freedom_values
  SUBTYPE OF (curve_freedom_and_value_definition);
END_ENTITY;

ENTITY curve_freedom_action_definition
  SUBTYPE OF (curve_freedom_and_value_definition);
  action                    : action_type;
END_ENTITY;

ENTITY surface_freedom_and_value_definition
  SUPERTYPE OF (ONEOF (surface_freedom_values,
                       surface_freedom_action_definition))
  SUBTYPE OF (state_definition);
  required_surface          : analysis_item_within_representation;
  coordinate_system         : fea_axis2_placement_3d;
  degrees_of_freedom        : freedoms_list;
  values                    : LIST [1:?] OF measure_or_unspecified_value;
WHERE
  WR1: SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
  WR2: ('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF (required_surface.item)) OR
       ('TOPOLOGY_SCHEMA.FACE_SURFACE' IN TYPEOF (required_surface.item));
END_ENTITY;

ENTITY surface_freedom_values
  SUBTYPE OF (surface_freedom_and_value_definition);
END_ENTITY;

ENTITY surface_freedom_action_definition
  SUBTYPE OF (surface_freedom_and_value_definition);
  action                    : action_type;
END_ENTITY;

ENTITY solid_freedom_and_value_definition
  SUPERTYPE OF (ONEOF (solid_freedom_values,
                       solid_freedom_action_definition))
  SUBTYPE OF (state_definition);
  required_solid            : analysis_item_within_representation;
  coordinate_system         : fea_axis2_placement_3d;
  degrees_of_freedom        : freedoms_list;
  values                    : LIST [1:?] OF measure_or_unspecified_value;
WHERE
  WR1: SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
  WR2: 'GEOMETRIC_MODEL_SCHEMA.SOLID_MODEL' IN TYPEOF (required_solid.item);
END_ENTITY;

ENTITY solid_freedom_values
  SUBTYPE OF (solid_freedom_and_value_definition);
END_ENTITY;

ENTITY solid_freedom_action_definition
  SUBTYPE OF (solid_freedom_and_value_definition);
  action                    : action_type;
END_ENTITY;

ENTITY freedoms_list;
  freedoms                  : LIST [1:?] OF degree_of_freedom;
END_ENTITY;

ENTITY linear_constraint_equation_element_value
  SUBTYPE OF (state_definition);
  element                   : linear_constraint_equation_element;
  b                         : measure_or_unspecified_value;
END_ENTITY;

ENTITY single_point_constraint_element_values
  SUBTYPE OF (state_definition);
  element                   : single_point_constraint_element;
  degrees_of_freedom        : freedoms_list;
  b                         : LIST [1:?] OF measure_or_unspecified_value;
WHERE
  WR1: SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (b);
END_ENTITY;

ENTITY analysis_message
  SUPERTYPE OF (ONEOF (whole_model_analysis_message,
                       element_analysis_message,
                       node_analysis_message,
                       element_group_analysis_message))
  SUBTYPE OF (state_definition);
  level                     : message_level;
  message_text              : text;
END_ENTITY;

ENTITY whole_model_analysis_message
  SUPERTYPE OF (whole_model_modes_and_frequencies_analysis_message)
  SUBTYPE OF (analysis_message);
END_ENTITY;

ENTITY whole_model_modes_and_frequencies_analysis_message
  SUBTYPE OF (whole_model_analysis_message);
  mode                      : count_measure;
  frequency                 : context_dependent_measure;
END_ENTITY;

ENTITY element_analysis_message
  SUBTYPE OF (analysis_message);
  element                   : element_representation;
END_ENTITY;

ENTITY node_analysis_message
  SUBTYPE OF (analysis_message);
  node                      : node_output_reference;
END_ENTITY;

ENTITY element_group_analysis_message
  SUBTYPE OF (analysis_message);
  group                     : element_group;
END_ENTITY;

ENTITY volume_3d_substructure_element_reference;
  substructure_element_ref  : substructure_element_representation;
  element_ref               : volume_3d_element_representation;
END_ENTITY;

ENTITY volume_2d_substructure_element_reference;
  substructure_element_ref  : substructure_element_representation;
  element_ref               : volume_2d_element_representation;
END_ENTITY;

ENTITY surface_3d_substructure_element_reference;
  substructure_element_ref  : substructure_element_representation;
  element_ref               : surface_3d_element_representation;
END_ENTITY;

ENTITY surface_2d_substructure_element_reference;
  substructure_element_ref  : substructure_element_representation;
  element_ref               : surface_2d_element_representation;
END_ENTITY;

ENTITY curve_3d_substructure_element_reference;
  substructure_element_ref  : substructure_element_representation;
  element_ref               : curve_3d_element_representation;
END_ENTITY;

ENTITY curve_2d_substructure_element_reference;
  substructure_element_ref  : substructure_element_representation;
  element_ref               : curve_2d_element_representation;
END_ENTITY;

ENTITY substructure_node_reference;
  substructure_element_ref  : substructure_element_representation;
  node_ref                  : node_representation;
END_ENTITY;

FUNCTION necessary_value_coordinate_system 
    (cs_value               : field_value;
     coordinate_system      : GENERIC): BOOLEAN;

    IF (SIZEOF (
        ['FEA_SCALAR_VECTOR_TENSOR_SCHEMA.TENSOR1_2D',
         'FEA_SCALAR_VECTOR_TENSOR_SCHEMA.TENSOR1_3D',
         'FEA_SCALAR_VECTOR_TENSOR_SCHEMA.SYMMETRIC_TENSOR2_2D',
         'FEA_SCALAR_VECTOR_TENSOR_SCHEMA.SYMMETRIC_TENSOR2_3D'] *
        TYPEOF (cs_value)) = 1) THEN
        IF (NOT EXISTS (coordinate_system) ) THEN
            RETURN (FALSE);
        END_IF;
    END_IF;

    RETURN (TRUE);

END_FUNCTION;

FUNCTION consistent_set_values
    (values_and_locations   : SET [1:?] OF GENERIC;
     variable               : GENERIC) : BOOLEAN;

    LOCAL
     vv_type                : STRING;
     fv_type                : SET [1:?] OF STRING;
     i                      : INTEGER;
    END_LOCAL;

    vv_type := variable_value_type (variable);

    REPEAT i := 1 TO HIINDEX (values_and_locations);

       fv_type := TYPEOF (values_and_locations[i].simple_value);

       IF NOT (('FINITE_ELEMENT_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.' +
           'UNSPECIFIED_VALUE') IN fv_type) THEN

          IF NOT (vv_type IN fv_type) THEN
             RETURN (FALSE);
          END_IF;

       END_IF;

    END_REPEAT;

    RETURN (TRUE);

END_FUNCTION;

FUNCTION consistent_list_values
    (values                 : LIST [1:?] OF field_value;
     variable               : GENERIC) : BOOLEAN;
 
    LOCAL
     vv_type                : STRING;
     fv_type                : SET [1:?] OF STRING;
     i                      : INTEGER;
    END_LOCAL;

    vv_type := variable_value_type (variable);

    REPEAT i := 1 TO HIINDEX (values);

       fv_type := TYPEOF (values[i]);

       IF NOT (('FINITE_ELEMENT_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.' +
           'UNSPECIFIED_VALUE') IN fv_type) THEN

          IF NOT (vv_type IN fv_type) THEN
             RETURN (FALSE);
          END_IF;

       END_IF;

    END_REPEAT;

    RETURN (TRUE);

END_FUNCTION;

FUNCTION consistent_value
    (c_value                : field_value;
     variable               : GENERIC) : BOOLEAN;

    LOCAL
     vv_type                : STRING;
     fv_type                : SET [1:?] OF STRING;
    END_LOCAL;

    vv_type := variable_value_type (variable);

    fv_type := TYPEOF (c_value);

    IF NOT (('FINITE_ELEMENT_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.' +
       'UNSPECIFIED_VALUE') IN fv_type) THEN

       IF NOT (vv_type IN fv_type) THEN
          RETURN (FALSE);
       END_IF;

    END_IF;

    RETURN (TRUE);

END_FUNCTION;

FUNCTION variable_value_type
    (variable               : GENERIC) : STRING;

    LOCAL
     svt                    : STRING;
     feacr                  : STRING;
     variable_typeof        : SET [1:?] OF STRING;
    END_LOCAL;
        
    svt     := 'FEA_SCALAR_VECTOR_TENSOR_SCHEMA.';
    feacr   := 'FINITE_ELEMENT_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.';
    variable_typeof := TYPEOF (variable);

    IF SIZEOF ([(feacr + 'CURVE_SCALAR_VARIABLE'),
                (feacr + 'SURFACE_SCALAR_VARIABLE'),
                (feacr + 'VOLUME_SCALAR_VARIABLE'),
                (feacr + 'BOUNDARY_CURVE_SCALAR_VARIABLE'),
                (feacr + 'BOUNDARY_SURFACE_SCALAR_VARIABLE'),
                (feacr + 'AGGREGATED_SCALAR_VARIABLE'),
                (feacr + 'VOLUME_ANGULAR_VARIABLE'),
                (feacr + 'AGGREGATED_ANGULAR_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_SCALAR_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'SCALAR');
    END_IF;

    IF SIZEOF ([(feacr + 'CURVE_VECTOR_2D_VARIABLE'),
                (feacr + 'SURFACE_VECTOR_2D_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_VECTOR_2D_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'TENSOR1_2D');
    END_IF;

    IF SIZEOF ([(feacr + 'CURVE_VECTOR_3D_VARIABLE'),
                (feacr + 'SURFACE_VECTOR_3D_VARIABLE'),
                (feacr + 'VOLUME_VECTOR_3D_VARIABLE'),
                (feacr + 'BOUNDARY_CURVE_VECTOR_3D_VARIABLE'),
                (feacr + 'BOUNDARY_SURFACE_VECTOR_3D_VARIABLE'),
                (feacr + 'AGGREGATED_VECTOR_3D_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_VECTOR_3D_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'TENSOR1_3D');
    END_IF;

    IF SIZEOF ([(feacr + 'SURFACE_TENSOR2_2D_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_TENSOR2_2D_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'SYMMETRIC_TENSOR2_2D');
    END_IF;

    IF SIZEOF ([(feacr + 'VOLUME_TENSOR2_3D_VARIABLE'),
                (feacr + 'AGGREGATED_TENSOR2_3D_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_TENSOR2_3D_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'SYMMETRIC_TENSOR2_3D');
    END_IF;

    RETURN ('NO_MATCH');

END_FUNCTION;

FUNCTION appropriate_set_value_existence
    (values_and_locations   : SET [1:?] OF GENERIC;
     type_self              : SET [1:?] OF STRING) : BOOLEAN;

    LOCAL
     i                      : INTEGER;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX (values_and_locations);
       IF NOT (appropriate_value_existence
                (values_and_locations[i].simple_value, type_self)) 
          THEN
          RETURN (FALSE);
       END_IF;
    END_REPEAT;

    RETURN (TRUE);

END_FUNCTION;

FUNCTION appropriate_list_value_existence
    (values                 : LIST [1:?] OF GENERIC;
     type_self              : SET [1:?] OF STRING) : BOOLEAN;

    LOCAL
     i                      : INTEGER;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX (values);
       IF NOT (appropriate_value_existence (values[i], type_self)) THEN
          RETURN (FALSE);
       END_IF;
    END_REPEAT;

    RETURN (TRUE);

END_FUNCTION;

FUNCTION appropriate_value_existence
    (a_value_e              : GENERIC;
     type_self              : SET [1:?] OF STRING) : BOOLEAN;

    LOCAL
     feacr                  : STRING;
     value_typeof           : SET [1:?] OF STRING;
    END_LOCAL;
        
    feacr := 'FINITE_ELEMENT_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.';
    value_typeof := TYPEOF(a_value_e);

    IF (((feacr + 'OUTPUT_REQUEST_STATE') IN type_self) AND
       NOT ((feacr + 'UNSPECIFIED_VALUE') IN value_typeof)) THEN
       RETURN (FALSE);
    END_IF;

    RETURN (TRUE);

END_FUNCTION;

END_SCHEMA; -- finite_element_analysis_control_and_result_schema


--
-- FOUNDATION_REPRESENTATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/foundation_representation/mim.exp)
--
(* 
Id: mim.exp,v 1.25 2020/08/04 12:53:08 kevin Exp $ 
ISO TC184/SC4/WG12 N10673 - ISO/TS 10303-1006 Foundation representation - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N10390
*) 


SCHEMA Foundation_representation_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   description_attribute_select,
   id_attribute,
   id_attribute_select); 

USE FROM measure_schema   -- ISO 10303-41
  (global_unit_assigned_context); 

USE FROM qualified_measure_schema   -- ISO 10303-45
  (descriptive_representation_item); 

USE FROM representation_schema   -- ISO 10303-43
  (global_uncertainty_assigned_context,
   representation,
   representation_context,
   representation_context_reference,
   representation_reference,
   representation_item,
   representation_item_relationship,
   representation_relationship,
   rs_description_attribute_select,
   rs_id_attribute_select,
   uncertainty_measure_with_unit);
  
USE FROM Support_resource_mim;   -- ISO/TS 10303-1800

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


END_SCHEMA;  -- Foundation_representation_mim


--
-- FOUNDATION_STATE_DEFINITION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/foundation_state_definition/mim.exp)
--
(*
   $Id: mim.exp,v 1.11 2008/10/11 11:05:01 abhpf Exp 
   ISO TC184/SC4/WG12 N5870 - ISO/TS 10303-1469 Foundation state definition - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4584
*) 

SCHEMA Foundation_state_definition_mim;

USE FROM state_type_schema   -- ISO 10303-56
  (state_type,
   state_type_assignment,
   state_type_relationship); 


TYPE state_type_of_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_state_type_assignment
  SUBTYPE OF (state_type_assignment);
  items : SET[1:?] OF state_type_of_item;
END_ENTITY;

END_SCHEMA;  -- Foundation_state_definition_mim



--
-- FUNCTIONAL_BREAKDOWN_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/functional_breakdown/mim.exp)
--
(*
 $Id: mim.exp,v 1.13 2008/09/12 12:36:40 liutkuviene Exp 
 ISO TC184/SC4/WG12 N5396 - ISO/TS 10303-1216 Functional breakdown - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4938
*) 

SCHEMA Functional_breakdown_mim;

USE FROM Product_breakdown_mim;    -- ISO/TS 10303-1248

  ENTITY functional_breakdown_context
    SUBTYPE OF (breakdown_context);
  END_ENTITY;

  ENTITY functional_element_usage
    SUBTYPE OF (breakdown_element_usage);
  END_ENTITY;

END_SCHEMA;



--
-- GENERIC_EXPRESSION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/generic_expression/mim.exp)
--
(* 
 $Id: mim.exp,v 1.23 2012/10/11 05:49:08 liutkuviene Exp 
 ISO TC184/SC4/WG12 N7865 - ISO/TS 10303-1341 Generic expression - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N7218
*)

SCHEMA Generic_expression_mim;

USE FROM iso13584_generic_expressions_schema(
	binary_generic_expression,
	environment,
	generic_expression,
	generic_literal,
	generic_variable,
	multiple_arity_generic_expression,
	simple_generic_expression,
	unary_generic_expression,
	variable_semantics
	);
	
USE FROM iso13584_expressions_schema(
	variable);

END_SCHEMA;


--
-- GEOMETRIC_MODEL_RELATIONSHIP_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/geometric_model_relationship/mim.exp)
--
(*
   $Id: mim.exp,v 1.7 2012/10/11 05:49:26 liutkuviene Exp 
   ISO TC184/SC4/WG12 N8024 - ISO/TS 10303-1403 Geometric model relationship - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6906
*)   
SCHEMA Geometric_model_relationship_mim;

USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

USE FROM representation_schema(
  definitional_representation_relationship
);

USE FROM product_property_representation_schema -- ISO 10303-41
  (shape_representation_relationship);


END_SCHEMA;


--
-- GEOMETRIC_MODEL_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/geometric_model_schema/geometric_model_schema.exp)
--
(* 
ISO 10303 TC184/SC4/WG12 N11366
EXPRESS Source:
ISO 10303-42 ed8 Geometric and topological representation - Geometric model schema
The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:
Copyright ISO 2024  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:
THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.
In addition, any modified copy of the Schema shall include the following notice:
THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-42 ed8 Geometric and topological representation - Geometric model schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)
SCHEMA geometric_model_schema  '{iso standard 10303 part(42) version(11) object(1) geometric_model_schema(3)}';
REFERENCE FROM geometry_schema;    -- ISO 10303-42
REFERENCE FROM topology_schema;    -- ISO 10303-42
REFERENCE FROM measure_schema   -- ISO 10303-41
  (global_unit_assigned_context,
   length_measure,
   parameter_value,
   plane_angle_measure,
   plane_angle_unit,
   positive_length_measure,
   positive_plane_angle_measure,
   ratio_measure);
REFERENCE FROM representation_schema   -- ISO 10303-43
  (founded_item,
   get_representations_for_items,
   mapped_item,
   representation,
   representation_item,
   using_representations);
REFERENCE FROM product_property_representation_schema   -- ISO 10303-41
  (shape_representation);

TYPE angular_deviation = positive_plane_angle_measure;
END_TYPE;

TYPE boolean_operand = SELECT
   (boolean_result, 
    csg_primitive, 
    half_space_2d, 
    half_space_solid, 
    solid_model);
END_TYPE;

TYPE boolean_operator = ENUMERATION OF 
   (union,
    intersection,
    difference);
END_TYPE;

TYPE bounded_primitive_2d = EXTENSIBLE GENERIC_ENTITY SELECT
   (area_with_outer_boundary, 
    circular_area, 
    elliptic_area, 
    polygonal_area, 
    rectangular_area);
END_TYPE;

TYPE chordal_deviation = positive_length_measure;
END_TYPE;

TYPE csg_primitive = SELECT
   (block, 
    bounded_primitive_2d, 
    cyclide_segment_solid, 
    eccentric_cone, 
    ellipsoid, 
    faceted_primitive, 
    rectangular_pyramid, 
    right_angular_wedge, 
    right_circular_cone, 
    right_circular_cylinder, 
    sphere, 
    torus);
END_TYPE;

TYPE csg_select = SELECT
   (boolean_result, 
    csg_primitive);
END_TYPE;

TYPE edge_or_curve = SELECT
   (curve,
    edge_curve);
END_TYPE;

TYPE face_or_surface = SELECT
   (face_surface, 
    surface);
END_TYPE;

TYPE geometric_set_select = EXTENSIBLE GENERIC_ENTITY SELECT
  (curve,
   point,
   surface);
END_TYPE;

TYPE length_to_height_ratio =  ratio_measure;
END_TYPE;

TYPE maximum_edge_length = positive_length_measure;
END_TYPE;

TYPE path_or_composite_curve = SELECT
   (composite_curve, 
    path);
END_TYPE;

TYPE surface_model = SELECT
   (face_based_surface_model, 
    shell_based_surface_model);
END_TYPE;

TYPE tessellated_facet_long_short_edge_ratio = ratio_measure;
END_TYPE;

TYPE tessellated_edge_or_vertex = SELECT
   (tessellated_edge, 
    tessellated_vertex);
END_TYPE;

TYPE tessellation_accuracy_parameter_item = 
    EXTENSIBLE SELECT(angular_deviation,
                      chordal_deviation,
                      length_to_height_ratio,
                      maximum_edge_length,
                      tessellated_facet_long_short_edge_ratio);
END_TYPE;

TYPE wireframe_model = SELECT
   (edge_based_wireframe_model, 
    shell_based_wireframe_model);
END_TYPE;

ENTITY solid_model
  SUPERTYPE OF (ONEOF (csg_solid,
                       manifold_solid_brep,
                       swept_face_solid,
                       swept_area_solid,
                       swept_disk_solid,
                       solid_replica,
                       brep_2d,
                       trimmed_volume))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY manifold_solid_brep
  SUBTYPE OF (solid_model);
  outer : closed_shell;
--IP1:
--IP2:
--IP3:
--IP4:
--IP5:
--IP6:
--IP7:
--IP8:
--IP9:
--IP10:
--IP11:
--IP12:
END_ENTITY;

TYPE advanced_brep_shape_representation_items_select = SELECT (
            manifold_solid_brep,
            mapped_item,
            axis2_placement_3d);
END_TYPE;

ENTITY advanced_brep_shape_representation
 SUBTYPE OF ( shape_representation );
 SELF\representation.items : SET [1:?] OF advanced_brep_shape_representation_items_select;
WHERE
WR1 : SIZEOF (
QUERY ( it <* SELF.items| ( SIZEOF ([ 'GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP', 'REPRESENTATION_SCHEMA.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) > 0;
WR2 : SIZEOF (
QUERY ( msb <*
QUERY ( it <* SELF.items| ('GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF (
QUERY ( csh <* msb_shells(msb)| NOT ( SIZEOF (
QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT ('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fcs)) )) = 0) )) = 0) )) = 0;
WR3 : SIZEOF (
QUERY ( msb <*
QUERY ( it <* items| ('GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF (msb\manifold_solid_brep.outer)) )) = 0;
WR4 : SIZEOF (
QUERY ( brv <*
QUERY ( it <* items| ('GEOMETRIC_MODEL_SCHEMA.BREP_WITH_VOIDS' IN TYPEOF (it)) )| NOT ( SIZEOF (
QUERY ( csh <* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation )) = 0) )) = 0;
WR5 : SIZEOF (
QUERY ( mi <*
QUERY ( it <* items| ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('GEOMETRIC_MODEL_SCHEMA.ADVANCED_BREP_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
END_ENTITY;

TYPE faceted_brep_shape_representation_items_select = SELECT (
            faceted_brep,
            mapped_item,
            axis2_placement_3d);
END_TYPE;

ENTITY faceted_brep_shape_representation
 SUBTYPE OF ( shape_representation );
 SELF\representation.items : SET [1:?] OF faceted_brep_shape_representation_items_select;
 WHERE
   WR1 :
     SIZEOF (
     QUERY ( it <* items| ( SIZEOF ([ 'GEOMETRIC_MODEL_SCHEMA.FACETED_BREP', 'REPRESENTATION_SCHEMA.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) > 0;
   WR2 :
     SIZEOF (
     QUERY ( fbrep <*
     QUERY ( it <* items| ('GEOMETRIC_MODEL_SCHEMA.FACETED_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF (
     QUERY ( csh <* msb_shells(fbrep)| NOT ( SIZEOF (
     QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT (('TOPOLOGY_SCHEMA.FACE_SURFACE' IN TYPEOF (fcs)) AND (('GEOMETRY_SCHEMA.PLANE' IN TYPEOF (fcs\face_surface.face_geometry)) AND ('GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF (fcs\face_surface.face_geometry\elementary_surface.position.location)))) )) = 0) )) = 0) )) = 0;
   WR3 :
     SIZEOF (
     QUERY ( fbrep <*
     QUERY ( it <* items| ('GEOMETRIC_MODEL_SCHEMA.FACETED_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF (
     QUERY ( csh <* msb_shells(fbrep)| NOT ( SIZEOF (
     QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT ( SIZEOF (
     QUERY ( bnds <* fcs.bounds| ('TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF (bnds)) )) = 1) )) = 0) )) = 0) )) = 0;
   WR4 :
     SIZEOF (
     QUERY ( msb <*
     QUERY ( it <* items| ('GEOMETRIC_MODEL_SCHEMA.FACETED_BREP' IN TYPEOF (it)) )| ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF (msb\manifold_solid_brep.outer)) )) = 0;
   WR5 :
      SIZEOF (
      QUERY ( brv <*
      QUERY ( it <* items| ('GEOMETRIC_MODEL_SCHEMA.BREP_WITH_VOIDS' IN TYPEOF (it)) )| NOT ( SIZEOF (
      QUERY ( csh <* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation )) = 0) )) = 0;
      WR6 :
      SIZEOF (
      QUERY ( mi <*
      QUERY ( it <* items| ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('GEOMETRIC_MODEL_SCHEMA.FACETED_BREP_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
END_ENTITY;

ENTITY elementary_brep_shape_representation
 SUBTYPE OF (shape_representation);
 SELF\representation.items : SET [1:?] OF advanced_brep_shape_representation_items_select;
 WHERE
   WR1 : SIZEOF (QUERY (it <* SELF.items |
         SIZEOF(['GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP',
         'REPRESENTATION_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) =1 )) > 0;
   WR2 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
            NOT (SIZEOF (QUERY(fcs <* csh.cfs_faces |
              NOT('TOPOLOGY_SCHEMA.FACE_SURFACE' IN TYPEOF(fcs)))) = 0
                 ))) = 0
                   ))) = 0;
   WR3 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
            NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
              NOT(('GEOMETRY_SCHEMA.ELEMENTARY_SURFACE' IN
                   TYPEOF(fcs\face_surface.face_geometry))
             ))) = 0
                 ))) = 0
                   ))) = 0;
   WR4 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                  NOT('TOPOLOGY_SCHEMA.EDGE_CURVE' IN
            TYPEOF(oe.edge_element)))) = 0
                   ))) = 0
                 ))) = 0
               ))) = 0
             ))) = 0;
   WR5 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   NOT (SIZEOF (['GEOMETRY_SCHEMA.LINE',
                         'GEOMETRY_SCHEMA.CONIC',
                         'GEOMETRY_SCHEMA.POLYLINE'] *
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1 )
               )) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0
                    ))) = 0;
   WR6 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
            NOT(('TOPOLOGY_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.edge_start))
                AND ('TOPOLOGY_SCHEMA.VERTEX_POINT' IN
                 TYPEOF(oe.edge_end))
            ))) = 0
              ))) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0;
   WR7 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   ('GEOMETRY_SCHEMA.POLYLINE' IN
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND
            (NOT (SIZEOF (oe\oriented_edge.edge_element\
                  edge_curve.edge_geometry\polyline.points) >= 3))
               )) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0
                    ))) = 0;
   WR8 : SIZEOF (QUERY (msb <* QUERY (it <* items |
          'GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
          'TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF
              (msb\manifold_solid_brep.outer)))
             = 0;
   WR9 : SIZEOF (QUERY (brv <* QUERY (it <* items |
          'GEOMETRIC_MODEL_SCHEMA.BREP_WITH_VOIDS' IN TYPEOF(it)) |
          NOT (SIZEOF (QUERY (csh <* brv\brep_with_voids.voids |
           csh\oriented_closed_shell.orientation)) = 0))) = 0;
   WR10 : SIZEOF (QUERY (mi <*  QUERY (it <* items |
                 'REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) |
          NOT ('GEOMETRIC_MODEL_SCHEMA.ELEMENTARY_BREP_SHAPE_REPRESENTATION' IN
             TYPEOF(mi\mapped_item.mapping_source.
                           mapped_representation)))) = 0;
   WR11 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
            'GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
            NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
              NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* fcs.bounds |
         'TOPOLOGY_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)) |
           NOT(('TOPOLOGY_SCHEMA.VERTEX_POINT' IN
               TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND
                ('GEOMETRY_SCHEMA.CARTESIAN_POINT' IN
                   TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.
                     loop_vertex\vertex_point.vertex_geometry))
            ))) = 0))) = 0))) = 0))) =0;
 END_ENTITY;

----------
TYPE non_manifold_surface_shape_representation_select = SELECT (
            face_based_surface_model,
            mapped_item,
            axis2_placement_3d);
END_TYPE;

ENTITY non_manifold_surface_shape_representation 
   SUBTYPE OF (shape_representation);
  SELF\representation.items : SET [1:?] OF non_manifold_surface_shape_representation_select;
WHERE 
  WR1: SIZEOF (QUERY (it <* SELF.items |
       SIZEOF (['GEOMETRIC_MODEL_SCHEMA.FACE_BASED_SURFACE_MODEL',
       'REPRESENTATION_SCHEMA.MAPPED_ITEM'] * TYPEOF (it)) = 1)) > 0;
  WR2: SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
       'REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF (it)) |
       NOT (('GEOMETRIC_MODEL_SCHEMA.'+
       'NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION'
       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))
       AND
       (SIZEOF(QUERY (mr_it <*
       mi\mapped_item.mapping_source.mapped_representation.items |
       ('GEOMETRIC_MODEL_SCHEMA.FACE_BASED_SURFACE_MODEL'
       IN TYPEOF (mr_it)))) > 0 )))) = 0;
  WR3: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (SIZEOF (['TOPOLOGY_SCHEMA.FACE_SURFACE',
       'TOPOLOGY_SCHEMA.ORIENTED_FACE'] * TYPEOF (fa)) = 1)))
       = 0))) = 0))) = 0;
  WR4: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (f_sf <* QUERY (fa <* cfs.cfs_faces |
       ('TOPOLOGY_SCHEMA.FACE_SURFACE' IN TYPEOF (fa))) |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (f_sf))
       OR
       (nmsf_surface_check(f_sf\face_surface.face_geometry))))) = 0))) 
       = 0))) = 0;
  WR5: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (o_fa <* QUERY (fa <* cfs.cfs_faces |
       ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (fa))) |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF 
       (o_fa\oriented_face.face_element))
       OR
       (nmsf_surface_check
       (o_fa\oriented_face.face_element\face_surface.face_geometry)))))
       = 0))) = 0))) = 0;
  WR6: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (bnds <* fa.bounds |
       NOT (SIZEOF (['TOPOLOGY_SCHEMA.EDGE_LOOP',
       'TOPOLOGY_SCHEMA.VERTEX_LOOP']
       * TYPEOF (bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0;
  WR7: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items|
       'GEOMETRIC_MODEL_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF 
       (oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0;
  WR8: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe_cv <* QUERY (oe <* 
       elp_fbnds\path.edge_list |
       'TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF (oe.edge_element)) |
       NOT (SIZEOF (['GEOMETRY_SCHEMA.B_SPLINE_CURVE',
       'GEOMETRY_SCHEMA.CONIC',
       'GEOMETRY_SCHEMA.CURVE_REPLICA',
       'GEOMETRY_SCHEMA.LINE',
       'GEOMETRY_SCHEMA.OFFSET_CURVE_3D',
       'GEOMETRY_SCHEMA.PCURVE',
       'GEOMETRY_SCHEMA.POLYLINE',
       'GEOMETRY_SCHEMA.SURFACE_CURVE'] * 
       TYPEOF (oe_cv.edge_element\edge_curve.edge_geometry)) 
       = 1))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR9: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT (nmsf_curve_check (oe.edge_element\edge_curve.edge_geometry)))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR10: SIZEOF (QUERY(fbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list|
       NOT (('TOPOLOGY_SCHEMA.VERTEX_POINT' IN TYPEOF
       (oe.edge_element.edge_start))
       AND
       ('TOPOLOGY_SCHEMA.VERTEX_POINT' IN
       TYPEOF (oe.edge_element.edge_end))))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR11: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ((SIZEOF (['GEOMETRY_SCHEMA.CARTESIAN_POINT',
       'GEOMETRY_SCHEMA.DEGENERATE_PCURVE',
       'GEOMETRY_SCHEMA.POINT_ON_CURVE',
       'GEOMETRY_SCHEMA.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1)
       AND
       (SIZEOF (['GEOMETRY_SCHEMA.CARTESIAN_POINT',
       'GEOMETRY_SCHEMA.DEGENERATE_PCURVE',
       'GEOMETRY_SCHEMA.POINT_ON_CURVE',
       'GEOMETRY_SCHEMA.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1
       )))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR12: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'TOPOLOGY_SCHEMA.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT ('TOPOLOGY_SCHEMA.VERTEX_POINT' IN TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex)))) = 0)))) = 0))) 
       = 0))) = 0;
 WR13: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'TOPOLOGY_SCHEMA.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (['GEOMETRY_SCHEMA.CARTESIAN_POINT',
       'GEOMETRY_SCHEMA.DEGENERATE_PCURVE',
       'GEOMETRY_SCHEMA.POINT_ON_CURVE',
       'GEOMETRY_SCHEMA.POINT_ON_SURFACE'] * TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) 
       = 1))) = 0)))) = 0))) = 0))) = 0;

--IP1: The portion of a b_spline_curve that is within the topological domain of a non_manifold_surface_shape_representation shall not self-intersect.
--IP2: The portion of a b_spline_surface that is within the topological domain of a non_manifold_surface_shape_representation shall not self-intersect.
--IP3: The portion of an offset_curve_3d that is within the topological domain of a non_manifold_surface_shape_representation shall not self-intersect.
--IP4: The portion of an offset_surface that is within the topological domain of a non_manifold_surface_shape_representation shall not self-intersect.
--IP5: If a face has only one connected outer bound,the corresponding loop shall be represented as face_outer_bound. If the outer bound is not connected, face_outer_bound shall not be used.
END_ENTITY;

FUNCTION nmsf_curve_check (cv : representation_item) : BOOLEAN;  
 
(* This function varifies the validity of a curve in the context of a
   non-manifold surface model. Representation_items are
   valid input, however, they are supposed to be curves; otherwise
   this function will return false.
*)
 (* complex subtypes of curve that are both bounded_curve and
    oneof conic, curve_replica, line, or offset_curve_3d are not
    valid
 *)
 IF SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE',
   'GEOMETRY_SCHEMA.CONIC',
   'GEOMETRY_SCHEMA.CURVE_REPLICA',
   'GEOMETRY_SCHEMA.LINE',
   'GEOMETRY_SCHEMA.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1
 THEN RETURN(FALSE);
 ELSE
  (* b_spline_curves shall not self-intersect
   *)
  IF (('GEOMETRY_SCHEMA.B_SPLINE_CURVE' IN TYPEOF (cv)) AND
    (cv\b_spline_curve.self_intersect = FALSE) OR
    (cv\b_spline_curve.self_intersect = UNKNOWN))
  THEN RETURN(TRUE);
  ELSE
    (* conics and lines are valid curve types
     *)
    IF SIZEOF (['GEOMETRY_SCHEMA.CONIC',
    'GEOMETRY_SCHEMA.LINE'] * TYPEOF (cv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      (* a curve_replica shall reference a valid curve
       *)
      IF 'GEOMETRY_SCHEMA.CURVE_REPLICA' IN TYPEOF(cv) THEN
        RETURN (nmsf_curve_check(cv\curve_replica.parent_curve));
      ELSE 
 
        (* an offset_curve_3d shall not self-intersect and
           shall reference a valid curve; a polyline is not a
           valid basis_curve
         *)
        IF (('GEOMETRY_SCHEMA.OFFSET_CURVE_3D' IN TYPEOF (cv)) 
          AND
          ((cv\offset_curve_3d.self_intersect = FALSE) OR
          (cv\offset_curve_3d.self_intersect = UNKNOWN))
          AND
          (NOT ('GEOMETRY_SCHEMA.POLYLINE' IN TYPEOF
          (cv\offset_curve_3d.basis_curve)))) THEN
          RETURN (nmsf_curve_check(cv\offset_curve_3d.basis_curve));
        ELSE 
 
          (* a pcurve shall reference a valid curve and a valid
             basis_surface
           *)
          IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(cv) THEN 
            RETURN ((nmsf_curve_check
            (cv\pcurve.reference_to_curve\representation.items[1]))
            AND
            (nmsf_surface_check(cv\pcurve.basis_surface)));
          ELSE 
 
            (* a surface_curve references a curve_3d and one or
               two pcurves or one or two surfaces or one of
               each; all of these references shall be valid
             *)
            IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(cv) THEN 
              (* if the curve reference is correct, check also the rest
               *)
              IF nmsf_curve_check(cv\surface_curve.curve_3d) THEN
                REPEAT i := 1 TO SIZEOF
                (cv\surface_curve.associated_geometry);
                  (* do for one or two associated_geometrys:
                   *)
                  IF 'GEOMETRY_SCHEMA.SURFACE' IN 
                    TYPEOF (cv\surface_curve.associated_geometry[i]) THEN  
                    IF NOT nmsf_surface_check
                      (cv\surface_curve.associated_geometry[i]) THEN  
                      RETURN(FALSE);  
                    END_IF;  
                  ELSE  
                    IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF 
                      (cv\surface_curve.associated_geometry[i]) THEN  
                      IF NOT nmsf_curve_check
                        (cv\surface_curve.associated_geometry[i]) THEN 
                        RETURN(FALSE);  
                      END_IF;  
                    END_IF;  
                  END_IF;
                END_REPEAT;  
                RETURN(TRUE);
              END_IF;
            ELSE
              (* a polyline shall have at least 3 points 
               *)
              IF 'GEOMETRY_SCHEMA.POLYLINE' IN TYPEOF(cv) THEN
                IF (SIZEOF (cv\polyline.points) >= 3) THEN RETURN (TRUE);
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
 END_IF;
 (* FALSE is returned if the input parameter cv is not a valid curve.
  *)
 RETURN (FALSE);
END_FUNCTION;


FUNCTION nmsf_surface_check (surf : surface) : BOOLEAN;
(* This function varifies the validity of a surface in the
   context of a non-manifold surface model.
*)
  (* elementary_surfaces are valid surface types
   *)
  IF 'GEOMETRY_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
    RETURN(TRUE);
  ELSE 
    (* a swept_surface shall have a valid sweeping curve
     *)
    IF 'GEOMETRY_SCHEMA.SWEPT_SURFACE' IN TYPEOF (surf) THEN 
      RETURN (nmsf_curve_check(surf\swept_surface.swept_curve));  
    ELSE 
 
      (* an offset_surface shall not self-intersect and shall
         reference a valid surface
       *)
      IF (('GEOMETRY_SCHEMA.OFFSET_SURFACE' IN TYPEOF (surf)) AND
        (surf\offset_surface.self_intersect = FALSE) OR 
        (surf\offset_surface.self_intersect = UNKNOWN)) THEN
        RETURN (nmsf_surface_check(surf\offset_surface.basis_surface));
      ELSE 
 
        (* a surface_replica shall have a valid parent surface
         *)
        IF 'GEOMETRY_SCHEMA.SURFACE_REPLICA' IN TYPEOF(surf) THEN 
          RETURN(nmsf_surface_check(surf\surface_replica.parent_surface));
        ELSE
          (* a b_spline_surface shall not self-intersect
           *)
          IF (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF(surf))
            AND
            (surf\b_spline_surface.self_intersect = FALSE) OR
            (surf\b_spline_surface.self_intersect = UNKNOWN)) THEN
            RETURN(TRUE);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

TYPE manifold_surface_shape_representation_select = SELECT (
            shell_based_surface_model,
            mapped_item,
            axis2_placement_3d);
END_TYPE;

ENTITY manifold_surface_shape_representation 
   SUBTYPE OF (shape_representation);
  SELF\representation.items : SET [1:?] OF manifold_surface_shape_representation_select;
WHERE 
  WR1: SIZEOF (QUERY (it <* SELF.items |
       SIZEOF (['GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL',
       'REPRESENTATION_SCHEMA.MAPPED_ITEM'] * TYPEOF (it)) = 1)) > 0;
  WR2: SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
       'REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF (it)) |
       NOT (('GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SURFACE_SHAPE_REPRESENTATION'
       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))
       AND
       (SIZEOF(QUERY (mr_it <*
       mi\mapped_item.mapping_source.mapped_representation.items |
       ('GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL'
       IN TYPEOF (mr_it)))) > 0 )))) = 0;
  WR3: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (sh <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (['TOPOLOGY_SCHEMA.OPEN_SHELL',
       'TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL',
       'TOPOLOGY_SCHEMA.CLOSED_SHELL']
       * TYPEOF (sh)) = 1))) = 0))) = 0;
  WR4: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT ('TOPOLOGY_SCHEMA.FACE_SURFACE' IN TYPEOF (fa)) )) = 0)))
       = 0))) = 0;
  WR5: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (msf_surface_check(fa\face_surface.face_geometry))))) = 0))) 
       = 0))) = 0;
  WR6: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (bnds <* fa.bounds |
       NOT (SIZEOF (['TOPOLOGY_SCHEMA.EDGE_LOOP',
       'TOPOLOGY_SCHEMA.VERTEX_LOOP']
       * TYPEOF (bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0;
  WR7: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items|
       'GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF 
       (oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0;
  WR8: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe_cv <* QUERY (oe <* 
       elp_fbnds\path.edge_list |
       'TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF (oe.edge_element)) |
       NOT (SIZEOF (['GEOMETRY_SCHEMA.B_SPLINE_CURVE',
       'GEOMETRY_SCHEMA.CONIC',
       'GEOMETRY_SCHEMA.CURVE_REPLICA',
       'GEOMETRY_SCHEMA.LINE',
       'GEOMETRY_SCHEMA.OFFSET_CURVE_3D',
       'GEOMETRY_SCHEMA.PCURVE',
       'GEOMETRY_SCHEMA.POLYLINE',
       'GEOMETRY_SCHEMA.SURFACE_CURVE'] * 
       TYPEOF (oe_cv.edge_element\edge_curve.edge_geometry)) 
       = 1))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR9: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT (msf_curve_check (oe.edge_element\edge_curve.edge_geometry)))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR10: SIZEOF (QUERY(sbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list|
       NOT (('TOPOLOGY_SCHEMA.VERTEX_POINT' IN TYPEOF
       (oe.edge_element.edge_start))
       AND
       ('TOPOLOGY_SCHEMA.VERTEX_POINT' IN
       TYPEOF (oe.edge_element.edge_end))))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR11: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ((SIZEOF (['GEOMETRY_SCHEMA.CARTESIAN_POINT',
       'GEOMETRY_SCHEMA.DEGENERATE_PCURVE',
       'GEOMETRY_SCHEMA.POINT_ON_CURVE',
       'GEOMETRY_SCHEMA.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1)
       AND
       (SIZEOF (['GEOMETRY_SCHEMA.CARTESIAN_POINT',
       'GEOMETRY_SCHEMA.DEGENERATE_PCURVE',
       'GEOMETRY_SCHEMA.POINT_ON_CURVE',
       'GEOMETRY_SCHEMA.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1
       )))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR12: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'TOPOLOGY_SCHEMA.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT ('TOPOLOGY_SCHEMA.VERTEX_POINT' IN TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex)))) = 0)))) = 0))) 
       = 0))) = 0;
 WR13: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'TOPOLOGY_SCHEMA.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (['GEOMETRY_SCHEMA.CARTESIAN_POINT',
       'GEOMETRY_SCHEMA.DEGENERATE_PCURVE',
       'GEOMETRY_SCHEMA.POINT_ON_CURVE',
       'GEOMETRY_SCHEMA.POINT_ON_SURFACE'] * TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) 
       = 1))) = 0)))) = 0))) = 0))) = 0;

--IP1: The portion of a b_spline_curve that is within the topological domain of a manifold_surface_shape_representation shall not self-intersect.
--IP2: The portion of a b_spline_surface that is within the topological domain of a manifold_surface_shape_representation shall not self-intersect.
--IP3: The portion of an offset_curve_3d that is within the topological domain of a manifold_surface_shape_representation shall not self-intersect.
--IP4: The portion of an offset_surface that is within the topological domain of a manifold_surface_shape_representation shall not self-intersect.
--IP5: If a face has only one connected outer bound, the corresponding loop shall be represented as face_outer_bound. 
--IP6: If the outer bound is not connected, face_outer_bound shall not be used.
END_ENTITY;

(*
  WR1: SIZEOF (QUERY (it <* SELF.items |
       NOT (SIZEOF (['GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL',
       'REPRESENTATION_SCHEMA.MAPPED_ITEM',
       'GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1))) = 0;
*)
-----

FUNCTION msf_curve_check (cv : representation_item) : BOOLEAN;  
 
(* This function varifies the validity of a curve in the context of a
   manifold surface model. Representation_items are
   valid input, however, they are supposed to be curves; otherwise
   this function will return false.
*)
(* complex subtypes of curve that are both bounded_curve and
   oneof conic, curve_replica, line, or offset_curve_3d are not
   valid
*)
IF SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE',
  'GEOMETRY_SCHEMA.CONIC',
  'GEOMETRY_SCHEMA.CURVE_REPLICA', 'GEOMETRY_SCHEMA.LINE',
  'GEOMETRY_SCHEMA.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1 THEN
  RETURN(FALSE);
END_IF;
(* b_spline_curves shall not self-intersect
 *)
IF (('GEOMETRY_SCHEMA.B_SPLINE_CURVE' IN TYPEOF (cv)) AND
  (cv\b_spline_curve.self_intersect = FALSE)OR
  (cv\b_spline_curve.self_intersect = UNKNOWN)) THEN
  RETURN(TRUE);
ELSE
  (* conics and lines are valid curve types
   *)
  IF SIZEOF (['GEOMETRY_SCHEMA.CONIC', 'GEOMETRY_SCHEMA.LINE'] 
    * TYPEOF (cv)) = 1 THEN
    RETURN(TRUE);
  ELSE
    (* a curve_replica shall reference a valid curve
     *)
    IF 'GEOMETRY_SCHEMA.CURVE_REPLICA' IN TYPEOF(cv) THEN
      RETURN (msf_curve_check(cv\curve_replica.parent_curve));
    ELSE 
 
      (* an offset_curve_3d shall not self-intersect and
         shall reference a valid curve; a polyline is not a
         valid basis_curve
       *)
      IF (('GEOMETRY_SCHEMA.OFFSET_CURVE_3D' IN TYPEOF (cv))
        AND
        ((cv\offset_curve_3d.self_intersect = FALSE) OR
        (cv\offset_curve_3d.self_intersect = UNKNOWN))
        AND
        (NOT ('GEOMETRY_SCHEMA.POLYLINE' IN TYPEOF
        (cv\offset_curve_3d.basis_curve)))) THEN
        RETURN (msf_curve_check(cv\offset_curve_3d.basis_curve));
      ELSE 
 
        (* a pcurve shall reference a valid curve and a valid
           basis_surface
         *)
        IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(cv) THEN 
          RETURN ((msf_curve_check
          (cv\pcurve.reference_to_curve\representation.items[1])) AND
          (msf_surface_check(cv\pcurve.basis_surface)));
        ELSE 
 
          (* a surface_curve references a curve_3d and one or
             two pcurves or one or two surfaces or one of
             each; all of these references shall be valid
           *)
          IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(cv) THEN 
            (* if the curve reference is correct, check also the rest
             *)
            IF msf_curve_check(cv\surface_curve.curve_3d) THEN
              REPEAT i := 1 TO SIZEOF
              (cv\surface_curve.associated_geometry);
                (* do for one or two associated_geometrys:
                 *)
                IF 'GEOMETRY_SCHEMA.SURFACE' IN 
                  TYPEOF (cv\surface_curve.associated_geometry[i]) THEN  
                  IF NOT msf_surface_check
                    (cv\surface_curve.associated_geometry[i]) THEN  
                    RETURN(FALSE);  
                  END_IF;  
                ELSE  
                  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF 
                    (cv\surface_curve.associated_geometry[i]) THEN  
                    IF NOT msf_curve_check
                      (cv\surface_curve.associated_geometry[i]) THEN 
                      RETURN(FALSE);  
                    END_IF;  
                  END_IF;  
                END_IF;
              END_REPEAT;  
              RETURN(TRUE);
            END_IF;
          ELSE
            (* a polyline shall have at least 3 points
             *)
            IF 'GEOMETRY_SCHEMA.POLYLINE' IN TYPEOF(cv) THEN
              IF (SIZEOF (cv\polyline.points) >= 3) THEN RETURN (TRUE);
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
END_IF;
(* FALSE is returned if the input parameter cv is not a valid curve.
 *)
RETURN (FALSE);
END_FUNCTION;


FUNCTION msf_surface_check (surf : surface) : BOOLEAN;
(* This function varifies the validity of a surface in the
   context of a manifold surface model.
*)
  (* elementary_surfaces are valid surface types
   *)
  IF 'GEOMETRY_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
    RETURN(TRUE);
  ELSE 
    (* a swept_surface shall have a valid sweeping curve
     *)
    IF 'GEOMETRY_SCHEMA.SWEPT_SURFACE' IN TYPEOF (surf) THEN 
      RETURN (msf_curve_check(surf\swept_surface.swept_curve));  
    ELSE 
 
      (* an offset_surface shall not self-intersect and shall
         reference a valid surface
       *)
      IF (('GEOMETRY_SCHEMA.OFFSET_SURFACE' IN TYPEOF (surf)) AND
        (surf\offset_surface.self_intersect = FALSE) OR 
        (surf\offset_surface.self_intersect = UNKNOWN)) THEN
        RETURN (msf_surface_check(surf\offset_surface.basis_surface));
      ELSE 
 
        (* a surface_replica shall have a valid parent surface
         *)
        IF 'GEOMETRY_SCHEMA.SURFACE_REPLICA' IN TYPEOF(surf) THEN 
          RETURN(msf_surface_check(surf\surface_replica.parent_surface));
        ELSE
          (* a b_spline_surface shall not self-intersect
           *)
          IF (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF(surf)) AND
            (surf\b_spline_surface.self_intersect = FALSE) OR
            (surf\b_spline_surface.self_intersect = UNKNOWN)) THEN
            RETURN(TRUE);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

---------
TYPE manifold_subsurface_shape_representation_select = SELECT (
            connected_face_sub_set,
            mapped_item,
            axis2_placement_3d);
END_TYPE;

 ENTITY manifold_subsurface_shape_representation
 SUBTYPE OF (shape_representation);
  SELF\representation.items : SET [1:?] OF manifold_subsurface_shape_representation_select;
 WHERE
   WR1: SIZEOF (QUERY (it <* SELF.items |
         SIZEOF(['TOPOLOGY_SCHEMA.CONNECTED_FACE_SUB_SET',
         'REPRESENTATION_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) =1 )) > 0;
   WR2: SIZEOF (QUERY (mi <*  QUERY (it <* items |
                 'REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) |
   NOT ('GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION' IN
             TYPEOF(mi\mapped_item.mapping_source.
                           mapped_representation)))) = 0;
   WR3: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'TOPOLOGY_SCHEMA.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
          NOT('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(cfss)))) = 0;
   WR4: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'TOPOLOGY_SCHEMA.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
          NOT( (('TOPOLOGY_SCHEMA.CONNECTED_FACE_SUB_SET' IN
                   TYPEOF(cfss\connected_face_sub_set.parent_face_set))AND
           (SIZEOF(QUERY(fac <* cfss\connected_face_sub_set.parent_face_set\connected_face_set.cfs_faces | NOT
                 advanced_face_properties(fac))) = 0)) OR
            (SIZEOF(QUERY(fac <* cfss\connected_face_sub_set.parent_face_set\connected_face_set.cfs_faces | NOT
              ('TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF(fac)))) = 0)
                    ))) = 0;
   WR5: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'TOPOLOGY_SCHEMA.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
          ( SIZEOF (QUERY (fac <* cfss\connected_face_set.cfs_faces  | NOT
              advanced_face_properties(fac))) = 0))) = 0;
   WR6: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
          'TOPOLOGY_SCHEMA.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
               ('TOPOLOGY_SCHEMA.SUBFACE' IN TYPEOF(fcs)) AND
            NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                  NOT(('TOPOLOGY_SCHEMA.EDGE_CURVE' IN
            TYPEOF(oe.edge_element)) OR
           ('TOPOLOGY_SCHEMA.SUBEDGE' IN
            TYPEOF(oe.edge_element)) ))) = 0
                   ))) = 0
                 ))) = 0
             ))) = 0;
   WR7: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'TOPOLOGY_SCHEMA.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
           ('TOPOLOGY_SCHEMA.SUBFACE' IN TYPEOF(fcs)) AND
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
          NOT(('TOPOLOGY_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.edge_start))
                AND ('TOPOLOGY_SCHEMA.VERTEX_POINT' IN
                 TYPEOF(oe.edge_end))
            ))) = 0
              ))) = 0
               ))) = 0
                   ))) = 0;
   WR8: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'TOPOLOGY_SCHEMA.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'TOPOLOGY_SCHEMA.SUBFACE' IN TYPEOF(fcs)) AND
              ( NOT (SIZEOF(QUERY  (bnds <* fcs.bounds |
         NOT (SIZEOF (['TOPOLOGY_SCHEMA.EDGE_LOOP',
                'TOPOLOGY_SCHEMA.VERTEX_LOOP'] *
                   TYPEOF(bnds.bound)) = 1 )
                   )) = 0)
                 ))) = 0
             ))) = 0;
   WR9: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'TOPOLOGY_SCHEMA.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'TOPOLOGY_SCHEMA.SUBFACE' IN TYPEOF(fcs)) AND
              ( NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   NOT (SIZEOF (['GEOMETRY_SCHEMA.LINE',
                         'GEOMETRY_SCHEMA.CONIC',
                         'GEOMETRY_SCHEMA.POLYLINE',
                         'GEOMETRY_SCHEMA.SURFACE_CURVE',
                         'GEOMETRY_SCHEMA.B_SPLINE_CURVE' ] *
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1 )
               )) = 0
               ))) = 0
                 )))) = 0
                    ))) = 0;
   WR10: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'TOPOLOGY_SCHEMA.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'TOPOLOGY_SCHEMA.SUBFACE' IN TYPEOF(fcs)) AND
               (NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND
            (NOT ((SIZEOF (QUERY (sc_ag <*
            oe.edge_element\edge_curve.edge_geometry\
            surface_curve.associated_geometry |
            NOT ('GEOMETRY_SCHEMA.PCURVE' IN
            TYPEOF(sc_ag)))) = 0)))
               )) = 0
               ))) = 0
                   )))) = 0
                    ))) = 0;
   WR11: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'TOPOLOGY_SCHEMA.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'TOPOLOGY_SCHEMA.SUBFACE' IN TYPEOF(fcs)) AND
               (NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   ('GEOMETRY_SCHEMA.POLYLINE' IN
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND
            (NOT (SIZEOF (oe\oriented_edge.edge_element\
                  edge_curve.edge_geometry\polyline.points) >= 3))
               )) = 0
               ))) = 0
                   )))) = 0
                    ))) = 0;
END_ENTITY;

TYPE csg_shape_representation_select = SELECT (
            axis2_placement_3d,
            csg_solid,
	    extruded_face_solid,
            mapped_item,
	    revolved_face_solid,
	    solid_replica);
END_TYPE;

ENTITY csg_shape_representation
 SUBTYPE OF ( shape_representation );
  SELF\representation.items : SET [1:?] OF csg_shape_representation_select;
WHERE
  WR1 : SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
  WR2 :
    SIZEOF (
    QUERY ( mi <*
    QUERY ( it <* SELF.items| ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('GEOMETRIC_MODEL_SCHEMA.CSG_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
  WR3 :
    SIZEOF (
    QUERY ( sr <*
    QUERY ( it <* SELF.items| ('GEOMETRIC_MODEL_SCHEMA.SOLID_REPLICA' IN TYPEOF (it)) )| ( SIZEOF ([ 'GEOMETRIC_MODEL_SCHEMA.CSG_SOLID', 'GEOMETRIC_MODEL_SCHEMA.REVOLVED_FACE_SOLID', 'GEOMETRIC_MODEL_SCHEMA.EXTRUDED_FACE_SOLID' ] * TYPEOF (sr\solid_replica.parent_solid)) = 0) )) = 0;
  WR4 :
    SIZEOF (
    QUERY ( it <* SELF.items| NOT ('GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF (it)) )) > 0;
--IP1: Any instance of solid_model used directly, or indirectly, as first_operand or second_operand of a boolean_result to define a csg_solid in the items set of a csg_shape_representation shall be either of type extruded_face_solid, revolved_face_solid, manifold_solid_brep, or solid_replica. If it is of type solid_replica, its parent_solid shall be of type csg_solid, extruded_face_solid, revolved_face_solid or manifold_solid_brep.
--IP2: Any instance of manifold_solid_brep used directly, or indirectly, as first_operand or second_operand of a boolean_result to define a csg_solid occurring in a csg_shape_representation shall be compatible with either the rules defined for its use in an advanced_brep_shape_representation or, the rules defined for its use in a faceted_brep_shape_representation. In particular each face shall either be of type advanced_face or, in the case of a faceted_brep, shall be a face_surface bounded by poly_loops and with a plane as face_geometry.
END_ENTITY;

TYPE hybrid_brep_reference_shape_representation = SELECT(advanced_brep_shape_representation,
                                                         faceted_brep_shape_representation,
                                                         hybrid_brep_shape_representation,
                                                         tessellated_brep_shape_representation);
END_TYPE;

TYPE hybrid_brep_shape_assignment_select = SELECT (hybrid_brep_face_assignment,
                                                   hybrid_brep_edge_assignment,
                                                   hybrid_brep_vertex_assignment,
                                                   mapped_item);
END_TYPE;


ENTITY hybrid_brep_shape_representation
SUBTYPE OF (shape_representation);
  associated_geometric_representation : OPTIONAL SET[1:?] OF shape_representation;
  SELF\representation.items : SET[1:?] OF hybrid_brep_shape_assignment_select;
  SELF\representation.context_of_items : geometric_representation_context;
  reference_representation : hybrid_brep_reference_shape_representation;
WHERE
  WR1: context_of_items\geometric_representation_context.coordinate_space_dimension = 3.0;
  WR2: NOT(SELF IN associated_geometric_representation);
  WR3: NOT(reference_representation IN associated_geometric_representation);
  WR4: SELF :<>: reference_representation;
END_ENTITY;


TYPE hybrid_brep_point_select = SELECT(point,
                                       tessellated_vertex);
END_TYPE;


TYPE hybrid_brep_vertex_select = SELECT(vertex_point,
                                        tessellated_vertex_point);
END_TYPE;


ENTITY hybrid_brep_vertex_assignment
  SUBTYPE OF(geometric_representation_item);
  associated_topological_representation_item : hybrid_brep_vertex_select;
  hybrid_brep_point : LIST[1:?] OF hybrid_brep_point_select;
INVERSE
 owner : hybrid_brep_shape_representation FOR items;
WHERE
 WR1: (owner\hybrid_brep_shape_representation.reference_representation IN
        using_representations(associated_topological_representation_item)) AND
      (owner IN get_representations_for_items(hybrid_brep_point));
END_ENTITY;


TYPE hybrid_brep_curve_select = SELECT(curve,
                                       tessellated_edge);
END_TYPE;


TYPE hybrid_brep_edge_select = SELECT(edge_curve,
                                      tessellated_edge_curve);
END_TYPE;


ENTITY hybrid_brep_edge_assignment
  SUBTYPE OF(geometric_representation_item);
  associated_topological_representation_item : hybrid_brep_edge_select;
  hybrid_brep_curve : LIST[1:?] OF hybrid_brep_curve_select;
INVERSE
  owner : hybrid_brep_shape_representation FOR items;
WHERE      
WR1: (owner\hybrid_brep_shape_representation.reference_representation IN
      using_representations(associated_topological_representation_item)) AND
     (owner IN get_representations_for_items(hybrid_brep_curve));
END_ENTITY;


TYPE hybrid_brep_surface_select = SELECT(surface,
                                         tessellated_face);
END_TYPE;


TYPE hybrid_brep_face_select = SELECT(advanced_face,
                                      face_surface,
                                      tessellated_face_surface);
END_TYPE;


ENTITY hybrid_brep_face_assignment
  SUBTYPE OF(geometric_representation_item);
  associated_topological_representation_item : hybrid_brep_face_select;
  hybrid_brep_surface : LIST[1:?] OF hybrid_brep_surface_select;
INVERSE
  owner : hybrid_brep_shape_representation FOR items;
WHERE
  WR1: (owner\hybrid_brep_shape_representation.reference_representation IN
        using_representations(associated_topological_representation_item)) AND
       (owner IN get_representations_for_items(hybrid_brep_surface));
END_ENTITY;

 ENTITY brep_with_voids
  SUBTYPE OF (manifold_solid_brep);
  voids : SET[1:?] OF oriented_closed_shell;
END_ENTITY;

ENTITY faceted_brep
  SUBTYPE OF (manifold_solid_brep);
--IP1:
--IP2:
END_ENTITY;

ENTITY brep_2d
  SUBTYPE OF (solid_model);
  extent : face;
WHERE
  WR1: SIZEOF (['TOPOLOGY_SCHEMA.FACE_SURFACE', 'TOPOLOGY_SCHEMA.SUBFACE', 'TOPOLOGY_SCHEMA.ORIENTED_FACE'] * TYPEOF (SELF.extent)) = 0;
  WR2: SIZEOF (QUERY (bnds <* extent.bounds | NOT ('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound))) ) = 0;
  WR3: SIZEOF (QUERY (bnds <* extent.bounds | 'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(bnds))) = 1;
  WR4: SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* extent.bounds | 'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) | NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list | NOT (('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element)) AND (oe.edge_element\geometric_representation_item.dim = 2)))) = 0))) = 0;
END_ENTITY;

ENTITY csg_solid
  SUBTYPE OF (solid_model);
  tree_root_expression : csg_select;
END_ENTITY;

ENTITY boolean_result
  SUBTYPE OF (geometric_representation_item);
  operator : boolean_operator;
  first_operand : boolean_operand;
  second_operand : boolean_operand;
END_ENTITY;

ENTITY block
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  x : positive_length_measure;
  y : positive_length_measure;
  z : positive_length_measure;
END_ENTITY;

ENTITY right_angular_wedge
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  x : positive_length_measure;
  y : positive_length_measure;
  z : positive_length_measure;
  ltx : length_measure;
WHERE
  WR1: ((0.0 <= ltx) AND (ltx < x));
END_ENTITY;

ENTITY rectangular_pyramid
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
  height : positive_length_measure;
END_ENTITY;

ENTITY faceted_primitive
  SUPERTYPE OF (ONEOF (tetrahedron,
                       convex_hexahedron))
  SUBTYPE OF (geometric_representation_item);
  points : LIST[4:?] OF UNIQUE cartesian_point;
WHERE
  WR1: points[1].dim = 3;
--IP1:
--IP2:
END_ENTITY;

ENTITY tetrahedron
  SUBTYPE OF (faceted_primitive);
WHERE
  WR1: SIZEOF(points) = 4;
  WR2: above_plane(points[1], points[2], points[3], points[4]) <> 0.0;
END_ENTITY;

ENTITY convex_hexahedron
  SUBTYPE OF (faceted_primitive);
WHERE
  WR1: SIZEOF(points) = 8;
  WR2: above_plane(points[1], points[2], points[3], points[4]) = 0.0;
  WR3: above_plane(points[5], points[8], points[7], points[6]) = 0.0;
  WR4: above_plane(points[1], points[4], points[8], points[5]) = 0.0;
  WR5: above_plane(points[4], points[3], points[7], points[8]) = 0.0;
  WR6: above_plane(points[3], points[2], points[6], points[7]) = 0.0;
  WR7: above_plane(points[1], points[5], points[6], points[2]) = 0.0;
  WR8: same_side([points[1], points[2], points[3]], [points[5], points[6], points[7], points[8]]);
  WR9: same_side([points[1], points[4], points[8]], [points[3], points[7], points[6], points[2]]);
  WR10: same_side([points[1], points[2], points[5]], [points[3], points[7], points[8], points[4]]);
  WR11: same_side([points[5], points[6], points[7]], [points[1], points[2], points[3], points[4]]);
  WR12: same_side([points[3], points[7], points[6]], [points[1], points[4], points[8], points[5]]);
  WR13: same_side([points[3], points[7], points[8]], [points[1], points[5], points[6], points[2]]);
END_ENTITY;

ENTITY sphere
  SUBTYPE OF (geometric_representation_item);
  radius : positive_length_measure;
  centre : point;
END_ENTITY;

ENTITY right_circular_cone
  SUBTYPE OF (geometric_representation_item);
  position : axis1_placement;
  height : positive_length_measure;
  radius : length_measure;
  semi_angle : plane_angle_measure;
WHERE
  WR1: radius >= 0.0;
--IP1:
END_ENTITY;

ENTITY right_circular_cylinder
  SUBTYPE OF (geometric_representation_item);
  position : axis1_placement;
  height : positive_length_measure;
  radius : positive_length_measure;
END_ENTITY;

ENTITY eccentric_cone
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  height : positive_length_measure;
  x_offset : length_measure;
  y_offset : length_measure;
  ratio : REAL;
WHERE
  WR1: ratio >= 0.0;
END_ENTITY;

ENTITY torus
  SUBTYPE OF (geometric_representation_item);
  position : axis1_placement;
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
WHERE
  WR1: major_radius > minor_radius;
END_ENTITY;

ENTITY ellipsoid
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  semi_axis_3 : positive_length_measure;
END_ENTITY;

ENTITY cyclide_segment_solid
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  radius1 : positive_length_measure;
  radius2 : positive_length_measure;
  cone_angle1 : plane_angle_measure;
  cone_angle2 : plane_angle_measure;
  turn_angle : plane_angle_measure;
--IP1:
--IP2:
END_ENTITY;

ENTITY half_space_solid
  SUBTYPE OF (geometric_representation_item);
  base_surface : surface;
  agreement_flag : BOOLEAN;
--IP1:
END_ENTITY;

ENTITY boxed_half_space
  SUBTYPE OF (half_space_solid);
  enclosure : box_domain;
END_ENTITY;

ENTITY box_domain
  SUBTYPE OF (founded_item);
  corner : cartesian_point;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
  zlength : positive_length_measure;
WHERE
  WR1: SIZEOF(QUERY(item <* USEDIN(SELF,'')| NOT ('GEOMETRIC_MODEL_SCHEMA.BOXED_HALF_SPACE' IN TYPEOF(item)))) = 0;
END_ENTITY;

ENTITY primitive_2d
  SUPERTYPE OF (ONEOF (circular_area,
                       elliptic_area,
                       rectangular_area,
                       polygonal_area,
                       half_space_2d))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY circular_area
  SUBTYPE OF (primitive_2d);
  centre : cartesian_point;
  radius : positive_length_measure;
END_ENTITY;

ENTITY elliptic_area
  SUBTYPE OF (primitive_2d);
  position : axis2_placement_2d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
END_ENTITY;

ENTITY rectangular_area
  SUBTYPE OF (primitive_2d);
  position : axis2_placement_2d;
  x : positive_length_measure;
  y : positive_length_measure;
END_ENTITY;

ENTITY polygonal_area
  SUBTYPE OF (primitive_2d);
  bounds : LIST[3:?] OF UNIQUE cartesian_point;
--IP1:
END_ENTITY;

ENTITY area_with_outer_boundary
  SUBTYPE OF (half_space_2d);
  SELF\half_space_2d.base_curve : composite_curve;
WHERE
  WR1: base_curve\composite_curve.closed_curve = TRUE;
--IP1:
END_ENTITY;

ENTITY half_space_2d
  SUBTYPE OF (primitive_2d);
  base_curve : curve;
  agreement_flag : BOOLEAN;
--IP1:
--IP2:
END_ENTITY;

ENTITY rectangled_half_space
  SUBTYPE OF (half_space_2d);
  enclosure : rectangle_domain;
END_ENTITY;

ENTITY rectangle_domain
  SUBTYPE OF (founded_item);
  corner : cartesian_point;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
WHERE
  WR1: SIZEOF(QUERY(item <* USEDIN(SELF, '')| NOT ('GEOMETRIC_MODEL_SCHEMA.RECTANGLED_HALF_SPACE' IN TYPEOF(item)))) = 0;
END_ENTITY;

ENTITY swept_face_solid
  SUPERTYPE OF (ONEOF (extruded_face_solid,
                       revolved_face_solid,
                       surface_curve_swept_face_solid))
  SUBTYPE OF (solid_model);
  swept_face : face_surface;
WHERE
  WR1: 'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_face.face_geometry);
END_ENTITY;

ENTITY extruded_face_solid
  SUBTYPE OF (swept_face_solid);
  extruded_direction : direction;
  depth : positive_length_measure;
WHERE
  WR1: dot_product( (SELF\swept_face_solid.swept_face.face_geometry\elementary_surface.position.p[3]), extruded_direction) <> 0.0;
END_ENTITY;

ENTITY revolved_face_solid
  SUBTYPE OF (swept_face_solid);
  axis : axis1_placement;
  angle : plane_angle_measure;
DERIVE
  axis_line : line := representation_item('')|| geometric_representation_item()|| curve()|| line(axis.location, representation_item('')|| geometric_representation_item()|| vector(axis.z, 1.0));
--IP1:
--IP2:
--IP3:
END_ENTITY;

ENTITY surface_curve_swept_face_solid
  SUBTYPE OF (swept_face_solid);
  directrix : curve;
  start_param : REAL;
  end_param : REAL;
  reference_surface : surface;
WHERE
  WR1: (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR (reference_surface IN (directrix\surface_curve.basis_surface));
--IP1:
--IP2:
END_ENTITY;

ENTITY swept_area_solid
  SUPERTYPE OF (ONEOF (revolved_area_solid,
                       extruded_area_solid,
                       surface_curve_swept_area_solid))
  SUBTYPE OF (solid_model);
  swept_area : curve_bounded_surface;
WHERE
  WR1: 'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_area.basis_surface);
END_ENTITY;

ENTITY extruded_area_solid
  SUBTYPE OF (swept_area_solid);
  extruded_direction : direction;
  depth : positive_length_measure;
WHERE
  WR1: dot_product( (SELF\swept_area_solid.swept_area.basis_surface\elementary_surface.position.p[3]), extruded_direction) <> 0.0;
END_ENTITY;

ENTITY revolved_area_solid
  SUBTYPE OF (swept_area_solid);
  axis : axis1_placement;
  angle : plane_angle_measure;
DERIVE
  axis_line : line := representation_item('')|| geometric_representation_item()|| curve()|| line(axis.location, representation_item('')|| geometric_representation_item()|| vector(axis.z, 1.0));
--IP1:
--IP2:
--IP3:
END_ENTITY;

ENTITY surface_curve_swept_area_solid
  SUBTYPE OF (swept_area_solid);
  directrix : curve;
  start_param : REAL;
  end_param : REAL;
  reference_surface : surface;
WHERE
  WR1: (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR (reference_surface IN (directrix\surface_curve.basis_surface));
--IP1:
--IP2:
END_ENTITY;

ENTITY swept_disk_solid
  SUBTYPE OF (solid_model);
  directrix : curve;
  radius : positive_length_measure;
  inner_radius : OPTIONAL positive_length_measure;
  start_param : REAL;
  end_param : REAL;
WHERE
  WR1: directrix.dim = 3;
  WR2: (NOT EXISTS(inner_radius)) OR (radius > inner_radius);
END_ENTITY;

ENTITY trimmed_volume
  SUBTYPE OF (solid_model);
  basis_volume : volume;
  u1 : parameter_value;
  u2 : parameter_value;
  v1 : parameter_value;
  v2 : parameter_value;
  w1 : parameter_value;
  w2 : parameter_value;
WHERE
  WR1: u1 <> u2;
  WR2: v1 <> v2;
  WR3: w1 <> w2;
END_ENTITY;

ENTITY solid_replica
  SUBTYPE OF (solid_model);
  parent_solid : solid_model;
  transformation : cartesian_transformation_operator_3d;
WHERE
  WR1: acyclic_solid_replica(SELF, parent_solid);
  WR2: parent_solid\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY shell_based_surface_model
  SUBTYPE OF (geometric_representation_item);
  sbsm_boundary : SET[1:?] OF shell;
WHERE
  WR1: constraints_geometry_shell_based_surface_model(SELF);
--IP1:
--IP2:
--IP3:
END_ENTITY;

ENTITY face_based_surface_model
  SUBTYPE OF (geometric_representation_item);
  fbsm_faces : SET[1:?] OF connected_face_set;
--IP1:
--IP2:
END_ENTITY;

ENTITY shell_based_wireframe_model
  SUBTYPE OF (geometric_representation_item);
  sbwm_boundary : SET[1:?] OF shell;
WHERE
  WR1: constraints_geometry_shell_based_wireframe_model(SELF);
--IP1:
--IP2:
--IP3:
END_ENTITY;

ENTITY edge_based_wireframe_model
  SUBTYPE OF (geometric_representation_item);
  ebwm_boundary : SET[1:?] OF connected_edge_set;
--IP1:
--IP2:
END_ENTITY;

ENTITY geometric_set
  SUPERTYPE OF (ONEOF (geometric_curve_set,
                       geometric_set_replica))
  SUBTYPE OF (geometric_representation_item);
  elements : SET[1:?] OF geometric_set_select;
END_ENTITY;

ENTITY geometric_curve_set
  SUBTYPE OF (geometric_set);
WHERE
 WR1: SIZEOF(QUERY(temp <* SELF\geometric_set.elements |NOT (('GEOMETRY_SCHEMA.CURVE' IN TYPEOF(temp)) OR  ('GEOMETRY_SCHEMA.POINT' IN 
TYPEOF(temp))) )) = 0;
END_ENTITY;

ENTITY sectioned_spine
  SUBTYPE OF (geometric_curve_set);
  cross_sections : LIST[2:?] OF curve;
  spine_points : LIST[2:?] OF point;
WHERE
  WR1: SIZEOF(SELF\geometric_set.elements) = 1;
  WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF(SELF\geometric_set.elements[1]);
  WR3: SIZEOF(cross_sections) = SIZEOF(spine_points);
  WR4: SELF\geometric_representation_item.dim = 3;
--IP1:
--IP2:
END_ENTITY;

ENTITY geometric_set_replica
  SUBTYPE OF (geometric_set);
  parent_set : geometric_set;
  transformation : cartesian_transformation_operator;
DERIVE
  SELF\geometric_set.elements : SET[1:?] OF geometric_set_select := build_transformed_set(transformation, parent_set);
WHERE
  WR1: acyclic_set_replica(SELF, parent_set);
END_ENTITY;


TYPE tessellated_manifold_subsurface_shape_representation_select = SELECT (
            connected_face_sub_set,
            mapped_item,
            axis2_placement_3d);
END_TYPE;


ENTITY tessellated_manifold_subsurface_shape_representation
 SUBTYPE OF (shape_representation);
  SELF\representation.items : SET [1:?] OF tessellated_manifold_subsurface_shape_representation_select;
 WHERE
  WR1: SIZEOF (QUERY (it <* SELF.items |
         SIZEOF(['TOPOLOGY_SCHEMA.CONNECTED_FACE_SUB_SET',
         'REPRESENTATION_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) =1 )) > 0;
   WR2: SIZEOF (QUERY (mi <*  QUERY (it <* items |
                 'REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) |
   NOT ('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION' IN
             TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
   WR3: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'TOPOLOGY_SCHEMA.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
          NOT('TOPOLOGY_SCHEMA.TESSELLATED_OPEN_SHELL' IN TYPEOF(cfss)))) = 0;
   WR4: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
          'TOPOLOGY_SCHEMA.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
               ('TOPOLOGY_SCHEMA.TESSELLATED_SUBFACE_SURFACE' IN TYPEOF(fcs)) AND
            NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                  NOT(('TOPOLOGY_SCHEMA.TESSELLATED_EDGE_CURVE' IN
            TYPEOF(oe.edge_element)) OR
           ('TOPOLOGY_SCHEMA.TESSELLATED_SUBEDGE_CURVE' IN
            TYPEOF(oe.edge_element)) ))) = 0
                   ))) = 0
                 ))) = 0
             ))) = 0;
   WR5: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'TOPOLOGY_SCHEMA.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
           ('TOPOLOGY_SCHEMA.TESSELLATED_SUBFACE_SURFACE' IN TYPEOF(fcs)) AND
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
          NOT(('TOPOLOGY_SCHEMA.TESSELLATED_VERTEX_POINT' IN TYPEOF(oe.edge_start))
                AND ('TOPOLOGY_SCHEMA.TESSELLATED_VERTEX_POINT' IN
                 TYPEOF(oe.edge_end))
            ))) = 0
              ))) = 0
               ))) = 0
                   ))) = 0;
   WR6: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'TOPOLOGY_SCHEMA.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'TOPOLOGY_SCHEMA.TESSELLATED_SUBFACE_SURFACE' IN TYPEOF(fcs)) AND
              ( NOT (SIZEOF(QUERY  (bnds <* fcs.bounds |
         NOT (SIZEOF (['TOPOLOGY_SCHEMA.EDGE_LOOP',
                'TOPOLOGY_SCHEMA.VERTEX_LOOP'] *
                   TYPEOF(bnds.bound)) = 1 )
                   )) = 0)
                 ))) = 0
             ))) = 0;
 END_ENTITY;


--bug 1782
ENTITY tessellated_manifold_surface_shape_representation 
   SUBTYPE OF (shape_representation);
  SELF\representation.items : SET [1:?] OF manifold_surface_shape_representation_select;
WHERE 
  WR1: SIZEOF (QUERY (it <* SELF.items |
       SIZEOF (['GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL',
       'REPRESENTATION_SCHEMA.MAPPED_ITEM'] * TYPEOF (it)) = 1)) > 0;
  WR2: SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
       'REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF (it)) |
       NOT (('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_MANIFOLD_SURFACE_SHAPE_REPRESENTATION'
       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))
       AND
       (SIZEOF(QUERY (mr_it <*
       mi\mapped_item.mapping_source.mapped_representation.items |
       ('GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL'
       IN TYPEOF (mr_it)))) > 0 )))) = 0;
  WR3: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (sh <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (['TOPOLOGY_SCHEMA.TESSELLATED_OPEN_SHELL',
       'TOPOLOGY_SCHEMA.ORIENTED_TESSELLATED_CLOSED_SHELL',
       'TOPOLOGY_SCHEMA.TESSELLATED_CLOSED_SHELL']
       * TYPEOF (sh)) = 1))) = 0))) = 0;
END_ENTITY;

-- 2078
ENTITY tessellated_closed_shell
 SUBTYPE OF (closed_shell);
WHERE
  WR1 : SIZEOF (QUERY(fcs <* SELF\connected_face_set.cfs_faces |
          NOT('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_FACE_SURFACE' IN TYPEOF(fcs))))
          = 0;
  WR2 : SIZEOF (QUERY(fcs <* SELF\connected_face_set.cfs_faces |
          NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
          'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
            NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
              NOT('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_EDGE_CURVE' IN
              TYPEOF(oe.edge_element)))) = 0
              ))) = 0
                ))) = 0;
  WR3 : SIZEOF (QUERY(fcs <* SELF\connected_face_set.cfs_faces |
          NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
        'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
            NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
           NOT(('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_VERTEX_POINT' IN TYPEOF(oe.edge_start))
            AND ('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_VERTEX_POINT' IN
            TYPEOF(oe.edge_end))
           ))) = 0
             ))) = 0
              ))) = 0;
END_ENTITY;

-- 2077
ENTITY tessellated_open_shell
 SUBTYPE OF (open_shell);
WHERE
  WR1 : SIZEOF (QUERY(fcs <* SELF\connected_face_set.cfs_faces |
          NOT('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_FACE_SURFACE' IN TYPEOF(fcs))))
          = 0;
  WR2 : SIZEOF (QUERY(fcs <* SELF\connected_face_set.cfs_faces |
          NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
          'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
            NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
              NOT('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_EDGE_CURVE' IN
              TYPEOF(oe.edge_element)))) = 0
              ))) = 0
                ))) = 0;
  WR3 : SIZEOF (QUERY(fcs <* SELF\connected_face_set.cfs_faces |
          NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
        'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
            NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
           NOT(('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_VERTEX_POINT' IN TYPEOF(oe.edge_start))
            AND ('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_VERTEX_POINT' IN
            TYPEOF(oe.edge_end))
           ))) = 0
             ))) = 0
              ))) = 0;
END_ENTITY;

ENTITY tessellated_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: 'REPRESENTATION_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN
         TYPEOF(SELF\representation.context_of_items);
  WR2: NOT( SIZEOF(QUERY ( it <* SELF.items|   
       'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_ITEM' IN TYPEOF (it))) = 0 );  
END_ENTITY;

ENTITY tessellated_shape_representation_with_accuracy_parameters
  SUBTYPE OF (tessellated_shape_representation);
     tessellation_accuracy_parameters : SET [1:?] OF
       tessellation_accuracy_parameter_item;
END_ENTITY;

ENTITY tessellated_item
  ABSTRACT SUPERTYPE OF (ONEOF (coordinates_list,
                                tessellated_solid,
                                tessellated_shell,
                                tessellated_wire,
                                tessellated_geometric_set,
                                tessellated_curve_set,
                                tessellated_point_set,
                                tessellated_surface_set,
                                tessellated_structured_item))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: SIZEOF (QUERY (using_rep <* using_representations (SELF) | NOT ('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_SHAPE_REPRESENTATION' IN TYPEOF(using_rep)))) = 0;
END_ENTITY;

ENTITY repositioned_tessellated_item
  SUBTYPE OF (tessellated_item);
  location : axis2_placement_3d;
WHERE
  WR1: NOT (SIZEOF (['GEOMETRIC_MODEL_SCHEMA.TESSELLATED_CURVE_SET', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_GEOMETRIC_SET', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_POINT_SET', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_SURFACE_SET', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_SHELL', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_SOLID', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_WIRE'] * TYPEOF(SELF)) = 0);
END_ENTITY;

ENTITY tessellated_structured_item
  SUPERTYPE OF (ONEOF (tessellated_face,
                       tessellated_edge,
                       tessellated_vertex))
  SUBTYPE OF (tessellated_item);
END_ENTITY;

ENTITY coordinates_list
  SUBTYPE OF (tessellated_item);
  npoints : INTEGER;
  position_coords : LIST[1:?] OF LIST[3:3] OF REAL;
WHERE
  WR1: npoints = SIZEOF(position_coords);
  WR2: SIZEOF (['GEOMETRIC_MODEL_SCHEMA.REPOSITIONED_TESSELLATED_ITEM'] * TYPEOF(SELF)) = 0;
END_ENTITY;

ENTITY tessellated_vertex
  SUBTYPE OF (tessellated_structured_item);
  coordinates : coordinates_list;
  topological_link : OPTIONAL vertex_point;
  point_index : INTEGER;
END_ENTITY;

ENTITY tessellated_edge
  SUPERTYPE OF (ONEOF (tessellated_connecting_edge,     
                       cubic_bezier_tessellated_edge))
  SUBTYPE OF (tessellated_structured_item);
  coordinates : coordinates_list;
  geometric_link : OPTIONAL edge_or_curve;
  line_strip : LIST[2:?] OF INTEGER;
END_ENTITY;

ENTITY tessellated_connecting_edge
  SUBTYPE OF (tessellated_edge);
  smooth : LOGICAL;
  face1 : tessellated_face;
  face2 : tessellated_face;
  line_strip_face1 : LIST[2:?] OF INTEGER;
  line_strip_face2 : LIST[2:?] OF INTEGER;
WHERE
  WR1: SIZEOF(line_strip_face1) = SIZEOF(line_strip_face2);
  WR2: SIZEOF(line_strip_face1) = SIZEOF(SELF\tessellated_edge.line_strip);
  WR3: NOT(('GEOMETRIC_MODEL_SCHEMA.CUBIC_BEZIER_TRIANGULATED_FACE') IN TYPEOF(face1));
  WR4: NOT(('GEOMETRIC_MODEL_SCHEMA.CUBIC_BEZIER_TRIANGULATED_FACE') IN TYPEOF(face2));
END_ENTITY;

ENTITY cubic_bezier_tessellated_edge
  SUBTYPE OF (tessellated_edge);
   SELF\tessellated_edge.line_strip: LIST[4:?] OF INTEGER;
END_ENTITY;

ENTITY cubic_tessellated_connecting_edge
  SUBTYPE OF (cubic_bezier_tessellated_edge);
  smooth : LOGICAL;
  face1 : cubic_bezier_triangulated_face;
  face2 : cubic_bezier_triangulated_face;
END_ENTITY;

ENTITY tessellated_face
  ABSTRACT SUPERTYPE OF (ONEOF (triangulated_face,
                                complex_triangulated_face,
                                cubic_bezier_triangulated_face))
  SUBTYPE OF (tessellated_structured_item);
  coordinates : coordinates_list;
  pnmax : INTEGER;
  normals : LIST[0:?] OF LIST[3:3] OF REAL;
  geometric_link : OPTIONAL face_or_surface;
WHERE
  WR1: ((SIZEOF(normals) = 0) OR (SIZEOF(normals) = 1) OR (SIZEOF(normals) = pnmax));
END_ENTITY;

ENTITY triangulated_face
  SUBTYPE OF (tessellated_face);
  pnindex : LIST[0:?] OF INTEGER;
  triangles : LIST[1:?] OF LIST[3:3] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_face.pnmax));
  WR2: NOT((SIZEOF(pnindex) = 0) AND (SELF\tessellated_face.pnmax <> coordinates.npoints));
END_ENTITY;

ENTITY complex_triangulated_face
  SUBTYPE OF (tessellated_face);
  pnindex : LIST[0:?] OF INTEGER;
  triangle_strips : LIST[0:?] OF LIST[3:?] OF INTEGER;
  triangle_fans : LIST[0:?] OF LIST[3:?] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_face.pnmax));
  WR2: NOT((SIZEOF(pnindex) = 0) AND (SELF\tessellated_face.pnmax <> coordinates.npoints));
  WR3: NOT ((SIZEOF(triangle_strips) = 0) AND (SIZEOF(triangle_fans) = 0));
END_ENTITY;

ENTITY cubic_bezier_triangulated_face
  SUBTYPE OF (tessellated_face);
    ctriangles : LIST[1: ?] OF LIST [10: 10] OF INTEGER;
  WHERE
       WR1: SIZEOF( SELF\tessellated_face.normals) = 0;
END_ENTITY;

ENTITY tessellated_solid
  SUBTYPE OF (tessellated_item);
  items : SET[1:?] OF tessellated_structured_item;
  geometric_link : OPTIONAL manifold_solid_brep;
END_ENTITY;

ENTITY tessellated_shell
  SUBTYPE OF (tessellated_item);
  items : SET[1:?] OF tessellated_structured_item;
  topological_link : OPTIONAL connected_face_set;
END_ENTITY;

ENTITY tessellated_wire
  SUBTYPE OF (tessellated_item);
  items : SET[1:?] OF tessellated_edge_or_vertex;
  geometric_model_link : OPTIONAL path_or_composite_curve;
END_ENTITY;

ENTITY tessellated_surface_set
  ABSTRACT SUPERTYPE OF (ONEOF (triangulated_surface_set,
                                complex_triangulated_surface_set))
  SUBTYPE OF (tessellated_item);
  coordinates : coordinates_list;
  pnmax : INTEGER;
  normals : LIST[0:?] OF LIST[3:3] OF REAL;
WHERE
  WR1: ((SIZEOF(normals) = 0) OR (SIZEOF(normals) = 1) OR (SIZEOF(normals) = pnmax));
END_ENTITY;

ENTITY triangulated_surface_set
  SUBTYPE OF (tessellated_surface_set);
  pnindex : LIST[0:?] OF INTEGER;
  triangles : LIST[1:?] OF LIST[3:3] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_surface_set.pnmax));
  WR2: NOT((SIZEOF(pnindex) = 0) AND (SELF\tessellated_surface_set.pnmax <> coordinates.npoints));
END_ENTITY;

ENTITY complex_triangulated_surface_set
  SUBTYPE OF (tessellated_surface_set);
  pnindex : LIST[0:?] OF INTEGER;
  triangle_strips : LIST[0:?] OF LIST[3:?] OF INTEGER;
  triangle_fans : LIST[0:?] OF LIST[3:?] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_surface_set.pnmax));
  WR2: NOT((SIZEOF(pnindex) = 0) AND (SELF\tessellated_surface_set.pnmax <> coordinates.npoints));
  WR3: NOT ((SIZEOF(triangle_strips) = 0) AND (SIZEOF(triangle_fans) = 0));
END_ENTITY;

ENTITY tessellated_curve_set
  SUBTYPE OF (tessellated_item);
  coordinates : coordinates_list;
  line_strips : LIST[1:?] OF LIST[2:?] OF INTEGER;
END_ENTITY;

ENTITY tessellated_geometric_set
  SUBTYPE OF (tessellated_item);
  children : SET[1:?] OF tessellated_item;
END_ENTITY;

ENTITY tessellated_point_set
  SUBTYPE OF (tessellated_item);
  coordinates : coordinates_list;
  point_list : LIST[1:?] OF INTEGER;
END_ENTITY;

SUBTYPE_CONSTRAINT gms_face_subtypes FOR face; 
(ONEOF (face_surface,
        oriented_face,
        subface,
        tessellated_face_surface)); 
END_SUBTYPE_CONSTRAINT;

--bug 1825
ENTITY tessellated_face_surface
SUBTYPE OF (face, geometric_representation_item);
  tessellated_face_geometry : tessellated_face;
WHERE
  WR1: NOT EXISTS (tessellated_face_geometry\tessellated_face.geometric_link) OR
                  ('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(tessellated_face_geometry\tessellated_face.geometric_link));
END_ENTITY;

--bug 1783
ENTITY tessellated_subface_surface
SUBTYPE OF (tessellated_face_surface);
  parent_face : tessellated_face_surface;
WHERE
  WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF)) + list_to_set(list_face_loops(parent_face))));
  WR2: SELF <> parent_face;
--IP1:;
--IP2:;
END_ENTITY;

--bug 1825
ENTITY tessellated_edge_curve
 SUBTYPE OF (edge, geometric_representation_item);
 tessellated_edge_geometry :  tessellated_edge;
WHERE
  WR1: NOT EXISTS (tessellated_edge_geometry\tessellated_edge.geometric_link) OR
                ('GEOMETRY_SCHEMA.CURVE' IN TYPEOF(tessellated_edge_geometry\tessellated_edge.geometric_link));
END_ENTITY;

ENTITY tessellated_subedge_curve
 SUBTYPE OF (tessellated_edge_curve);
  parent_edge : tessellated_edge_curve;
WHERE
  WR1: SELF :<>: parent_edge;
--IP1:;
--IP2:;
END_ENTITY;

SUBTYPE_CONSTRAINT gms_edge_subtypes FOR edge;
    (ONEOF (edge_curve,
            oriented_edge,
            subedge,
            tessellated_edge_curve));
END_SUBTYPE_CONSTRAINT;

ENTITY tessellated_vertex_point
 SUBTYPE OF (vertex, geometric_representation_item);
 tessellated_vertex_geometry :  tessellated_vertex;
WHERE
  WR1: NOT EXISTS (tessellated_vertex_geometry\tessellated_vertex.topological_link);
END_ENTITY;

SUBTYPE_CONSTRAINT gms_vertex_subtypes FOR vertex;
    (ONEOF (tessellated_vertex_point,
                       vertex_point));
END_SUBTYPE_CONSTRAINT;

TYPE brep_shape_representation_items_select = SELECT (
            manifold_solid_brep,
            mapped_item,
            axis2_placement_3d);
END_TYPE;

ENTITY tessellated_brep_shape_representation
 SUBTYPE OF ( shape_representation );
 SELF\representation.items : SET [1:?] OF brep_shape_representation_items_select;
 WHERE
   WR1 : SIZEOF (QUERY (it <* SELF.items | (SIZEOF (['GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP', 'REPRESENTATION_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) =1 ))) > 0;
   WR2 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
            NOT (SIZEOF (QUERY(fcs <* csh.cfs_faces |
              NOT('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_FACE_SURFACE' IN TYPEOF(fcs)))) = 0
                 ))) = 0
                   ))) = 0;
   WR3 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                  NOT('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_EDGE_CURVE' IN
            TYPEOF(oe.edge_element)))) = 0
                   ))) = 0
                 ))) = 0
               ))) = 0
             ))) = 0;
   WR4 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
                    'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
            NOT(('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_VERTEX_POINT' IN TYPEOF(oe.edge_start))
                AND ('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_VERTEX_POINT' IN
                 TYPEOF(oe.edge_end))
            ))) = 0
              ))) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0;
   WR5 : SIZEOF (QUERY (msb <* QUERY (it <* items |
          'GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
          'TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF
              (msb\manifold_solid_brep.outer)))
             = 0;
   WR6 : SIZEOF (QUERY (brv <* QUERY (it <* items |
          'GEOMETRIC_MODEL_SCHEMA.BREP_WITH_VOIDS' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* brv\brep_with_voids.voids |
            csh\oriented_closed_shell.orientation)) = 0))) = 0;
   WR7 : SIZEOF (QUERY (mi <*  QUERY (it <* items |
                 'REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) |
          NOT ('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_BREP_SHAPE_REPRESENTATION' IN
             TYPEOF(mi\mapped_item.mapping_source.
                           mapped_representation)))) = 0;
END_ENTITY;

FUNCTION acyclic_set_replica
 (rep : geometric_set_replica; parent : geometric_set) : BOOLEAN;
IF NOT (('GEOMETRY_SCHEMA.GEOMETRIC_SET_REPLICA') IN TYPEOF(parent))
        THEN  RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type geometric_set_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same geometric_set_replica,
     otherwise, call function again with the parents own parent_set.  *)
    ELSE RETURN(acyclic_set_replica(rep,
                          parent\geometric_set_replica.parent_set));
    END_IF;
  END_FUNCTION;

FUNCTION acyclic_solid_replica
 (rep : solid_replica; parent : solid_model) : BOOLEAN;
IF NOT (('GEOMETRY_SCHEMA.SOLID_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type solid_replica. *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same solid_replica, otherwise,
   call function again with the parents own parent_solid.     *)
    ELSE RETURN(acyclic_solid_replica(rep,
                      parent\solid_replica.parent_solid));
    END_IF;
 END_FUNCTION;

FUNCTION advanced_face_properties (testface : face) : BOOLEAN;
(* return TRUE if testface is of type advanced_face *)
IF 'TOPOLOGY_SCHEMA.ADVANCED_FACE' IN TYPEOF(testface) THEN
    RETURN (TRUE);
END_IF;
(* if testface is a subface recursively test the parent_face,
return FALSE for all other types of face *)
IF  ('TOPOLOGY_SCHEMA.SUBFACE' IN TYPEOF(testface)) THEN
     RETURN(advanced_face_properties(testface\subface.parent_face));
   ELSE RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION build_transformed_set
 (tr : cartesian_transformation_operator; gset : geometric_set) : SET[0:?] OF geometric_set_select;
LOCAL
   s          : SET [1:?] OF geometric_set_select := gset.elements;
   trset      : SET [0:?] OF geometric_set_select := [];
  END_LOCAL;
  REPEAT j := 1 TO SIZEOF(s);
    IF ('GEOMETRY_SCHEMA.CURVE' IN TYPEOF(s[j])) THEN
     trset := trset + dummy_gri || curve() ||curve_replica(s[j],tr); ELSE
     IF ('GEOMETRY_SCHEMA.POINT' IN TYPEOF(s[j])) THEN
       trset := trset + dummy_gri || point() || point_replica(s[j],tr);
       ELSE
       IF ('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(s[j])) THEN
         trset := trset + dummy_gri || surface()  || surface_replica(s[j],
           tr || cartesian_transformation_operator_3d (?));
       END_IF;
     END_IF;
    END_IF;
  END_REPEAT;
  RETURN(trset);
 END_FUNCTION;

FUNCTION constraints_geometry_shell_based_surface_model
 (m : shell_based_surface_model) : BOOLEAN;
LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
     IF (NOT ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN
                     TYPEOF(m.sbsm_boundary[j])) AND
        (NOT ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN
           TYPEOF(m.sbsm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);
       (* A surface model is composed of OPEN_ and CLOSED_SHELLs. *)
     END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

FUNCTION constraints_geometry_shell_based_wireframe_model
 (m : shell_based_wireframe_model) : BOOLEAN;
LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;
   REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
     IF (NOT ('TOPOLOGY_SCHEMA.WIRE_SHELL' IN
                    TYPEOF(m.sbwm_boundary[j])) AND
        (NOT ('TOPOLOGY_SCHEMA.VERTEX_SHELL' IN
                      TYPEOF(m.sbwm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);
       (* A wireframe model is composed of WIRE_ and VERTEX_SHELLs *)
     END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

FUNCTION msb_shells
 (brep : manifold_solid_brep) : SET[1:?] OF closed_shell;
LOCAL   
      return_set: SET[1:?] OF closed_shell := [brep.outer];   
    END_LOCAL;   
    IF SIZEOF(QUERY(msbtype <* TYPEOF(brep) |   
                 msbtype LIKE '*BREP_WITH_VOIDS'))  >= 1    
          THEN   
       return_set := return_set + brep\brep_with_voids.voids;   
    END_IF;   
   RETURN(return_set);
 END_FUNCTION;

END_SCHEMA;  -- geometric_model_schema


--
-- GEOMETRY_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/geometry_schema/geometry_schema.exp)
--
(* 
ISO 10303 TC184/SC4/WG12 N11415 

EXPRESS Source:
ISO 10303-42 ed8 Geometric and topological representation - Geometry schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2024  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-42 ed8 Geometric and topological representation - Geometry schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD

 *)
SCHEMA geometry_schema '{iso standard 10303 part(42) version(13) object(1) geometry_schema(1)}';

REFERENCE FROM geometric_model_schema   -- ISO 10303-42
  (block,
   boolean_result,
   cyclide_segment_solid,
   eccentric_cone,
   edge_based_wireframe_model,
   ellipsoid,
   face_based_surface_model,
   faceted_primitive,
   geometric_set,
   half_space_solid,
   primitive_2d,
   rectangular_pyramid,
   right_angular_wedge,
   right_circular_cone,
   right_circular_cylinder,
   shell_based_surface_model,
   shell_based_wireframe_model,
   solid_model,
   sphere,
   tessellated_item,
   torus); 
   
REFERENCE FROM measure_schema   -- ISO 10303-41
  (global_unit_assigned_context,
   length_measure,
   parameter_value,
   plane_angle_measure,
   plane_angle_unit,
   positive_length_measure,
   positive_plane_angle_measure); 
   
REFERENCE FROM representation_schema   -- ISO 10303-43
  (definitional_representation,
   founded_item,
   functionally_defined_transformation,
   item_in_context,
   representation,
   representation_context,
   representation_item,
   using_representations); 

REFERENCE FROM scan_data_3d_shape_model_schema    -- ISO 10303-42 
  (scanned_data_item);
  
(* for isogeometry added volume_with_faces *)
REFERENCE FROM topology_schema   -- ISO 10303-42
  (edge_curve,
   face_surface,
   poly_loop,
   vertex_point,
   volume_with_faces); 

CONSTANT
  dummy_gri : geometric_representation_item := representation_item('')|| geometric_representation_item(); 
END_CONSTANT; 

TYPE axis2_placement = SELECT
   (axis2_placement_2d, 
    axis2_placement_3d);
END_TYPE; 

TYPE b_spline_curve_form = ENUMERATION OF 
   (polyline_form,
    circular_arc,
    elliptic_arc,
    parabolic_arc,
    hyperbolic_arc,
    unspecified);
END_TYPE; 

TYPE b_spline_surface_form = ENUMERATION OF 
   (plane_surf,
    cylindrical_surf,
    conical_surf,
    spherical_surf,
    toroidal_surf,
    surf_of_revolution,
    ruled_surf,
    generalised_cone,
    quadric_surf,
    surf_of_linear_extrusion,
    unspecified);
END_TYPE; 

TYPE curve_on_surface = SELECT
   (composite_curve_on_surface, 
    pcurve, 
    surface_curve);
END_TYPE; 

TYPE dimension_count = INTEGER;
WHERE
  WR1: SELF > 0;
END_TYPE; 

TYPE extent_enumeration = ENUMERATION OF 
   (invalid,
    zero,
    finite_non_zero,
    infinite);
END_TYPE; 

TYPE knot_type = ENUMERATION OF 
   (uniform_knots,
    quasi_uniform_knots,
    piecewise_bezier_knots,
    unspecified);
END_TYPE; 

TYPE pcurve_or_surface = SELECT
   (pcurve, 
    surface);
END_TYPE; 

TYPE preferred_surface_curve_representation = ENUMERATION OF 
   (curve_3d,
    pcurve_s1,
    pcurve_s2);
END_TYPE; 

TYPE surface_boundary = SELECT
   (boundary_curve, 
    degenerate_pcurve);
END_TYPE; 

TYPE transition_code = ENUMERATION OF 
   (discontinuous,
    continuous,
    cont_same_gradient,
    cont_same_gradient_same_curvature);
END_TYPE; 

TYPE trimming_preference = ENUMERATION OF 
   (cartesian,
    parameter,
    unspecified);
END_TYPE; 

TYPE trimming_select = SELECT
   (cartesian_point, 
    parameter_value);
END_TYPE; 

TYPE vector_or_direction = SELECT
   (direction, 
    vector);
END_TYPE; 

(* isogeometry TYPE additions *)
TYPE locally_refined_spline_type_enum = ENUMERATION OF 
  (analysis_suitable_t_spline, 
  hierarchical_b_spline, 
  lr_b_spline, 
  semi_standard_t_spline, 
  standard_t_spline); 
END_TYPE; 

TYPE linearly_independent_enum = ENUMERATION OF 
  (independent, 
  not_independent, 
  not_tested);
END_TYPE;

TYPE spline_knot_values = LIST [2: ?] OF REAL; 
WHERE 
WR1 : increasing_values_in_list(SELF);
END_TYPE;

ENTITY geometric_representation_context
  SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
END_ENTITY;

ENTITY geometric_representation_item
  SUBTYPE OF (representation_item);
DERIVE
  dim : dimension_count := dimension_of(SELF);
WHERE
  WR1: SIZEOF (QUERY (using_rep <* using_representations (SELF) | NOT ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF (using_rep.context_of_items)))) = 0;
END_ENTITY;

SUBTYPE_CONSTRAINT gs_gri_subtypes FOR geometric_representation_item;
(ONEOF (block,
        boolean_result,
        cartesian_transformation_operator,
        curve,
        cyclide_segment_solid,
        direction,
        edge_based_wireframe_model,
        edge_curve,
        ellipsoid,
        face_based_surface_model,
        face_surface,
        faceted_primitive,
        geometric_set,
        half_space_solid,
        placement,
        point,
        poly_loop,
        primitive_2d,
        rectangular_pyramid,
        right_angular_wedge,
        right_circular_cone,
        right_circular_cylinder,
        scanned_data_item,
        shell_based_surface_model,
        shell_based_wireframe_model,
        solid_model,
        sphere,
        surface,
        tessellated_item,
        torus,
        vector,
        vertex_point,
        volume));
END_SUBTYPE_CONSTRAINT;

ENTITY point
  SUPERTYPE OF (ONEOF (cartesian_point,
                       point_on_curve,
                       point_on_surface,
                       point_in_volume,
                       point_replica,
                       degenerate_pcurve))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY cartesian_point
  SUPERTYPE OF (ONEOF (cylindrical_point,
                       polar_point,
                       spherical_point))
  SUBTYPE OF (point);
  coordinates : LIST[1:3] OF length_measure;
END_ENTITY;

ENTITY cylindrical_point
  SUBTYPE OF (cartesian_point);
  r : length_measure;
  theta : plane_angle_measure;
  z : length_measure;
DERIVE
  SELF\cartesian_point.coordinates : LIST[3:3] OF length_measure := [r*cos(theta), r*sin(theta), z];
WHERE
  WR1: r >= 0.0;
  --IP1:
END_ENTITY;

ENTITY spherical_point
  SUBTYPE OF (cartesian_point);
  r : length_measure;
  theta : plane_angle_measure;
  phi : plane_angle_measure;
DERIVE
  SELF\cartesian_point.coordinates : LIST[3:3] OF length_measure := [r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)];
WHERE
  WR1: r >= 0.0;
  --IP1:
  --IP2:
END_ENTITY;

ENTITY polar_point
  SUBTYPE OF (cartesian_point);
  r : length_measure;
  theta : plane_angle_measure;
DERIVE
  SELF\cartesian_point.coordinates : LIST[2:2] OF length_measure := [r*cos(theta), r*sin(theta)];
WHERE
  WR1: r >= 0.0;
  --IP1:
END_ENTITY;

ENTITY point_on_curve
  SUBTYPE OF (point);
  basis_curve : curve;
  point_parameter : parameter_value;
  --IP1:
END_ENTITY;

ENTITY point_on_surface
  SUBTYPE OF (point);
  basis_surface : surface;
  point_parameter_u : parameter_value;
  point_parameter_v : parameter_value;
  --IP1:
END_ENTITY;

ENTITY point_in_volume
  SUBTYPE OF (point);
  basis_volume : volume;
  point_parameter_u : parameter_value;
  point_parameter_v : parameter_value;
  point_parameter_w : parameter_value;
  --IP1:
END_ENTITY;

ENTITY point_replica
  SUBTYPE OF (point);
  parent_pt : point;
  transformation : cartesian_transformation_operator;
WHERE
  WR1: transformation.dim = parent_pt.dim;
  WR2: acyclic_point_replica (SELF,parent_pt);
END_ENTITY;

ENTITY degenerate_pcurve
  SUBTYPE OF (point);
  basis_surface : surface;
  reference_to_curve : definitional_representation;
WHERE
  WR1: SIZEOF(reference_to_curve\representation.items) = 1;
  WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF (reference_to_curve\representation.items[1]);
  WR3: reference_to_curve\representation. items[1]\geometric_representation_item.dim =2;
  --IP1:
END_ENTITY;

ENTITY evaluated_degenerate_pcurve
  SUBTYPE OF (degenerate_pcurve);
  equivalent_point : cartesian_point;
END_ENTITY;

ENTITY direction
  SUBTYPE OF (geometric_representation_item);
  direction_ratios : LIST[2:3] OF REAL;
WHERE
  WR1: SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
END_ENTITY;

ENTITY vector
  SUBTYPE OF (geometric_representation_item);
  orientation : direction;
  magnitude : length_measure;
WHERE
  WR1: magnitude >= 0.0;
END_ENTITY;

ENTITY placement
  SUPERTYPE OF (ONEOF (axis1_placement,
                       axis2_placement_2d,
                       axis2_placement_3d))
  SUBTYPE OF (geometric_representation_item);
  location : cartesian_point;
END_ENTITY;

ENTITY axis1_placement
  SUBTYPE OF (placement);
  axis : OPTIONAL direction;
DERIVE
  z : direction := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY axis2_placement_2d
  SUBTYPE OF (placement);
  ref_direction : OPTIONAL direction;
DERIVE
  p : LIST[2:2] OF direction := build_2axes(ref_direction);
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY axis2_placement_3d
  SUBTYPE OF (placement);
  axis : OPTIONAL direction;
  ref_direction : OPTIONAL direction;
DERIVE
  p : LIST[3:3] OF direction := build_axes(axis,ref_direction);
WHERE
  WR1: SELF\placement.location.dim = 3;
  WR2: (NOT (EXISTS (axis))) OR (axis.dim = 3);
  WR3: (NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3);
  WR4: (NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR (cross_product(axis,ref_direction).magnitude > 0.0);
END_ENTITY;

ENTITY cartesian_transformation_operator
  SUPERTYPE OF (ONEOF (cartesian_transformation_operator_2d,
                       cartesian_transformation_operator_3d))
  SUBTYPE OF (geometric_representation_item, functionally_defined_transformation);
  axis1 : OPTIONAL direction;
  axis2 : OPTIONAL direction;
  local_origin : cartesian_point;
  scale : OPTIONAL REAL;
DERIVE
  scl : REAL := NVL(scale, 1.0);
WHERE
  WR1: scl > 0.0;
END_ENTITY;

ENTITY cartesian_transformation_operator_3d
  SUBTYPE OF (cartesian_transformation_operator);
  axis3 : OPTIONAL direction;
DERIVE
  u : LIST[3:3] OF direction := base_axis(3,SELF\cartesian_transformation_operator.axis1, SELF\cartesian_transformation_operator.axis2,axis3);
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY cartesian_transformation_operator_2d
  SUBTYPE OF (cartesian_transformation_operator);
DERIVE
  u : LIST[2:2] OF direction := base_axis(2,SELF\cartesian_transformation_operator.axis1, SELF\cartesian_transformation_operator.axis2,?);
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY curve
  SUPERTYPE OF (ONEOF (line,
                       conic,
                       clothoid,
                       circular_involute,
                       pcurve,
                       surface_curve,
                       offset_curve_2d,
                       offset_curve_3d,
                       curve_replica))
  SUBTYPE OF (geometric_representation_item);
  --IP1:
  --IP2:
  --IP3:
END_ENTITY;

ENTITY line
  SUBTYPE OF (curve);
  pnt : cartesian_point;
  dir : vector;
WHERE
  WR1: dir.dim = pnt.dim;
END_ENTITY;

ENTITY conic
  SUPERTYPE OF (ONEOF (circle,
                       ellipse,
                       hyperbola,
                       parabola))
  SUBTYPE OF (curve);
  position : axis2_placement;
END_ENTITY;

ENTITY circle
  SUBTYPE OF (conic);
  radius : positive_length_measure;
END_ENTITY;

ENTITY ellipse
  SUBTYPE OF (conic);
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
END_ENTITY;

ENTITY hyperbola
  SUBTYPE OF (conic);
  semi_axis : positive_length_measure;
  semi_imag_axis : positive_length_measure;
END_ENTITY;

ENTITY parabola
  SUBTYPE OF (conic);
  focal_dist : length_measure;
WHERE
  WR1: focal_dist <> 0.0;
END_ENTITY;

ENTITY clothoid
  SUBTYPE OF (curve);
  position : axis2_placement;
  clothoid_constant : length_measure;
END_ENTITY;

ENTITY circular_involute
  SUBTYPE OF (curve);
  position : axis2_placement;
  base_radius : positive_length_measure;
END_ENTITY;

ENTITY bounded_curve
  SUPERTYPE OF (ONEOF (polyline,
                       b_spline_curve,
                       trimmed_curve,
                       bounded_pcurve,
                       bounded_surface_curve,
                       composite_curve,
                       locally_refined_spline_curve))
  SUBTYPE OF (curve);
  --IP1:
  --IP2:
END_ENTITY;

ENTITY polyline
  SUBTYPE OF (bounded_curve);
  points : LIST[2:?] OF cartesian_point;
END_ENTITY;

ENTITY b_spline_curve
  SUPERTYPE OF (ONEOF (uniform_curve,
                       b_spline_curve_with_knots,
                       quasi_uniform_curve,
                       bezier_curve)
               ANDOR rational_b_spline_curve)
  SUBTYPE OF (bounded_curve);
  degree : INTEGER;
  control_points_list : LIST[2:?] OF cartesian_point;
  curve_form : b_spline_curve_form;
  closed_curve : LOGICAL;
  self_intersect : LOGICAL;
DERIVE
  upper_index_on_control_points : INTEGER := (SIZEOF(control_points_list) - 1);
  control_points : ARRAY[0:upper_index_on_control_points] OF cartesian_point := list_to_array(control_points_list,0, upper_index_on_control_points);
WHERE
  WR1: ('GEOMETRY_SCHEMA.UNIFORM_CURVE' IN TYPEOF(self)) OR ('GEOMETRY_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(self)) OR ('GEOMETRY_SCHEMA.BEZIER_CURVE' IN TYPEOF(self)) OR ('GEOMETRY_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self));
END_ENTITY;

ENTITY b_spline_curve_with_knots
  SUBTYPE OF (b_spline_curve);
  knot_multiplicities : LIST[2:?] OF INTEGER;
  knots : LIST[2:?] OF parameter_value;
  knot_spec : knot_type;
DERIVE
  upper_index_on_knots : INTEGER := SIZEOF(knots);
WHERE
  WR1: constraints_param_b_spline(SELF.degree, upper_index_on_knots, upper_index_on_control_points, knot_multiplicities, knots);
  WR2: SIZEOF(knot_multiplicities) = upper_index_on_knots;
END_ENTITY;

ENTITY uniform_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY;

ENTITY quasi_uniform_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY;

ENTITY bezier_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY;

ENTITY rational_b_spline_curve
  SUBTYPE OF (b_spline_curve);
  weights_data : LIST[2:?] OF REAL;
DERIVE
  weights : ARRAY[0:upper_index_on_control_points] OF REAL := list_to_array(weights_data,0, upper_index_on_control_points);
WHERE
  WR1: SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve. control_points_list);
  WR2: curve_weights_positive(SELF);
END_ENTITY;

(* isogeometry additions  next 3 entities *)

ENTITY local_b_spline
  SUBTYPE OF(representation_item);
  degree : INTEGER;
  knots : LIST [2:?] OF INTEGER;
  multiplicities : LIST [2:?] OF INTEGER;
WHERE
  WR1 : degree > 0;
  WR2 : SIZEOF(knots) = SIZEOF(multiplicities);
  WR3 : constraints_param_local_b_spline(degree, knots, multiplicities);
END_ENTITY;

ENTITY locally_refined_spline_curve
SUBTYPE OF(bounded_curve);
 b_splines : LIST [2:?] OF local_b_spline;
 knot_values                    : spline_knot_values;
 control_points_list : LIST [2:?] OF cartesian_point;
 scaling_factors            : LIST [2:?] OF REAL;
 closed_curve : LOGICAL;
 locally_refined_spline_type : locally_refined_spline_type_enum;
 self_intersect : LOGICAL;
 domain : LIST [2:2] OF REAL;
WHERE
 WR1 : SIZEOF(b_splines) = SIZEOF(control_points_list);
 WR2 : SIZEOF(scaling_factors) = SIZEOF(control_points_list);
 WR3 : constraints_scaling(scaling_factors);
END_ENTITY;

ENTITY rational_locally_refined_spline_curve
SUBTYPE OF(locally_refined_spline_curve);
 weights_data : LIST [2:?] OF REAL;
WHERE
  WR1 : SIZEOF(weights_data) = SIZEOF(SELF\locally_refined_spline_curve.control_points_list);
  WR2 : weights_positive(weights_data);
END_ENTITY;

ENTITY trimmed_curve
  SUBTYPE OF (bounded_curve);
  basis_curve : curve;
  trim_1 : SET[1:2] OF trimming_select;
  trim_2 : SET[1:2] OF trimming_select;
  sense_agreement : BOOLEAN;
  master_representation : trimming_preference;
WHERE
  WR1: (HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
  WR2: (HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
  --IP1:
  --IP2:
  --IP3:
  --IP4:
  --IP5:
END_ENTITY;

ENTITY composite_curve
  SUBTYPE OF (bounded_curve);
  segments : LIST[1:?] OF composite_curve_segment;
  self_intersect : LOGICAL;
DERIVE
  n_segments : INTEGER := SIZEOF(segments);
  closed_curve : LOGICAL := segments[n_segments].transition <> discontinuous;
WHERE
  WR1: ((NOT closed_curve) AND (SIZEOF(QUERY(temp <* segments | temp.transition = discontinuous)) = 1)) OR ((closed_curve) AND (SIZEOF(QUERY(temp <* segments | temp.transition = discontinuous)) = 0));
END_ENTITY;

ENTITY composite_curve_segment
  SUBTYPE OF (founded_item);
  transition : transition_code;
  same_sense : BOOLEAN;
  parent_curve : curve;
INVERSE
  using_curves : BAG[1:?] OF composite_curve FOR segments;
WHERE
  WR1: ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve));
END_ENTITY;

ENTITY reparametrised_composite_curve_segment
  SUBTYPE OF (composite_curve_segment);
  param_length : parameter_value;
WHERE
  WR1: param_length > 0.0;
END_ENTITY;

ENTITY pcurve
  SUBTYPE OF (curve);
  basis_surface : surface;
  reference_to_curve : definitional_representation;
WHERE
  WR1: SIZEOF(reference_to_curve\representation.items) = 1;
  WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF (reference_to_curve\representation.items[1]);
  WR3: reference_to_curve\representation.items[1]\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY bounded_pcurve
  SUBTYPE OF (pcurve, bounded_curve);
WHERE
  WR1: ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\pcurve.reference_to_curve.items[1]));
END_ENTITY;

ENTITY surface_curve
  SUPERTYPE OF (ONEOF (intersection_curve,
                       seam_curve)
               ANDOR bounded_surface_curve)
  SUBTYPE OF (curve);
  curve_3d : curve;
  associated_geometry : LIST[1:2] OF pcurve_or_surface;
  master_representation : preferred_surface_curve_representation;
DERIVE
  basis_surface : SET[1:2] OF surface := get_basis_surface(SELF);
WHERE
  WR1: curve_3d.dim = 3;
  WR2: ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[1])) OR (master_representation <> pcurve_s1);
  WR3: ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[2])) OR (master_representation <> pcurve_s2);
  WR4: NOT ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(curve_3d));
  --IP1:
  --IP2:
END_ENTITY;

ENTITY intersection_curve
  SUBTYPE OF (surface_curve);
WHERE
  WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
  WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) <> associated_surface(SELF\surface_curve.associated_geometry[2]);
END_ENTITY;

ENTITY seam_curve
  SUBTYPE OF (surface_curve);
WHERE
  WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
  WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) = associated_surface(SELF\surface_curve.associated_geometry[2]);
  WR3: 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[1]);
  WR4: 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[2]);
END_ENTITY;

ENTITY bounded_surface_curve
  SUBTYPE OF (surface_curve, bounded_curve);
WHERE
  WR1: ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\surface_curve.curve_3d));
END_ENTITY;

ENTITY composite_curve_on_surface
  SUPERTYPE OF (boundary_curve)
  SUBTYPE OF (composite_curve);
DERIVE
  basis_surface : SET[0:2] OF surface := get_basis_surface(SELF);
WHERE
  WR1: SIZEOF(basis_surface) > 0;
  WR2: constraints_composite_curve_on_surface(SELF);
  --IP1:
END_ENTITY;

ENTITY offset_curve_2d
  SUBTYPE OF (curve);
  basis_curve : curve;
  distance : length_measure;
  self_intersect : LOGICAL;
WHERE
  WR1: basis_curve.dim = 2;
END_ENTITY;

ENTITY offset_curve_3d
  SUBTYPE OF (curve);
  basis_curve : curve;
  distance : length_measure;
  self_intersect : LOGICAL;
  ref_direction : direction;
WHERE
  WR1: (basis_curve.dim = 3) AND (ref_direction.dim = 3);
  --IP1:
END_ENTITY;

ENTITY curve_replica
  SUBTYPE OF (curve);
  parent_curve : curve;
  transformation : cartesian_transformation_operator;
WHERE
  WR1: transformation.dim = parent_curve.dim;
  WR2: acyclic_curve_replica (SELF, parent_curve);
END_ENTITY;

ENTITY surface
  SUPERTYPE OF (ONEOF (elementary_surface,
                       swept_surface,
                       bounded_surface,
                       offset_surface,
                       surface_replica))
  SUBTYPE OF (geometric_representation_item);
  --IP1:
  --IP2:
END_ENTITY;

ENTITY elementary_surface
  SUPERTYPE OF (ONEOF (plane,
                       cylindrical_surface,
                       conical_surface,
                       spherical_surface,
                       toroidal_surface))
  SUBTYPE OF (surface);
  position : axis2_placement_3d;
END_ENTITY;

ENTITY plane
  SUBTYPE OF (elementary_surface);
END_ENTITY;

ENTITY cylindrical_surface
  SUBTYPE OF (elementary_surface);
  radius : positive_length_measure;
END_ENTITY;

ENTITY conical_surface
  SUBTYPE OF (elementary_surface);
  radius : length_measure;
  semi_angle : plane_angle_measure;
WHERE
  WR1: radius >= 0.0;
END_ENTITY;

ENTITY spherical_surface
  SUBTYPE OF (elementary_surface);
  radius : positive_length_measure;
END_ENTITY;

ENTITY toroidal_surface
  SUBTYPE OF (elementary_surface);
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
END_ENTITY;

ENTITY degenerate_toroidal_surface
  SUBTYPE OF (toroidal_surface);
  select_outer : BOOLEAN;
WHERE
  WR1: major_radius < minor_radius;
END_ENTITY;

ENTITY dupin_cyclide_surface
  SUBTYPE OF (elementary_surface);
  generalised_major_radius : positive_length_measure;
  generalised_minor_radius : positive_length_measure;
  skewness : length_measure;
WHERE
  WR1: skewness >= 0.0;
END_ENTITY;

ENTITY swept_surface
  SUPERTYPE OF (ONEOF (surface_of_linear_extrusion,
                       surface_of_revolution,
                       surface_curve_swept_surface,
                       fixed_reference_swept_surface))
  SUBTYPE OF (surface);
  swept_curve : curve;
END_ENTITY;

ENTITY surface_of_linear_extrusion
  SUBTYPE OF (swept_surface);
  extrusion_axis : vector;
  --IP1:
END_ENTITY;

ENTITY surface_of_revolution
  SUBTYPE OF (swept_surface);
  axis_position : axis1_placement;
DERIVE
  axis_line : line := representation_item('')|| geometric_representation_item()|| curve()|| line(axis_position.location, representation_item('')|| geometric_representation_item()|| vector(axis_position.z, 1.0));
  --IP1:
  --IP2:
END_ENTITY;

ENTITY surface_curve_swept_surface
  SUBTYPE OF (swept_surface);
  directrix : curve;
  reference_surface : surface;
WHERE
  WR1: (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR (reference_surface IN (directrix\surface_curve.basis_surface));
  --IP1:
  --IP2:
  END_ENTITY;

ENTITY fixed_reference_swept_surface
  SUBTYPE OF (swept_surface);
  directrix : curve;
  fixed_reference : direction;
  --IP1:
  --IP2:
END_ENTITY;

ENTITY bounded_surface
  SUPERTYPE OF (ONEOF (b_spline_surface,
                       rectangular_trimmed_surface,
                       curve_bounded_surface,
                       rectangular_composite_surface,
                       locally_refined_spline_surface))
  SUBTYPE OF (surface);
  --IP1:
  --IP2:
END_ENTITY;

ENTITY b_spline_surface
  SUPERTYPE OF (ONEOF (b_spline_surface_with_knots,
                       uniform_surface,
                       quasi_uniform_surface,
                       bezier_surface)
               ANDOR rational_b_spline_surface)
  SUBTYPE OF (bounded_surface);
  u_degree : INTEGER;
  v_degree : INTEGER;
  control_points_list : LIST[2:?] OF LIST[2:?] OF cartesian_point;
  surface_form : b_spline_surface_form;
  u_closed : LOGICAL;
  v_closed : LOGICAL;
  self_intersect : LOGICAL;
DERIVE
  u_upper : INTEGER := SIZEOF(control_points_list) - 1;
  v_upper : INTEGER := SIZEOF(control_points_list[1]) - 1;
  control_points : ARRAY[0:u_upper] OF ARRAY[0:v_upper] OF cartesian_point := make_array_of_array(control_points_list, 0,u_upper,0,v_upper);
WHERE
  WR1: ('GEOMETRY_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.BEZIER_SURFACE' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY;

ENTITY b_spline_surface_with_knots
  SUBTYPE OF (b_spline_surface);
  u_multiplicities : LIST[2:?] OF INTEGER;
  v_multiplicities : LIST[2:?] OF INTEGER;
  u_knots : LIST[2:?] OF parameter_value;
  v_knots : LIST[2:?] OF parameter_value;
  knot_spec : knot_type;
DERIVE
  knot_u_upper : INTEGER := SIZEOF(u_knots);
  knot_v_upper : INTEGER := SIZEOF(v_knots);
WHERE
  WR1: constraints_param_b_spline(SELF\b_spline_surface.u_degree, knot_u_upper, SELF\b_spline_surface.u_upper, u_multiplicities, u_knots);
  WR2: constraints_param_b_spline(SELF\b_spline_surface.v_degree, knot_v_upper, SELF\b_spline_surface.v_upper, v_multiplicities, v_knots);
  WR3: SIZEOF(u_multiplicities) = knot_u_upper;
  WR4: SIZEOF(v_multiplicities) = knot_v_upper;
END_ENTITY;

ENTITY uniform_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY;

ENTITY quasi_uniform_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY;

ENTITY bezier_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY;

ENTITY rational_b_spline_surface
  SUBTYPE OF (b_spline_surface);
  weights_data : LIST[2:?] OF LIST[2:?] OF REAL;
DERIVE
  weights : ARRAY[0:u_upper] OF ARRAY[0:v_upper] OF REAL := make_array_of_array(weights_data,0,u_upper,0,v_upper);
WHERE
  WR1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_surface.control_points_list[1]));
  WR2: surface_weights_positive(SELF);
END_ENTITY;

(* isogeometry additions 2 surface entities *)

ENTITY locally_refined_spline_surface
SUBTYPE OF(bounded_surface);
 u_b_splines : LIST [4:?] OF local_b_spline;
 v_b_splines                : LIST [4:?] OF local_b_spline;
 u_knots                    : spline_knot_values;
 v_knots                    : spline_knot_values;
 control_points_list : LIST [4:?] OF cartesian_point;
 scaling_factors            : LIST [4:?] OF REAL;
 linearly_independent : linearly_independent_enum;
 locally_refined_spline_type : locally_refined_spline_type_enum;
 self_intersect : LOGICAL;
 u_closed : LOGICAL;
 v_closed : LOGICAL;
 domain : LIST [2:2] OF LIST[2:2] OF  REAL;
WHERE
 WR1 : SIZEOF(u_b_splines) = SIZEOF(control_points_list);
 WR2 : SIZEOF(v_b_splines) = SIZEOF(control_points_list);
 WR3 : SIZEOF(scaling_factors) = SIZEOF(control_points_list);
 WR4 : constraints_scaling(scaling_factors);
END_ENTITY;


ENTITY rational_locally_refined_spline_surface
SUBTYPE OF(locally_refined_spline_surface);
 weights_data : LIST [4:?] OF REAL;
WHERE
 WR1 : SIZEOF(weights_data) = SIZEOF(SELF\locally_refined_spline_surface.control_points_list);
 WR2 : weights_positive(weights_data);
END_ENTITY;


ENTITY rectangular_trimmed_surface
  SUBTYPE OF (bounded_surface);
  basis_surface : surface;
  u1 : parameter_value;
  u2 : parameter_value;
  v1 : parameter_value;
  v2 : parameter_value;
  usense : BOOLEAN;
  vsense : BOOLEAN;
WHERE
  WR1: u1 <> u2;
  WR2: v1 <> v2;
  WR3: (('GEOMETRY_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface)) AND (NOT ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(basis_surface)))) OR ('GEOMETRY_SCHEMA.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface)) OR (usense = (u2 > u1));
  WR4: (('GEOMETRY_SCHEMA.SPHERICAL_SURFACE' IN TYPEOF(basis_surface)) OR ('GEOMETRY_SCHEMA.TOROIDAL_SURFACE' IN TYPEOF(basis_surface))) OR (vsense = (v2 > v1));
  --IP1:
END_ENTITY;

ENTITY curve_bounded_surface
  SUBTYPE OF (bounded_surface);
  basis_surface : surface;
  boundaries : SET[1:?] OF boundary_curve;
  implicit_outer : BOOLEAN;
WHERE
  WR1: (NOT implicit_outer) OR (SIZEOF (QUERY (temp <* boundaries | 'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) = 0);
  WR2: (NOT(implicit_outer)) OR ('GEOMETRY_SCHEMA.BOUNDED_SURFACE' IN TYPEOF(basis_surface));
  WR3: SIZEOF(QUERY(temp <* boundaries | 'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) <= 1;
  WR4: SIZEOF(QUERY(temp <* boundaries | (temp\composite_curve_on_surface.basis_surface [1] <> basis_surface))) = 0;
  --IP1:
  --IP2:
  --IP3:
END_ENTITY;

ENTITY boundary_curve
  SUBTYPE OF (composite_curve_on_surface);
WHERE
  WR1: SELF\composite_curve.closed_curve;
END_ENTITY;

ENTITY outer_boundary_curve
  SUBTYPE OF (boundary_curve);
END_ENTITY;

ENTITY rectangular_composite_surface
  SUBTYPE OF (bounded_surface);
  segments : LIST[1:?] OF LIST[1:?] OF surface_patch;
DERIVE
  n_u : INTEGER := SIZEOF(segments);
  n_v : INTEGER := SIZEOF(segments[1]);
WHERE
  WR1: SIZEOF(QUERY (s <* segments | n_v <> SIZEOF (s))) = 0;
  WR2: constraints_rectangular_composite_surface(SELF);
  --IP1:
END_ENTITY;

ENTITY surface_patch
  SUBTYPE OF (founded_item);
  parent_surface : bounded_surface;
  u_transition : transition_code;
  v_transition : transition_code;
  u_sense : BOOLEAN;
  v_sense : BOOLEAN;
INVERSE
  using_surfaces : BAG[1:?] OF rectangular_composite_surface FOR segments;
WHERE
  WR1: (NOT ('GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE' IN TYPEOF(parent_surface)));
END_ENTITY;

ENTITY offset_surface
  SUBTYPE OF (surface);
  basis_surface : surface;
  distance : length_measure;
  self_intersect : LOGICAL;
END_ENTITY;

ENTITY oriented_surface
  SUBTYPE OF (surface);
  orientation : BOOLEAN;
END_ENTITY;

ENTITY surface_replica
  SUBTYPE OF (surface);
  parent_surface : surface;
  transformation : cartesian_transformation_operator_3d;
WHERE
  WR1: acyclic_surface_replica(SELF, parent_surface);
END_ENTITY;

ENTITY volume
  SUPERTYPE OF (ONEOF (block_volume,
                       wedge_volume,
                       spherical_volume,
                       cylindrical_volume,
                       eccentric_conical_volume,
                       toroidal_volume,
                       pyramid_volume,
                       b_spline_volume,
                       ellipsoid_volume,
                       tetrahedron_volume,
                       hexahedron_volume,
                       locally_refined_spline_volume))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY block_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  x : positive_length_measure;
  y : positive_length_measure;
  z : positive_length_measure;
END_ENTITY;

ENTITY wedge_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  x : positive_length_measure;
  y : positive_length_measure;
  z : positive_length_measure;
  ltx : length_measure;
WHERE
  WR1: ((0.0 <= ltx) AND (ltx < x));
END_ENTITY;

ENTITY pyramid_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
  height : positive_length_measure;
END_ENTITY;

ENTITY tetrahedron_volume
  SUBTYPE OF (volume);
  point_1 : cartesian_point;
  point_2 : cartesian_point;
  point_3 : cartesian_point;
  point_4 : cartesian_point;
WHERE
  WR1: point_1.dim = 3;
  WR2: above_plane(point_1, point_2, point_3, point_4) <> 0.0;
END_ENTITY;

ENTITY hexahedron_volume
  SUBTYPE OF (volume);
  points : LIST[8:8] OF cartesian_point;
WHERE
  WR1: above_plane(points[1], points[2], points[3], points[4]) = 0.0;
  WR2: above_plane(points[5], points[8], points[7], points[6]) = 0.0;
  WR3: above_plane(points[1], points[4], points[8], points[5]) = 0.0;
  WR4: above_plane(points[4], points[3], points[7], points[8]) = 0.0;
  WR5: above_plane(points[3], points[2], points[6], points[7]) = 0.0;
  WR6: above_plane(points[1], points[5], points[6], points[2]) = 0.0;
  WR7: same_side([points[1], points[2], points[3]], [points[5], points[6], points[7], points[8]]);
  WR8: same_side([points[1], points[4], points[8]], [points[3], points[7], points[6], points[2]]);
  WR9: same_side([points[1], points[2], points[5]], [points[3], points[7], points[8], points[4]]);
  WR10: same_side([points[5], points[6], points[7]], [points[1], points[2], points[3], points[4]]);
  WR11: same_side([points[3], points[7], points[6]], [points[1], points[4], points[8], points[5]]);
  WR12: same_side([points[3], points[7], points[8]], [points[1], points[5], points[6], points[2]]);
  WR13: points[1].dim = 3;
END_ENTITY;

ENTITY spherical_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  radius : positive_length_measure;
END_ENTITY;

ENTITY cylindrical_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  radius : positive_length_measure;
  height : positive_length_measure;
END_ENTITY;

ENTITY eccentric_conical_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  height : positive_length_measure;
  x_offset : length_measure;
  y_offset : length_measure;
  ratio : REAL;
WHERE
  WR1: ratio >= 0.0;
END_ENTITY;

ENTITY toroidal_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
WHERE
  WR1: minor_radius < major_radius;
END_ENTITY;

ENTITY ellipsoid_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  semi_axis_3 : positive_length_measure;
END_ENTITY;

ENTITY b_spline_volume
  SUPERTYPE OF (ONEOF (b_spline_volume_with_knots,
                       uniform_volume,
                       quasi_uniform_volume,
                       bezier_volume)
               ANDOR rational_b_spline_volume)
  SUBTYPE OF (volume);
  u_degree : INTEGER;
  v_degree : INTEGER;
  w_degree : INTEGER;
  control_points_list : LIST[2:?] OF LIST[2:?] OF LIST[2:?] OF cartesian_point;
DERIVE
  u_upper : INTEGER := SIZEOF(control_points_list) - 1;
  v_upper : INTEGER := SIZEOF(control_points_list[1]) - 1;
  w_upper : INTEGER := SIZEOF(control_points_list[1][1]) - 1;
  control_points : ARRAY[0:u_upper] OF ARRAY[0:v_upper] OF ARRAY[0:w_upper] OF cartesian_point := make_array_of_array_of_array (control_points_list, 0,u_upper,0,v_upper, 0,w_upper );
WHERE
  WR1: ('GEOMETRY_SCHEMA.BEZIER_VOLUME' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.UNIFORM_VOLUME' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.QUASI_UNIFORM_VOLUME' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.B_SPLINE_VOLUME_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY;

ENTITY b_spline_volume_with_knots
  SUBTYPE OF (b_spline_volume);
  u_multiplicities : LIST[2:?] OF INTEGER;
  v_multiplicities : LIST[2:?] OF INTEGER;
  w_multiplicities : LIST[2:?] OF INTEGER;
  u_knots : LIST[2:?] OF parameter_value;
  v_knots : LIST[2:?] OF parameter_value;
  w_knots : LIST[2:?] OF parameter_value;
DERIVE
  knot_u_upper : INTEGER := SIZEOF(u_knots);
  knot_v_upper : INTEGER := SIZEOF(v_knots);
  knot_w_upper : INTEGER := SIZEOF(w_knots);
WHERE
  WR1: constraints_param_b_spline(SELF\b_spline_volume.u_degree, knot_u_upper, SELF\b_spline_volume.u_upper, u_multiplicities, u_knots);
  WR2: constraints_param_b_spline(SELF\b_spline_volume.v_degree, knot_v_upper, SELF\b_spline_volume.v_upper, v_multiplicities, v_knots);
  WR3: constraints_param_b_spline(SELF\b_spline_volume.w_degree, knot_w_upper, SELF\b_spline_volume.w_upper, w_multiplicities, w_knots);
  WR4: SIZEOF(u_multiplicities) = knot_u_upper;
  WR5: SIZEOF(v_multiplicities) = knot_v_upper;
  WR6: SIZEOF(w_multiplicities) = knot_w_upper;
END_ENTITY;

ENTITY bezier_volume
  SUBTYPE OF (b_spline_volume);
END_ENTITY;

ENTITY uniform_volume
  SUBTYPE OF (b_spline_volume);
END_ENTITY;

ENTITY quasi_uniform_volume
  SUBTYPE OF (b_spline_volume);
END_ENTITY;

ENTITY rational_b_spline_volume
  SUBTYPE OF (b_spline_volume);
  weights_data : LIST[2:?] OF LIST[2:?] OF LIST[2:?] OF REAL;
DERIVE
  weights : ARRAY[0:u_upper] OF ARRAY[0:v_upper] OF ARRAY[0:w_upper] OF REAL := make_array_of_array_of_array (weights_data,0,u_upper,0,v_upper,0,w_upper);
WHERE
  WR1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_volume.control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_volume.control_points_list[1])) AND (SIZEOF(weights_data[1][1]) = SIZEOF(SELF\b_spline_volume.control_points_list[1][1]));
  WR2: volume_weights_positive(SELF);
END_ENTITY;

(* isogeometry additions 2 volume entities *)

ENTITY locally_refined_spline_volume
SUBTYPE OF(volume);
 u_b_splines : LIST [8:?] OF local_b_spline;
 v_b_splines : LIST [8:?] OF local_b_spline;
 w_b_splines : LIST [8:?] OF local_b_spline;
 u_knots                    : spline_knot_values;
 v_knots                    : spline_knot_values;
 w_knots                    : spline_knot_values;
 control_points_list : LIST [8:?] OF cartesian_point;
 scaling_factors            : LIST [8:?] OF REAL;
 linearly_independent : linearly_independent_enum;
 locally_refined_spline_type : locally_refined_spline_type_enum;
 domain : LIST [3:3] OF LIST[2:2] OF  REAL;
WHERE
 WR1 : SIZEOF(u_b_splines) = SIZEOF(control_points_list);
 WR2 : SIZEOF(v_b_splines) = SIZEOF(control_points_list);
 WR3 : SIZEOF(w_b_splines) = SIZEOF(control_points_list);
 WR4 : SIZEOF(scaling_factors) = SIZEOF(control_points_list);
 WR5 : constraints_scaling(scaling_factors);  
END_ENTITY;


ENTITY rational_locally_refined_spline_volume
SUBTYPE OF(locally_refined_spline_volume);
 weights_data : LIST [8:?] OF REAL;
WHERE
 WR1  : SIZEOF(weights_data) = SIZEOF(SELF\locally_refined_spline_volume.control_points_list);
 WR2  : weights_positive(weights_data);
END_ENTITY;


(* changed rule July 2020 *)
RULE compatible_dimension FOR (cartesian_point,
                               direction,
                               geometric_representation_context);
  WHERE
 WR1: ((SIZEOF(cartesian_point) = 0) AND (SIZEOF(direction) = 0) AND (SIZEOF(geometric_representation_context) = 0)) OR
       check_geometric_dimension(cartesian_point, direction, geometric_representation_context);
END_RULE;

(* 2 new functions neede for revised rule *)

FUNCTION check_geometric_dimension (
           capt: SET [0:?] OF cartesian_point;
           dir : SET [0:?] OF direction;
           grc : SET [1:?] OF geometric_representation_context) : BOOLEAN;
(* Determine whether there are mixed dimensions in the contexts.
   If not, only one check of dimensionality is needed per instance of CAPT/DIR
   against this dimension value, not checks against each representation that it
   is referenced by.
   Find for all CAPT and DIR all representations that they are referenced by.
   Return FALSE for the first CAPT or DIR that is not referenced (founded).
   Ensure that the dimensions of all representations are identical to the CAPT/DIR
   dimension. Return FALSE at the first mismatch.
 *)
LOCAL
  globaldim    : INTEGER := 0; (* means mixed dimensionality *)
  reps         : SET [0:?] OF representation := [];
  result       : BOOLEAN := TRUE; (* means no error *)
END_LOCAL;

globaldim:= geometric_dimensionalities_in_contexts(grc);

IF (globaldim > 0) then
(* Same dimension for all contexts; only one check needed. *)
  IF (SIZEOF(capt) > 0) THEN
    REPEAT i := 1 TO HIINDEX(capt);
      IF (HIINDEX(capt[i].coordinates) <> globaldim) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  IF (SIZEOF(dir) > 0) THEN
    REPEAT i := 1 TO HIINDEX(dir);
      IF  (HIINDEX(dir[i].direction_ratios) <> globaldim) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN(result);
ELSE
(*  globaldim=0, mixed dimensions for contexts; check needed for context of each representation in which gri is used. *)
  IF (SIZEOF(capt) > 0) THEN
    REPEAT i := 1 TO HIINDEX(capt);
      reps := using_representations(capt[i]);
      IF (SIZEOF(reps) > 0) THEN
        REPEAT j := 1 TO HIINDEX(reps);
          IF (HIINDEX(capt[i].coordinates) <> reps[j].context_of_items\geometric_representation_context.coordinate_space_dimension) THEN
            RETURN(FALSE);
          END_IF;
        END_REPEAT;
      ELSE (* zero reps *)
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  IF (SIZEOF(dir) > 0) THEN
    REPEAT i := 1 TO HIINDEX(dir);
    (*  globaldim=0, Mixed dimensions for  contexts, check needed for context of each representation in which gri is used *)
      reps := using_representations(dir[i]);
      IF (SIZEOF(reps) > 0) THEN
        REPEAT j := 1 TO HIINDEX(reps);
          IF (HIINDEX(dir[i].direction_ratios) <> reps[j].context_of_items\geometric_representation_context.coordinate_space_dimension) THEN
            RETURN(FALSE);
          END_IF;
        END_REPEAT;
      ELSE (* zero reps *)
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
END_IF;

RETURN(result);

END_FUNCTION;

FUNCTION geometric_dimensionalities_in_contexts(grcs: SET [1:?] OF geometric_representation_context) : INTEGER;
(* There may be three types of geometric dimensionality: 1d, 2d or 3d.
   This function determines how many of those are in the input set.
   If there is one type only, the number 1, 2 or 3 is returned depending on the type of dimensionality.
   Otherwise, the number 0 is returned.
 *)
LOCAL
  grcs_1d : INTEGER := 0;
  grcs_2d : INTEGER := 0;
  grcs_3d : INTEGER := 0;
END_LOCAL;

IF (SIZEOF(grcs) = 1) THEN
  (* only one geometric_context, will be one type of dimension anyway *)
  RETURN(grcs[1]\geometric_representation_context.coordinate_space_dimension);
ELSE
  REPEAT i := 1 TO HIINDEX(grcs);
    IF (grcs[i]\geometric_representation_context.coordinate_space_dimension = 1) THEN
      grcs_1d := grcs_1d + 1;
    ELSE
      IF (grcs[i]\geometric_representation_context.coordinate_space_dimension = 2) THEN
        grcs_2d := grcs_2d + 1;
      ELSE
        IF (grcs[i]\geometric_representation_context.coordinate_space_dimension = 3) THEN
          grcs_3d := grcs_3d + 1;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_IF;

IF (grcs_1d + grcs_2d = 0) THEN
  RETURN(3);
ELSE
  IF (grcs_1d + grcs_3d = 0) THEN
    RETURN(2);
  ELSE
    IF (grcs_2d + grcs_3d = 0) THEN
      RETURN(1);
    ELSE
      RETURN(0); (* multiple dimensions *)
    END_IF;
  END_IF;
END_IF;

END_FUNCTION;


FUNCTION above_plane
 (p1 : cartesian_point; p2 : cartesian_point; p3 : cartesian_point; p4 : cartesian_point) : REAL; 
LOCAL
     dir2, dir3, dir4 : direction :=
                 dummy_gri || direction([1.0, 0.0, 0.0]);
     val, mag         : REAL;
   END_LOCAL;

   IF (p1.dim <> 3) THEN
     RETURN(?);
   END_IF;
   REPEAT i := 1 TO 3;
     dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
     dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
     dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
     mag := dir4.direction_ratios[i]*dir4.direction_ratios[i];
  END_REPEAT;
  mag := sqrt(mag);
  val := mag*dot_product(dir4, cross_product(dir2, dir3).orientation);
  RETURN(val);
END_FUNCTION; 

FUNCTION acyclic_curve_replica
 (rep : curve_replica; parent : curve) : BOOLEAN; 
IF NOT (('GEOMETRY_SCHEMA.CURVE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type curve_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same curve_replica, otherwise,
   call function again with the parents own parent_curve.     *)
    ELSE
    RETURN(acyclic_curve_replica(rep,
               parent\curve_replica.parent_curve));
    END_IF;
  END_FUNCTION; 

FUNCTION acyclic_point_replica
 (rep : point_replica; parent : point) : BOOLEAN; 
IF NOT (('GEOMETRY_SCHEMA.POINT_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type point_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same point_replica, otherwise,
   call function again with the parents own parent_pt.     *)
    ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
    END_IF;
  END_FUNCTION; 

FUNCTION acyclic_surface_replica
 (rep : surface_replica; parent : surface) : BOOLEAN; 
IF NOT (('GEOMETRY_SCHEMA.SURFACE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type surface_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same surface_replica, otherwise,
   call function again with the parents own parent_surface.     *)
    ELSE RETURN(acyclic_surface_replica(rep,
                   parent\surface_replica.parent_surface));
    END_IF;
  END_FUNCTION; 

FUNCTION associated_surface
 (arg : pcurve_or_surface) : surface; 
LOCAL
     surf : surface;
   END_LOCAL;
   
   IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(arg) THEN
     surf := arg\pcurve.basis_surface;
   ELSE
     surf := arg;
   END_IF;
   RETURN(surf);
 END_FUNCTION; 

FUNCTION base_axis
 (dim : INTEGER; axis1 : direction; axis2 : direction; axis3 : direction) : LIST[2:3] OF direction; 
LOCAL
    u      : LIST [2:3] OF direction;
    factor : REAL;
    d1, d2 : direction;
  END_LOCAL;
  
  IF (dim = 3) THEN
    d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1,axis1);
    u := [d2, second_proj_axis(d1,d2,axis2), d1];
  ELSE
     IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1, orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2,u[2]);
        IF (factor < 0.0) THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1), d1]; 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                direction([0.0, 1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);
END_FUNCTION; 

FUNCTION build_2axes
 (ref_direction : direction) : LIST[2:2] OF direction; 
LOCAL
     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));
   END_LOCAL;

   RETURN([d, orthogonal_complement(d)]);END_FUNCTION; 

FUNCTION build_axes
 (axis : direction; ref_direction : direction) : LIST[3:3] OF direction; 
LOCAL
       d1, d2 : direction;
     END_LOCAL;
    d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1, ref_direction);
    RETURN([d2, normalise(cross_product(d1,d2))\vector.orientation, d1]);
  END_FUNCTION; 


FUNCTION constraints_composite_curve_on_surface
 (c : composite_curve_on_surface) : BOOLEAN; 
LOCAL
     n_segments : INTEGER := SIZEOF(c.segments);
   END_LOCAL;
        
   REPEAT k := 1 TO n_segments;
     IF (NOT('GEOMETRY_SCHEMA.PCURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN
           TYPEOF(c\composite_curve.segments[k].parent_curve)))  THEN
       RETURN (FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);
 END_FUNCTION; 

FUNCTION constraints_param_b_spline
 (degree : INTEGER; up_knots : INTEGER; up_cp : INTEGER; knot_mult : LIST[0:?] OF INTEGER; knots : LIST[0:?] OF parameter_value) : BOOLEAN; 
LOCAL
     result  : BOOLEAN := TRUE;
     k, sum  : INTEGER;
   END_LOCAL;
   
   (* Find sum of knot multiplicities. *)
   sum := knot_mult[1];
   
   REPEAT i := 2 TO up_knots;
     sum := sum + knot_mult[i];
   END_REPEAT;
   
   (* Check limits holding for all B-spline parametrisations *)
   IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR
         (sum <> (degree + up_cp + 2)) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
   
   k := knot_mult[1];
   
   IF (k < 1) OR (k > degree + 1) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
      
   REPEAT i := 2 TO up_knots;
     IF (knot_mult[i] < 1) OR (knots[i] <= knots[i-1]) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     k := knot_mult[i];
     
     IF (i < up_knots) AND (k > degree) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     IF (i = up_knots) AND (k > degree + 1) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION; 

FUNCTION constraints_rectangular_composite_surface
 (s : rectangular_composite_surface) : BOOLEAN; 
REPEAT i := 1 TO s.n_u;
       REPEAT j := 1 TO s.n_v;
         IF NOT (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface)) OR
                 ('GEOMETRY_SCHEMA.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface))) THEN
           RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;

   (* Check the transition codes, omitting the last row or column *)
   REPEAT i := 1 TO s.n_u-1;
     REPEAT j := 1 TO s.n_v;
       IF s.segments[i][j].u_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   
   REPEAT i := 1 TO s.n_u;
     REPEAT j := 1 TO s.n_v-1;
       IF s.segments[i][j].v_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(TRUE);
 END_FUNCTION; 

FUNCTION cross_product
 (arg1 : direction; arg2 : direction) : vector; 
LOCAL
    mag    : REAL;
    res    : direction;
    v1,v2  : LIST[3:3] OF REAL;
    result : vector;
  END_LOCAL;
  
  IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
     ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;
      v2  := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
            (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
      mag := 0.0;
      REPEAT i := 1 TO 3;
        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
      END_REPEAT;
      IF (mag > 0.0) THEN
        result := dummy_gri || vector(res, SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1, 0.0);
      END_IF;
      RETURN(result);
    END;
  END_IF;
 END_FUNCTION; 

FUNCTION curve_weights_positive
 (b : rational_b_spline_curve) : BOOLEAN; 
LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT i := 0 TO b.upper_index_on_control_points;
     IF b.weights[i] <= 0.0  THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);END_FUNCTION; 

FUNCTION default_b_spline_curve_weights
 (up_cp : INTEGER) : ARRAY[0:up_cp] OF REAL; 
RETURN([1:up_cp + 1]);END_FUNCTION; 

FUNCTION default_b_spline_knot_mult
 (degree : INTEGER; up_knots : INTEGER; uniform : knot_type) : LIST[2:?] OF INTEGER; 
LOCAL
     knot_mult : LIST [1:up_knots] OF INTEGER;
   END_LOCAL;
        
   IF uniform = uniform_knots THEN
     knot_mult := [1:up_knots];
   ELSE
     IF uniform = quasi_uniform_knots THEN
       knot_mult := [1:up_knots];
       knot_mult[1] := degree + 1;
       knot_mult[up_knots] := degree + 1;
     ELSE
       IF uniform = piecewise_bezier_knots THEN
         knot_mult := [degree:up_knots];
         knot_mult[1] := degree + 1;
         knot_mult[up_knots] := degree + 1;
       ELSE
         knot_mult := [0:up_knots];
       END_IF;
     END_IF;
   END_IF;
   RETURN(knot_mult);
 END_FUNCTION; 

FUNCTION default_b_spline_knots
 (degree : INTEGER; up_knots : INTEGER; uniform : knot_type) : LIST[2:?] OF parameter_value; 
LOCAL
    knots  : LIST [1:up_knots] OF parameter_value := [0:up_knots];
    ishift : INTEGER := 1;
  END_LOCAL;

  IF (uniform = uniform_knots) THEN
     ishift := degree + 1;
  END_if;
  IF (uniform = uniform_knots) OR 
     (uniform = quasi_uniform_knots) OR
     (uniform = piecewise_bezier_knots) THEN
    
    REPEAT i := 1 TO up_knots;
      knots[i] := i - ishift;
    END_REPEAT;
  END_IF;
  RETURN(knots);
END_FUNCTION; 

FUNCTION default_b_spline_surface_weights
 (u_upper : INTEGER; v_upper : INTEGER) : ARRAY[0:u_upper] OF ARRAY[0:v_upper] OF REAL; 
RETURN([[1:v_upper + 1]:u_upper +1]);END_FUNCTION; 

FUNCTION dimension_of
 (item : geometric_representation_item) : dimension_count; 
LOCAL
    x   : SET OF representation;
    y   : representation_context;
    dim : dimension_count;
  END_LOCAL;
  -- For cartesian_point, direction, or vector dimension is determined by
  -- counting components.
    IF 'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF(item) THEN
       dim := SIZEOF(item\cartesian_point.coordinates);
       RETURN(dim);
    END_IF;
    IF 'GEOMETRY_SCHEMA.DIRECTION' IN TYPEOF(item) THEN
       dim := SIZEOF(item\direction.direction_ratios);
       RETURN(dim);
    END_IF;
    IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(item) THEN
       dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
       RETURN(dim);
    END_IF;
  -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 

  x := using_representations(item);

  -- Determines the dimension_count of the 
  -- geometric_representation_context.
  -- The SET x is non-empty for legal instances since this is required by WR1 of
  -- representation_item.
    IF (SIZEOF(x) > 0) THEN
       y := x[1].context_of_items;
      dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN (dim);
    ELSE
      RETURN(?);
    -- mark error by returning indeterminate result
   END_IF;
 END_FUNCTION; 

FUNCTION dot_product
 (arg1 : direction; arg2 : direction) : REAL; 
LOCAL
     scalar : REAL;
     vec1, vec2: direction;
     ndim : INTEGER;
   END_LOCAL;
   
   IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
     scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
   ELSE
     IF (arg1.dim <> arg2.dim) THEN
       scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
     ELSE
       BEGIN
         vec1   := normalise(arg1);
         vec2   := normalise(arg2);
         ndim   := arg1.dim;
         scalar := 0.0;
         REPEAT  i := 1 TO ndim;
           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];
         END_REPEAT;
       END;
     END_IF;
   END_IF;
   RETURN (scalar);END_FUNCTION; 

FUNCTION first_proj_axis
 (z_axis : direction; arg : direction) : direction; 
LOCAL
    x_axis : direction;
    v      : direction;
    z      : direction;
    x_vec  : vector;
  END_LOCAL;
  
  IF (NOT EXISTS(z_axis)) THEN
    RETURN (?) ;
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF ((z.direction_ratios <> [1.0,0.0,0.0]) AND
          (z.direction_ratios <> [-1.0,0.0,0.0]))  THEN
        v :=  dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF  (arg.dim <> 3) THEN
        RETURN (?) ;
      END_IF;
      IF ((cross_product(arg,z).magnitude) = 0.0) THEN
        RETURN (?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);
END_FUNCTION; 

FUNCTION get_basis_surface
 (c : curve_on_surface) : SET[0:2] OF surface; 
LOCAL
    surfs  : SET[0:2] OF surface;
    n      : INTEGER;
  END_LOCAL;
  surfs := [];
  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (c) THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF (c) THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n;
      surfs := surfs +
                associated_surface(c\surface_curve.associated_geometry[i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF (c) THEN
   (* For a composite_curve_on_surface the basis_surface is the intersection
    of the basis_surfaces of all the segments. *)
     n := SIZEOF(c\composite_curve.segments);
     surfs := get_basis_surface(
                     c\composite_curve.segments[1].parent_curve);
     IF n > 1 THEN
       REPEAT i := 2 TO n;
         surfs := surfs * get_basis_surface(
                  c\composite_curve.segments[i].parent_curve);
       END_REPEAT;
     END_IF;

  END_IF;
  RETURN(surfs);
END_FUNCTION; 

FUNCTION list_to_array
 (lis : LIST[0:?] OF GENERIC : T; low : INTEGER; u : INTEGER) : ARRAY[low:u] OF GENERIC : T; 
LOCAL
     n   : INTEGER;
     res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
      
   n := SIZEOF(lis);
   IF (n <> (u-low +1)) THEN
     RETURN(?);
   ELSE
     res := [lis[1] : n];
     REPEAT i := 2 TO n;
       res[low+i-1] := lis[i];
     END_REPEAT;
     RETURN(res);
   END_IF;
 END_FUNCTION; 

FUNCTION make_array_of_array
 (lis : LIST[1:?] OF LIST[1:?] OF GENERIC : T; low1 : INTEGER; u1 : INTEGER; low2 : INTEGER; u2 : INTEGER) : ARRAY[low1:u1] OF ARRAY[low2:u2] OF GENERIC : T; 
LOCAL
     res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   END_LOCAL;

(* Check input dimensions for consistency *)
   IF (u1-low1+1) <> SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2 - low2 + 1 ) <> SIZEOF(lis[1]) THEN
     RETURN (?) ;
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [list_to_array(lis[1], low2, u2) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) <> SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;     
     res[low1+i-1] := list_to_array(lis[i], low2, u2);
   END_REPEAT; 
   
   RETURN (res);
 END_FUNCTION; 

FUNCTION make_array_of_array_of_array
 (lis : LIST[1:?] OF LIST[1:?] OF LIST[1:?] OF GENERIC : T; low1 : INTEGER; u1 : INTEGER; low2 : INTEGER; u2 : INTEGER; low3 : INTEGER; u3 : INTEGER) : ARRAY[low1:u1] OF ARRAY[low2:u2] OF ARRAY[low3:u3] OF GENERIC : T; 
LOCAL 
   res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF
             ARRAY[low3:u3] OF GENERIC : T;
 END_LOCAL;                

(* Check input dimensions for consistency *)
   IF (u1-low1+1) <> SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2-low2+1) <> SIZEOF(lis[1]) THEN
     RETURN (?);
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [make_array_of_array(lis[1], low2, u2, low3, u3) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) <> SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;  
     res[low1+i-1] := make_array_of_array(lis[i], low2, u2, low3, u3);
   END_REPEAT; 
   RETURN (res);
 END_FUNCTION; 

FUNCTION normalise
 (arg : vector_or_direction) : vector_or_direction; 
LOCAL
      ndim   : INTEGER;
      v      : direction := dummy_gri || direction ([1.0,0.0,0.0]);
      result : vector_or_direction;
      vec    : vector := dummy_gri || vector (v, 1.0);
      mag    : REAL;
    END_LOCAL;
    
    IF NOT EXISTS (arg) THEN
      result := ?;
  (* When function is called with invalid data a NULL result is returned *)
    ELSE
      ndim := arg.dim;
      IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
              v := dummy_gri || direction(arg\vector.orientation.direction_ratios);
          IF arg\vector.magnitude = 0.0 THEN
            RETURN(?);
          ELSE
           vec := dummy_gri || vector (v, 1.0);
          END_IF;
        END;
      ELSE
        v := dummy_gri || direction (arg.direction_ratios);
      END_IF;
      mag := 0.0;
      REPEAT  i := 1 TO ndim;
        mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
      END_REPEAT;
      IF mag > 0.0 THEN
        mag := SQRT(mag);
        REPEAT  i := 1 TO ndim;
          v.direction_ratios[i] := v.direction_ratios[i]/mag;
        END_REPEAT;
        IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN (result);
  END_FUNCTION; 

FUNCTION orthogonal_complement
 (vec : direction) : direction; 
LOCAL
     result :  direction ;
   END_LOCAL;

   IF (vec.dim <> 2) OR NOT EXISTS (vec) THEN
     RETURN(?);
   ELSE
     result := dummy_gri || direction([-vec.direction_ratios[2],
                                          vec.direction_ratios[1]]);
     RETURN(result);
   END_IF;END_FUNCTION; 

FUNCTION same_side
 (plane_pts : LIST[3:3] OF cartesian_point; test_points : LIST[2:?] OF cartesian_point) : BOOLEAN; 
LOCAL
     val1, val2 : REAL;
     n          : INTEGER;
   END_LOCAL;

   IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2) THEN
     RETURN(?);
   END_IF;
   n := SIZEOF(test_points);
   val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[1] );
   REPEAT i := 2 TO n;
     val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[i] );
     IF (val1*val2 <= 0.0) THEN
       RETURN(FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);
 END_FUNCTION; 

FUNCTION scalar_times_vector
 (scalar : REAL; vec : vector_or_direction) : vector; 
LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
 
    IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
      RETURN (?) ;
     ELSE
      IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF (vec) THEN
        v   := dummy_gri || direction(vec\vector.orientation.direction_ratios);
        mag := scalar * vec\vector.magnitude;
      ELSE
        v   := dummy_gri || direction(vec.direction_ratios);
        mag := scalar;
      END_IF;
      IF (mag < 0.0 ) THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios);
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result := dummy_gri || vector(normalise(v), mag);
    END_IF;
    RETURN (result);
  END_FUNCTION; 

FUNCTION second_proj_axis
 (z_axis : direction; x_axis : direction; arg : direction) : direction; 
LOCAL
     y_axis : vector;
     v      : direction;
     temp   : vector;
   END_LOCAL;
   
   IF NOT EXISTS(arg) THEN
     v := dummy_gri || direction([0.0,1.0,0.0]);
   ELSE
     v := arg;
   END_IF;
   
   temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);
   y_axis := vector_difference(v, temp);
   temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);
   y_axis := vector_difference(y_axis, temp);
   y_axis := normalise(y_axis);
   RETURN(y_axis.orientation);
 END_FUNCTION; 

FUNCTION surface_weights_positive
 (b : rational_b_spline_surface) : BOOLEAN; 
LOCAL
     result        : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT i := 0 TO b.u_upper;
     REPEAT j := 0 TO b.v_upper;
       IF (b.weights[i][j] <= 0.0)  THEN
         result := FALSE;
         RETURN(result);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION; 

FUNCTION vector_difference
 (arg1 : vector_or_direction; arg2 : vector_or_direction) : vector; 
LOCAL
      result          : vector;
      res, vec1, vec2 : direction;
      mag, mag1, mag2 : REAL;
      ndim            : INTEGER;
    END_LOCAL;
 
    IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
        THEN
      RETURN (?) ;
     ELSE
      BEGIN
        IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
          mag1 := arg1\vector.magnitude;
          vec1 := arg1\vector.orientation;
        ELSE
          mag1 := 1.0;
          vec1 := arg1;
        END_IF;
        IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
          mag2 := arg2\vector.magnitude;
          vec2 := arg2\vector.orientation;
        ELSE
          mag2 := 1.0;
          vec2 := arg2;
        END_IF;
        vec1 := normalise (vec1);
        vec2 := normalise (vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0.0;
        res := dummy_gri || direction(vec1.direction_ratios);
        REPEAT i := 1 TO ndim;
          res.direction_ratios[i] := mag1*vec1.direction_ratios[i] -
                                      mag2*vec2.direction_ratios[i];
          mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
        END_REPEAT;
        IF (mag > 0.0 ) THEN
        result := dummy_gri || vector( res, SQRT(mag));
        ELSE
          result := dummy_gri || vector( vec1,  0.0);
        END_IF;
      END;
    END_IF;
    RETURN (result);
  END_FUNCTION; 

FUNCTION vector_sum
 (arg1 : vector_or_direction; arg2 : vector_or_direction) : vector; 
LOCAL
     result          : vector;
     res, vec1, vec2 : direction;
     mag, mag1, mag2 : REAL;
     ndim            : INTEGER;
   END_LOCAL;

   IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
       THEN
     RETURN (?) ;

   ELSE
     BEGIN
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
         mag1 := arg1\vector.magnitude;
         vec1 := arg1\vector.orientation;
       ELSE
         mag1 := 1.0;
         vec1 := arg1;
       END_IF;
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
         mag2 := arg2\vector.magnitude;
         vec2 := arg2\vector.orientation;
       ELSE
         mag2 := 1.0;
         vec2 := arg2;
       END_IF;
       vec1 := normalise (vec1);
       vec2 := normalise (vec2);
       ndim := SIZEOF(vec1.direction_ratios);
       mag := 0.0;
       res := dummy_gri || direction(vec1.direction_ratios);
       REPEAT i := 1 TO ndim;
         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                      mag2*vec2.direction_ratios[i];
         mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
       END_REPEAT;
       IF (mag > 0.0 ) THEN
       result := dummy_gri || vector( res, SQRT(mag));
       ELSE
         result := dummy_gri || vector( vec1,  0.0);
       END_IF;
     END;
   END_IF;
   RETURN (result);
 END_FUNCTION; 

FUNCTION volume_weights_positive
 (b : rational_b_spline_volume) : BOOLEAN; 
LOCAL
       result   : BOOLEAN := TRUE;
     END_LOCAL;

     REPEAT i := 0 TO b.u_upper;
       REPEAT j := 0 TO b.v_upper;
         REPEAT k := 0 TO b.w_upper;
           IF (b.weights[i][j][k] <= 0.0)  THEN
             result := FALSE;
             RETURN(result);
           END_IF;
         END_REPEAT;
       END_REPEAT;
     END_REPEAT;
     RETURN(result);
   END_FUNCTION; 
(* isogeometry function additions *)

FUNCTION increasing_values_in_list(values: LIST[2: ?] OF REAL) : BOOLEAN;
LOCAL
result : BOOLEAN := TRUE;
limit : INTEGER := SIZEOF(values);
END_LOCAL;
REPEAT i := 2 TO limit;
 IF values[i] <= values[i-1] THEN
   result := FALSE;
 END_IF;
END_REPEAT;
RETURN(result);
END_FUNCTION;

FUNCTION constraints_param_local_b_spline(degree: INTEGER;
knot_mult : LIST OF INTEGER;
knots : LIST OF INTEGER) : BOOLEAN;
LOCAL
  result : BOOLEAN := TRUE;
  k, up_knots, sum : INTEGER;
END_LOCAL;
(* Find sum of knot multiplicities. *)
  up_knots := SIZEOF(knots);
  sum := knot_mult[1];
REPEAT i := 2 TO up_knots;
  sum := sum + knot_mult[i];
END_REPEAT;
(* Check limits holding for all B-spline parametrisations *)
IF (degree < 1) OR (up_knots < 2) OR 
(sum <> (degree + 2)) THEN
  result := FALSE;
RETURN(result);
END_IF;
k := knot_mult[1];
IF (k < 1) OR (k > degree + 1) THEN
  result := FALSE;
  RETURN(result);
END_IF;
(* first pointer shall be 1 or more *)
IF (knots[1] < 1) THEN
 result :=  FALSE;
END_IF;
REPEAT i := 2 TO up_knots;
 IF (knot_mult[i] < 1) OR (knots[i] <= knots[i-1]) THEN
 result := FALSE;
 RETURN(result);
END_IF;
k := knot_mult[i];
IF (i < up_knots) AND (k > degree) THEN
 result := FALSE;
 RETURN(result);
END_IF;
IF (i = up_knots) AND (k > degree + 1) THEN
 result := FALSE;
 RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);
END_FUNCTION;

FUNCTION weights_positive(weights: LIST OF REAL) : BOOLEAN;
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 1 TO SIZEOF(weights);
IF weights[i] <= 0.0 THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);
END_FUNCTION;

FUNCTION constraints_scaling(factors: LIST OF REAL) : BOOLEAN;
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 1 TO SIZEOF(factors);
IF NOT({0.0 < factors[i] <= 1.0}) THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);
END_FUNCTION;



END_SCHEMA;  -- geometry_schema


--
-- GROUP_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/group/mim.exp)
--
(*
 $Id: mim.exp,v 1.8 2006/03/24 18:45:20 thendrix Exp 
 ISO TC184/SC4/WG12 N4276 - ISO/TS 10303-1113 Group - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N3246
*) 


SCHEMA Group_mim;

USE FROM group_schema   -- ISO 10303-41
  (group,
   group_relationship); 

USE FROM management_resources_schema   -- ISO 10303-41
  (group_assignment); 

USE FROM Basic_attribute_schema(
	id_attribute, 
	id_attribute_select); -- ISO/IS 10303-41

TYPE groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT;
WHERE
  WR1: NOT ('GROUP_MIM.GROUP' IN TYPEOF(SELF));
END_TYPE; 

ENTITY applied_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET[1:?] OF groupable_item;
END_ENTITY;

END_SCHEMA;  -- Group_mim



--
-- GROUP_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/group_schema/group_schema.exp)
--
(*
Id: group_schema.exp,v 1.13 2014/03/04 00:30:37 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Group schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Group schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA group_schema '{iso standard 10303 part(41) version(7) object(1) group_schema(12)}';

  REFERENCE FROM support_resource_schema (
    label, 
    bag_to_set, 
    identifier, 
    text);
  REFERENCE FROM basic_attribute_schema (
    get_id_value, 
    id_attribute,
    id_attribute_select);
    
  TYPE gs_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    group);
  END_TYPE;
    
  ENTITY group;
    name : label;
    description : OPTIONAL text;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY group_relationship;
    name : label;
    description : OPTIONAL text;
    relating_group : group;
    related_group : group;
  END_ENTITY;

  FUNCTION acyclic_group_relationship (relation : group_relationship; relatives : SET [1:?] OF group; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF group_relationship;
    END_LOCAL;

    IF relation.relating_group IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(grp <* bag_to_set(USEDIN(relation.relating_group, 'GROUP_SCHEMA.' + 'GROUP_RELATIONSHIP.' + 'RELATED_GROUP')) | specific_relation IN TYPEOF(grp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_group_relationship(x[i], relatives + relation.relating_group, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;


--
-- IDENTIFICATION_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/identification_assignment/mim.exp)
--
(*
Id: mim.exp,v 1.13 2010/06/09 22:02:45 philsp Exp 
ISO TC184/SC4/WG12 N7115 - ISO/TS 10303-1021 Identification assignment - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N2915
*)

SCHEMA Identification_assignment_mim;

USE FROM management_resources_schema   -- ISO 10303-41
  (identification_assignment); 


TYPE identification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_identification_assignment
  SUBTYPE OF (identification_assignment);
  items : SET[1:?] OF identification_item;
END_ENTITY;

END_SCHEMA;  -- Identification_assignment_mim


--
-- IDENTIFICATION_RELATIONSHIP_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/identification_relationship/mim.exp)
--
(*
 $Id: mim.exp,v 1.4 2009/08/11 07:52:38 robbod Exp 
 ISO TC184/SC4/WG12 N6040 - ISO/TS 10303-1398 Identification relationship - EXPRESS MIM
*) 


SCHEMA Identification_relationship_mim;

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM management_resources_schema   -- ISO 10303-41
  (identification_assignment_relationship); 


END_SCHEMA;  -- Identification_relationship_mim


--
-- INDEPENDENT_PROPERTY_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/independent_property/mim.exp)
--
(*
 $Id: mim.exp,v 1.10 2004/10/22 14:15:40 darla Exp 
 ISO TC184/SC4/WG12 N1238 - ISO/TS 10303-1036 Independent property - EXPRESS MIM
*)
SCHEMA Independent_property_mim;

USE FROM product_property_definition_schema
(general_property,
 general_property_relationship);

END_SCHEMA;



--
-- INDEPENDENT_PROPERTY_REPRESENTATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/independent_property_representation/mim.exp)
--
(*
 $Id: mim.exp,v 1.11 2006/05/18 11:42:07 liutkuviene Exp 
 ISO TC184/SC4/WG12 N4372 - ISO/TS 10303-1038 Independent property representation - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1244
*)
SCHEMA Independent_property_representation_mim;

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

END_SCHEMA;


--
-- INFORMATION_RIGHTS_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/information_rights/mim.exp)
--
(*
 $Id: mim.exp,v 1.13 2018/11/10 06:42:32 tom Exp 
 ISO TC184/SC4/WG12 N10040 - ISO/TS 10303-1241 Information rights - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N6124
*)


SCHEMA Information_rights_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method,
   action_method_relationship);

USE FROM Activity_mim;    -- ISO/TS 10303-1047

USE FROM Contract_mim;    -- ISO/TS 10303-1062

USE FROM Management_resource_information_mim;    -- ISO/TS 10303-1288


TYPE ir_approval_item = SELECT BASED_ON mri_approval_item WITH
   (applied_usage_right,
    information_usage_right);
END_TYPE;

TYPE ir_contract_item = SELECT BASED_ON contract_item WITH
   (information_usage_right);
END_TYPE;

TYPE ir_date_and_time_item = SELECT BASED_ON mri_date_and_time_item WITH
   (information_usage_right);
END_TYPE;

TYPE ir_date_item = SELECT BASED_ON mri_date_item WITH
   (information_usage_right);
END_TYPE;

TYPE ir_identification_item = SELECT BASED_ON mri_identification_item WITH
   (information_right,
    information_usage_right);
END_TYPE;

TYPE ir_organization_item = SELECT BASED_ON mri_organization_item WITH
   (information_usage_right);
END_TYPE;

TYPE ir_person_and_organization_item = SELECT BASED_ON mri_person_and_organization_item WITH
   (information_usage_right);
END_TYPE;

TYPE ir_usage_item = action_items;
END_TYPE;

ENTITY applied_usage_right
  SUBTYPE OF (action_assignment);
  items : SET[1:?] OF ir_usage_item;
END_ENTITY;

ENTITY information_right
  SUBTYPE OF (action_method);
END_ENTITY;

ENTITY information_usage_right
  SUBTYPE OF (action_method);
END_ENTITY;

ENTITY right_to_usage_association
  SUBTYPE OF (action_method_relationship);
  SELF\action_method_relationship.relating_method RENAMED right_usage : information_usage_right;
  SELF\action_method_relationship.related_method RENAMED right_applied : information_right;
END_ENTITY;

ENTITY usage_association
  SUBTYPE OF (action_method_relationship);
  SELF\action_method_relationship.relating_method RENAMED relating : information_usage_right;
  SELF\action_method_relationship.related_method RENAMED related : information_usage_right;
END_ENTITY;

SUBTYPE_CONSTRAINT action_assignment_subtypes FOR action_assignment;
    (ONEOF (applied_usage_right,
         applied_action_assignment)); 
 END_SUBTYPE_CONSTRAINT;

END_SCHEMA;  -- Information_rights_mim





--
-- INTERFACE_LIFECYCLE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/interface_lifecycle/mim.exp)
--
(*
 $Id: mim.exp,v 1.7 2004/11/19 21:37:36 robbod Exp 
 ISO TC184/SC4/WG12 N3065 - ISO/TS 10303-1294 Interface lifecycle - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2277
*) 


SCHEMA Interface_lifecycle_mim;

USE FROM Interface_mim;    -- ISO/TS 10303-1251

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition_formation,
   product_definition_formation_relationship); 


ENTITY interface_connector_as_planned
  SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY interface_connector_as_realized
  SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY interface_connector_design
  SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY interface_connector_design_to_planned
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : interface_connector_design;
  SELF\product_definition_formation_relationship.related_product_definition_formation : interface_connector_as_planned;
WHERE
  WR1: SELF.relating_product_definition_formation.of_product :=: SELF.related_product_definition_formation.of_product;
END_ENTITY;

ENTITY interface_connector_design_to_realized
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : interface_connector_design;
  SELF\product_definition_formation_relationship.related_product_definition_formation : interface_connector_as_realized;
WHERE
  WR1: SELF.relating_product_definition_formation.of_product :=: SELF.related_product_definition_formation.of_product;
END_ENTITY;

ENTITY interface_connector_planned_to_realized
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : interface_connector_as_planned;
  SELF\product_definition_formation_relationship.related_product_definition_formation : interface_connector_as_realized;
WHERE
  WR1: SELF.relating_product_definition_formation.of_product :=: SELF.related_product_definition_formation.of_product;
END_ENTITY;

END_SCHEMA;  -- Interface_lifecycle_mim



--
-- INTERFACE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/interface/mim.exp)
--
(*
ISO TC184/SC4/WG12 N10742 - ISO/TS 10303-1251 Interface - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6127
*) 

SCHEMA Interface_mim;

USE FROM Assembly_structure_mim;    -- ISO/TS 10303-1026

USE FROM Group_mim;    -- ISO/TS 10303-1113

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041

TYPE connection_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH
  (assembly_component_usage,
   product_definition,
   product_definition_relationship);
END_TYPE;

TYPE interface_component_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH
  (interface_definition_for);
END_TYPE;

TYPE interface_connector_occurrence_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH
  (product_definition);
END_TYPE;

TYPE interface_connector_on_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH
  (assembly_component_usage,
   product_definition,
   product_definition_relationship);
END_TYPE;

ENTITY connection_definition_to_connection
SUBTYPE OF (group);
END_ENTITY;

ENTITY hierarchical_interface_connection
SUBTYPE OF (interface_connection);
END_ENTITY;

ENTITY interface_connection
SUBTYPE OF (group);
END_ENTITY;

ENTITY interface_connector_definition
SUBTYPE OF (product_definition);
END_ENTITY;

ENTITY interface_connector_occurrence
SUBTYPE OF (group);
END_ENTITY;

ENTITY interface_connector_version
SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY interface_definition_connection
SUBTYPE OF (product_definition_relationship);
END_ENTITY;

ENTITY interface_definition_for
SUBTYPE OF (product_definition_relationship);
END_ENTITY;

ENTITY interface_specification_definition
SUBTYPE OF (product_definition);
END_ENTITY;

ENTITY interface_specification_version
SUBTYPE OF (product_definition_formation);
END_ENTITY;

END_SCHEMA;  -- Interface_mim



--
-- ISO13584_EXPRESSIONS_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/iso13584_expressions_schema/iso13584_expressions_schema.exp)
--
(*
   $Id: iso13584_expressions_schema.exp,v 1.18 2019/06/09 16:58:00 kevin Exp 
   ISO 13584-20:1998/Cor.1:2013 Logical model of expressions - EXPRESS
   ISO TC184/SC4/WG12 N10536

The following permission notice and disclaimer shall be included in all copies of these EXPRESS schemas 
("the Schema"), and derivations of the Schema:

Copyright ISO 2013  All rights reserved

Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema, 
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of 
developing, implementing, installing and using software based on the Schema, and to permit persons to 
whom the Schema is furnished to do so, subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 
EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN ISO 13584-20:1998/Cor.1:2013, AND SHOULD NOT BE INTERPRETED AS 
COMPLYING WITH THAT STANDARD.

*)


SCHEMA iso13584_expressions_schema;

REFERENCE FROM iso13584_generic_expressions_schema(
			generic_expression,
			simple_generic_expression,
			generic_variable,
			generic_literal,
			unary_generic_expression,
			binary_generic_expression,
			multiple_arity_generic_expression);

ENTITY expression
ABSTRACT SUPERTYPE OF (ONEOF (numeric_expression,
				boolean_expression,
				string_expression))
SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY variable
ABSTRACT SUPERTYPE OF (ONEOF (numeric_variable,
				boolean_variable,
					string_variable))
SUBTYPE OF(generic_variable);
END_ENTITY;

ENTITY defined_function
ABSTRACT SUPERTYPE OF ((ONEOF (numeric_defined_function,
				string_defined_function,
				boolean_defined_function)
				)
				ANDOR SQL_mappable_defined_function);
END_ENTITY;

ENTITY sql_mappable_defined_function
ABSTRACT SUPERTYPE
SUBTYPE OF (defined_function);
END_ENTITY;

ENTITY numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (simple_numeric_expression,
								unary_numeric_expression,
								binary_numeric_expression,
								multiple_arity_numeric_expression,
								length_function,
								value_function,
								numeric_defined_function))
SUBTYPE OF (expression);
DERIVE
	is_int: BOOLEAN := is_int_expr (SELF);
	sql_mappable: BOOLEAN := is_sql_mappable (SELF);
END_ENTITY;

ENTITY simple_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (literal_number, numeric_variable))
SUBTYPE OF (numeric_expression, simple_generic_expression);
END_ENTITY;

ENTITY literal_number 
ABSTRACT SUPERTYPE OF (ONEOF (int_literal, real_literal))
SUBTYPE OF (simple_numeric_expression, generic_literal);
	the_value: NUMBER;
END_ENTITY;

ENTITY int_literal
SUBTYPE OF (literal_number);
	SELF\literal_number.the_value: INTEGER;
END_ENTITY;

ENTITY real_literal
SUBTYPE OF (literal_number); 
	SELF\literal_number.the_value: REAL;
END_ENTITY;

ENTITY numeric_variable
SUPERTYPE OF (ONEOF (int_numeric_variable,
			          real_numeric_variable))
SUBTYPE OF (simple_numeric_expression, variable);
WHERE 
	WR1:	('ISO13584_EXPRESSIONS_SCHEMA.INT_NUMERIC_VARIABLE' 
			IN TYPEOF(SELF) ) OR
			('ISO13584_EXPRESSIONS_SCHEMA.REAL_NUMERIC_VARIABLE' 
			IN TYPEOF(SELF) );
END_ENTITY;

ENTITY int_numeric_variable
SUBTYPE OF (numeric_variable);
END_ENTITY;

ENTITY real_numeric_variable
SUBTYPE OF (numeric_variable);
END_ENTITY;

ENTITY unary_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (unary_function_call))
SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand	: numeric_expression;
END_ENTITY;

ENTITY binary_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (minus_expression,
				div_expression,
				mod_expression,
				slash_expression,
				power_expression,
				binary_function_call))
SUBTYPE OF (numeric_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands : LIST [2:2] OF 
						numeric_expression;
END_ENTITY;

ENTITY multiple_arity_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (plus_expression,
				mult_expression,
				multiple_arity_function_call))
SUBTYPE OF (numeric_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands	: LIST [2:?] OF 						numeric_expression;
END_ENTITY;

ENTITY length_function
SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand: string_expression;
END_ENTITY;

ENTITY value_function
SUPERTYPE OF (int_value_function)
SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand: string_expression;
END_ENTITY;

ENTITY int_value_function
SUBTYPE OF (value_function);
END_ENTITY;

ENTITY numeric_defined_function
ABSTRACT SUPERTYPE OF (ONEOF (integer_defined_function,
				real_defined_function))
SUBTYPE OF (numeric_expression, defined_function);
END_ENTITY;

ENTITY plus_expression
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY minus_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY mult_expression
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY div_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY mod_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY slash_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY power_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY unary_function_call
ABSTRACT SUPERTYPE OF (ONEOF (abs_function,
				minus_function,
				sin_function,
				cos_function,
				tan_function,
				asin_function,
				acos_function,
				exp_function,
				log_function,
				log2_function,
				log10_function,
				square_root_function))
SUBTYPE OF (unary_numeric_expression);
END_ENTITY;

ENTITY binary_function_call
ABSTRACT SUPERTYPE OF (ONEOF (atan_function))
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY multiple_arity_function_call
ABSTRACT SUPERTYPE OF (ONEOF (maximum_function, 
				minimum_function))
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY abs_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY minus_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY sin_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY cos_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY tan_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY asin_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY acos_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY exp_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log2_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log10_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY square_root_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY atan_function
SUBTYPE OF (binary_function_call);
END_ENTITY;

ENTITY maximum_function
SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;

ENTITY minimum_function
SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;

ENTITY integer_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (numeric_defined_function);
END_ENTITY ;

ENTITY real_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (numeric_defined_function);
END_ENTITY ;

ENTITY boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (simple_boolean_expression,
				unary_boolean_expression,
				binary_boolean_expression,
				multiple_arity_Boolean_expression,
				comparison_expression,
				interval_expression,
				boolean_defined_function))
SUBTYPE OF (expression);
END_ENTITY;

ENTITY simple_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (boolean_literal,
				boolean_variable))
SUBTYPE OF (boolean_expression, simple_generic_expression);
END_ENTITY;

ENTITY boolean_literal
SUBTYPE OF (simple_Boolean_expression, generic_literal);
	the_value: BOOLEAN;
END_ENTITY;

ENTITY boolean_variable
SUBTYPE OF (simple_Boolean_expression, variable);
END_ENTITY;

ENTITY unary_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (not_expression, odd_function))
SUBTYPE OF (boolean_expression, unary_generic_expression);
END_ENTITY;

ENTITY not_expression
SUBTYPE OF (unary_Boolean_expression);
SELF\unary_generic_expression.operand: boolean_expression;
END_ENTITY;

ENTITY odd_function
SUBTYPE OF (unary_Boolean_expression);
	SELF\unary_generic_expression.operand: numeric_expression;
WHERE
	WR1: is_int_expr(operand);
END_ENTITY;

ENTITY binary_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (xor_expression, equals_expression))
SUBTYPE OF (boolean_expression, binary_generic_expression);
END_ENTITY;

ENTITY multiple_arity_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (and_expression, or_expression))
SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands	: 
LIST [2:?] OF boolean_expression;
END_ENTITY;

ENTITY xor_expression
SUBTYPE OF (binary_boolean_expression);
	SELF\binary_generic_expression.operands: 
				LIST [2:2] OF boolean_expression;
END_ENTITY;

ENTITY equals_expression
SUBTYPE OF (binary_boolean_expression);
END_ENTITY;

ENTITY and_expression
SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;

ENTITY or_expression
SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;

(* Entity below modified by David Leal 2003-12-14 *)

ENTITY comparison_expression
ABSTRACT SUPERTYPE OF (ONEOF (comparison_equal,
				comparison_greater,
				comparison_greater_equal,
				comparison_less,
				comparison_less_equal,
				comparison_not_equal,
				like_expression))
SUBTYPE OF (boolean_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands	: LIST [2:2] OF expression; 
WHERE 
	WR1: (('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[2]))) 
OR
 (('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' 
	IN TYPEOF(SELF\binary_generic_expression.operands[2])))
OR
(('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[2]))) ;
END_ENTITY;

ENTITY comparison_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_greater
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_greater_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_less
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_less_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_not_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY;

(* Entity below modified by David Leal 2003-12-14 *)

ENTITY like_expression
SUBTYPE OF (comparison_expression);
WHERE
	WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
		IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND 
		('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
		IN TYPEOF(SELF\binary_generic_expression.operands[2]));
END_ENTITY;

ENTITY interval_expression
SUBTYPE OF (boolean_expression, multiple_arity_generic_expression) ;
DERIVE
	interval_low: generic_expression
			:= SELF\multiple_arity_generic_expression.operands[1];
	interval_item:generic_expression
			:= SELF\multiple_arity_generic_expression.operands[2];
	interval_high:generic_expression
			:= SELF\multiple_arity_generic_expression.operands[3];
WHERE
	WR1:('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' 
				IN TYPEOF(interval_low))
		AND ('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' 
				IN TYPEOF(interval_item) )
		AND ('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' 
				IN TYPEOF(interval_high));
	WR2:(('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
				IN TYPEOF (SELF.interval_low)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION'  
				IN TYPEOF (SELF.interval_high)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
				IN TYPEOF (SELF.interval_item))) 
		OR
		(('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
				IN TYPEOF(SELF.interval_low)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
				IN TYPEOF(SELF.interval_item)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
				IN TYPEOF(SELF.interval_high)));
END_ENTITY; 

ENTITY boolean_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (defined_function, boolean_expression);
END_ENTITY ;

ENTITY string_expression
ABSTRACT SUPERTYPE OF (ONEOF (simple_string_expression,
				index_expression,
				substring_expression,
				concat_expression,
				format_function,
				string_defined_function)) 
SUBTYPE OF (expression);
END_ENTITY;

ENTITY simple_string_expression
ABSTRACT SUPERTYPE OF (ONEOF (string_literal,
				string_variable))
SUBTYPE OF (string_expression, simple_generic_expression);
END_ENTITY;

ENTITY string_literal
SUBTYPE OF (simple_string_expression, generic_literal);
	the_value: STRING;
END_ENTITY;

ENTITY string_variable
SUBTYPE OF (simple_string_expression, variable);
END_ENTITY;

ENTITY index_expression
SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	operand:generic_expression:=
SELF\binary_generic_expression.operands[1];
	index:generic_expression:= 
SELF\binary_generic_expression.operands[2];
WHERE
	WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
			IN TYPEOF(operand))
		AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
			IN TYPEOF(index));
	WR2: is_int_expr (index);
END_ENTITY;

ENTITY substring_expression
SUBTYPE OF (string_expression, multiple_arity_generic_expression);
DERIVE
	operand:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[1];
	index1:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[2];
	index2:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[3]; 
WHERE
	WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
					IN TYPEOF(operand))
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
					IN TYPEOF(index1))
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
					IN TYPEOF(index2));
	WR2: SIZEOF(SELF\multiple_arity_generic_expression.operands)=3;
	WR3: is_int_expr (index1);
	WR4: is_int_expr (index2);
END_ENTITY;

ENTITY concat_expression
SUBTYPE OF (string_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands: 
				LIST [2 : ?] OF string_expression;
END_ENTITY;

ENTITY format_function
SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	value_to_format: generic_expression:=
			SELF\binary_generic_expression.operands[1];
	format_string:generic_expression:=
			SELF\binary_generic_expression.operands[2];
WHERE
	WR1: (('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION') 
					IN TYPEOF(value_to_format)) 
			AND (('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION') 
					IN TYPEOF(format_string));
END_ENTITY;

ENTITY string_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (defined_function, string_expression);
END_ENTITY ;

FUNCTION is_int_expr (arg: numeric_expression) : BOOLEAN;

IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.REAL_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.REAL_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COS_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MULT_EXPRESSION' 
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MAXIMUM_FUNCTION'
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MINIMUM_FUNCTION'
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
	IF NOT 
		is_int_expr(arg\multiple_arity_numeric_expression.operands[i]) 
	THEN 
		RETURN (FALSE);
	END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (is_int_expr(arg\binary_numeric_expression.operands[1])
		AND is_int_expr(arg\binary_numeric_expression.operands[2]));
END_IF;
IF	('ISO13584_EXPRESSIONS_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg))
THEN 
	RETURN(TRUE);	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SLASH_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.LENGTH_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg) 
THEN 
	IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_VALUE_FUNCTION' 
								IN TYPEOF(arg) 
	THEN 
		RETURN (TRUE); 
	ELSE 
		RETURN (FALSE); 
	END_IF;
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTEGER_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(TRUE) ;
END_IF;
IF'ISO13584_EXPRESSIONS_SCHEMA.REAL_DEFINED_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'ISO13584_EXPRESSIONS_SCHEMA.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN (FALSE) ;
END_IF ;

RETURN (FALSE);

END_FUNCTION; -- is_int_expr

FUNCTION is_sql_mappable (arg: expression) : BOOLEAN;

IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_NUMERIC_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SQL_MAPPABLE_DEFINED_FUNCTION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_sql_mappable(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LENGTH_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MULT_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MAXIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MINIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
		IF NOT is_sql_mappable(
			arg\multiple_arity_numeric_expression.operands[i])
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
RETURN (TRUE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SLASH_EXPRESSION' IN 
								TYPEOF(arg))
THEN
		RETURN (is_sql_mappable(
			arg\binary_numeric_expression.operands[1])
		AND is_sql_mappable(arg\binary_numeric_expression.operands[2]));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.NOT_EXPRESSION' IN TYPEOF (arg) 
THEN 
	RETURN (is_sql_mappable (arg\UNARY_GENERIC_EXPRESSION.OPERAND));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.ODD_FUNCTION'IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.XOR_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN	
	RETURN (FALSE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.AND_EXPRESSION' IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.OR_EXPRESSION' IN TYPEOF (arg)) 
THEN
	REPEAT i:=1 TO SIZEOF (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS);
		IF NOT is_sql_mappable (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS[i]) 
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.EQUALS_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN(is_sql_mappable (
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [1])
		AND is_sql_mappable(
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [2]));
END_IF;
IF	('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_EQUAL' IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_GREATER' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_GREATER_EQUAL'
								IN TYPEOF (arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_LESS' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_LESS_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_NOT_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LIKE_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN
	RETURN (is_sql_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[1])
		AND is_sql_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTERVAL_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (is_sql_mappable(arg\interval_expression.interval_low) 
		AND is_sql_mappable(arg\interval_expression.interval_high)
		AND is_sql_mappable(arg\interval_expression.interval_item));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_DEFINED_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg))  
THEN 
		RETURN (FALSE) ;
END_IF;

IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_STRING_EXPRESSION' 
								IN TYPEOF(ARG) 
THEN 
	RETURN (TRUE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.INDEX_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SUBSTRING_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.CONCAT_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.FORMAT_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	RETURN (FALSE);
END_IF;

	RETURN (FALSE);
END_FUNCTION; -- is_sql_mappable

FUNCTION used_functions (arg : expression) : SET OF defined_function;

LOCAL
	result : SET OF defined_function := [];
END_LOCAL;

IF ('ISO13584_EXPRESSIONS_SCHEMA.DEFINED_FUNCTION' IN TYPEOF(arg))  
THEN 
	RETURN ( [arg] ) ;
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.UNARY_NUMERIC_EXPRESSION' IN 
	TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\unary_numeric_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BINARY_NUMERIC_EXPRESSION' IN 
		TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\binary_numeric_expression.operands[1])
		+ used_functions (arg\binary_numeric_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_NUMERIC_EXPRESSION' IN 		TYPEOF (arg) 
THEN
	REPEAT i := 1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
		result := result + used_functions (
			arg\multiple_arity_numeric_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' 
		IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\unary_generic_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BINARY_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\binary_generic_expression.operands[1])
		+ used_functions (
			arg\binary_generic_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	REPEAT i := 1 TO 
		SIZEOF (arg\multiple_arity_Boolean_expression.operands);
		result := result + used_functions(
			arg\multiple_arity_Boolean_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\comparison_expression.operands[1])
			+ used_functions (arg\comparison_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTERVAL_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (used_functions(arg\interval_expression.interval_low)
		+ used_functions(arg\interval_expression.interval_high)
		+ used_functions(arg\interval_expression.interval_item));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INDEX_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\index_expression.operand)
		+ used_functions (arg\index_expression.index));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SUBSTRING_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\substring_expression.operand)
		+ used_functions (arg\substring_expression.index1)
		+ used_functions (arg\substring_expression.index2));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.CONCAT_EXPRESSION' IN TYPEOF (arg) 
THEN
	REPEAT i := 1 TO SIZEOF (arg\concat_expression.operands);
		result := result + used_functions (
			arg\concat_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.FORMAT_FUNCTION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\format_function.value_to_format)
		+ used_functions (arg\format_function.format_string));
END_IF;

IF 'ISO13584_EXPRESSIONS_SCHEMA.LIKE_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\comparison_expression.operands[1])
		+ used_functions (arg\comparison_expression.operands[2]));
END_IF;

RETURN ([ ]);

END_FUNCTION; -- used_functions

END_SCHEMA;


--
-- ISO13584_GENERIC_EXPRESSIONS_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/iso13584_generic_expressions_schema/iso13584_generic_expressions_schema.exp)
--
(*
   $Id: iso13584_generic_expressions_schema.exp,v 1.8 2015/06/29 18:58:17 dgnedwards Exp 
   ISO 13584-20:1998/Cor.1:2013 Logical model of expressions - EXPRESS
   ISO TC184/SC4/WG12 N8550
The following permission notice and disclaimer shall be included in all copies of these EXPRESS schemas 
("the Schema"), and derivations of the Schema:

Copyright ISO 2013  All rights reserved

Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema, 
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of 
developing, implementing, installing and using software based on the Schema, and to permit persons to 
whom the Schema is furnished to do so, subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 
EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN ISO 13584-20:1998/Cor.1:2013, AND SHOULD NOT BE INTERPRETED AS 
COMPLYING WITH THAT STANDARD.

*)

SCHEMA iso13584_generic_expressions_schema;

ENTITY generic_expression
ABSTRACT SUPERTYPE OF(ONEOF(simple_generic_expression,
								unary_generic_expression,
								binary_generic_expression,
								multiple_arity_generic_expression));
WHERE 
	WR1: is_acyclic(SELF);
END_ENTITY;

ENTITY simple_generic_expression
ABSTRACT SUPERTYPE OF (ONEOF(generic_literal, generic_variable))
SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY generic_literal
ABSTRACT SUPERTYPE
SUBTYPE OF (simple_generic_expression);
END_ENTITY; 

ENTITY generic_variable
ABSTRACT SUPERTYPE
SUBTYPE OF (simple_generic_expression);
INVERSE
	interpretation :
			environment FOR syntactic_representation;
END_ENTITY;

ENTITY variable_semantics
ABSTRACT SUPERTYPE;
END_ENTITY;

ENTITY environment;
	syntactic_representation: generic_variable;
	semantics: variable_semantics;
END_ENTITY;

ENTITY unary_generic_expression
ABSTRACT SUPERTYPE
SUBTYPE OF(generic_expression);
	operand: generic_expression;
END_ENTITY;

ENTITY binary_generic_expression
ABSTRACT SUPERTYPE
SUBTYPE OF(generic_expression);
	operands: LIST [2:2] OF generic_expression;
END_ENTITY;

ENTITY multiple_arity_generic_expression
ABSTRACT SUPERTYPE
SUBTYPE OF(generic_expression);
	operands: LIST [2:?] OF generic_expression;
END_ENTITY;

FUNCTION is_acyclic (arg: generic_expression): BOOLEAN;
RETURN (acyclic (arg, []));
END_FUNCTION ; -- is_acyclic

FUNCTION acyclic (arg1: generic_expression; 
			arg2: SET OF generic_expression): BOOLEAN;

LOCAL
	result: BOOLEAN := TRUE;
END_LOCAL;

IF ('ISO13584_GENERIC_EXPRESSIONS_SCHEMA.SIMPLE_GENERIC_EXPRESSION'
	IN TYPEOF (arg1)) 
THEN
	RETURN (TRUE);
END_IF;

IF arg1 IN arg2 
THEN 
	RETURN (FALSE);
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\unary_generic_expression.operand,arg2+[arg1]));
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.BINARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\binary_generic_expression.operands[1],arg2+[arg1])
	AND
	acyclic(arg1\binary_generic_expression.operands[2],arg2+[arg1]));
END_IF;

IF 
'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	result := TRUE;
	REPEAT i := 1 TO 
			SIZEOF (arg1\multiple_arity_generic_expression.operands);
		result := result AND
		acyclic(arg1\multiple_arity_generic_expression.operands[i], arg2+[arg1]);
	END_REPEAT;

	RETURN (result);
END_IF;
	RETURN (result);
END_FUNCTION; -- acyclic

FUNCTION used_variables (arg : generic_expression) : 
			SET OF generic_variable;

LOCAL
	result : SET OF generic_variable := [];
END_LOCAL;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.GENERIC_VARIABLE' 
	IN TYPEOF (arg) 
THEN 
	RETURN ([arg]);
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg)
THEN 
	RETURN (used_variables (arg\unary_generic_expression.operand));
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.BINARY_GENERIC_EXPRESSION'
	IN TYPEOF (arg)
THEN 
	RETURN(used_variables(arg\binary_generic_expression.operands[1])
		+ used_variables (arg\binary_generic_expression.operands[2]));
END_IF;

IF
'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg)
THEN
	REPEAT i := 1 TO 
		SIZEOF(arg\multiple_arity_generic_expression.operands);
		result := result + used_variables(
			arg\multiple_arity_generic_expression.operands[i]);
	END_REPEAT;
	
	RETURN (result);
END_IF;
RETURN ([ ]);      -- in this case the subtype shall not contain
			            -- any variable (see IP1 in generic_expression)
END_FUNCTION; -- used_variables

END_SCHEMA; 


--
-- ITEM_DEFINITION_STRUCTURE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/item_definition_structure/mim.exp)
--
(*
 $Id: mim.exp,v 1.20 2012/10/07 17:34:57 thomasrthurman Exp 
 ISO TC184/SC4/WG12 N7733 - ISO/TS 10303-1345 Item definition structure - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N6912
*)


SCHEMA Item_definition_structure_mim;

USE FROM Effectivity_application_mim; -- ISO/TS 10303-1059
USE FROM Product_occurrence_mim; -- ISO/TS 10303-1715
USE FROM Product_structure_mim; -- ISO/TS 10303-1134

REFERENCE FROM product_definition_schema
	(categories_of_product);


  TYPE effectivity_item_for_replacement  = SELECT BASED_ON effectivity_item WITH
    (product_definition_relationship);
  END_TYPE;

  RULE product_definition_replacement_requires_effectivity_assignment FOR 
      (product_definition_relationship);
    WHERE 
      WR1: SIZEOF( QUERY( pdr <* product_definition_relationship | 
        (pdr.name = 'definition replacement') AND 
        (SIZEOF( USEDIN(pdr,'EFFECTIVITY_APPLICATION_MIM.APPLIED_EFFECTIVITY_ASSIGNMENT.ITEMS') ) = 0) ))
        = 0; 
  END_RULE; 

  RULE restrict_assembly_category FOR (product_definition);
    LOCAL
      assembly_definitions: SET OF product_definition := [];
    END_LOCAL;
      assembly_definitions :=  QUERY( pd <* product_definition | 
        SIZEOF( QUERY( pdca <* USEDIN( pd, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') |
        pdca.frame_of_reference.name= 'assembly definition')) > 0 );
      WHERE
        WR1: SIZEOF( QUERY( pd <* assembly_definitions | 
          NOT ('assembly' IN categories_of_product(pd.formation.of_product)) ))= 0;
  END_RULE;

  RULE restrict_product_definitions_for_part_definition_relationship FOR
    (product_definition_relationship);
    WHERE
      WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
        ( pdr.name IN [ 'geometrical relationship' , 'definition replacement' ] ) AND 
	    ( ( pdr.relating_product_definition.frame_of_reference.name <>'part definition' ) OR 
        ( pdr.related_product_definition.frame_of_reference.name <>'part definition' ) ) ) ) =0;
  END_RULE;

END_SCHEMA;


--
-- JUSTIFICATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/justification/mim.exp)
--
(*
Id: mim.exp,v 1.15 2009/08/11 07:53:21 robbod Exp 
ISO TC184/SC4/WG12 N6043 - ISO/TS 10303-1263 Justification - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N3068
*) 


SCHEMA Justification_mim;

USE FROM application_context_schema   -- ISO 10303-41
  (application_context_element,
   product_context); 

USE FROM Foundation_state_definition_mim;    -- ISO/TS 10303-1469

USE FROM group_schema   -- ISO 10303-41
  (group); 

USE FROM management_resources_schema   -- ISO 10303-41
  (group_assignment); 

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_category,
   product_related_product_category,
   product_relationship); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object); 

USE FROM State_observed_mim;    -- ISO/TS 10303-1256

USE FROM state_observed_schema   -- ISO 10303-56
  (state_observed,
   state_observed_relationship); 


TYPE just_state_observed_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_observed_of_item WITH 
   (assumption);
END_TYPE; 

TYPE just_state_type_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_type_of_item WITH 
   (assumption);
END_TYPE; 

TYPE justification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

TYPE justification_support_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY assumption
  SUBTYPE OF (state_observed);
END_ENTITY;

ENTITY assumption_assignment
  SUBTYPE OF (characterized_applied_state_observed_assignment);
END_ENTITY;

ENTITY assumption_relationship
  SUBTYPE OF (state_observed_relationship);
END_ENTITY;

ENTITY characterized_applied_state_observed_assignment
  SUBTYPE OF (applied_state_observed_assignment, characterized_object);
END_ENTITY;

ENTITY item_assumed
  SUBTYPE OF (characterized_applied_state_observed_assignment);
END_ENTITY;

ENTITY justification_assignment
  SUBTYPE OF (group);
END_ENTITY;

ENTITY justification_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET[1:1] OF product;
END_ENTITY;

ENTITY justification_item_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET[1:1] OF justification_item;
END_ENTITY;

ENTITY justification_support_assignment
  SUBTYPE OF (group);
END_ENTITY;

ENTITY justification_support_item_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET[1:1] OF justification_support_item;
END_ENTITY;

END_SCHEMA;  -- Justification_mim


--
-- LANGUAGE_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/language_schema/language_schema.exp)
--
(*

ISO 10303 TC184/SC4/WG12 N10234

EXPRESS Source:
ISO 10303-41 ed6 Fundamentals of product description and support - Language schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2019  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Language schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA language_schema '{iso standard 10303 part(41) version(1) object(1) location_schema(13)}'; 

REFERENCE FROM group_schema   -- ISO 10303-41
  (group); 


ENTITY language 
	SUBTYPE OF (group); 
	WHERE
		WR1: SELF\group.name <> '';
	-- Informal proposition
--- IP1: The name attribute of the language shall be an alpha-3 bibliographic code of ISO 639-2.
--- IP2: If present, the description attribute shall identify a country with an alpha-2 code specified in ISO 3166-1. 

END_ENTITY; 

END_SCHEMA;


--
-- LOCATION_ASSIGNMENT_CHARACTERIZED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/location_assignment_characterized/mim.exp)
--
(*
 $Id: mim.exp,v 1.10 2004/11/19 21:37:36 robbod Exp 
 ISO TC184/SC4/WG12 N3077 - ISO/TS 10303-1358 Location assignment characterized - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2394
*) 


SCHEMA Location_assignment_characterized_mim;

USE FROM Approval_mim;    -- ISO/TS 10303-1012

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Effectivity_application_mim;    -- ISO/TS 10303-1059

USE FROM Location_assignment_mim;    -- ISO/TS 10303-1277

USE FROM Multi_linguism_mim;    -- ISO/TS 10303-1105

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object); 

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030


TYPE location_assignment_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (applied_location_assignment);
END_TYPE; 

TYPE location_assignment_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (applied_location_assignment);
END_TYPE; 

TYPE location_assignment_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (applied_location_assignment);
END_TYPE; 

TYPE location_assignment_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (applied_location_assignment);
END_TYPE; 

TYPE location_assignment_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (applied_location_assignment);
END_TYPE; 

TYPE location_assignment_effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON effectivity_item WITH 
   (applied_location_assignment);
END_TYPE; 

TYPE location_assignment_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (applied_location_assignment);
END_TYPE; 

TYPE location_assignment_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (applied_location_assignment);
END_TYPE; 

ENTITY characterized_applied_location_assignment
  SUBTYPE OF (applied_location_assignment, characterized_object);
END_ENTITY;

END_SCHEMA;  -- Location_assignment_characterized_mim



--
-- LOCATION_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/location_assignment/mim.exp)
--
(*
 $Id: mim.exp,v 1.7 2004/11/19 21:37:36 robbod Exp 
 ISO TC184/SC4/WG12 N3074 - ISO/TS 10303-1277 Location assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2391
*) 


SCHEMA Location_assignment_mim;

USE FROM Location_mim;    -- ISO/TS 10303-1276

USE FROM management_resources_schema   -- ISO 10303-41
  (location_assignment); 


TYPE location_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_location_assignment
  SUBTYPE OF (location_assignment);
  items : SET[1:?] OF location_item;
END_ENTITY;

END_SCHEMA;  -- Location_assignment_mim


--
-- LOCATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/location/mim.exp)
--
(*
 ISO TC184/SC4/WG12 N10755 - ISO/TS 10303-1276 Location - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N3071
*) 


SCHEMA Location_mim;

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Group_mim;    -- ISO/TS 10303-1113

USE FROM location_schema   -- ISO 10303-41
  (location,
   location_relationship);

USE FROM management_resources_schema   -- ISO 10303-41
  (location_representation_assignment);

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_definition,
   characterized_object,
   property_definition);

USE FROM product_property_representation_schema   -- ISO 10303-41
  (property_definition_representation,
   represented_definition);

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

USE FROM qualified_measure_schema   -- ISO 10303-45
  (measure_representation_item);

USE FROM representation_schema   -- ISO 10303-43
  (representation,
   representation_context,
   representation_item);

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054

TYPE location_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH
  (location,
   location_relationship,
   location_representation_relationship);
END_TYPE;

TYPE location_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH
  (location_representation_item,
   representation);
END_TYPE;

TYPE location_representation_item = EXTENSIBLE GENERIC_ENTITY SELECT 
  (organizational_address,
   person_and_organization_address,
   product,
   product_definition_formation);
END_TYPE;

ENTITY applied_location_representation_assignment
SUBTYPE OF (location_representation_assignment);
  items : SET [1 : ?] OF location_representation_item;
END_ENTITY;

ENTITY characterized_location_object
SUBTYPE OF (characterized_object, location);
END_ENTITY;

ENTITY location_representation_relationship
SUBTYPE OF (group);
END_ENTITY;

END_SCHEMA;  -- Location_mim



--
-- LOCATION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/location_schema/location_schema.exp)
--
(*
Id: location_schema.exp,v 1.17 2014/03/04 00:30:38 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Location schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Location schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA location_schema '{iso standard 10303 part(41) version(4) object(1) location_schema(13)}';
  REFERENCE FROM support_resource_schema (identifier, label, text, bag_to_set);
  ENTITY location;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY location_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_location : location;
    related_location : location;
  END_ENTITY;

  FUNCTION acyclic_location_relationship (relation : location_relationship; relatives : SET OF location; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF location_relationship;
    END_LOCAL;

    IF relation.relating_location IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(lctn <* bag_to_set(USEDIN(relation.relating_location, 'LOCATION_SCHEMA.' + 'LOCATION_RELATIONSHIP.' + 'RELATED_LOCATION')) | specific_relation IN TYPEOF(lctn));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_location_relationship(x[i], relatives + relation.relating_location, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;


--
-- MACHINING_FEATURE_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/machining_feature_schema/machining_feature_schema.exp)
--
(*
Id: machining_feature_schema.exp,v 1.13 2021/07/20 14:18:45 kevin Exp 
ISO 10303 TC184/SC4/WG12 N10600

EXPRESS Source:
ISO/FDIS 10303-113 ed2 Mechanical features - Machining feature schema

The following permission notice and disclaimer shall be included in
all copies of this EXPRESS schema ("the Schema"), and derivations of
the Schema:

Copyright ISO 2021 All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any
person obtaining a copy of the Schema, to use, copy, modify, merge and
distribute free of charge, copies of the Schema for the purposes of
developing, implementing, installing and using software based on the
Schema, and to permit persons to whom the Schema is furnished to do
so, subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SCHEMA OR THE USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-113 ed2 Mechanical features - Machining feature schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA machining_feature_schema '{iso standard 10303 part(113) version(1) object(1) machining_feature_schema(2)}';
  REFERENCE FROM counterbore_countersink_schema       -- ISO 10303-113
       (explicit_composite_hole,
        explicit_round_hole);
        
  REFERENCE FROM external_reference_schema              -- ISO 10303-41	
      (externally_defined_item);   
      
  REFERENCE FROM geometry_schema		              -- ISO 10303-42
      (bounded_curve,
       direction,
       plane,
       placement,
       point);
      
  REFERENCE FROM measure_schema                         -- ISO 10303-41
      (count_measure,
       length_measure_with_unit,
       measure_with_unit,
       named_unit,
       plane_angle_measure_with_unit,
       ratio_measure_with_unit); 
       
  REFERENCE FROM product_definition_schema              -- ISO 10303-41
      (product_definition);
       
  REFERENCE FROM product_property_definition_schema     -- ISO 10303-41
      (characterized_object,
       product_definition_shape, 
       property_definition,
       shape_aspect,
       shape_aspect_relationship);
       
  REFERENCE FROM product_property_representation_schema  -- ISO 10303-41
      (get_property_definition_representations,
      property_definition_representation,
      shape_representation);   
    
  REFERENCE FROM qualified_measure_schema                -- ISO 10303-45
      (descriptive_representation_item,
       measure_representation_item);
       
  REFERENCE FROM shape_aspect_definition_schema          -- ISO 10303-47
      (composite_shape_aspect,
       feature_definition,
       instanced_feature,
       shape_representation_with_parameters);
       
  REFERENCE FROM topology_schema                         -- ISO 10303-42
      (edge_curve,
       face_surface,
       oriented_face,
       path);

TYPE machining_feature_definition = SELECT (
  boss,
  compound_feature,
  externally_defined_feature_definition,
  flat_face,
  gear,
  marking,
  outer_round,
  outside_profile,
  pocket,
  protrusion,
  removal_volume,
  replicate_feature,
  revolved_profile,
  rib_top,
  round_hole,
  rounded_end,
  spherical_cap,
  step,
  slot,
  thread,
  turned_knurl);
END_TYPE;  

ENTITY applied_area
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE'
         IN TYPEOF(SELF.of_shape));
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') IN TYPEOF(pdr.
         used_representation)) ) |  
         (NOT({2 <= SIZEOF(impl_rep.used_representation.items) <= 3} )
          ) )) = 0)) )) = 0);
    WR4: SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         (SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
         NOT (srwp_i.name IN ['orientation','effective length', 
         'maximum length']) )) > 0 ) )) = 0 )   )) = 0;
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'effective length')) )) = 1)) )) 
         = 0)) )) <= 1);
    WR6: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'maximum length')) )) <= 1)) )) 
         = 0)) )) = 0);
    WR7: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (('GEOMETRY_SCHEMA.PLACEMENT' 
         IN TYPEOF(it))  AND (it.name = 'orientation')) )) = 1)) )) 
         = 0)) )) = 0);
END_ENTITY; -- applied_area

ENTITY boss
  SUBTYPE OF (feature_definition);
   WHERE   
    WR1: SELF\characterized_object.description IN 
         ['circular', 'complex', 'rectangular'];
    WR2: SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
         TYPEOF (pd)) |
         NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
         (sa_occ.description = 'boss height occurrence') AND
         (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         (sar.description = 'path feature component usage') AND 
         ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' IN TYPEOF (sar))) |
         ('TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT' IN
         TYPEOF (sdr.relating_shape_aspect)) AND
         (sdr.relating_shape_aspect.description = 'linear') AND
         (sdr.name = 'boss height'))) = 1))) = 1))) = 0; 
    WR3: SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         ({1 <= SIZEOF(pdr.used_representation.items) <= 2} ) )) = 1 )) = 1;
    WR4: SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN
         TYPEOF(pdr.used_representation)) AND
         (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
         (srwp_i.name = 'orientation') OR
         (srwp_i.name = 'fillet radius'))) 
         = SIZEOF(pdr.used_representation.items)) )) = 1 )) = 1;
    WR5: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF (
         ['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'fillet radius'))) <= 1))) 
         = 0))) = 0;
    WR6: (NOT (SELF\characterized_object.description = 'circular')) OR
         (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF (pd)) |
         NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
         (sa_occ.description = 'circular profile occurrence') AND
         (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         (sar.description = 'profile usage') AND 
         ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' 
         IN TYPEOF (sar))) |
         'MACHINING_FEATURE_SCHEMA.CIRCULAR_CLOSED_PROFILE' 
         IN TYPEOF (sdr.relating_shape_aspect))) = 1))) = 1))) = 0);        
    WR7: SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | 
       (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'top condition occurrence') AND 
       (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(sa_occ,
   'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       ((sar.description = 'boss top usage') AND 
       ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
       IN TYPEOF(sar))) ) | (('MACHINING_FEATURE_SCHEMA.BOSS_TOP' 
       IN TYPEOF(fcr.relating_shape_aspect)) ) )) = 1)) )) = 1)) )) = 0;       
    WR8: (NOT (SELF\characterized_object.description = 'circular')) OR
         (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
         TYPEOF (pd)) | 
         NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
         (sa_occ.description = 'change in diameter occurrence') AND
         (SIZEOF (QUERY (fcr <* QUERY (sar <* USEDIN (sa_occ, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         (sar.description = 'taper usage') AND
         ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF (sar))) | 
       (('MACHINING_FEATURE_SCHEMA.TAPER' IN TYPEOF (fcr.related_shape_aspect)) 
         AND
         ('MACHINING_FEATURE_SCHEMA.BOSS' IN TYPEOF (fcr.relating_shape_aspect)))
         ) )= 1))) <= 1))) = 0);
    WR9: (NOT (SELF\characterized_object.description = 'complex')) OR
         (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
          TYPEOF (pd)) | 
          NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds, 
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
          (sa_occ.description = 'enclosed boundary occurrence') AND
          (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ, 
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
          (sar.description = 'profile usage') AND
          ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' 
          IN TYPEOF (sar))) |
          SIZEOF (['MACHINING_FEATURE_SCHEMA.NGON_CLOSED_PROFILE',
          'MACHINING_FEATURE_SCHEMA.CLOSED_PATH_PROFILE'] *  
          TYPEOF (sdr.relating_shape_aspect)) = 1)) = 1)))= 1))) = 0);
    WR10: (NOT (SELF\characterized_object.description 
          IN ['complex','rectangular'])) OR
          (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
          IN TYPEOF (pd)) | 
          NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds, 
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
          (sa_occ.description = 'change in boundary occurrence') AND
          (SIZEOF (QUERY (fcr <* QUERY (sar <* USEDIN (sa_occ, 
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
          (sar.description = 'taper usage') AND
          ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
          IN TYPEOF (sar))) |
       (('MACHINING_FEATURE_SCHEMA.TAPER' IN TYPEOF (fcr.related_shape_aspect)) 
          AND
        ('MACHINING_FEATURE_SCHEMA.BOSS' IN TYPEOF (fcr.relating_shape_aspect)) 
          AND
          (fcr.related_shape_aspect.description IN 
          ['angle taper','directed taper']))
          )) = 1))) <= 1))) = 0);
    WR11: (NOT (SELF\characterized_object.description = 'rectangular')) OR
          (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
          IN TYPEOF (pd)) |
          NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds, 
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
          (sa_occ.description = 'rectangular profile occurrence') AND
          (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ, 
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
          (sar.description = 'profile usage') AND 
          ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' 
          IN TYPEOF (sar))) |
          'MACHINING_FEATURE_SCHEMA.RECTANGULAR_CLOSED_PROFILE' 
          IN TYPEOF (sdr.relating_shape_aspect))) = 1))) = 1))) = 0);
  
 WR12: SIZEOF (QUERY(pdr <* get_property_definition_representations (SELF) | 
       ( 'MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION' 
       IN TYPEOF ( pdr.used_representation ) ) AND 
       ( pdr.used_representation.name ='maximum feature limit'))) >=0;
END_ENTITY;  -- Boss


ENTITY boss_top
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
         IN TYPEOF(SELF.of_shape.definition));
    WR2: (SELF.description IN ['planar','complex']);
    WR3: ((NOT (SELF.description = 'planar')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('MACHINING_FEATURE_SCHEMA.DIRECTION_SHAPE_REPRESENTATION') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0));
    WR4: ((NOT (SELF.description = 'planar')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('MACHINING_FEATURE_SCHEMA.LOCATION_SHAPE_REPRESENTATION') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0));
    WR5: (NOT (SELF.description = 'complex')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         ('MACHINING_FEATURE_SCHEMA.FACE_SHAPE_REPRESENTATION') 
         IN TYPEOF(pdr.used_representation) )) = 1)) )) = 0);
    WR6: (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.'  + 
         'RELATING_SHAPE_ASPECT') | 
         ((sar.description = 'boss top usage') AND
         (sar.name  IN ['boss height start','boss height end']))AND
         ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar)))  | 
        ((fcr.related_shape_aspect.description = 'top condition occurrence') 
         AND 
         ('MACHINING_FEATURE_SCHEMA.BOSS' 
         IN TYPEOF(fcr.related_shape_aspect.of_shape.definition)) AND 
         ('MACHINING_FEATURE_SCHEMA.BOSS_TOP' 
         IN TYPEOF(fcr.relating_shape_aspect)) ) 
         )) >= 1);
    WR7: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |  
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) <= 1)) )) = 0);
    WR8: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
         = 0)) )) = 0);
   WR9: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF (
        ['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
        TYPEOF (it)) = 2) AND (it.name = 'top radius'))) <= 1))) 
        = 0))) = 0;
END_ENTITY; -- boss_top  

ENTITY chamfer
  SUBTYPE OF (transition_feature);
   WHERE
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('MACHINING_FEATURE_SCHEMA.FACE_SHAPE_REPRESENTATION' 
         IN TYPEOF(pdr.used_representation)) AND 
        (pdr.used_representation.name = 'chamfer face')) )) <= 1)) )) = 0);
    WR2: (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
         ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar)) ) | 
         (('MACHINING_FEATURE_SCHEMA.CHAMFER_OFFSET' 
         IN TYPEOF(fcr.related_shape_aspect))AND 
         ('MACHINING_FEATURE_SCHEMA.CHAMFER' 
         IN TYPEOF(fcr.relating_shape_aspect)) AND 
         (fcr.related_shape_aspect.description = 'first offset') ) 
          )) = 1);
    WR3: (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
         ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar)) ) | 
         (('MACHINING_FEATURE_SCHEMA.CHAMFER_OFFSET' 
         IN TYPEOF(fcr.related_shape_aspect))  AND 
         ('MACHINING_FEATURE_SCHEMA.CHAMFER' 
         IN TYPEOF(fcr.relating_shape_aspect))AND 
         (fcr.related_shape_aspect.description = 'second offset')) 
         )) = 1);
END_ENTITY; -- chamfer

ENTITY chamfer_offset
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: (SELF.description IN ['first offset','second offset']);
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
         = 0)) )) = 0);
    WR4: ((NOT (SELF.description = 'first offset')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'offset amount')) )) = 1)) )) 
         = 0)) )) = 0));
    WR5: ((NOT (SELF.description = 'first offset')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |  
         (('MACHINING_FEATURE_SCHEMA.FACE_SHAPE_REPRESENTATION' 
         IN TYPEOF(pdr.used_representation)) AND 
         (pdr.used_representation.name = 'first face shape')) )) <= 1)) )) 
         = 0));
    WR6: ((NOT (SELF.description = 'second offset')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'offset amount')) OR 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] 
         * TYPEOF(it)) = 2) AND (it.name = 'offset angle'))) )) = 1)) )) 
         = 0)) )) = 0));
    WR7: ((NOT (SELF.description = 'second offset')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |        
         (('MACHINING_FEATURE_SCHEMA.FACE_SHAPE_REPRESENTATION' 
         IN TYPEOF(pdr.used_representation)) AND 
        (pdr.used_representation.name = 'second face shape')) )) <= 1)) )) 
         = 0));
    WR8: (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
         (('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP') 
         IN TYPEOF(sar)) ) | 
         (('MACHINING_FEATURE_SCHEMA.CHAMFER' 
         IN TYPEOF(sdr.relating_shape_aspect))AND 
        ('MACHINING_FEATURE_SCHEMA.CHAMFER_OFFSET' 
         IN TYPEOF(sdr.related_shape_aspect)))
         )) = 1);
END_ENTITY; -- chamfer_offset

ENTITY circular_pattern
  SUBTYPE OF (replicate_feature);
   WHERE
    WR1: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN
         (pds,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
         + 'RELATING_SHAPE_ASPECT') | 
         ((('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' 
         IN TYPEOF(sdr.related_shape_aspect)) )) = 1)) )) <= 3)) )) = 0);
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT ((SIZEOF (impl_rep.used_representation.items) >= 3)  
         AND (SIZEOF(impl_rep.used_representation.items) <= 5))) )) 
         = 0)) )) = 0);
     WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF(
         ['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'diameter')) )) <= 1)) )) 
         = 0)) )) = 0);
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF(
         ['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] * 
         TYPEOF(it)) = 2) AND (it.name = 'base feature rotation')) )) 
         <= 1)) )) = 0)) )) = 0);
    WR6: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND 
         ('MEASURE_SCHEMA.COUNT_MEASURE' 
         IN TYPEOF(it\measure_with_unit.value_component)) AND 
         (it.name = 'number of features')) )) = 1)) )) = 0)) )) = 0);
    WR7: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF(
         ['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] * 
         TYPEOF(it)) = 2) AND (it.name = 'angular spacing'))))= 1)) )) 
         = 0)) )) = 0);
    WR8: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (('GEOMETRY_SCHEMA.PLACEMENT' 
         IN TYPEOF(it)) AND (it.name = 'orientation')) )) = 1)) )) 
         = 0)) )) = 0);
END_ENTITY; -- circular_pattern

ENTITY circular_closed_profile
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
         IN TYPEOF(SELF.of_shape.definition));
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS')
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(impl_rep.used_representation.items) = 2)) )) 
         = 0)) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         NOT(SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (('GEOMETRY_SCHEMA.PLACEMENT' 
         IN TYPEOF(it)) 
         AND (it.name = 'orientation')) )) = 1) )) = 0)) )) = 0);
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'diameter')) )) = 1)) )) 
         =  0)) )) = 0);
END_ENTITY; -- circular_closed_profile

ENTITY closed_path_profile
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
         IN TYPEOF(SELF.of_shape.definition));
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
         = 0)) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (('GEOMETRY_SCHEMA.PLACEMENT' 
         IN TYPEOF(it)) AND (it.name = 'orientation')) )) = 1)) )) 
         = 0)) )) = 0);
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('TOPOLOGY_SCHEMA.PATH_SHAPE_REPRESENTATION') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
END_ENTITY; -- closed_path_profile

ENTITY composite_hole
  SUBTYPE OF (compound_feature);
   WHERE
    WR1: ('COUNTERBORE_COUNTERSINK_SCHEMA.EXPLICIT_COMPOSITE_HOLE' IN TYPEOF(SELF)) XOR
    	 (SELF\characterized_object.description IN ['counterbore',
         'countersunk']);
    WR2: ('COUNTERBORE_COUNTERSINK_SCHEMA.EXPLICIT_COMPOSITE_HOLE' IN TYPEOF(SELF)) XOR
    	 (SIZEOF(QUERY ( pds <* USEDIN(SELF,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
           (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
           IN TYPEOF(pds)) AND (SIZEOF(QUERY ( csa <* USEDIN(pds,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
           (('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' 
           IN TYPEOF(csa)) AND 
           (SIZEOF(QUERY ( sar <* csa.component_relationships | 
           ((('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
           IN TYPEOF(sar)) AND ('MACHINING_FEATURE_SCHEMA.ROUND_HOLE' 
           IN TYPEOF(sar.related_shape_aspect))) 
           ))) = 2)) )) = 1)) )) = 1); 
  WR3: ('COUNTERBORE_COUNTERSINK_SCHEMA.EXPLICIT_COMPOSITE_HOLE' IN TYPEOF(SELF)) XOR
       ((NOT (SELF\characterized_object.description = 'countersunk')) OR 
       (SIZEOF(QUERY ( pds <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pds)) AND 
       (SIZEOF(QUERY ( csa <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT'  
       IN TYPEOF(csa)) AND 
       (SIZEOF(QUERY ( sar <* csa.component_relationships | 
       (('MACHINING_FEATURE_SCHEMA.ROUND_HOLE' 
       IN TYPEOF(sar.related_shape_aspect)) AND 
       (NOT (SIZEOF(QUERY ( pds <* QUERY ( pd <* 
       USEDIN(sar.related_shape_aspect,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | 
       (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'change in diameter occurrence') AND
       (SIZEOF(QUERY ( fcr2 <* QUERY ( sar2 <* USEDIN(sa_occ,
  'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
       ((sar2.description = 'taper usage') AND 
       ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
       IN TYPEOF(sar2))) ) | 
      ('MACHINING_FEATURE_SCHEMA.TAPER' IN TYPEOF(fcr2.related_shape_aspect))  
       )) = 1)) )) = 0)) )) = 0))) )) = 1)) )) = 1)) )) = 1));
END_ENTITY; -- composite_hole

ENTITY compound_feature
  SUBTYPE OF (feature_definition);
     WHERE 
    WR1: ('COUNTERBORE_COUNTERSINK_SCHEMA.EXPLICIT_COMPOSITE_HOLE' IN TYPEOF(SELF)) XOR
    	 (SIZEOF( QUERY( pds <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pds))  AND
        (SIZEOF( QUERY( csa <* USEDIN( pds, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        ((csa.name='compound feature in solid') AND
        ('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' 
        IN TYPEOF(csa))) )) = 1)  )) = 1);
    WR2: ('COUNTERBORE_COUNTERSINK_SCHEMA.EXPLICIT_COMPOSITE_HOLE' IN TYPEOF(SELF)) XOR
        (SIZEOF( QUERY( pds <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pds))  AND
       (SIZEOF( QUERY( csa <* USEDIN( pds, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' 
       IN TYPEOF(csa) )) = 1)  )) = 1); 
    WR3: ('COUNTERBORE_COUNTERSINK_SCHEMA.EXPLICIT_COMPOSITE_HOLE' IN TYPEOF(SELF)) XOR
       (SIZEOF(QUERY ( pds <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pds)) AND (SIZEOF(QUERY ( csa <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' 
       IN TYPEOF(csa)) AND 
       (SIZEOF(QUERY ( fcr <* csa.component_relationships | 
       (NOT ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
       IN TYPEOF(fcr))) )) = 0)) )) = 1)) )) = 1);
   WR4: ('COUNTERBORE_COUNTERSINK_SCHEMA.EXPLICIT_COMPOSITE_HOLE' IN TYPEOF(SELF)) XOR
       (SIZEOF (QUERY (pds <* USEDIN (SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')|
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF (pds)) AND 
       (SIZEOF (QUERY (csa <* USEDIN (pds, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE')| 
       ('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' 
       IN TYPEOF (csa))   )) = 1) )) = 1); 
    WR5: ('COUNTERBORE_COUNTERSINK_SCHEMA.EXPLICIT_COMPOSITE_HOLE' IN TYPEOF(SELF)) XOR
       (SIZEOF(QUERY ( pds <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pds)) AND 
       (SIZEOF(QUERY ( csa <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' 
       IN TYPEOF(csa)) AND 
       (SIZEOF(QUERY ( sar <* csa.component_relationships | 
       ('MACHINING_FEATURE_SCHEMA.THREAD' 
       IN TYPEOF(sar.related_shape_aspect)) )) = 0)
       ) )) = 1)) )) = 1);
    WR6: ('COUNTERBORE_COUNTERSINK_SCHEMA.EXPLICIT_COMPOSITE_HOLE' IN TYPEOF(SELF)) XOR
       (SIZEOF (QUERY (pds <* USEDIN (SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')|
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF (pds)) AND   (SIZEOF (QUERY (csa <* USEDIN (pds, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE')|
       ('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' 
       IN TYPEOF (csa))  AND 
       (SIZEOF (QUERY (sar <*  csa.component_relationships |
       (('MACHINING_FEATURE_SCHEMA.COMPOUND_FEATURE' 
       IN TYPEOF (sar.related_shape_aspect))  AND
       (sar.related_shape_aspect\characterized_object.name <> 
       SELF\characterized_object.name)) )) = 0)  )) = 1) )) = 1); 
END_ENTITY;  -- compound_feature
 
ENTITY direction_shape_representation
  SUBTYPE OF (shape_representation);
   WHERE
    WR1: (SIZEOF(SELF.items) = 1);
    WR2: (SIZEOF(QUERY ( it <* SELF.items | 
         (NOT (
         'MACHINING_FEATURE_SCHEMA.DIRECTION' IN TYPEOF(it))) )) 
         = 0);
END_ENTITY; -- direction_shape_representation

ENTITY edge_round
  SUBTYPE OF (transition_feature);
WHERE
    WR1: (NOT (SELF\shape_aspect.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <*  USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF (pdr.used_representation))) = 1))) = 0);
    WR2: (NOT (SELF\shape_aspect.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         (NOT (SIZEOF (impl_rep.used_representation.items) >= 1)
         AND  (SIZEOF (impl_rep.used_representation.items) <= 3)))) 
         = 0))) = 0); 
    WR3: (NOT (SELF.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF 
         (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'radius'))) = 1))) = 0))) = 0);
    WR4: (NOT (SELF.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF 
         (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'first offset'))) <= 1))) 
         = 0))) = 0);
    WR5: (NOT (SELF.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF 
         (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'second offset'))) <= 1))) 
         = 0))) = 0);
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('MACHINING_FEATURE_SCHEMA.FACE_SHAPE_REPRESENTATION'
         IN TYPEOF (pdr.used_representation)) AND 
         (pdr.used_representation.name = 'edge round face'))) <= 1))) = 0; 
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('MACHINING_FEATURE_SCHEMA.FACE_SHAPE_REPRESENTATION'
         IN TYPEOF (pdr.used_representation)) AND 
         (pdr.used_representation.name = 'first face shape'))) <= 1))) = 0;
    WR8: SIZEOF (QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('MACHINING_FEATURE_SCHEMA.FACE_SHAPE_REPRESENTATION'
         IN TYPEOF (pdr.used_representation)) AND 
         (pdr.used_representation.name = 'second face shape'))) <= 1))) = 0;
END_ENTITY; -- edge_round


ENTITY externally_defined_feature_definition
  SUBTYPE OF (feature_definition, externally_defined_item);
   WHERE
    WR1: (((SELF\characterized_object.description = 'thread') AND 
         (SELF\externally_defined_item.item_id='external thread') AND 
         (SELF\externally_defined_item.source.source_id=
         'external feature specification') ) OR 
         ((SELF\characterized_object.description = 'gear') AND 
         (SELF\externally_defined_item.item_id='external gear') AND 
         (SELF\externally_defined_item.source.source_id=
         'external feature specification')) OR 
         ((SELF\characterized_object.description = 'marking') AND 
         (SELF\externally_defined_item.item_id='external marking') AND 
         (SELF\externally_defined_item.source.source_id=
         'external feature specification')) OR 
         ((SELF\characterized_object.description = 'knurl') AND 
         (SELF\externally_defined_item.item_id='external knurl') AND  
         (SELF\externally_defined_item.source.source_id=
         'external feature specification')));
    WR2: ((NOT (SELF\characterized_object.description = 'thread')) OR 
         (SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         ({5 <= SIZEOF(pdr.used_representation.items) <= 10} ) )) 
         = 1  )) = 1));
    WR3: ((NOT (SELF\characterized_object.description = 'marking')) OR 
         (SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         (SIZEOF(pdr.used_representation.items) = 2)  )) = 1  )) = 1));
    WR4: ((NOT (SELF\characterized_object.description = 'knurl')) OR 
         (SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         (SIZEOF(pdr.used_representation.items) = 1)   )) = 1  )) = 1));
    WR5: (NOT (SELF\characterized_object.description IN [ 'knurl',
         'thread'])) OR
         (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN
         (pds,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'partial area occurrence') AND 
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
         + 'RELATED_SHAPE_ASPECT') | 
         ((sar.description = 'applied area usage') AND 
         (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         ('MACHINING_FEATURE_SCHEMA.APPLIED_AREA' 
         IN TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) <= 1)) )) = 0); 

    WR6: ((NOT (SELF\characterized_object.description = 'marking')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
         (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND (it.name = 'marking text')) )) = 1)) )) 
         = 0)) )) = 0));
    WR7: ((NOT (SELF\characterized_object.description = 'thread')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
         (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND (it.name = 'removal direction') AND 
         ((it.description = 'internal') OR 
         (it.description = 'external'))) )) = 1)) )) = 0)) )) = 0));
     WR8: ((NOT (SELF\characterized_object.description = 'thread')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
         (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND (it.name = 'qualifier')) ))<= 1)) ))= 0)) )) 
         = 0));
    WR9: ((NOT (SELF\characterized_object.description = 'thread')) OR 
         (SIZEOF(QUERY ( pd <*  USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
         (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND (it.name = 'hand')) )) = 1)) )) = 0)) )) 
         = 0));
     WR10: ((NOT (SELF\characterized_object.description = 'thread')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
         (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND (it.name = 'fit class')) )) = 1)) )) = 
         0)) )) = 0));
     WR11: ((NOT (SELF\characterized_object.description = 'thread')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
         (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND (it.name = 'form')) )) = 1)) )) = 0)) )) 
         = 0));
    WR12: ((NOT (SELF\characterized_object.description = 'thread')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
         (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'major diameter')) )) <= 1)) )) 
         = 0)) )) = 0));
     WR13: ((NOT (SELF\characterized_object.description = 'thread')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
         (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.RATIO_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'number of threads')) )) = 1)) )) 
         = 0)) )) = 0));
     WR14 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'fit class 2')) )) <= 1)) )) = 0)) )) 
        = 0);   
        
     WR15 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
        * TYPEOF(it)) = 2) AND (it.name = 'nominal size')) )) 
        <= 1)) )) = 0)) )) = 0); 

    WR16: (NOT (SELF\characterized_object.description IN [ 'knurl',
         'gear', 'thread'])) OR
         (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN
         (pds,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
         + 'RELATED_SHAPE_ASPECT') | 
         ((sar.description = 'applied shape') AND 
         (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' 
         IN TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) <= 1)) )) = 0);
     WR17: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR 
          (SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
          SIZEOF( QUERY( pdr <* USEDIN( pd, 
          'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
          ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
          IN TYPEOF(pdr.used_representation)) AND 
          (10 <= SIZEOF(pdr.used_representation.items)) AND 
          (SIZEOF(pdr.used_representation.items) >= 11)    
          )) = 1  )) = 1));

 WR18: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR  
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.RATIO_MEASURE_WITH_UNIT'] *
       TYPEOF(it)) = 2) AND (it.name = 'number of teeth')) )) = 1)) )) 
       = 0)) )) = 0));

 WR19: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR  
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
    TYPEOF(it)) = 2) AND (it.name = 'reference pressure angle')) )) = 1)) )) 
       = 0)) )) = 0));

 WR20: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR  
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF(it)) = 2) AND (it.name = 'rake shift factor')) )) = 1)) )) 
       = 0)) )) = 0));

 WR21: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR  
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF(it)) = 2) AND (it.name = 'nominal tooth depth')) )) = 1)) )) 
       = 0)) )) = 0));

 WR22: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR  
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF(it)) = 2) AND (it.name = 'face width')) )) = 1)) )) 
       = 0)) )) = 0));

 WR23: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR  
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF(it)) = 2) AND (it.name = 'tip diameter')) )) = 1)) )) 
       = 0)) )) = 0));

  WR24: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR 
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
       (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
       IN TYPEOF(it)) AND (it.name = 'module or diametral pitch') AND 
       ((it.description = 'module') OR 
       (it.description = 'diametral pitch'))) )) = 1)) )) = 0)) )) = 0));

 WR25: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR  
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF(it)) = 2) AND (it.name = 'normal attribute')) )) = 1)) )) 
       = 0)) )) = 0));

  WR26: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR 
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
       (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
       IN TYPEOF(it)) AND (it.name = 'internal or external gear') AND 
       ((it.description = 'internal') OR 
       (it.description = 'external'))) )) = 1)) )) = 0)) )) = 0));

 WR27: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR  
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
    TYPEOF(it)) = 2) AND (it.name = 'root fillet radius')) )) <= 1)) )) 
       = 0)) )) = 0));

END_ENTITY; -- externally_defined_feature_definition

ENTITY face_shape_representation
  SUBTYPE OF (shape_representation);
   WHERE
    WR1: (SIZEOF(SELF.items) >= 1);
    WR2: (SIZEOF(QUERY ( it <* SELF.items | (NOT (
         ('TOPOLOGY_SCHEMA.FACE_SURFACE' IN TYPEOF(it)) OR
         ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF(it)) ))
          )) = 0);
END_ENTITY; -- face_shape_representation 
   
ENTITY feature_component_definition
  SUBTYPE OF (characterized_object);
   WHERE
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(USEDIN(pd,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE')) = 1)) )) 
        = 0);
END_ENTITY; -- feature_component_definition

ENTITY feature_component_relationship
  SUPERTYPE OF (ONEOF (pattern_omit_membership,pattern_offset_membership))
  SUBTYPE OF (shape_aspect_relationship);
   WHERE
    WR1: ((SIZEOF([
         'SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT',
         'MACHINING_FEATURE_SCHEMA.REPLICATE_FEATURE',
         'MACHINING_FEATURE_SCHEMA.TRANSITION_FEATURE',
         'MACHINING_FEATURE_SCHEMA.MODIFIED_PATTERN'] * TYPEOF
         (SELF.relating_shape_aspect)) = 1) OR 
         ('MACHINING_FEATURE_SCHEMA.MACHINING_FEATURE_DEFINITION' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition)) OR 
         ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition)));
END_ENTITY; -- feature_component_relationship

ENTITY feature_pattern
  SUBTYPE OF (replicate_feature);
   WHERE
    WR1: SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
         NOT ('GEOMETRY_SCHEMA.PLACEMENT' 
         IN TYPEOF(srwp_i)) )) > 0 ) ))   > 0  )) = 0;
    WR2: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         ('GEOMETRY_SCHEMA.PLACEMENT' 
         IN TYPEOF (it)) AND (it.name = 'base feature placement'))) > 1))) 
         = 0))) = 0;
END_ENTITY; -- feature_pattern

ENTITY fillet
  SUBTYPE OF (transition_feature);
  WHERE
    WR1: (NOT (SELF\shape_aspect.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <*  USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF (pdr.used_representation))) = 1))) = 0);
    WR2: (NOT (SELF\shape_aspect.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         (NOT (SIZEOF (impl_rep.used_representation.items) >= 1)
         AND(SIZEOF (impl_rep.used_representation.items) <= 3)))) 
         = 0))) = 0); 
    WR3: (NOT (SELF.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF 
         (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'radius'))) = 1))) = 0))) = 0);
    WR4: (NOT (SELF.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF 
         (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'first offset'))) <= 1))) 
         = 0))) = 0);
    WR5: (NOT (SELF.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF 
         (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'second offset'))) <= 1))) 
         = 0))) = 0); 
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('MACHINING_FEATURE_SCHEMA.FACE_SHAPE_REPRESENTATION'
         IN TYPEOF (pdr.used_representation)) AND 
         (pdr.used_representation.name = 'fillet face'))) = 1))) = 0; 
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('MACHINING_FEATURE_SCHEMA.FACE_SHAPE_REPRESENTATION'
         IN TYPEOF (pdr.used_representation)) AND 
         (pdr.used_representation.name = 'first face shape'))) = 1))) = 0; 
    WR8: SIZEOF (QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('MACHINING_FEATURE_SCHEMA.FACE_SHAPE_REPRESENTATION'
         IN TYPEOF (pdr.used_representation)) AND 
         (pdr.used_representation.name = 'second face shape'))) = 1))) = 0;  
END_ENTITY;

ENTITY flat_face
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         (('MACHINING_FEATURE_SCHEMA.DIRECTION_SHAPE_REPRESENTATION' 
         IN TYPEOF(pdr.used_representation)) AND 
         (pdr.used_representation.name = 'removal direction')) )) = 1)) )) 
         = 0);
    WR2: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'course of travel occurrence') AND 
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
         ((sar.description = 'path feature component usage') AND 
         (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         (('TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT' 
         IN TYPEOF(sdr.relating_shape_aspect)) AND 
         (sdr.relating_shape_aspect.description = 'linear') AND 
         (sdr.name = 'course of travel')) )) = 1)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'removal boundary occurrence') AND 
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
         ((sar.description = 'profile usage') AND 
         (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         (('MACHINING_FEATURE_SCHEMA.LINEAR_PROFILE' 
         IN TYPEOF(sdr.relating_shape_aspect)) AND 
         (sdr.name = 'removal boundary')) )) = 1)) )) = 1)) )) = 0);
    WR4: SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF (pd)) | 
         NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
         (sa_occ.description = 'enclosed boundary occurrence') AND
         (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         (sar.description = 'profile usage') AND
         ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' 
         IN TYPEOF (sar))) |
         (SIZEOF 
         (['MACHINING_FEATURE_SCHEMA.CIRCULAR_CLOSED_PROFILE', 
         'MACHINING_FEATURE_SCHEMA.NGON_CLOSED_PROFILE',
         'MACHINING_FEATURE_SCHEMA.RECTANGULAR_CLOSED_PROFILE',
         'MACHINING_FEATURE_SCHEMA.CLOSED_PATH_PROFILE'] *
         TYPEOF (sdr.relating_shape_aspect)) = 1) AND
         (sdr.relating_shape_aspect.description = 'boundary'))) 
         = 1))) <= 1))) = 0;
  WR5: SIZEOF(QUERY( pdr <* get_property_definition_representations (SELF) | 
        ( 'MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION' 
        IN TYPEOF ( pdr.used_representation ) ) AND 
        ( pdr.used_representation.name ='maximum feature limit'))) >=0;
   WR6: SIZEOF(QUERY ( pds <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pds)) AND (SIZEOF(QUERY ( csa <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' IN 
        TYPEOF(csa)) AND 
        (csa.name='uncut volume') AND 
        (SIZEOF(QUERY ( sar <* csa.component_relationships | 
        (('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF(sar)) AND (SIZEOF([
        'MACHINING_FEATURE_SCHEMA.BOSS',
        'MACHINING_FEATURE_SCHEMA.PROTRUSION'] * TYPEOF(sar.
        related_shape_aspect)) = 1)) )) = 1)) )) <= 1)) )) = 1;            
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF (
         ['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'removal depth'))) <= 1))) 
         = 0))) = 0;     
        
END_ENTITY; -- flat_face  


ENTITY gear
  SUBTYPE OF (feature_definition);
WHERE
  WR1 : SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
    SIZEOF(QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation)) 
    AND (10 <= SIZEOF(pdr.used_representation.items)) AND 
    (SIZEOF(pdr.used_representation.items) <= 13))) = 1)) = 1;
    
  WR2 : NOT (SELF\characterized_object.description 
      IN ['straight bevel gear', 'helical bevel gear', 
          'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation)) | NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | 
     (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
    'MEASURE_SCHEMA.RATIO_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND 
    (it.name = 'number of teeth'))) = 1))) = 0))) = 0);
    
  WR3 : NOT (SELF\characterized_object.description 
        IN ['straight bevel gear', 'helical bevel gear', 
            'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF,  
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation)) | NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
   'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT']* TYPEOF(it))= 2) AND 
    (it.name = 'reference pressure angle'))) = 1))) = 0))) = 0);
     
  WR4 : NOT (SELF\characterized_object.description 
      IN ['straight bevel gear', 'helical bevel gear', 
      'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation)) | NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
   'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND 
    (it.name = 'rake shift factor'))) = 1))) = 0))) = 0);
    
  WR5 : NOT (SELF\characterized_object.description 
        IN ['straight bevel gear', 'helical bevel gear', 
        'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation))| NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
    'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']* TYPEOF(it)) = 2) AND 
    (it.name = 'nominal tooth depth'))) = 1))) = 0))) = 0);
    
  WR6 : NOT (SELF\characterized_object.description 
        IN ['straight bevel gear', 'helical bevel gear', 
        'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation))| NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
    'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']* TYPEOF(it)) = 2) AND 
    (it.name = 'face width'))) = 1))) = 0))) = 0);
    
  WR7 : NOT (SELF\characterized_object.description 
        IN ['straight bevel gear', 'helical bevel gear', 
        'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation))| NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
    'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']* TYPEOF(it)) = 2) AND 
    (it.name = 'tip diameter'))) = 1))) = 0))) = 0);
    
  WR8 : NOT (SELF\characterized_object.description 
       IN ['straight bevel gear', 'helical bevel gear', 
       'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation))| NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | 
('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND 
    (it.name = 'module or diametral pitch') AND 
    ((it.description ='module') OR (it.description = 'diametral pitch')))) 
    = 1))) = 0))) = 0);
    
  WR9 : NOT (SELF\characterized_object.description 
       IN ['straight bevel gear', 'helical bevel gear', 
       'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation))| NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | 
('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND 
    (it.name = 'internal or external gear') AND 
    ((it.description ='internal') OR (it.description = 'external')))) 
    = 1))) = 0))) = 0);   
     
  WR10: NOT (SELF\characterized_object.description 
        IN ['straight bevel gear', 'helical bevel gear', 
        'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation))| NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
    'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']* TYPEOF(it)) = 2) AND 
    (it.name = 'normal attribute'))) = 1))) = 0))) = 0);
    
  WR11 : NOT (SELF\characterized_object.description 
        IN ['straight bevel gear', 'helical bevel gear', 
        'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation))| NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
    'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']* TYPEOF(it)) = 2) AND 
    (it.name = 'root fillet radius'))) <= 1))) = 0))) = 0);
    
  WR12 : NOT (SELF\characterized_object.description 
    IN ['helix gear','helical bevel gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
    NOT (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation)) | NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT']* TYPEOF(it))= 2) AND 
    (it.name = 'reference helix angle'))) = 1))) = 0))) =  0);
    
  WR13 : NOT (SELF\characterized_object.description 
       IN ['helix gear','helical bevel gear']) OR 
       (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation))| NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | 
     ('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
     IN TYPEOF(it)) AND (it.name = 'gear tooth') AND 
     ((it.description = 'left hand tooth') OR 
     (it.description = 'right hand tooth')))) = 1))) = 0))) = 0);
    
  WR14 : NOT (SELF\characterized_object.description 
    IN ['straight bevel gear','helical bevel gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
    NOT (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation)) | NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT']* TYPEOF(it))= 2) AND 
    (it.name = 'tip angle'))) = 1))) = 0))) =   0);
    
  WR15 : NOT (SELF\characterized_object.description 
    IN ['straight bevel gear','helical bevel gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
    NOT (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation)) | NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT']* TYPEOF(it))= 2) AND 
    (it.name = 'root angle'))) = 1))) = 0))) =  0);
    
  WR16 : SIZEOF(QUERY(pds <* QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)) | NOT 
    (SIZEOF(QUERY(sa_occ <* USEDIN(pds, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
    SIZEOF( QUERY(sdr <* QUERY(sar <* USEDIN(sa_occ, 
  'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
    (sar.description = 'applied shape') AND 
    ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' 
    IN TYPEOF(sar))) | 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' 
    IN TYPEOF(sdr.relating_shape_aspect))) = 1)) = 1))) = 0;
    
END_ENTITY;

ENTITY hole_bottom
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
         IN TYPEOF(SELF.of_shape.definition));
    WR2: (SELF.description IN ['through', 'flat', 'flat with radius',
         'flat with taper','spherical', 'conical']);
    WR3: ((NOT (SELF.description = 'through')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) = 0)) )) 
          = 0));
    WR4: ((NOT (SELF.description IN ['flat with radius', 
         'flat with taper', 'spherical','conical'])) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0));
   WR5: ((NOT (SELF.description = 'flat')) OR 
        (SIZEOF(QUERY ( pd <*  USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 0)) )) 
         = 0)) )) = 0));
    WR6: ((NOT (SELF.description IN ['flat with radius','spherical'])) 
        OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
        = 0)) )) = 0));
    WR7: ((NOT (SELF.description = 'flat with taper')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 2)) )) 
        = 0)) )) = 0));
    WR8: ((NOT (SELF.description = 'conical')) OR (SIZEOF(
        QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF (impl_rep.used_representation.items) >= 1)
        AND  (SIZEOF (impl_rep.used_representation.items) <= 2)) )) 
        = 0)) )) = 0));
    WR9: ((SELF.description = 'through') OR 
        (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
        ((sar.description = 'hole bottom usage') AND
        ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF(sar))) ) | 
        ((fcr.name IN ['hole depth start','hole depth end'])) )) >= 1));
   WR10: ((NOT (SELF.description = 'flat with radius')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
        TYPEOF(it)) = 2) AND (it.name = 'corner radius')))) = 1)) )) 
        = 0)) )) = 0));
    WR11: ((NOT (SELF.description = 'spherical')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'radius')) )) = 1)) )) = 
        0)) )) = 0));
    WR12: ((NOT (SELF.description = 'conical')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'tip radius')) )) <= 1)) )) 
        = 0)) )) = 0));
    WR13: ((NOT (SELF.description = 'conical')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'tip angle')) )) = 1)) )) 
        = 0)) )) = 0));
    WR14: (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
        ((sar.description = 'hole bottom usage') AND
        ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF(sar))) ) | 
      ((fcr.related_shape_aspect.description ='bottom condition occurrence') 
        AND ('MACHINING_FEATURE_SCHEMA.ROUND_HOLE' 
        IN TYPEOF(fcr.related_shape_aspect.of_shape.definition)) AND 
        ('MACHINING_FEATURE_SCHEMA.HOLE_BOTTOM' 
        IN TYPEOF(fcr.relating_shape_aspect))) 
        )) >= 1);
    WR15: ((NOT (SELF.description = 'flat with taper')) OR (SIZEOF(
        QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |  
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'final diameter')))) = 1)) )) 
        = 0)) )) = 0));
    WR16: ((NOT (SELF.description = 'flat with taper')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name =  'taper diameter')) )) = 1)) )) 
        = 0)) )) = 0));
 END_ENTITY; -- hole_bottom

ENTITY linear_profile
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
         IN TYPEOF(SELF.of_shape.definition));
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(impl_rep.used_representation.items) = 2)) )) 
         = 0)) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (('GEOMETRY_SCHEMA.PLACEMENT' IN TYPEOF(it)) AND 
         (it.name = 'orientation')) )) = 1)) )) = 0)) )) = 0);
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'profile length')) )) = 1)) )) 
         = 0)) )) = 0);
END_ENTITY; -- linear_profile
 
ENTITY location_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
   WR1: (SIZEOF(SELF.items) = 1);
   WR2: (SIZEOF(QUERY ( it <* SELF.items | 
        (NOT ('GEOMETRY_SCHEMA.POINT' 
        IN TYPEOF(it))) )) = 0);
END_ENTITY; -- location_shape_representation

ENTITY marking
  SUBTYPE OF (feature_definition);
WHERE
    WR1: SIZEOF( QUERY( pd <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        SIZEOF( QUERY( pdr <* USEDIN( pd, 
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN
        TYPEOF(pdr.used_representation)) AND
        ({2 <= SIZEOF(pdr.used_representation.items) <=6} ) )) 
        = 1 )) = 1;
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* 
        QUERY ( pdr <* USEDIN(pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'marking text')) )) = 1)) )) 
        = 0)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'special instructions')) )) <= 1)) )) 
        = 0)) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd, 
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'font name')))) <= 1)))) 
        = 0)) )) = 0);
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'character height')) )) <= 1)) )) 
        = 0)) )) = 0);
    WR6: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'character spacing')) )) <= 1)) )) 
        = 0)) )) = 0);
    WR7: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | 
        (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
        + 'RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'applied shape') AND 
        (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' 
        IN TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) = 1)) )) = 0);
END_ENTITY; -- marking

ENTITY modified_pattern
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: SIZEOF( QUERY (fcr <* QUERY(sar <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
        'MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar)) |
        (SIZEOF( 
        ['MACHINING_FEATURE_SCHEMA.REPLICATE_FEATURE',
        'SHAPE_ASPECT_DEFINITION_SCHEMA.INSTANCED_FEATURE'] * 
        TYPEOF (fcr.related_shape_aspect.of_shape.definition)) >= 1)  AND
        (fcr.description = 'base shape')) ) = 1;
   WR2: SIZEOF( QUERY (fcr <* QUERY(sar <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
        'MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar)) |
        (SIZEOF( 
        ['MACHINING_FEATURE_SCHEMA.CIRCULAR_PATTERN', 
        'MACHINING_FEATURE_SCHEMA.RECTANGULAR_PATTERN'] * 
        TYPEOF(fcr.related_shape_aspect.of_shape.definition)) = 1) AND 
        (fcr.description = 'base pattern')) ) = 1;
   WR3: SIZEOF(QUERY ( sar <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
        (SIZEOF(QUERY ( msar <* USEDIN(sar.related_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        (SIZEOF([
        'MACHINING_FEATURE_SCHEMA.PATTERN_OFFSET_MEMBERSHIP',
        'MACHINING_FEATURE_SCHEMA.PATTERN_OMIT_MEMBERSHIP'] * 
        TYPEOF(sar)) = 1) AND (sar.description='modified pattern') 
        AND (sar :<>: msar) )) >= 1) )) = 0;
END_ENTITY; -- modified_pattern

ENTITY ngon_closed_profile
  SUBTYPE OF (shape_aspect);
WHERE
    WR1: 'MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
         IN TYPEOF (SELF.of_shape.definition);
    WR2: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation))) = 1))) = 0;
    WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT ((SIZEOF (impl_rep.used_representation.items) >= 3)  
         AND (SIZEOF(impl_rep.used_representation.items) <= 4)))) = 0))) = 0;
    WR4:  SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
         (srwp_i.name = 'orientation') OR
         (srwp_i.name = 'number of sides') OR
         (srwp_i.name = 'circumscribed diameter') OR
         (srwp_i.name = 'corner radius') OR
         (srwp_i.name = 'diameter across flats'))) 
         = SIZEOF(pdr.used_representation.items))  )) = 1 )) = 1;
    WR5: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         ('GEOMETRY_SCHEMA.PLACEMENT' IN TYPEOF (it)) AND 
         (it.name = 'orientation'))) = 1))) = 0))) = 0;
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
         IN TYPEOF (it)) AND 
         ('MEASURE_SCHEMA.COUNT_MEASURE' 
         IN TYPEOF (it\measure_with_unit.value_component)) AND 
         (it.name = 'number of sides'))) = 1))) = 0))) = 0;
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF 
         (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
         TYPEOF (it)) = 2) AND 
         (it.name IN ['circumscribed diameter','diameter across flats']) )) 
         = 1) )) = 0))) = 0;
    WR8: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF 
         (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
         TYPEOF (it)) = 2) AND 
         (it.name = 'corner radius'))) <= 1))) = 0))) = 0;
  END_ENTITY;

ENTITY open_path_profile
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
         IN TYPEOF(SELF.of_shape.definition));
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF (impl_rep.used_representation.items) = 1)) )) 
         = 0)) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (('GEOMETRY_SCHEMA.PLACEMENT' 
         IN TYPEOF(it)) AND 
         (it.name = 'orientation')) )) = 1)) )) = 0)) )) = 0);
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         ('TOPOLOGY_SCHEMA.PATH_SHAPE_REPRESENTATION' 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION'
         IN TYPEOF (pdr.used_representation))AND
         (pdr.used_representation.name = 'profile limit') )) <= 1))) = 0;
END_ENTITY;

ENTITY outer_round
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: ((NOT (SELF\characterized_object.description = 'outer diameter')) OR 
        (SIZEOF( QUERY( pd <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        SIZEOF( QUERY( pdr <* USEDIN( pd, 
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
        IN TYPEOF(pdr.used_representation)) AND
        (SIZEOF (pdr.used_representation.items) = 3) )) = 1 )) = 1));
    WR2: ((NOT (SELF\characterized_object.description 
        = 'outer diameter to shoulder')) OR 
        (SIZEOF( QUERY( pd <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        SIZEOF( QUERY( pdr <* USEDIN( pd, 
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
        IN TYPEOF(pdr.used_representation)) AND
       ( {2 <= SIZEOF(pdr.used_representation.items) <= 3}) )) = 1 )) = 1));
    WR3: (SELF\characterized_object.description IN 
        ['outer diameter', 'outer diameter to shoulder']);
  WR4: ((NOT (SELF\characterized_object.description = 'outer diameter')) OR 
        (SIZEOF( QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'length')) )) = 1)) ))
        = 0)) )) = 0));
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'diameter')) )) = 1)) )) 
        = 0)) )) = 0);
    WR6: ((NOT (SELF\characterized_object.description 
        = 'outer diameter to shoulder')) OR (
        SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
        TYPEOF(pd)) ) | 
        (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'v-shape boundary occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'profile usage') AND 
        (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (('MACHINING_FEATURE_SCHEMA.VEE_PROFILE' 
        IN TYPEOF(sdr.relating_shape_aspect)) AND 
        (sdr.relating_shape_aspect.description = 'v-shape')) )) = 1)) )) 
        = 1)) )) = 0));
  WR7: ((NOT (SELF\characterized_object.description = 'outer diameter')) OR 
        (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'reduced size occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'taper usage') AND 
        (('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (('MACHINING_FEATURE_SCHEMA.TAPER' 
        IN TYPEOF(sdr.relating_shape_aspect)) AND 
        ('MACHINING_FEATURE_SCHEMA.OUTER_ROUND' 
        IN TYPEOF(sdr.related_shape_aspect.of_shape.definition)) AND 
        (sdr.name = 'reduced size')) 
        ))  = 1)) ))
        <= 1)) )) = 0));
    WR8: ((NOT (SELF\characterized_object.description = 
         'outer diameter to shoulder')) OR 
        (SIZEOF( QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'length')) )) <= 1)) ))
        = 0)) )) = 0));  
     WR9: ((NOT (SELF\characterized_object.description = 
         'outer diameter to shoulder')) OR 
        (SIZEOF( QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'feature length')) )) <= 1)) ))
        = 0)) )) = 0));         
END_ENTITY; -- outer_round

ENTITY outside_profile
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: SIZEOF( QUERY( pd <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        SIZEOF( QUERY( pdr <* USEDIN( pd, 
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
        IN TYPEOF(pdr.used_representation)) AND
        (SIZEOF (pdr.used_representation.items) = 1) )) = 1 )) = 1;
    WR2: SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description IN ['boundary occurrence',
        'non-planar boundary occurrence',
        'partial circular boundary occurrence',
        'closed circular boundary occurrence',
        'open rectangular boundary occurrence',
        'closed rectangular boundary occurrence']) )) =1)  ))=0;
    WR3: (NOT(SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'boundary occurrence') )) =1)  ))=0))  OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile usage') AND
        ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' IN TYPEOF (sar))) |
        (SIZEOF (['MACHINING_FEATURE_SCHEMA.CIRCULAR_CLOSED_PROFILE', 
        'MACHINING_FEATURE_SCHEMA.NGON_CLOSED_PROFILE',
        'MACHINING_FEATURE_SCHEMA.RECTANGULAR_CLOSED_PROFILE',
        'MACHINING_FEATURE_SCHEMA.CLOSED_PATH_PROFILE',
        'MACHINING_FEATURE_SCHEMA.SQUARE_U_PROFILE',
        'MACHINING_FEATURE_SCHEMA.PARTIAL_CIRCULAR_PROFILE',
        'MACHINING_FEATURE_SCHEMA.ROUNDED_U_PROFILE',
        'MACHINING_FEATURE_SCHEMA.LINEAR_PROFILE',
        'MACHINING_FEATURE_SCHEMA.VEE_PROFILE',
        'MACHINING_FEATURE_SCHEMA.TEE_PROFILE',
        'MACHINING_FEATURE_SCHEMA.OPEN_PATH_PROFILE'] *
        TYPEOF (sdr.relating_shape_aspect)) = 1) AND
        (sdr.relating_shape_aspect.description = 'outside boundary'))) 
        = 1))) = 1))) = 0);  
    WR4: (NOT(SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description IN ['complex boundary occurrence',
        'partial circular boundary occurrence',
        'closed circular boundary occurrence',
        'open rectangular boundary occurrence',
        'closed rectangular boundary occurrence']) ))=1)   ))=0)) OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        NOT(SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile floor usage') AND
        ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        (('MACHINING_FEATURE_SCHEMA.PROFILE_FLOOR' 
        IN TYPEOF (sdr.relating_shape_aspect)) AND
        ('MACHINING_FEATURE_SCHEMA.OUTSIDE_PROFILE' 
        IN TYPEOF (sdr.related_shape_aspect.of_shape.definition)))
        )) = 1))) = 0))) = 0);
    WR5: (NOT(SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description IN ['outside boundary',
        'complex boundary occurrence',
        'partial circular boundary occurrence',
        'closed circular boundary occurrence',
        'open rectangular boundary occurrence',
        'closed rectangular boundary occurrence']) ))=1)   ))=0)) OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'path feature component usage') AND
        ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' IN TYPEOF (sar))) |
        (SIZEOF (['TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT'] *
        TYPEOF (sdr.relating_shape_aspect)) = 1) AND
        (sdr.name = 'profile swept shape') AND
        (sdr.relating_shape_aspect.description='linear') ))  = 1))) 
        = 1))) = 0);
    WR6: (NOT(SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'complex boundary occurrence') )) 
        =1)  ))=0))  OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile usage') AND
        ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        (SIZEOF (['MACHINING_FEATURE_SCHEMA.CIRCULAR_CLOSED_PROFILE',
        'MACHINING_FEATURE_SCHEMA.NGON_CLOSED_PROFILE',
        'MACHINING_FEATURE_SCHEMA.RECTANGULAR_CLOSED_PROFILE',
        'MACHINING_FEATURE_SCHEMA.CLOSED_PATH_PROFILE',
        'MACHINING_FEATURE_SCHEMA.SQUARE_U_PROFILE',
        'MACHINING_FEATURE_SCHEMA.PARTIAL_CIRCULAR_PROFILE',
        'MACHINING_FEATURE_SCHEMA.ROUNDED_U_PROFILE',
        'MACHINING_FEATURE_SCHEMA.VEE_PROFILE',
        'MACHINING_FEATURE_SCHEMA.TEE_PROFILE',
        'MACHINING_FEATURE_SCHEMA.LINEAR_PROFILE',
        'MACHINING_FEATURE_SCHEMA.OPEN_PATH_PROFILE'] *  
        TYPEOF (sdr.relating_shape_aspect)) =1))  ) 
        = 1)))= 1))) = 0);
    WR7: (NOT(SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'partial circular boundary occurrence') )) 
        =1)  ))=0))  OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile usage') AND
        ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        ('MACHINING_FEATURE_SCHEMA.PARTIAL_CIRCULAR_PROFILE' IN  
        TYPEOF (sdr.relating_shape_aspect)))) 
        = 1)))= 1))) = 0);
    WR8: (NOT(SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'closed circular boundary occurrence') )) 
        =1)  ))=0))  OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile usage') AND
        ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        ('MACHINING_FEATURE_SCHEMA.CIRCULAR_CLOSED_PROFILE' IN  
        TYPEOF (sdr.relating_shape_aspect)))) 
        = 1)))= 1))) = 0);
    WR9: (NOT(SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'open rectangular boundary occurrence') )) 
        =1)  ))=0))  OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile usage') AND
        ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        ('MACHINING_FEATURE_SCHEMA.SQUARE_U_PROFILE' IN  
        TYPEOF (sdr.relating_shape_aspect)))) 
        = 1)))= 1))) = 0);
    WR10: (NOT(SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'closed rectangular boundary occurrence') )) 
        =1)  ))=0))  OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile usage') AND
        ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        ('MACHINING_FEATURE_SCHEMA.RECTANGULAR_CLOSED_PROFILE' IN  
        TYPEOF (sdr.relating_shape_aspect)) )) = 1)))
        = 1))) = 0);
    WR11: (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description IN ['boundary occurrence',
        'complex boundary occurrence',
        'partial circular boundary occurrence',
        'closed circular boundary occurrence',
        'open rectangular boundary occurrence',
        'closed rectangular boundary occurrence']) )) =1)  ))=0) OR
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        (('MACHINING_FEATURE_SCHEMA.DIRECTION_SHAPE_REPRESENTATION' 
        IN TYPEOF(pdr.used_representation)) AND 
        (pdr.used_representation.name = 'removal direction')) )) = 1)) )) 
        = 0);
  WR12: SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
       ( 'MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION' 
       IN TYPEOF ( pdr.used_representation ) ) AND 
       ( pdr.used_representation.name ='maximum feature limit'))) >=0; 
END_ENTITY; -- outside_profile

ENTITY partial_circular_profile
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF(SELF.of_shape.definition));
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF (impl_rep.used_representation.items) >= 3)) )) 
        = 0)) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        (('GEOMETRY_SCHEMA.PLACEMENT' 
        IN TYPEOF(it)) AND (it.name = 'orientation')) )) = 1)) )) 
        = 0)) )) = 0);
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'radius')))) = 1)) )) 
        = 0)) )) = 0);
    WR6: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'sweep angle')) )) = 1)) )) 
        = 0)) )) = 0);
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION'
        IN TYPEOF (pdr.used_representation))AND
        (pdr.used_representation.name = 'profile limit'))) <= 1))) = 0;
END_ENTITY; -- partial_circular_profile
      
ENTITY path_feature_component
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF(SELF.of_shape.definition));
    WR2: (SELF.description IN ['partial circular','complete circular',
        'linear','complex']);
    WR3: ((NOT (SELF.description = 'complex')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0));
    WR4: ((SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        (('GEOMETRY_SCHEMA.PLACEMENT' 
        IN TYPEOF(it)) AND (it.name = 'orientation')) )) = 1)) )) 
        = 0)) )) = 0));
    WR5: ((NOT (SELF.description = 'partial circular')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 3)) )) 
        = 0)) )) = 0));
    WR6: ((NOT (SELF.description = 'partial circular')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'radius')) )) = 1)) )) 
        = 0)) )) = 0));
    WR7: ((NOT (SELF.description = 'partial circular')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'sweep angle')) )) = 1)) )) 
        = 0)) )) = 0));
    WR8: ((NOT (SELF.description = 'complete circular')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 2)) )) 
        = 0)) )) = 0));
    WR9: ((NOT (SELF.description = 'complete circular')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'radius')) )) = 1)) )) 
        = 0)) )) = 0));
    WR10: ((NOT (SELF.description = 'linear')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 2)) )) 
         = 0)) )) = 0));
   WR11: ((NOT (SELF.description = 'linear')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'distance')) )) = 1)) )) 
        = 0)) )) = 0));
   WR12: ((NOT (SELF.description = 'linear')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('MACHINING_FEATURE_SCHEMA.DIRECTION_SHAPE_REPRESENTATION' 
        IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0));
    WR13: ((NOT (SELF.description = 'complex')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('TOPOLOGY_SCHEMA.PATH_SHAPE_REPRESENTATION' 
        IN TYPEOF(pdr.used_representation)) AND 
        (pdr.used_representation.name = 'sweep path')AND                 
        (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
        (srwp_i.name = 'profile shape') )) = 1)
        ) )) = 1)) )) = 0));
END_ENTITY; -- path_feature_component
     
ENTITY path_shape_representation
  SUBTYPE OF (shape_representation);
   WHERE
    WR1: (SIZEOF(SELF.items) >= 1);
    WR2: (SIZEOF(QUERY ( i <* SELF.items | (SIZEOF([
         'MACHINING_FEATURE_SCHEMA.BOUNDED_CURVE',
         'TOPOLOGY_SCHEMA.EDGE_CURVE',
         'TOPOLOGY_SCHEMA.PATH'] * TYPEOF(i)) = 
         1) )) >= 1);
END_ENTITY; -- path_shape_representation 

ENTITY pattern_offset_membership
  SUBTYPE OF (feature_component_relationship);
   WHERE
    WR1 : (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(
         SELF.relating_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
         + 'RELATING_SHAPE_ASPECT') | 
         (('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar)) AND (sar :<>: SELF)) ) | 
         ((SIZEOF (QUERY( pdr <*(QUERY(pd <* USEDIN
         (fcr.related_shape_aspect.of_shape,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd))) |
         SIZEOF (['MACHINING_FEATURE_SCHEMA.CIRCULAR_PATTERN',
         'MACHINING_FEATURE_SCHEMA.RECTANGULAR_PATTERN']
         * TYPEOF(pdr.definition))  =1 )) = 0 )) )) = 0);    
    WR2 : (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(
         SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         (('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar)) AND (sar :<>: SELF)) ) | 
         (fcr.description='modified pattern') AND
         ('MACHINING_FEATURE_SCHEMA.MODIFIED_PATTERN' 
         IN TYPEOF(fcr.relating_shape_aspect)) )) >= 1);
    WR3 : (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(
         SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         (('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar)) AND (sar :<>: SELF)) ) | 
         (('MACHINING_FEATURE_SCHEMA.MODIFIED_PATTERN' 
         IN TYPEOF(fcr.relating_shape_aspect)) AND 
         (NOT (SIZEOF(QUERY ( modfcr <* QUERY ( modsar <* USEDIN(
         fcr.relating_shape_aspect,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
         ((SIZEOF(['MACHINING_FEATURE_SCHEMA.CIRCULAR_PATTERN',
         'MACHINING_FEATURE_SCHEMA.RECTANGULAR_PATTERN'] * 
         TYPEOF(modsar.related_shape_aspect.of_shape.definition)) = 1) AND 
         (modsar :<>: fcr)) ) | 
         (NOT (modfcr.related_shape_aspect.of_shape.definition :=: 
         SELF.relating_shape_aspect.of_shape.definition)) )) 
         = 0))) )) = 0);
    WR4 : ((NOT ('MACHINING_FEATURE_SCHEMA.RECTANGULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(USEDIN(pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) = 2)) )) = 0));
    WR5 : ((NOT ('MACHINING_FEATURE_SCHEMA.CIRCULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(USEDIN(pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) = 1)) )) = 0));
    WR6 : ((NOT ('MACHINING_FEATURE_SCHEMA.CIRCULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (NOT (SIZEOF(pdr.used_representation.items) = 2)) )) = 0)) )) 
         = 0));
    WR7 : ((NOT ('MACHINING_FEATURE_SCHEMA.CIRCULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND 
         ('MEASURE_SCHEMA.COUNT_MEASURE' 
         IN TYPEOF(it\measure_with_unit.value_component)) AND 
         (it.name = 'index number')) )) = 1)) )) = 0)) )) = 0));
    WR8 : ((NOT ('MACHINING_FEATURE_SCHEMA.CIRCULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT' 
         IN TYPEOF(it)) AND (it.name = 'offset')) )) = 1)) )) = 0)) )) 
         = 0));
    WR9:  ((NOT ('MACHINING_FEATURE_SCHEMA.RECTANGULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')|
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(impl_rep.used_representation.items ) = 3)) )) 
         = 0)) )) = 0));
    WR10: ((NOT ('MACHINING_FEATURE_SCHEMA.RECTANGULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')|
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND 
         ('MEASURE_SCHEMA.COUNT_MEASURE' 
         IN TYPEOF(it\measure_with_unit.value_component)) AND 
         (it.name = 'row index')) )) = 1)) )) = 0)) )) = 0));
    WR11: ((NOT ('MACHINING_FEATURE_SCHEMA.RECTANGULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND 
         ('MEASURE_SCHEMA.COUNT_MEASURE' 
         IN TYPEOF(it\measure_with_unit.value_component)) AND 
         (it.name = 'column index')) )) = 1)) )) = 0)) )) = 0));
    WR12: ((NOT ('MACHINING_FEATURE_SCHEMA.RECTANGULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' 
         IN TYPEOF(it)) AND (it.name = 'offset distance')) )) = 1)) )) 
         = 0)) )) = 0));
    WR13: ((NOT ('MACHINING_FEATURE_SCHEMA.RECTANGULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         (('MACHINING_FEATURE_SCHEMA.DIRECTION_SHAPE_REPRESENTATION' 
         IN TYPEOF(pdr.used_representation)) AND 
         (pdr.used_representation.name = 'offset direction')) )) = 1)) )) 
         = 0));
END_ENTITY; -- pattern_offset_membership 

ENTITY pattern_omit_membership
  SUBTYPE OF (feature_component_relationship);
   WHERE
    WR1: (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(
        SELF.relating_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
        + 'RELATING_SHAPE_ASPECT') | 
        (('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF(sar)) AND (sar :<>: SELF)) ) | 
        ((SIZEOF (QUERY( pdr <*(QUERY(pd <* USEDIN
        (fcr.related_shape_aspect.of_shape,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd))) |
        SIZEOF (['MACHINING_FEATURE_SCHEMA.CIRCULAR_PATTERN',
        'MACHINING_FEATURE_SCHEMA.RECTANGULAR_PATTERN']
        * TYPEOF(pdr.definition))  =1 )) = 0 )) )) = 0);   
    WR2: (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(
        SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF(sar)) AND (sar :<>: SELF)) ) | 
        (fcr.description='modified pattern') AND
        ('MACHINING_FEATURE_SCHEMA.MODIFIED_PATTERN' 
        IN TYPEOF(fcr.relating_shape_aspect)) )) >= 1);
    WR3: (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(
        SELF.related_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF(sar)) AND (sar :<>: SELF)) ) | 
        (('MACHINING_FEATURE_SCHEMA.MODIFIED_PATTERN' 
        IN TYPEOF(fcr.relating_shape_aspect)) AND 
        (NOT (SIZEOF(QUERY ( modfcr <* QUERY ( modsar <* USEDIN(
        fcr.relating_shape_aspect,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
        ((SIZEOF(['MACHINING_FEATURE_SCHEMA.CIRCULAR_PATTERN',
        'MACHINING_FEATURE_SCHEMA.RECTANGULAR_PATTERN'] * 
        TYPEOF(modsar.related_shape_aspect.of_shape.definition)) = 1) AND 
        (modsar :<>: fcr)) ) | 
        (NOT (modfcr.related_shape_aspect.of_shape.definition :=: 
        SELF.relating_shape_aspect.of_shape.definition)) ))
         = 0))) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(USEDIN(pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) = 1)) )) = 0);
    WR5: ((NOT ('MACHINING_FEATURE_SCHEMA.CIRCULAR_PATTERN' 
        IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (NOT (SIZEOF(pdr.used_representation.items) = 1)) )) = 0)) )) = 0));
    WR6: ((NOT ('MACHINING_FEATURE_SCHEMA.CIRCULAR_PATTERN' 
        IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND 
        ('MEASURE_SCHEMA.COUNT_MEASURE' 
        IN TYPEOF(it\measure_with_unit.value_component)) AND 
        (it.name = 'index number')) )) = 1)) )) = 0)) )) = 0));
    WR7: ((NOT ('MACHINING_FEATURE_SCHEMA.RECTANGULAR_PATTERN' 
        IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (NOT (SIZEOF(pdr.used_representation.items) = 2)) )) = 0)) )) = 0));
    WR8: ((NOT ('MACHINING_FEATURE_SCHEMA.RECTANGULAR_PATTERN' 
        IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND ('MEASURE_SCHEMA.COUNT_MEASURE' 
        IN TYPEOF(it\measure_with_unit.value_component)) AND 
        (it.name = 'row index')) )) = 1)) )) = 0)) )) = 0));
    WR9: ((NOT ('MACHINING_FEATURE_SCHEMA.RECTANGULAR_PATTERN' 
        IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND ('MEASURE_SCHEMA.COUNT_MEASURE' 
        IN TYPEOF(it\measure_with_unit.value_component)) AND 
        (it.name = 'column index')) )) = 1)) )) = 0)) )) = 0));
END_ENTITY; -- pattern_omit_membership
 
ENTITY planar_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
    WR1: SIZEOF (SELF.items) = 1;
    WR2: SIZEOF (QUERY (it <* SELF.items |
        ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF (it)))) = 1 ;
END_ENTITY; 

ENTITY pocket
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: (SELF\characterized_object.description IN 
         ['closed rectangular','open rectangular', 'complex', 
         'circular cutout', 'complex cutout', 'recess']);
    WR2: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'pocket depth occurrence') AND
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
         ((sar.description = 'path feature component usage')  AND 
         (sar.name = 'pocket depth') AND 
         (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         (('TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT' 
         IN TYPEOF(sdr.relating_shape_aspect)) AND 
         (sdr.relating_shape_aspect.description ='linear')) )) 
         = 1)) )) = 1)) )) = 0);
   WR3: SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
       ( 'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF ( pdr.used_representation ) ) )) =1; 
    WR4:  SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
          SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         ({1 <= SIZEOF(pdr.used_representation.items) <= 2} ) )) = 1 )) = 1;
    WR5:  SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN
         TYPEOF(pdr.used_representation)) AND
         (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
         (srwp_i.name = 'orientation') OR
         (srwp_i.name = 'fillet radius'))) 
         = SIZEOF(pdr.used_representation.items)) )) = 1 )) = 1;
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF (
         ['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'fillet radius'))) <= 1))) 
         = 0))) = 0;
    WR7: ((NOT (SELF\characterized_object.description IN ['complex',
         'non-circular cutout','recess'])) OR 
         (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'boundary occurrence') AND 
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         ((sar.description = 'profile usage') AND 
         (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | ((SIZEOF([
         'MACHINING_FEATURE_SCHEMA.CIRCULAR_CLOSED_PROFILE',
         'MACHINING_FEATURE_SCHEMA.NGON_CLOSED_PROFILE',
         'MACHINING_FEATURE_SCHEMA.RECTANGULAR_CLOSED_PROFILE',
         'MACHINING_FEATURE_SCHEMA.CLOSED_PATH_PROFILE',
         'MACHINING_FEATURE_SCHEMA.SQUARE_U_PROFILE',
         'MACHINING_FEATURE_SCHEMA.PARTIAL_CIRCULAR_PROFILE',
         'MACHINING_FEATURE_SCHEMA.ROUNDED_U_PROFILE',
         'MACHINING_FEATURE_SCHEMA.VEE_PROFILE',
         'MACHINING_FEATURE_SCHEMA.TEE_PROFILE',
         'MACHINING_FEATURE_SCHEMA.OPEN_PATH_PROFILE'] * 
         TYPEOF(sdr.relating_shape_aspect)) = 1)) )) = 1)) )) 
         = 1)) )) = 0));
    WR8: ((NOT (SELF\characterized_object.description = 
         'closed rectangular')) 
         OR (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'closed boundary occurrence') AND 
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
         ((sar.description = 'profile usage') AND 
         (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         (('MACHINING_FEATURE_SCHEMA.RECTANGULAR_CLOSED_PROFILE' 
         IN TYPEOF(sdr.relating_shape_aspect))) )) = 1)) )) 
         = 1)) )) = 0));
    WR9: ((NOT (SELF\characterized_object.description = 'open rectangular')) 
         OR (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |  
         ((sa_occ.description = 'open boundary occurrence') AND 
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
         ((sar.description = 'profile usage') AND 
         (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         (('MACHINING_FEATURE_SCHEMA.SQUARE_U_PROFILE' 
         IN TYPEOF(sdr.relating_shape_aspect))) )) = 1)) )) 
         = 1)) )) = 0));
    WR10: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'bottom condition occurrence') AND 
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
         ((sar.description = 'pocket bottom usage') AND 
         (('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         (('MACHINING_FEATURE_SCHEMA.POCKET_BOTTOM' 
         IN TYPEOF(sdr.relating_shape_aspect)) AND 
         ('MACHINING_FEATURE_SCHEMA.POCKET' 
         IN TYPEOF(sdr.related_shape_aspect.of_shape.definition)))
         )) = 1)) )) = 1)) )) = 0);
    WR11: ((NOT (SELF\characterized_object.description IN ['complex',
         'non-circular cutout','recess'])) OR 
          (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'change in boundary occurrence') AND 
         (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
         ((sar.description = 'taper usage') AND 
         (('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         (('MACHINING_FEATURE_SCHEMA.TAPER' 
         IN TYPEOF(fcr.relating_shape_aspect)) AND 
         ('MACHINING_FEATURE_SCHEMA.POCKET' 
         IN TYPEOF(fcr.related_shape_aspect.of_shape.definition)) AND
         (fcr.related_shape_aspect.description 
         IN ['angle taper','directed taper'])) 
         )) = 1)) ))  <= 1)) )) = 0));       
   WR12: (NOT (SELF\characterized_object.description = 'circular cutout')) OR 
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
        TYPEOF (pd)) | NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'enclosed boundary occurrence') AND
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile usage') AND
        ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        ('MACHINING_FEATURE_SCHEMA.CIRCULAR_CLOSED_PROFILE' 
        IN TYPEOF (sdr.relating_shape_aspect)))) 
        = 1))) = 1))) = 0);
   WR13: (NOT (SELF\characterized_object.description IN 
        ['circular cutout','complex cutout'])) OR 
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
        TYPEOF (pd)) | NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'bottom condition occurrence') AND
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'pocket bottom usage') AND
        ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        (('MACHINING_FEATURE_SCHEMA.POCKET_BOTTOM' 
        IN TYPEOF (sdr.relating_shape_aspect)) AND
        ('MACHINING_FEATURE_SCHEMA.POCKET' 
        IN TYPEOF (sdr.related_shape_aspect.of_shape.definition))AND
        (sdr.relating_shape_aspect.description = 'through') )
        )) = 1))) = 1))) = 0);
    WR14: (NOT (SELF\characterized_object.description = 'recess')) OR 
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
        TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'bottom condition occurrence') AND
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'pocket bottom usage') AND
        ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        (('MACHINING_FEATURE_SCHEMA.POCKET_BOTTOM' 
        IN TYPEOF (sdr.relating_shape_aspect)) AND
        ('MACHINING_FEATURE_SCHEMA.POCKET' 
        IN TYPEOF (sdr.related_shape_aspect.of_shape.definition)) AND
        (sdr.relating_shape_aspect.description IN ['planar','complex']) )
        )) = 1))) = 1))) = 0); 
  WR15: SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
        ( 'MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION' 
        IN TYPEOF ( pdr.used_representation ) ) AND 
        ( pdr.used_representation.name ='maximum feature limit'))) >=0; 
           
    WR16:  ((NOT (SELF\characterized_object.description IN 
           ['closed rectangular','open rectangular', 'complex', 
            'recess'])) OR 
            (SIZEOF(QUERY ( pds <* USEDIN(SELF,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
           (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
           IN TYPEOF(pds)) AND (SIZEOF(QUERY ( csa <* USEDIN(pds,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
           (('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' 
           IN TYPEOF(csa)) AND 
           (csa.name='uncut volume') AND 
           (SIZEOF(QUERY ( sar <* csa.component_relationships | 
           ((('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
           IN TYPEOF(sar)) AND 
     (SIZEOF(['MACHINING_FEATURE_SCHEMA.BOSS','MACHINING_FEATURE_SCHEMA.PROTRUSION']
           * TYPEOF(sar.related_shape_aspect))=1) 
           ) ))) = 1)) )) <= 1)) )) = 1));      
               
    WR17: ((NOT (SELF\characterized_object.description IN 
          ['closed rectangular','open rectangular'])) OR 
          (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'change in boundary occurrence') AND 
         (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
         ((sar.description = 'taper usage') AND 
         (('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         (('MACHINING_FEATURE_SCHEMA.TAPER' 
         IN TYPEOF(fcr.relating_shape_aspect)) AND 
         ('MACHINING_FEATURE_SCHEMA.POCKET' 
         IN TYPEOF(fcr.related_shape_aspect.of_shape.definition)) AND
         (fcr.related_shape_aspect.description 
         IN ['angle taper','directed taper'])) 
         )) >= 1)) ))  <=1)) )) = 0));             
           
END_ENTITY; -- pocket  

ENTITY pocket_bottom
  SUBTYPE OF (shape_aspect);
  WHERE
    WR1: 'MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF (SELF.of_shape.definition);
    WR2: SELF.description IN ['planar', 'complex', 'through'];
    WR3: ((NOT (SELF.description = 'planar')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
          (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('MACHINING_FEATURE_SCHEMA.DIRECTION_SHAPE_REPRESENTATION') 
         IN TYPEOF(pdr.used_representation))  AND 
         (pdr.used_representation.name = 'floor normal') )) = 1)) )) = 0));
    WR4 : ((NOT (SELF.description = 'planar')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('MACHINING_FEATURE_SCHEMA.LOCATION_SHAPE_REPRESENTATION') 
         IN TYPEOF(pdr.used_representation))  AND 
         (pdr.used_representation.name = 'floor location'))) = 1)) )) = 0));
    WR5 : ((NOT (SELF.description = 'complex')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        ('MACHINING_FEATURE_SCHEMA.FACE_SHAPE_REPRESENTATION' 
        IN TYPEOF(pdr.used_representation)) AND 
        (pdr.used_representation.name = 'floor face') )) = 1)) )) = 0));
    WR6: (NOT (SELF.description IN  ['planar', 'complex']) OR
        (SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation))) = 1))) = 0));
    WR7: (NOT (SELF.description IN  ['planar', 'complex']) OR
        (SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (impl_rep.used_representation.items) 
        <= 1) )) = 0))) = 0)); 
    WR8: (NOT (SELF.description = 'through') OR 
        (SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation))) = 0))) = 0));
    WR9: (NOT (SELF.description IN ['planar', 'complex'])) OR 
        (SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
        TYPEOF (it)) = 2) AND (it.name = 'radius'))) <= 1))) = 0))) = 0);
    WR10: SIZEOF (QUERY (fcr <* QUERY (sar <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
        (sar.description = 'pocket bottom usage') AND
        ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar))) |
      ((fcr.related_shape_aspect.description = 'bottom condition occurrence') 
        AND
        ('MACHINING_FEATURE_SCHEMA.POCKET' 
        IN TYPEOF(fcr.related_shape_aspect.of_shape.definition)) AND
        ('MACHINING_FEATURE_SCHEMA.POCKET_BOTTOM' 
        IN TYPEOF(fcr.relating_shape_aspect)) )
        )) >= 1;
   WR11: ((NOT (SELF.description IN ['planar','complex'])) OR
         (SIZEOF (QUERY (fcr <* QUERY (sar <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
        (sar.description = 'pocket bottom usage') AND
        ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar))) |
      (fcr.related_shape_aspect.description = 'bottom condition occurrence')
       AND
      (fcr.related_shape_aspect.name IN 
       ['pocket depth start', 'pocket depth end'])
       )) = 0));
END_ENTITY;  -- Pocket_bottom

ENTITY profile_floor
  SUBTYPE OF (shape_aspect);
  WHERE
    WR1: 'MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF (SELF.of_shape.definition);
    WR2: SELF.description IN ['planar', 'complex', 'through'];
    WR3: (NOT (SELF.description IN ['planar', 'complex']) OR 
        (SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation))) = 1))) = 0));
    WR4: (NOT (SELF.description IN  ['planar', 'complex'])) OR
        (SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (impl_rep.used_representation.items) >= 1)AND
       (SIZEOF (impl_rep.used_representation.items) <= 2))) = 0))) = 0); 
    WR5: (NOT (SELF.description = 'through') OR 
        (SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation))) = 0))) = 0));
    WR6: (NOT (SELF.description IN ['planar', 'complex'])) OR 
        (SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
        TYPEOF (it)) = 2) AND (it.name = 'radius'))) = 1))) = 0))) = 0); 
    WR7: SIZEOF (QUERY (fcr <* QUERY (sar <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
        (sar.description = 'profile floor usage') AND
        ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' IN
        TYPEOF (sar))) |
        (('MACHINING_FEATURE_SCHEMA.OUTSIDE_PROFILE' IN TYPEOF
        (fcr.related_shape_aspect.of_shape.definition))AND
        ('MACHINING_FEATURE_SCHEMA.PROFILE_FLOOR' IN TYPEOF
        (fcr.relating_shape_aspect)))
        )) >= 1;      
    WR8: ((NOT (SELF.description IN ['planar','complex'])) OR
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
        | (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') IN TYPEOF(pdr.
        used_representation)) ) | (NOT (SIZEOF(QUERY ( it <* 
        impl_rep.used_representation.items | 
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
        IN TYPEOF(it)) AND (it.name = 'shape profile floor orientation') 
        AND (it.description IN ['shape profile start','shape profile end']))
        )) =  1)) )) = 0)) )) = 0));
   WR9: (NOT (SELF.description = 'complex')) OR
        (SIZEOF (QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('MACHINING_FEATURE_SCHEMA.FACE_SHAPE_REPRESENTATION'
        IN TYPEOF (pdr.used_representation))  AND 
        (pdr.used_representation.name='floor'))) = 1))) = 1);
   WR10: (NOT (SELF.description = 'planar')) OR
        (SIZEOF (QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION'
        IN TYPEOF (pdr.used_representation))  AND 
        (pdr.used_representation.name='floor'))) = 1))) = 1);
END_ENTITY;   -- profile_floor

ENTITY protrusion
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
        = 0)) )) = 0);
    WR2: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'shape volume occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'volume shape usage') AND 
        (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (sdr.relating_shape_aspect.description = 'volume shape') )) = 1)) )) 
        = 1)) )) = 0);
   WR3: SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
       ( 'MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION' 
       IN TYPEOF ( pdr.used_representation ) ) AND 
       ( pdr.used_representation.name ='maximum feature limit'))) >=0; 
END_ENTITY; -- protrusion

ENTITY rectangular_closed_profile
  SUBTYPE OF (shape_aspect);
  WHERE
    WR1: 'MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF (SELF.of_shape.definition);
    WR2: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation))) = 1))) = 0;
    WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT ((SIZEOF (impl_rep.used_representation.items) >= 3)  
        AND (SIZEOF(impl_rep.used_representation.items) <= 4)))) = 0))) = 0;
    WR4:  SIZEOF( QUERY( pd <* 
        USEDIN( SELF,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        SIZEOF( QUERY( pdr <* USEDIN( pd, 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
        IN TYPEOF(pdr.used_representation)) AND
        (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
        (srwp_i.name = 'orientation') OR
        (srwp_i.name = 'length') OR
        (srwp_i.name = 'width') OR
        (srwp_i.name = 'corner radius') )) =
        SIZEOF(pdr.used_representation.items))
         )) = 1 )) = 1;
    WR5: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        ('GEOMETRY_SCHEMA.PLACEMENT' IN TYPEOF (it)) AND 
        (it.name = 'orientation'))) = 1))) = 0))) = 0;
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'width'))) = 1))) = 0))) = 0;
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'length'))) = 1))) = 0))) = 0;
    WR8: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'corner radius'))) <= 1))) = 0))) = 0;
END_ENTITY;  -- rectangular_closed_profile

ENTITY rectangular_pattern
  SUBTYPE OF (replicate_feature);
   WHERE
    WR1: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
          ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
          IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN
          (pds,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
          ((SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
          + 'RELATING_SHAPE_ASPECT') | 
          ((('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP') 
          IN TYPEOF(sar))) ) | 
          ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' 
          IN TYPEOF(sdr.related_shape_aspect)) )) = 1)) )) <= 5)) )) = 0);
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         (('MACHINING_FEATURE_SCHEMA.DIRECTION_SHAPE_REPRESENTATION' 
         IN TYPEOF(pdr.used_representation)) AND 
         (pdr.used_representation.name = 'row layout direction') ) )) 
         = 1)) ))  = 0);
    WR3 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('MACHINING_FEATURE_SCHEMA.DIRECTION_SHAPE_REPRESENTATION' 
         IN TYPEOF(pdr.used_representation)) AND 
         (pdr.used_representation.name = 'column layout direction')) )) 
         = 1)) )) = 0);
    WR4 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR5 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(impl_rep.used_representation.items) = 5)) )) 
         = 0)) )) = 0);
    WR6 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND 
         ('MEASURE_SCHEMA.COUNT_MEASURE' 
         IN TYPEOF(it\measure_with_unit.value_component)) AND 
         (it.name = 'number of rows')) )) = 1)) )) = 0)) )) = 0);
   WR7 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND 
         ('MEASURE_SCHEMA.COUNT_MEASURE' 
         IN TYPEOF(it\measure_with_unit.value_component)) AND 
         (it.name = 'number of columns')) )) = 1)) )) = 0)) )) = 0);
    WR8 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'row spacing')) )) = 1)) )) 
         = 0)) )) = 0);
    WR9: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'column spacing'))))= 1)) )) 
         = 0)) )) = 0);
    WR10: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (('GEOMETRY_SCHEMA.PLACEMENT' IN TYPEOF(it)) AND 
         (it.name = 'orientation')) )) = 1)) )) = 0)) )) = 0);
END_ENTITY; -- rectangular_pattern

ENTITY removal_volume
  SUBTYPE OF (feature_definition);
   WHERE
 
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
        = 0)) )) = 0);
    WR2: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'shape volume occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
        + 'RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'volume shape usage') AND 
        (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (sdr.relating_shape_aspect.description = 'volume shape') )) = 1)) )) 
        = 1)) )) = 0);
END_ENTITY; -- removal_volume

ENTITY replicate_feature
    SUPERTYPE OF (ONEOF (circular_pattern, rectangular_pattern, 
      feature_pattern))
  SUBTYPE OF (feature_definition);
  WHERE
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
         | (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') IN TYPEOF(pdr.
         used_representation)) ))  = 1)) )) = 0);
    WR2: (SIZEOF(QUERY ( fcr <* QUERY ( sar <* 
         USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
         + 'RELATING_SHAPE_ASPECT') | 
         ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar)) ) | 
         ((SIZEOF(['MACHINING_FEATURE_SCHEMA.REPLICATE_FEATURE',
         'SHAPE_ASPECT_DEFINITION_SCHEMA.INSTANCED_FEATURE'] * 
         TYPEOF(fcr.related_shape_aspect)) >= 1) AND 
         (fcr.name = 'pattern basis')) )) = 1);
    WR3: ((SIZEOF(QUERY ( sar <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
         + 'RELATING_SHAPE_ASPECT') | 
         (NOT
          ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar))) )) + 
         SIZEOF(QUERY ( sar <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
         + 'RELATED_SHAPE_ASPECT') | 
         (NOT
         ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar))) ))) = 0);
END_ENTITY;  -- replicate_feature

ENTITY revolved_profile
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: (SELF\characterized_object.description IN 
        ['groove','flat','round','open profile']);
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 2)) )) 
        = 0)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'radius')))) = 1)) )) 
        = 0)) )) = 0);
  WR4:  SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
       ( 'MACHINING_FEATURE_SCHEMA.DIRECTION_SHAPE_REPRESENTATION' 
       IN TYPEOF ( pdr.used_representation ) ) AND 
       ( pdr.used_representation.name ='removal direction'))) =1; 
    WR5: ((NOT (SELF\characterized_object.description = 'open profile')) OR
        (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'outer edge shape occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'profile usage') AND 
        (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (('MACHINING_FEATURE_SCHEMA.OPEN_PATH_PROFILE' 
        IN TYPEOF(sdr.relating_shape_aspect)) AND 
       (sdr.relating_shape_aspect.description = 'outer edge shape')) )) 
        = 1)) )) = 1)) )) = 0));
    WR6: (NOT (SELF\characterized_object.description = 'flat')) OR 
        (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')|
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        (( sa_occ.description = 'flat edge shape occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'profile usage') AND 
        (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (('MACHINING_FEATURE_SCHEMA.LINEAR_PROFILE' 
        IN TYPEOF(sdr.relating_shape_aspect)) AND 
        (sdr.relating_shape_aspect.description = 'flat edge shape')) )) 
        = 1)) )) = 1)) )) = 0);
    WR7: ((NOT (SELF\characterized_object.description = 'round')) OR 
        (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'rounded edge shape occurrence') AND 
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'profile usage') AND 
        (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (('MACHINING_FEATURE_SCHEMA.PARTIAL_CIRCULAR_PROFILE' 
        IN TYPEOF(sdr.relating_shape_aspect)) AND 
        (sdr.relating_shape_aspect.description = 'rounded edge shape')) )) 
        = 1)) )) = 1)) )) = 0));
    WR8: ((NOT (SELF\characterized_object.description = 'groove')) OR 
        (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'sweep occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'profile usage') AND 
        (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        ((SIZEOF(['MACHINING_FEATURE_SCHEMA.SQUARE_U_PROFILE',
         'MACHINING_FEATURE_SCHEMA.PARTIAL_CIRCULAR_PROFILE',
        'MACHINING_FEATURE_SCHEMA.ROUNDED_U_PROFILE',
        'MACHINING_FEATURE_SCHEMA.VEE_PROFILE',
        'MACHINING_FEATURE_SCHEMA.TEE_PROFILE',
        'MACHINING_FEATURE_SCHEMA.OPEN_PATH_PROFILE'] * 
        TYPEOF(sdr.relating_shape_aspect)) = 1) AND 
        (sdr.relating_shape_aspect.description = 'sweep')) )) = 1)) )) 
        = 1)) )) = 0));
   WR9: SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
       ( 'MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION' 
       IN TYPEOF ( pdr.used_representation ) ) AND 
       ( pdr.used_representation.name ='maximum feature limit'))) >=0; 
END_ENTITY; -- revolved_profile

ENTITY rib_top
   SUBTYPE OF (feature_definition);
  WHERE
    WR1: SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'rib top condition occurrence') AND
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'rib top usage') AND
        ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        (('MACHINING_FEATURE_SCHEMA.RIB_TOP_FLOOR' 
        IN TYPEOF (sdr.relating_shape_aspect)) AND
        ('MACHINING_FEATURE_SCHEMA.RIB_TOP' 
        IN TYPEOF (sdr.related_shape_aspect.of_shape.definition)) )
        )) = 1))) = 1))) = 0;     
    WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('MACHINING_FEATURE_SCHEMA.DIRECTION_SHAPE_REPRESENTATION'
        IN TYPEOF (pdr.used_representation))AND
        (pdr.used_representation.name = 'removal direction'))) = 1))) = 1;  
   WR3: SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
        ( 'MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION' 
        IN TYPEOF ( pdr.used_representation ) ) AND 
        ( pdr.used_representation.name ='maximum feature limit'))) >=0; 
END_ENTITY;    -- rib_top

ENTITY rib_top_floor
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: 'MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' IN
        TYPEOF (SELF.of_shape.definition);
    WR2: SELF.description IN ['planar', 'complex'];
    WR3: SIZEOF (QUERY (fcr <* QUERY (sar <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
        (sar.description = 'rib top usage') AND
        ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar))) |
     ((fcr.related_shape_aspect.description = 'rib top condition occurrence') 
        AND
        ('MACHINING_FEATURE_SCHEMA.RIB_TOP' IN TYPEOF
        (fcr.related_shape_aspect.of_shape.definition)) AND
        ('MACHINING_FEATURE_SCHEMA.RIB_TOP_FLOOR' IN TYPEOF
        (fcr.relating_shape_aspect)) )
        )) >= 1;
    WR4: (NOT (SELF.description = 'complex')) OR
        (SIZEOF (QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('MACHINING_FEATURE_SCHEMA.FACE_SHAPE_REPRESENTATION'
        IN TYPEOF (pdr.used_representation))AND
        (pdr.used_representation.name = 'rib top face'))) = 1))) = 0);
    WR5: (NOT (SELF.description = 'planar')) OR
        (SIZEOF (QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION'
        IN TYPEOF (pdr.used_representation))AND
        (pdr.used_representation.name = 'rib top face'))) = 1))) = 0);
    WR6: (NOT (SELF.description = 'planar')) OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'boundary occurrence') AND
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile usage') AND
        ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        (SIZEOF (['MACHINING_FEATURE_SCHEMA.CIRCULAR_CLOSED_PROFILE', 
        'MACHINING_FEATURE_SCHEMA.NGON_CLOSED_PROFILE',
        'MACHINING_FEATURE_SCHEMA.RECTANGULAR_CLOSED_PROFILE',
         'MACHINING_FEATURE_SCHEMA.CLOSED_PATH_PROFILE'] *
        TYPEOF (sdr.relating_shape_aspect)) = 1) AND
        (sdr.relating_shape_aspect.description = 'rib top floor boundary'))) 
        = 1))) = 1))) = 0);
END_ENTITY;  -- rib_top_floor

ENTITY round_hole
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: (SIZEOF(['COUNTERBORE_COUNTERSINK_SCHEMA.EXPLICIT_ROUND_HOLE',
                  'COUNTERBORE_COUNTERSINK_SCHEMA.BASIC_ROUND_HOLE'] * TYPEOF(SELF)) = 1) XOR   
       (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')|
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'diameter occurrence') AND 
       (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'profile usage') AND 
       (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
       IN TYPEOF(sar))) ) | 
       (('MACHINING_FEATURE_SCHEMA.CIRCULAR_CLOSED_PROFILE' 
       IN TYPEOF(sdr.relating_shape_aspect)) AND 
       (sdr.name = 'diameter'))  )) = 1)) )) = 1)) )) = 0);
    WR2: (SIZEOF(['COUNTERBORE_COUNTERSINK_SCHEMA.EXPLICIT_ROUND_HOLE',
                  'COUNTERBORE_COUNTERSINK_SCHEMA.BASIC_ROUND_HOLE'] * TYPEOF(SELF)) = 1) XOR   
       (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'hole depth occurrence') AND 
       (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'path feature component usage') AND 
       (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
       IN TYPEOF(sar))) ) | 
       (('TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT' 
       IN TYPEOF(sdr.relating_shape_aspect)) AND 
       (sdr.name = 'hole depth') AND 
       (sdr.relating_shape_aspect.description = 'linear')) )) = 1)) )) 
       = 1)) )) = 0);
    WR3: (SIZEOF(['COUNTERBORE_COUNTERSINK_SCHEMA.EXPLICIT_ROUND_HOLE',
                  'COUNTERBORE_COUNTERSINK_SCHEMA.BASIC_ROUND_HOLE'] * TYPEOF(SELF)) = 1) XOR   
       (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'bottom condition occurrence') AND 
       (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'hole bottom usage') AND 
       (('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP') 
       IN TYPEOF(sar))) ) | 
       (('MACHINING_FEATURE_SCHEMA.HOLE_BOTTOM' 
       IN TYPEOF(fcr.relating_shape_aspect)) AND 
       ('MACHINING_FEATURE_SCHEMA.ROUND_HOLE' 
       IN TYPEOF(fcr.related_shape_aspect.of_shape.definition)))
       )) = 1)) )) = 1)) )) = 0);
    WR4: (SIZEOF(['COUNTERBORE_COUNTERSINK_SCHEMA.EXPLICIT_ROUND_HOLE',
                  'COUNTERBORE_COUNTERSINK_SCHEMA.BASIC_ROUND_HOLE'] * TYPEOF(SELF)) = 1) XOR   
       (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'change in diameter occurrence') AND 
       (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'taper usage') AND 
       (('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP') 
       IN TYPEOF(sar))) ) | 
       (('MACHINING_FEATURE_SCHEMA.TAPER' 
       IN TYPEOF(fcr.relating_shape_aspect)) AND 
       ('MACHINING_FEATURE_SCHEMA.ROUND_HOLE' 
       IN TYPEOF(fcr.related_shape_aspect.of_shape.definition)) )
       )) = 1)) )) <= 1)) )) = 0);
    WR5: (SIZEOF(['COUNTERBORE_COUNTERSINK_SCHEMA.EXPLICIT_ROUND_HOLE',
                  'COUNTERBORE_COUNTERSINK_SCHEMA.BASIC_ROUND_HOLE'] * TYPEOF(SELF)) = 1) XOR   
       (SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
       ( 'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
     IN TYPEOF ( pdr.used_representation ) ) )) =1); 
END_ENTITY; -- round_hole

ENTITY rounded_end
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
        = 0)) )) = 0);
    WR2: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'partial circular boundary occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'profile usage') AND 
        (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (('MACHINING_FEATURE_SCHEMA.PARTIAL_CIRCULAR_PROFILE' 
        IN TYPEOF(sdr.relating_shape_aspect)) ) )) = 1)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'course of travel occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'path feature component usage') AND 
        (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (('TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT' 
        IN TYPEOF(sdr.relating_shape_aspect)) AND 
        (sdr.relating_shape_aspect.description = 'linear')) )) = 1)) )) 
        = 1)) )) = 0);
   WR4: SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
        ( 'MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION' 
        IN TYPEOF ( pdr.used_representation ) ) AND 
        ( pdr.used_representation.name ='maximum feature limit'))) >=0;
END_ENTITY; -- rounded_end

ENTITY rounded_u_profile
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF(SELF.of_shape.definition));
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        (NOT (SIZEOF (impl_rep.used_representation.items) >= 1)
        AND  (SIZEOF (impl_rep.used_representation.items) <= 2)))) 
        = 0))) = 0; 
    WR4: SIZEOF( QUERY( pd <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        SIZEOF( QUERY( pdr <* USEDIN( pd, 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
        IN TYPEOF(pdr.used_representation)) AND
        (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
        (srwp_i.name = 'orientation') OR
        (srwp_i.name = 'depth')  )) 
         = SIZEOF(pdr.used_representation.items)) )) = 1 )) = 1;
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'width'))))= 1))))= 0))))= 0);
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION'
        IN TYPEOF (pdr.used_representation))AND
        (pdr.used_representation.name = 'profile limit'))) <= 1))) = 0;
   WR7: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'depth'))) <= 1))) = 0))) = 0;
END_ENTITY; -- rounded_u_profile

ENTITY shape_defining_relationship
  SUBTYPE OF (shape_aspect_relationship);
END_ENTITY;

ENTITY spherical_cap
  SUBTYPE OF (feature_definition);
   WHERE
  
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 3)) )) 
        = 0)) )) = 0);
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'radius')) )) = 1)))) 
        = 0)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'internal angle')))) = 1)) )) 
        = 0)) )) = 0);
END_ENTITY; -- spherical_cap

ENTITY square_u_profile
  SUBTYPE OF (shape_aspect);
  WHERE
    WR1: 'MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF (SELF.of_shape.definition);
    WR2: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation))) = 1))) = 0;
    WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        (NOT (SIZEOF (impl_rep.used_representation.items) >= 4)
        AND  (SIZEOF (impl_rep.used_representation.items) <= 7)))) 
        = 0))) = 0; 
    WR4: SIZEOF( QUERY( pd <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        SIZEOF( QUERY( pdr <* USEDIN( pd, 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
        IN TYPEOF(pdr.used_representation)) AND
        (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
        (srwp_i.name = 'orientation') OR
        (srwp_i.name = 'width') OR
        (srwp_i.name = 'first angle') OR
        (srwp_i.name = 'second angle') OR
        (srwp_i.name = 'first radius') OR
        (srwp_i.name = 'second radius') OR
        (srwp_i.name = 'profile limit') OR 
        (srwp_i.name = 'depth')  ))
         = SIZEOF(pdr.used_representation.items)) )) = 1 )) = 1;
    WR5: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        ('GEOMETRY_SCHEMA.PLACEMENT' IN TYPEOF (it)) AND 
        (it.name = 'orientation'))) = 1))) = 0))) = 0;
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'width'))) = 1))) = 0))) = 0;
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'first radius'))) <= 1))) = 0))) = 0;
    WR8: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'second radius'))) <= 1))) = 0))) = 0;
    WR9: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'first angle'))) = 1))) = 0))) = 0;
    WR10: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'second angle'))) = 1))) = 0))) = 0;
    WR11: SIZEOF (QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION'
        IN TYPEOF (pdr.used_representation))AND
        (pdr.used_representation.name = 'profile limit'))) <= 1))) = 0;
        
   WR12: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'depth'))) <= 1))) = 0))) = 0;
END_ENTITY; -- Square_U_profile

ENTITY step
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
        = 0)) )) = 0);
    WR2: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'course of travel occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'path feature component usage') AND 
        (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (('TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT' 
        IN TYPEOF(sdr.relating_shape_aspect)) AND 
        (sdr.relating_shape_aspect.description = 'linear')) )) = 1)) )) 
        = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'removal boundary occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'profile usage') AND 
        (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        ('MACHINING_FEATURE_SCHEMA.VEE_PROFILE' 
        IN TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) = 1)) )) = 0);
   WR4: SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
       ( 'MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION' 
       IN TYPEOF ( pdr.used_representation ) ) AND 
       ( pdr.used_representation.name ='maximum feature limit'))) >=0; 
   WR5: SIZEOF(QUERY ( pds <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pds)) AND (SIZEOF(QUERY ( csa <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' IN 
        TYPEOF(csa)) AND 
        (csa.name='uncut volume') AND 
        (SIZEOF(QUERY ( sar <* csa.component_relationships | 
        (('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF(sar)) AND (SIZEOF([
        'MACHINING_FEATURE_SCHEMA.BOSS',
        'MACHINING_FEATURE_SCHEMA.PROTRUSION'] * TYPEOF(sar.
        related_shape_aspect)) = 1)) )) = 1)) )) <= 1)) )) = 1;        
END_ENTITY; -- step

  ENTITY slot
    SUBTYPE OF (feature_definition);
    WHERE
      WR1: SIZEOF(QUERY ( pd <* USEDIN(SELF,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
                | (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
               'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
               'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') IN TYPEOF(pdr.
               used_representation)) ) | (NOT (SIZEOF(impl_rep.
               used_representation.items) = 1)) )) = 0)) )) = 0;
      WR2: SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
                | (
               'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
                TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
               'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | ((
               sa_occ.description = 'swept shape occurrence') AND (SIZEOF(
               QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
               'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
               + 'RELATED_SHAPE_ASPECT') | ((sar.description = 
               'profile usage') AND ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' 
               IN TYPEOF(sar))) ) | (SIZEOF([
               'MACHINING_FEATURE_SCHEMA.SQUARE_U_PROFILE',
               'MACHINING_FEATURE_SCHEMA.PARTIAL_CIRCULAR_PROFILE',
               'MACHINING_FEATURE_SCHEMA.ROUNDED_U_PROFILE',
               'MACHINING_FEATURE_SCHEMA.VEE_PROFILE',
               'MACHINING_FEATURE_SCHEMA.TEE_PROFILE',
               'MACHINING_FEATURE_SCHEMA.OPEN_PATH_PROFILE'] * 
               TYPEOF(sdr.relating_shape_aspect)) = 1) )) = 1)) )) = 1)) )) 
               = 0;
      WR3: SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
                | (
               'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
                TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
               'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | ((
               sa_occ.description = 'course of travel occurrence') AND (
               SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
               'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
               + 'RELATED_SHAPE_ASPECT') | ((sar.description = 
               'path feature component usage') AND ((sar.name = 
               'course of travel') AND ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' 
               IN TYPEOF(sar)))) ) | (
               'TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT' IN 
               TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) = 1)) )) = 0;
               
      WR4: SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
           ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
           IN TYPEOF(pd)) ) | 
           (NOT((SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
           ((sa_occ.description = 'end condition occurrence') AND 
           (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(sa_occ,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
           (((sar.description = 'slot end usage') AND 
           (sar.name IN ['course of travel start','course of travel end'])) AND 
           ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
           IN TYPEOF(sar))) ) | 
           ((('MACHINING_FEATURE_SCHEMA.SLOT_END' 
           IN TYPEOF(fcr.relating_shape_aspect)) AND 
           (fcr.relating_shape_aspect.description 
           IN ['open','radiused','flat','woodruff'])) AND 
           ('MACHINING_FEATURE_SCHEMA.SLOT' 
           IN TYPEOF(fcr.related_shape_aspect.of_shape.definition))) 
            )) = 1) ) )) = 2) 
            OR 
           (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
           ((sa_occ.description = 'end condition occurrence') AND 
           (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(sa_occ,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
           (((sar.description = 'slot end usage') AND 
           (sar.name IN ['course of travel start','course of travel end'])) AND 
           ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
           IN TYPEOF(sar))) ) | 
           ((('MACHINING_FEATURE_SCHEMA.SLOT_END' 
           IN TYPEOF(fcr.relating_shape_aspect)) AND 
           (fcr.relating_shape_aspect.description IN ['loop'])) AND 
           ('MACHINING_FEATURE_SCHEMA.SLOT' 
           IN TYPEOF(fcr.related_shape_aspect.of_shape.definition))) 
            )) = 1) ) )) = 1))) )) =0; 
               
      WR5: (NOT (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)) ) | 
        (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'end condition occurrence') AND 
        (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        (((sar.description = 'slot end usage') AND 
        (sar.name IN ['course of travel start','course of travel end'])) AND 
        ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF(sar))) ) | 
        ((('MACHINING_FEATURE_SCHEMA.SLOT_END' 
        IN TYPEOF(fcr.relating_shape_aspect)) AND 
        (fcr.relating_shape_aspect.description IN ['loop'])) AND 
        ('MACHINING_FEATURE_SCHEMA.SLOT' 
        IN TYPEOF(fcr.related_shape_aspect.of_shape.definition))) 
        )) = 1)) )) = 1)) )) =0)
           OR  
        (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')| 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)) ) | 
        (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'course of travel occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'path feature component usage') AND 
        ((sar.name = 'course of travel') AND 
        ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' 
        IN TYPEOF(sar)))) ) | 
        (('TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT' 
        IN TYPEOF(sdr.relating_shape_aspect)) AND 
        (sdr.relating_shape_aspect.description 
        IN ['complex','complete circular'])) 
        )) = 1)) )) = 1)) )) = 0));
                
      WR6: SIZEOF(QUERY ( pdr <* get_property_definition_representations(
           SELF) | ((
           'MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION' 
           IN TYPEOF(pdr.used_representation)) AND (pdr.
           used_representation.name = 'maximum feature limit')) )) >= 0;       
  END_ENTITY; -- slot 

ENTITY slot_end
  SUBTYPE OF (shape_aspect);
   WHERE
WR1 : 'MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
      IN TYPEOF(SELF.of_shape.definition);
      
WR2 : SELF.description IN ['open','radiused','flat','woodruff',
      'loop'];
      
WR3: (NOT (SELF.description IN ['open','radiused','loop'])) OR 
     (SIZEOF(QUERY ( pd <* USEDIN(SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')| 
     (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
     (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
     IN TYPEOF(pdr.used_representation)) )) = 0)) )) = 0);
     
WR4: (NOT (SELF.description IN ['flat','woodruff'])) OR 
     (SIZEOF(QUERY ( pd <* USEDIN(SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
     (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
     (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
     IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
     
WR5: (NOT (SELF.description IN ['flat'])) OR 
     (SIZEOF(QUERY ( pd <* USEDIN(SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
     (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
     (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
     IN TYPEOF(pdr.used_representation)) ) | 
     (NOT (SIZEOF(impl_rep.used_representation.items) = 2)) )) = 0)) )) = 0);
     
WR6: (NOT (SELF.description = 'flat')) OR 
     (SIZEOF(QUERY ( pd <* USEDIN(SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
     (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
     (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
     IN TYPEOF(pdr.used_representation)) ) | 
     (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
     ((SIZEOF([
     'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
     'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) 
     = 2) AND 
     (it.name = 'first radius')) )) = 1)) )) = 0)) )) = 0);
     
WR7: (NOT (SELF.description = 'flat')) OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
     (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
     (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
     IN TYPEOF(pdr.used_representation)) ) | 
     (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
     ((SIZEOF([
     'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
     'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) 
     = 2) AND (it.name = 'second radius')) )) = 1)) ))  = 0)) )) = 0);
     
WR8: (NOT (SELF.description = 'woodruff')) OR 
     (SIZEOF(QUERY ( pd <* USEDIN(SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
     (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
     (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
     IN TYPEOF(pdr.used_representation)) ) | 
     (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
     (('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' 
     IN TYPEOF(it)) AND 
     (it.name = 'radius')) )) = 1)) )) = 0)) )) = 0);
     
WR9: (NOT (SELF.description IN ['woodruff'])) OR 
     (SIZEOF(QUERY ( pd <* USEDIN(SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
     (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
     (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
     IN TYPEOF(pdr.used_representation)) ) | 
     (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) = 0)) )) = 0);
     
WR10: SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
     + 'RELATING_SHAPE_ASPECT') | 
     (((sar.description = 'slot end usage') AND 
     (sar.name IN ['course of travel start','course of travel end'])) AND 
     ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' 
     IN TYPEOF(sar))) ) | 
     (((fcr.related_shape_aspect.description = 'end condition occurrence') AND 
     ('MACHINING_FEATURE_SCHEMA.SLOT' 
     IN TYPEOF(fcr.related_shape_aspect.of_shape.definition))) AND 
     ('MACHINING_FEATURE_SCHEMA.SLOT_END' 
     IN TYPEOF(fcr.relating_shape_aspect))) )) >= 1;
     
END_ENTITY; -- slot_end

ENTITY taper
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF(SELF.of_shape.definition));
    WR2: (SELF.description IN ['angle taper','diameter taper',
        'directed taper']);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
        = 0)) )) = 0);
    WR5: ((NOT (SELF.description = 'angle taper')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'taper angle')) )) = 1)) )) 
        = 0)) )) = 0));
    WR6: ((NOT (SELF.description = 'diameter taper')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'final diameter')) )) = 1)) )) 
        = 0)) )) = 0));
    WR7: ((NOT (SELF.description = 'directed taper')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'angle')) )) = 1)) )) 
        = 0)) )) = 0));   
   WR8: ((NOT (SELF.description = 'directed taper')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('MACHINING_FEATURE_SCHEMA.DIRECTION_SHAPE_REPRESENTATION' 
        IN TYPEOF(pdr.used_representation)) AND 
        (pdr.used_representation.name = 'direction') )) 
        = 1)) )) = 0));
END_ENTITY; -- taper

ENTITY tee_profile
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: 'MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF (SELF.of_shape.definition);
    WR2: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation))) = 1))) = 0;
    WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        (NOT (SIZEOF (impl_rep.used_representation.items) >= 9)
        AND  (SIZEOF (impl_rep.used_representation.items) <= 10)))) 
        = 0))) = 0; 
    WR4:  SIZEOF( QUERY( pd <* USEDIN( SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF( QUERY( pdr <* USEDIN( pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
       IN TYPEOF(pdr.used_representation)) AND
       (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
       (srwp_i.name = 'orientation') OR
       (srwp_i.name = 'width') OR
       (srwp_i.name = 'depth') OR
       (srwp_i.name = 'cross bar width') OR
       (srwp_i.name = 'cross bar depth') OR
       (srwp_i.name = 'first offset') OR
       (srwp_i.name = 'second offset') OR
       (srwp_i.name = 'first angle') OR
       (srwp_i.name = 'second angle') OR
       (srwp_i.name = 'radius') )) 
       = SIZEOF(pdr.used_representation.items)) )) = 1 )) = 1;
    WR5: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       ('GEOMETRY_SCHEMA.PLACEMENT' IN TYPEOF (it)) AND 
       (it.name = 'orientation'))) = 1))) = 0))) = 0;
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND  (it.name = 'width'))) = 1))) = 0))) = 0;
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND (it.name = 'depth'))) = 1))) = 0))) = 0;
    WR8: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND (it.name = 'cross bar width'))) = 1))) 
       = 0))) = 0;
    WR9: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND (it.name = 'cross bar depth'))) = 1))) 
       = 0))) = 0;
   WR10: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND (it.name = 'first offset'))) = 1))) 
       = 0))) = 0;
   WR11: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND (it.name = 'second offset'))) = 1))) 
       = 0))) = 0;
   WR12: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND (it.name = 'first angle'))) = 1))) 
       = 0))) = 0;
   WR13: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND (it.name = 'second angle'))) = 1))) 
       = 0))) = 0;
   WR14: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND (it.name = 'radius'))) <= 1))) = 0))) = 0;
   WR15: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION'
       IN TYPEOF (pdr.used_representation))AND
       (pdr.used_representation.name = 'profile limit'))) <= 1))) = 0;
END_ENTITY;   -- tee_profile

ENTITY thread
  SUBTYPE OF (feature_definition);
   WHERE
    WR1 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        ((('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) AND 
        (8 <= SIZEOF(pdr.used_representation.items)) AND 
        (SIZEOF(pdr.used_representation.items) <= 11)) )) = 1) )) = 1);
    WR2 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |     
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
        * TYPEOF(it)) = 2) AND (it.name = 'major diameter')) )) = 1)) )) 
        = 0)) )) = 0);
    WR3 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
        * TYPEOF(it)) = 2) AND (it.name = 'minor diameter')) )) 
        <= 1)) )) = 0)) )) = 0);
    WR4 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
        * TYPEOF(it)) = 2) AND (it.name = 'pitch diameter')) )) <= 1)) )) 
        = 0)) )) = 0);
    WR5 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.RATIO_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'number of threads')) )) 
        = 1)) )) = 0)) )) = 0);
    WR6 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'fit class')) )) = 1)) )) = 0)) )) 
        = 0);
    WR7 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'form')) )) = 1)) )) = 0)) )) 
        = 0);
    WR8 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'hand')AND 
        (it.description IN ['left', 'right']) ) )) = 1)) )) = 0)) )) 
        = 0);
    WR9 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'qualifier')) )) <= 1)) )) 
        = 0)) )) = 0);
   WR10: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
       (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
       IN TYPEOF(it)) AND (it.name = 'thread side') AND 
       ((it.description = 'internal') OR (it.description = 'external'))) )) 
       = 1)) )) = 0)) )) = 0);
   WR11: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
       * TYPEOF(it)) = 2) AND (it.name = 'crest')) )) <= 1)) )) 
       = 0)) )) = 0);
   WR12: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | 
       (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'partial area occurrence') AND 
       (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'applied area usage') AND 
       (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
       IN TYPEOF(sar))) ) | 
       ('MACHINING_FEATURE_SCHEMA.APPLIED_AREA' 
       IN TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) = 1)) )) = 0);
   WR13: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | 
       (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'applied shape') AND 
       (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
       IN TYPEOF(sar))) ) | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' 
       IN TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) = 1)) )) = 0);
     WR14 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'fit class 2')) )) <= 1)) )) = 0)) )) 
        = 0);   
     WR15 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
        * TYPEOF(it)) = 2) AND (it.name = 'nominal size')) )) 
        <= 1)) )) = 0)) )) = 0);   

   WR16: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | 
       (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'thread runout') AND 
       (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'thread runout usage') AND 
       (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
       IN TYPEOF(sar))) ) | 
       ('MACHINING_FEATURE_SCHEMA.THREAD_RUNOUT' 
       IN TYPEOF(sdr.relating_shape_aspect)) )) <= 1)) )) = 1)) )) = 0);        
 END_ENTITY;   -- thread


ENTITY thread_runout
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE'
         IN TYPEOF(SELF.of_shape));
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF (impl_rep.used_representation.items) = 3)) )) 
         = 0)) )) = 0);
    WR4: SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         (SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
         NOT (srwp_i.name IN ['length of runout','pitch or dimension',
         'included or extra']) )) > 0 ) )) = 0 )   )) = 0;
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'length of runout')) )) = 1)) )) 
         = 0)) )) <= 1);
    WR6: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
        | (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') IN TYPEOF(pdr.
        used_representation)) ) | (NOT (SIZEOF(QUERY ( it <* 
        impl_rep.used_representation.items | 
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
        IN TYPEOF(it)) AND (it.name = 'pitch or dimension') 
        AND (it.description IN ['pitch','pitch or dimension']))
        )) =  1)) )) = 0)) )) = 0);
    WR7: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
        | (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') IN TYPEOF(pdr.
        used_representation)) ) | (NOT (SIZEOF(QUERY ( it <* 
        impl_rep.used_representation.items | 
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
        IN TYPEOF(it)) AND (it.name = 'included or extra') 
        AND (it.description IN ['included','extra']))
        )) =  1)) )) = 0)) )) = 0);        
END_ENTITY; -- thread_runout

ENTITY transition_feature
    SUPERTYPE OF (ONEOF (chamfer,edge_round,fillet))
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: SIZEOF(['PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION',
         'MACHINING_FEATURE_SCHEMA.COMPOUND_FEATURE']
         * TYPEOF(SELF.of_shape.definition)) = 1;
    WR2: SIZEOF(['MACHINING_FEATURE_SCHEMA.CHAMFER',
        'MACHINING_FEATURE_SCHEMA.EDGE_ROUND', 
        'MACHINING_FEATURE_SCHEMA.FILLET'] *
        TYPEOF(SELF)) = 1;
END_ENTITY; -- transition_feature

ENTITY turned_knurl
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: (SELF\characterized_object.description IN
        ['diamond','diagonal','straight']);
    WR2:  SIZEOF( QUERY( pd <* USEDIN( SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF( QUERY( pdr <* USEDIN( pd, 
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN
       TYPEOF(pdr.used_representation)) AND
       ({6 <= SIZEOF(pdr.used_representation.items) <= 9}) )) = 1 )) = 1;
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
       (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
       IN TYPEOF(it)) AND 
       ('MEASURE_SCHEMA.COUNT_MEASURE' 
       IN TYPEOF(it\measure_with_unit.value_component)) AND 
       (it.name = 'number of teeth')) )) <= 1)) )) = 0)) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
       * TYPEOF(it)) = 2) AND (it.name = 'major diameter'))))= 1)) )) 
       = 0)) )) = 0);
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
       * TYPEOF(it)) = 2) AND (it.name = 'nominal diameter')) )) = 1)) )) 
       = 0)) )) = 0);
    WR6: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(QUERY ( impl_rep <* 
       QUERY ( pdr <* USEDIN(pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') IN TYPEOF(pdr.
       used_representation)) ) | (NOT (SIZEOF(QUERY ( it <* 
       impl_rep.used_representation.items | ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
       * TYPEOF(it)) = 2) AND (it.name = 'tooth depth')) )) <= 1)) )) 
       = 0)) )) = 0);
    WR7: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF(it)) = 2) AND (it.name = 'root fillet')) )) <= 1)) )) 
       = 0)) )) = 0);
    WR8: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF(it)) = 2) AND (it.name = 'diametral pitch')) )) = 1)) )) 
       = 0)) )) = 0);
    WR9: ((NOT (SELF\characterized_object.description IN
       ['diamond','diagonal'])) OR (
       SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
       | (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(
       pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') IN TYPEOF(pdr.
       used_representation)) ) | (NOT (SIZEOF(QUERY ( it <* 
       impl_rep.used_representation.items | ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] 
       * TYPEOF(it)) = 2) AND (it.name = 'helix angle')) )) = 1)) )) 
       = 0)) )) = 0));
    WR10: ((NOT (SELF\characterized_object.description = 'diagonal')) OR 
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
      'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
       (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'helix hand')) )) = 1)) )) 
       = 0)) )) = 0));
    WR11: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'partial area occurrence') AND 
       (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'applied area usage') AND 
       (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') IN TYPEOF(sar))) ) | 
       ('MACHINING_FEATURE_SCHEMA.APPLIED_AREA' 
       IN TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) = 1)) )) = 0);
   WR12: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | 
       (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'applied shape') AND 
       (('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP') 
       IN TYPEOF(sar))) ) | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' 
       IN TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) = 1)) )) = 0);
END_ENTITY; -- turned_knurl

ENTITY vee_profile
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: 'MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_DEFINITION' 
       IN TYPEOF (SELF.of_shape.definition);
    WR2: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation))) = 1))) = 0;
    WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       (NOT (SIZEOF (impl_rep.used_representation.items) >= 3)
       AND  (SIZEOF (impl_rep.used_representation.items) <= 6)))) 
       = 0))) = 0;
    WR4: SIZEOF( QUERY( pd <* USEDIN( SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF( QUERY( pdr <* USEDIN( pd, 
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
       IN TYPEOF(pdr.used_representation)) AND
       (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
       (srwp_i.name = 'orientation') OR
       (srwp_i.name = 'profile angle') OR
       (srwp_i.name = 'tilt angle') OR
       (srwp_i.name = 'profile radius')  OR 
       (srwp_i.name = 'first length') OR
       (srwp_i.name = 'second length') )) 
       = SIZEOF(pdr.used_representation.items)) )) = 1 )) = 1;
    WR5: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       ('GEOMETRY_SCHEMA.PLACEMENT' IN TYPEOF (it)) AND 
       (it.name = 'orientation'))) = 1))) = 0))) = 0;
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
       IN TYPEOF (it)) AND 
       ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' 
       IN TYPEOF (it\measure_with_unit.value_component)) AND 
       (it.name = 'profile radius'))) <= 1))) = 0))) = 0;
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND 
       (it.name = 'profile angle'))) = 1))) = 0))) = 0;
    WR8: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND 
       (it.name = 'tilt angle'))) = 1))) = 0))) = 0;
    WR9: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION'
       IN TYPEOF (pdr.used_representation))AND
       (pdr.used_representation.name = 'profile limit'))) <= 1))) = 0;
    WR10: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
       IN TYPEOF (it)) AND 
       ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' 
       IN TYPEOF (it\measure_with_unit.value_component)) AND 
       (it.name = 'first length'))) <= 1))) = 0))) = 0;
    WR11: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
       IN TYPEOF (it)) AND 
       ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' 
       IN TYPEOF (it\measure_with_unit.value_component)) AND 
       (it.name = 'second length'))) <= 1))) = 0))) = 0;
END_ENTITY; -- vee_profile


RULE machining_feature_definition_constraints FOR (feature_definition);
LOCAL
  mfds : SET OF feature_definition := [];
END_LOCAL;
  mfds := QUERY(temp <* feature_definition | 'MACHINING_FEATURE_SCHEMA.MACHINING_FEATURE_DEFINITION' IN TYPEOF (temp) );
WHERE
  WR1: SIZEOF(QUERY( mfd <* mfds | NOT (SIZEOF(QUERY( pdr <*
       get_property_definition_representations (mfd) |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
       IN TYPEOF ( pdr.used_representation ) ) ) <=1 ) ) ) = 0;
  WR2: SIZEOF(QUERY( mfd <* mfds | NOT (SIZEOF (QUERY (pd <* USEDIN (mfd, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        ('GEOMETRY_SCHEMA.PLACEMENT' 
        IN TYPEOF (it)) AND (it.name = 'orientation'))) = 1))) = 0))) = 0 ) ) ) = 0;
  WR3: SIZEOF(QUERY( mfd <* mfds | NOT ((NOT (SIZEOF(['MACHINING_FEATURE_SCHEMA.ROUND_HOLE',
        'MACHINING_FEATURE_SCHEMA.BOSS',
        'MACHINING_FEATURE_SCHEMA.OUTSIDE_PROFILE',
        'MACHINING_FEATURE_SCHEMA.REMOVAL_VOLUME',
        'MACHINING_FEATURE_SCHEMA.FLAT_FACE',
        'MACHINING_FEATURE_SCHEMA.POCKET',
        'MACHINING_FEATURE_SCHEMA.PROTRUSION',
        'MACHINING_FEATURE_SCHEMA.RIB_TOP',
        'MACHINING_FEATURE_SCHEMA.ROUNDED_END',
        'MACHINING_FEATURE_SCHEMA.SLOT',
        'MACHINING_FEATURE_SCHEMA.STEP'] * TYPEOF(mfds)) = 1))   OR 
     ((SIZEOF(QUERY(pdr <* get_property_definition_representations (mfd) | 
        ( 'MACHINING_FEATURE_SCHEMA.PLANAR_SHAPE_REPRESENTATION' 
        IN TYPEOF ( pdr.used_representation ) ) AND 
        ( pdr.used_representation.name ='maximum feature limit'))) >=0)) ) ) ) = 0; 
END_RULE; 

SUBTYPE_CONSTRAINT machining_feature_definition_subtypes FOR feature_definition;
  ONEOF (  
    boss,
    compound_feature,
    externally_defined_feature_definition,
    flat_face,
    gear,
    marking,
    outer_round,
    outside_profile,
    pocket,
    protrusion,
    removal_volume,
    replicate_feature,
    revolved_profile,
    rib_top,
    round_hole,
    rounded_end,
    spherical_cap,
    step,
    slot,
    thread,
    turned_knurl);
END_SUBTYPE_CONSTRAINT;


END_SCHEMA;   -- MACHINING_FEATURE_SCHEMA


--
-- MANAGEMENT_RESOURCES_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/management_resources_schema/management_resources_schema.exp)
--
(*
Id: management_resources_schema.exp,v 1.40 2019/01/23 19:28:13 brandon Exp 
ISO 10303 TC184/SC4/WG12 N10233

EXPRESS Source:
ISO 10303-41 ed6 Fundamentals of product description and support - Management resources schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2019  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Management resources schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA management_resources_schema '{iso standard 10303 part(41) version(8) object(1) management_resources_schema(15)}';
  REFERENCE FROM action_schema;		-- ISO 10303-41
  REFERENCE FROM application_context_schema (library_context);	-- ISO 10303-41
  REFERENCE FROM approval_schema;		-- ISO 10303-41
  REFERENCE FROM basic_attribute_schema (	-- ISO 10303-41
    get_role, 
    object_role, 
    role_association,
    role_select);
  REFERENCE FROM certification_schema; 	-- ISO 10303-41
  REFERENCE FROM contract_schema;		-- ISO 10303-41
  REFERENCE FROM date_time_schema;		-- ISO 10303-41
  REFERENCE FROM document_schema;		-- ISO 10303-41
  REFERENCE FROM effectivity_schema;	-- ISO 10303-41
  REFERENCE FROM experience_schema;		-- ISO 10303-41
  REFERENCE FROM external_reference_schema (external_source);	-- ISO 10303-41
  REFERENCE FROM group_schema;			-- ISO 10303-41
  REFERENCE FROM location_schema;		-- ISO 10303-41
  REFERENCE FROM person_organization_schema;	-- ISO 10303-41
  REFERENCE FROM qualifications_schema;	-- ISO 10303-41
  REFERENCE FROM security_classification_schema;	-- ISO 10303-41
  REFERENCE FROM support_resource_schema;	-- ISO 10303-41

  TYPE mrs_role_select = SELECT BASED_ON role_select WITH (
    action_assignment,
    action_request_assignment,
    approval_assignment,
    certification_assignment,
    contract_assignment,
    document_reference,
    effectivity_assignment,
    external_referent_assignment,
    group_assignment,
    name_assignment,
    security_classification_assignment);
  END_TYPE;

TYPE assignment_object_select = EXTENSIBLE SELECT;
END_TYPE;

  TYPE attribute_type = SELECT (label, text);
  END_TYPE;

  ENTITY action_assignment
    ABSTRACT SUPERTYPE;
    assigned_action : action;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY action_method_assignment
    ABSTRACT SUPERTYPE;
    assigned_action_method : action_method;
    role : action_method_role;
  END_ENTITY;

  ENTITY action_method_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY action_request_assignment
    ABSTRACT SUPERTYPE;
    assigned_action_request : versioned_action_request;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY approval_assignment
    ABSTRACT SUPERTYPE;
    assigned_approval : approval;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

ENTITY assignment_object_relationship;
	id 				: OPTIONAL identifier;
	description		: OPTIONAL text;
	relating		: assignment_object_select;
	related			: assignment_object_select;
	relation_type	: STRING;
 WHERE 
  WR1: acyclic_assignment_object_relationship(SELF, [related], 'MANAGEMENT_RESOURCES_SCHEMA.ASSIGNMENT_OBJECT_RELATIONSHIP');
END_ENTITY;

  ENTITY attribute_classification_assignment
    ABSTRACT SUPERTYPE;
    assigned_class : group;
    attribute_name : label;
    role : classification_role;
  END_ENTITY;

  ENTITY attribute_value_assignment
    ABSTRACT SUPERTYPE;
    attribute_name : label;
    attribute_value : attribute_type;
    role : attribute_value_role;
  END_ENTITY;

  ENTITY attribute_value_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY certification_assignment
    ABSTRACT SUPERTYPE;
    assigned_certification : certification;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY classification_assignment
    ABSTRACT SUPERTYPE;
    assigned_class : group;
    role : classification_role;
  END_ENTITY;
  
  ENTITY classification_assignment_relationship;
    id 			: OPTIONAL identifier;
    description	: OPTIONAL text;
    relating	: classification_assignment;
    related		: classification_assignment;
    relation_type	: STRING;
   WHERE
    WR1: acyclic_classification_assignment_relationship(SELF, [related], 'MANAGEMENT_RESOURCES_SCHEMA.CLASSIFICATION_ASSIGNMENT_RELATIONSHIP');
  END_ENTITY;
  
  ENTITY classification_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY contract_assignment
    ABSTRACT SUPERTYPE;
    assigned_contract : contract;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY date_and_time_assignment
    ABSTRACT SUPERTYPE;
    assigned_date_and_time : date_and_time;
    role : date_time_role;
  END_ENTITY;

  ENTITY date_assignment
    ABSTRACT SUPERTYPE;
    assigned_date : date;
    role : date_role;
  END_ENTITY;

  ENTITY document_reference
    ABSTRACT SUPERTYPE;
    assigned_document : document;
    source : label;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY document_usage_constraint_assignment
    ABSTRACT SUPERTYPE;
    assigned_document_usage : document_usage_constraint;
    role : document_usage_role;
  END_ENTITY;

  ENTITY document_usage_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY effectivity_assignment
    ABSTRACT SUPERTYPE;
    assigned_effectivity : effectivity;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY effectivity_context_assignment
    ABSTRACT SUPERTYPE;
    assigned_effectivity_assignment : effectivity_assignment;
    role : effectivity_context_role;
  END_ENTITY;

  ENTITY effectivity_context_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY event_occurrence_assignment
    ABSTRACT SUPERTYPE;
    assigned_event_occurrence : event_occurrence;
    role : event_occurrence_role;
  END_ENTITY;

  ENTITY event_occurrence_context_assignment
    ABSTRACT SUPERTYPE;
    assigned_event_occurrence_assignment : event_occurrence_assignment;
    role : event_occurrence_context_role;
  END_ENTITY;

  ENTITY experience_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_experience : experience;
    role : experience_role;
  END_ENTITY;

  ENTITY experience_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY experience_type_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_experience_type : experience_type;
    role : experience_type_role;
  END_ENTITY;

  ENTITY experience_type_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY external_identification_assignment
    ABSTRACT SUPERTYPE
    SUBTYPE OF (identification_assignment);
    source : external_source;
  END_ENTITY;
  
  ENTITY external_identification_assignment_relationship;
    id 			: OPTIONAL identifier;
    description	: OPTIONAL text;
    relating	: external_identification_assignment;
    related		: external_identification_assignment;
    relation_type	: STRING;
   WHERE
    WR1: acyclic_external_identification_assignment_relationship(SELF, [related], 'MANAGEMENT_RESOURCES_SCHEMA.EXTERNAL_IDENTIFICATION_ASSIGNMENT_RELATIONSHIP');
  END_ENTITY;

  ENTITY external_referent_assignment
    ABSTRACT SUPERTYPE;
    assigned_name : label;
  DERIVE
    role : object_role := get_role(SELF);
  UNIQUE
    UR1: assigned_name;
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY group_assignment
    ABSTRACT SUPERTYPE;
    assigned_group : group;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY identification_assignment
    ABSTRACT SUPERTYPE;
    assigned_id : identifier;
    role : identification_role;
  END_ENTITY;

  ENTITY identification_assignment_relationship;
    name : label;
    description : OPTIONAL text;
    relating_identification_assignment : identification_assignment;
    related_identification_assignment : identification_assignment;
  END_ENTITY;

  ENTITY identification_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY library_assignment
    ABSTRACT SUPERTYPE
    SUBTYPE OF (external_referent_assignment);
    frame_of_reference : library_context;
  UNIQUE
    UR1: frame_of_reference;
  END_ENTITY;

  ENTITY location_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_location : location;
    role : location_role;
  END_ENTITY;

  ENTITY location_representation_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    represented_location : location;
    role : location_representation_role;
  END_ENTITY;

  ENTITY location_representation_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY location_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY name_assignment
    ABSTRACT SUPERTYPE;
    assigned_name : label;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY organization_assignment
    ABSTRACT SUPERTYPE;
    assigned_organization : organization;
    role : organization_role;
  END_ENTITY;

  ENTITY organization_type_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_organization_type : organization_type;
    role : organization_type_role;
  END_ENTITY;

  ENTITY organization_type_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY organizational_project_assignment
    ABSTRACT SUPERTYPE;
    assigned_organizational_project : organizational_project;
    role : organizational_project_role;
  END_ENTITY;

  ENTITY organizational_project_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY person_and_organization_assignment
    ABSTRACT SUPERTYPE;
    assigned_person_and_organization : person_and_organization;
    role : person_and_organization_role;
  END_ENTITY;

  ENTITY person_assignment
    ABSTRACT SUPERTYPE;
    assigned_person : person;
    role : person_role;
  END_ENTITY;

  ENTITY person_type_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_person_type : person_type;
    role : person_type_role;
  END_ENTITY;

  ENTITY person_type_definition_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_person_type_definition : person_type_definition;
    role : person_type_definition_role;
  END_ENTITY;

  ENTITY person_type_definition_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY person_type_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY position_in_organization_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_position_in_organization : position_in_organization;
    role : position_in_organization_role;
  END_ENTITY;

  ENTITY position_in_organization_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY position_in_organization_type_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_position_in_organization_type : position_in_organization_type;
    role : position_in_organization_type_role;
  END_ENTITY;

  ENTITY position_in_organization_type_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY qualification_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_qualification : qualification;
    role : qualification_role;
  END_ENTITY;

  ENTITY qualification_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY qualification_type_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_qualification_type : qualification_type;
    role : qualification_type_role;
  END_ENTITY;

  ENTITY qualification_type_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY security_classification_assignment
    ABSTRACT SUPERTYPE;
    assigned_security_classification : security_classification;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY time_assignment
    ABSTRACT SUPERTYPE;
    assigned_time : local_time;
    role : time_role;
  END_ENTITY;

  ENTITY time_interval_assignment
    ABSTRACT SUPERTYPE;
    assigned_time_interval : time_interval;
    role : time_interval_role;
  END_ENTITY;

FUNCTION acyclic_assignment_object_relationship (relation : assignment_object_relationship; relatives : SET [1:?] OF assignment_object_select; specific_relation : STRING):BOOLEAN;
  LOCAL
    x : SET OF assignment_object_relationship;
  END_LOCAL;
  
  IF relation.relating IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(aor <* bag_to_set(USEDIN(relation.relating, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'ASSIGNMENT_OBJECT_RELATIONSHIP.' + 'RELATED')) | specific_relation IN TYPEOF(aor));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_assignment_object_relationship(x[i], relatives + relation.relating, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;

 FUNCTION acyclic_classification_assignment_relationship (relation : classification_assignment_relationship; relatives : SET [1:?] OF classification_assignment; specific_relation : STRING):BOOLEAN;
  LOCAL
    x : SET OF classification_assignment_relationship;
  END_LOCAL;

  IF relation.relating IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(car <* bag_to_set(USEDIN(relation.relating, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'CLASSIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED')) | specific_relation IN TYPEOF(car));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_classification_assignment_relationship(x[i], relatives + relation.relating, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
 END_FUNCTION;

 FUNCTION acyclic_external_identification_assignment_relationship (relation : external_identification_assignment_relationship; relatives : SET [1:?] OF external_identification_assignment; specific_relation : STRING):BOOLEAN;
  LOCAL
    x : SET OF external_identification_assignment_relationship;
  END_LOCAL;

  IF relation.relating IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(eiar <* bag_to_set(USEDIN(relation.relating, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'EXTERNAL_IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED')) | specific_relation IN TYPEOF(eiar));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_external_identification_assignment_relationship(x[i], relatives + relation.relating, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
 END_FUNCTION;

  FUNCTION acyclic_identification_assignment_relationship (relation : identification_assignment_relationship; relatives : SET [1:?] OF identification_assignment; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF identification_assignment_relationship;
    END_LOCAL;

    IF relation.relating_identification_assignment IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ia <* bag_to_set(USEDIN(relation.relating_identification_assignment, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED_IDENTIFICATION_ASSIGNMENT')) | specific_relation IN TYPEOF(ia));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_identification_assignment_relationship(x[i], relatives + relation.relating_identification_assignment, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;


--
-- MANAGEMENT_RESOURCE_INFORMATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/management_resource_information/mim.exp)
--
(*
ISO TC184/SC4/WG12 N11210 - ISO/TS 10303-1288 Management resource information - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N104011
*) 


SCHEMA Management_resource_information_mim;

USE FROM Approval_mim;    -- ISO/TS 10303-1012

USE FROM Certification_mim;    -- ISO/TS 10303-1044

USE FROM Contract_mim;    -- ISO/TS 10303-1062

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM management_resources_schema   -- ISO 10303-41
  (identification_role);

USE FROM Multi_linguism_mim;    -- ISO/TS 10303-1105

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Project_mim;    -- ISO/TS 10303-1061

USE FROM Security_classification_mim;    -- ISO/TS 10303-1015

TYPE mri_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH
  (certification,
   contract);
END_TYPE;

TYPE mri_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH
  (applied_organizational_project_assignment,
   approval,
   approval_relationship,
   approval_status,
   certification,
   certification_type,
   contract,
   date_role,
   date_time_role,
   identification_role,
   organization_relationship,
   organizational_project,
   organizational_project_relationship,
   organizational_project_role,
   person_and_organization);
END_TYPE;

TYPE mri_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH
  (applied_organization_assignment,
   applied_person_and_organization_assignment,
   applied_security_classification_assignment,
   certification,
   contract,
   security_classification);
END_TYPE;

TYPE mri_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH
  (applied_organization_assignment,
   applied_person_and_organization_assignment,
   applied_security_classification_assignment,
   certification,
   contract,
   security_classification);
END_TYPE;

TYPE mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH
  (approval_status,
   contract,
   organization,
   security_classification_level);
END_TYPE;

TYPE mri_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH
  (applied_organizational_project_assignment,
   approval,
   approval_relationship,
   approval_status,
   certification,
   certification_type,
   contract,
   date_role,
   date_time_role,
   identification_role,
   organization_relationship,
   organizational_project,
   organizational_project_relationship,
   organizational_project_role,
   person_and_organization);
END_TYPE;

TYPE mri_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH
  (applied_identification_assignment,
   applied_security_classification_assignment,
   contract);
END_TYPE;

TYPE mri_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH
  (applied_identification_assignment,
   applied_security_classification_assignment,
   contract,
   person_and_organization);
END_TYPE;

END_SCHEMA;  -- Management_resource_information_mim



--
-- MATERIAL_PROPERTY_DEFINITION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/material_property_definition_schema/material_property_definition_schema.exp)
--
(*
Id: material_property_definition_schema.exp,v 1.13 2019/01/10 22:26:11 brandon Exp 
ISO 10303 TC184/SC4/WG12 N10209

EXPRESS Source:
ISO 10303-45 ed5 Material and other engineering properties - Material property definition schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2019  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-45 ed3 Material and other engineering properties - Material property definition schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA material_property_definition_schema '{iso standard 10303 part(45) version(4) object(1) material_property_definition_schema(1)}';

REFERENCE FROM material_property_representation_schema
     (material_property_representation);

REFERENCE FROM measure_schema
     (measure_with_unit);

REFERENCE FROM process_property_schema
	(action_property,
	 resource_property);

REFERENCE FROM product_definition_schema
      (product_definition_relationship);

REFERENCE FROM product_property_definition_schema
      (characterized_definition,
      property_definition);

REFERENCE FROM qualified_measure_schema
     (maths_value_with_unit);

REFERENCE FROM shape_dimension_schema
	(dimensional_location,
	 dimensional_size);     

REFERENCE FROM support_resource_schema
     (label,
      text,
      bag_to_set);

TYPE characterized_material_property = SELECT
  (material_property_representation,
   product_material_composition_relationship);
END_TYPE;

TYPE characterized_product_composition_value = SELECT
  (maths_value_with_unit,
   measure_with_unit);
END_TYPE;

TYPE generic_property_definition_select = SELECT
  (property_definition,
   action_property,
   resource_property,
   dimensional_location,
   dimensional_size);
END_TYPE;
   
ENTITY generic_property_relationship;
  name              : label;
  description       : text;
  relating 			: generic_property_definition_select;
  related  			: generic_property_definition_select;
  relation_type : STRING;
 WHERE
  WR1: acyclic_generic_property_relationship (SELF, [related], 'MATERIAL_PROPERTY_DEFINITION_SCHEMA.GENERIC_PROPERTY_RELATIONSHIP');
END_ENTITY;

ENTITY material_designation; 
  name       		: label;
  definitions 	: SET [1:?] OF characterized_definition;
END_ENTITY;

ENTITY material_designation_characterization;
  name       		: label;
  description 	: text;
  designation 	: material_designation;
  property    	: characterized_material_property;
END_ENTITY;

ENTITY material_property
SUBTYPE OF (property_definition);
UNIQUE
  UR1 : SELF\property_definition.name, SELF\property_definition.definition;
WHERE
  WR1 : ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT' IN
          TYPEOF(SELF\property_definition.definition)) OR
       (SIZEOF(bag_to_set(USEDIN(SELF ,
                     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                     'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) -
              QUERY(temp <* bag_to_set(USEDIN(SELF ,
                       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
                       ('MATERIAL_PROPERTY_REPRESENTATION_SCHEMA.' +
                      'MATERIAL_PROPERTY_REPRESENTATION' IN
                      TYPEOF(temp)))) = 0);
END_ENTITY;

ENTITY product_material_composition_relationship
SUBTYPE OF (product_definition_relationship);
  class        	       : label;
  constituent_amount  	: SET [1:?] OF characterized_product_composition_value;
  composition_basis    : label;
  determination_method : text;
END_ENTITY;

ENTITY property_definition_relationship;
  name                       	: label;
  description                 	: text;
  relating_property_definition 	: property_definition;
  related_property_definition  	: property_definition;
END_ENTITY;

FUNCTION acyclic_generic_property_relationship
  (relation          : generic_property_relationship;
   relatives         : SET [1:?] OF generic_property_definition_select;
   specific_relation : STRING) : LOGICAL;
  LOCAL
    x                : SET OF generic_property_relationship;
  END_LOCAL;
  IF relation.relating IN 
            relatives THEN
    RETURN (FALSE);
  END_IF;             -- IN is based in instance equality
  x := QUERY (gpr <* bag_to_set (USEDIN
       (relation.relating,
        'MATERIAL_PROPERTY_DEFINITION_SCHEMA.' +
        'GENERIC_PROPERTY_RELATIONSHIP.' +
        'RELATED')) |
         specific_relation IN TYPEOF (gpr));
  REPEAT I := 1 TO HIINDEX(x);             -- pre-checked loop
    IF NOT acyclic_generic_property_relationship
      (x[i],
       relatives + relation.relating,
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;  -- acyclic_generic_property_relationship

FUNCTION acyclic_property_definition_relationship
  (relation          : property_definition_relationship;
   relatives         : SET [1:?] OF property_definition;
   specific_relation : STRING) : LOGICAL;
  LOCAL
    x                : SET OF property_definition_relationship;
  END_LOCAL;
  IF relation.relating_property_definition IN 
            relatives THEN
    RETURN (FALSE);
  END_IF;             -- IN is based in instance equality
  x := QUERY (pd <* bag_to_set (USEDIN
       (relation.relating_property_definition,
        'MATERIAL_PROPERTY_DEFINITION_SCHEMA.' +
        'PROPERTY_DEFINITION_RELATIONSHIP.' +
        'RELATED_PROPERTY_DEFINITION')) |
         specific_relation IN TYPEOF (pd));
  REPEAT I := 1 TO HIINDEX(x);             -- pre-checked loop
    IF NOT acyclic_property_definition_relationship
      (x[i],
       relatives + relation.relating_property_definition,
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;  -- acyclic_property_definition_relationship

END_SCHEMA;    -- material_property_definition_schema


--
-- MATERIAL_PROPERTY_REPRESENTATION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/material_property_representation_schema/material_property_representation_schema.exp)
--
(*
Id: material_property_representation_schema.exp,v 1.7 2017/04/28 17:01:54 rswindells Exp 
ISO 10303 TC184/SC4/WG12 N6751

EXPRESS Source:
ISO 10303-45 ed3 Material and other engineering properties - Material property representation schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2017  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-45 ed3 Material and other engineering properties - Material property representation schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA material_property_representation_schema '{iso standard 10303 part(45) version(2) object(1) material_property_representation_schema(2)}';

REFERENCE FROM product_property_representation_schema
     (property_definition_representation);
     
REFERENCE FROM shape_dimension_schema
     (dimensional_characteristic_representation);

REFERENCE FROM process_property_representation_schema
     (action_property_representation,
      resource_property_representation);

REFERENCE FROM support_resource_schema
     (label,
      text);

TYPE characterized_property_representation = SELECT (
	action_property_representation,
	dimensional_characteristic_representation,
	property_definition_representation,
	resource_property_representation);
END_TYPE;

ENTITY data_environment;
  name       		: label;
  description 	: text;
  elements    	: SET [1:?] OF characterized_property_representation;
END_ENTITY;

ENTITY data_environment_relationship;
  name                    		: label;
  description              	: text;
  relating_data_environment 	: data_environment;
  related_data_environment  	: data_environment;
END_ENTITY;

ENTITY material_property_representation
  SUBTYPE OF (property_definition_representation);
  dependent_environment : data_environment;
END_ENTITY;

ENTITY material_dimensional_characteristic_representation
  SUBTYPE OF (dimensional_characteristic_representation);
  dependent_environment : data_environment;
END_ENTITY;

END_SCHEMA;		-- material_property_representation_schema


--
-- MATHEMATICAL_CONTEXT_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/mathematical_context_schema/mathematical_context_schema.exp)
--
(*
Id: mathematical_context_schema.exp,v 1.4 2014/03/04 00:30:38 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N3251

EXPRESS Source:
ISO 10303-51 ed1 Mathematical representation - Mathematical context schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-51 ed1 Mathematical representation - Mathematical context schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA mathematical_context_schema '{iso standard 10303 part(51) version(1) object(1) mathematical_context_schema(1)}';

REFERENCE FROM action_schema   -- ISO 10303-41
  (action,
   action_method); 

REFERENCE FROM mathematical_functions_schema   -- ISO 10303-50
  (maths_space,
   maths_value); 

REFERENCE FROM measure_schema   -- ISO 10303-41
  (unit); 

REFERENCE FROM product_definition_schema   -- ISO 10303-41
  (product_definition); 

REFERENCE FROM product_property_definition_schema   -- ISO 10303-41
  (general_property,
   shape_aspect); 

REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation_context,
   representation_item); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (identifier,
   label,
   text); 

REFERENCE FROM iso13584_generic_expressions_schema   -- ISO 13584-20
  (generic_expression); 


TYPE space_context_select = EXTENSIBLE SELECT
   (action, 
    action_method, 
    general_property, 
    product_definition, 
    representation_item, 
    shape_aspect);
END_TYPE; 

TYPE value_context_select = EXTENSIBLE SELECT
   (action, 
    action_method, 
    general_property, 
    product_definition, 
    representation_item, 
    shape_aspect);
END_TYPE; 

ENTITY compound_maths_space_context
  SUBTYPE OF (maths_space_context);
  components : LIST[2:?] OF maths_space_context;
END_ENTITY;

ENTITY defined_maths_space_context
  SUBTYPE OF (maths_space_context);
END_ENTITY;

ENTITY explicitly_enumerated_maths_space_context
  SUBTYPE OF (maths_space_context);
  members : SET[1:?] OF maths_value_context;
END_ENTITY;

ENTITY maths_space_context
  SUPERTYPE OF (ONEOF (compound_maths_space_context,
                       defined_maths_space_context,
                       explicitly_enumerated_maths_space_context));
  id : identifier;
  name : label;
  description : OPTIONAL text;
  abstract_space : maths_space;
  physical_space : space_context_select;
END_ENTITY;

ENTITY maths_value_context;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  abstract_value : maths_value;
  physical_value : value_context_select;
END_ENTITY;

ENTITY membership_of_maths_space_context;
  space_context : maths_space_context;
  value_context : maths_value_context;
END_ENTITY;

ENTITY normalized_maths_space_context
  SUBTYPE OF (defined_maths_space_context);
  normalization_basis : value_context_select;
END_ENTITY;

ENTITY representation_context_defined_maths_space_context
  SUBTYPE OF (defined_maths_space_context);
  representation_basis : representation_context;
END_ENTITY;

ENTITY unit_defined_maths_space_context
  SUBTYPE OF (defined_maths_space_context);
  unit_basis : unit;
END_ENTITY;

END_SCHEMA;  -- mathematical_context_schema


--
-- MATHEMATICAL_DESCRIPTION_OF_DISTRIBUTION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/mathematical_description_of_distribution_schema/mathematical_description_of_distribution_schema.exp)
--
(*
Id: mathematical_description_of_distribution_schema.exp,v 1.4 2014/03/04 00:30:38 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N3251

EXPRESS Source:
ISO 10303-51 ed1 Mathematical representation - Mathematical description of distribution schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-51 ed1 Mathematical representation - Mathematical description of distribution schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA mathematical_description_of_distribution_schema '{iso standard 10303 part(51) version(1) object(1) mathematical_description_of_distribution_schema(2)}';

REFERENCE FROM mathematical_context_schema   -- ISO 10303-51
  (maths_space_context); 

REFERENCE FROM mathematical_functions_schema   -- ISO 10303-50
  (maths_function); 

REFERENCE FROM process_property_schema   -- ISO 10303-49
  (action_property,
   resource_property); 

REFERENCE FROM product_property_definition_schema   -- ISO 10303-41
  (property_definition,
   general_property_relationship); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (identifier,
   label,
   text); 


TYPE property_distribution_select = EXTENSIBLE SELECT
   (action_property, 
    general_property_relationship, 
    property_definition, 
    resource_property);
END_TYPE; 

ENTITY maths_space_context_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_context : maths_space_context;
  related_context : maths_space_context;
END_ENTITY;

ENTITY maths_space_context_relationship_description;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  described_relationship : maths_space_context_relationship;
  describing_relationship : maths_function;
END_ENTITY;

ENTITY normalized_property_distribution_description;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  abstract_function : maths_function;
  domain_context : maths_space_context;
  normalization_basis : property_distribution_select;
  physical_function : property_distribution_select;
END_ENTITY;

ENTITY property_distribution_description;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  abstract_function : maths_function;
  domain_context : maths_space_context;
  physical_function : property_distribution_select;
  range_context : maths_space_context;
END_ENTITY;

END_SCHEMA;  -- mathematical_description_of_distribution_schema


--
-- MATHEMATICAL_FUNCTIONS_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/mathematical_functions_schema/mathematical_functions_schema.exp)
--
(*
Id: mathematical_functions_schema.exp,v 1.23 2014/05/26 12:22:03 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N8315

EXPRESS Source:
ISO 10303-50 ed1 Mathematical constructs - Mathematical functions schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-50 ed1 Mathematical constructs - Mathematical functions schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA mathematical_functions_schema '{iso standard 10303 part(50) version(3) object(1) mathematical_functions_schema(1)}';

REFERENCE FROM iso13584_generic_expressions_schema     -- ISO 13584-20
  (binary_generic_expression,
   environment,
   generic_expression,
   generic_literal,
   generic_variable,
   multiple_arity_generic_expression,
   simple_generic_expression,
   unary_generic_expression,
   variable_semantics);

REFERENCE FROM iso13584_expressions_schema             -- ISO 13584-20
  (abs_function                   AS abs_expression,
   acos_function                  AS acos_expression,
   and_expression,
   asin_function                  AS asin_expression,
   atan_function                  AS atan_expression,
   binary_boolean_expression,
   binary_function_call           AS binary_numeric_call_expression,
   binary_numeric_expression,
   boolean_defined_function       AS boolean_defined_expression,
   boolean_expression,
   boolean_literal,
   boolean_variable,
   comparison_equal,
   comparison_expression,
   comparison_greater,
   comparison_greater_equal,
   comparison_less,
   comparison_less_equal,
   comparison_not_equal,
   concat_expression,
   cos_function                   AS cos_expression,
   defined_function               AS defined_expression,
   div_expression,
   equals_expression,
   exp_function                   AS exp_expression,
   expression,
   format_function                AS format_expression,
   index_expression,
   int_literal,
   int_numeric_variable,
   int_value_function             AS int_value_expression,
   integer_defined_function       AS integer_defined_expression,
   interval_expression,
   length_function                AS length_expression,
   like_expression,
   literal_number,
   log_function                   AS log_expression,
   log10_function                 AS log10_expression,
   log2_function                  AS log2_expression,
   maximum_function               AS maximum_expression,
   minimum_function               AS minimum_expression,
   minus_expression,
   minus_function                 AS unary_minus_expression,
   mod_expression,
   mult_expression,
   multiple_arity_boolean_expression,
   multiple_arity_function_call   AS multiple_arity_numeric_call_expression,
   multiple_arity_numeric_expression,
   not_expression,
   numeric_defined_function       AS numeric_defined_expression,
   numeric_expression,
   numeric_variable,
   odd_function                   AS odd_expression,
   or_expression,
   plus_expression,
   power_expression,
   real_defined_function          AS real_defined_expression,
   real_literal,
   real_numeric_variable,
   simple_boolean_expression,
   simple_numeric_expression,
   simple_string_expression,
   sin_function                   AS sin_expression,
   slash_expression,
   sql_mappable_defined_function  AS sql_mappable_defined_expression,
   square_root_function           AS square_root_expression,
   string_defined_function        AS string_defined_expression,
   string_expression,
   string_literal,
   string_variable,
   substring_expression,
   tan_function                   AS tan_expression,
   unary_boolean_expression,
   unary_function_call            AS unary_numeric_call_expression,
   unary_numeric_expression,
   value_function                 AS value_expression,
   variable,
   xor_expression);

REFERENCE FROM support_resource_schema                 -- ISO 10303-41
  (label,
   text);

REFERENCE FROM external_reference_schema               -- ISO 10303-41
  (externally_defined_item);

REFERENCE FROM geometry_schema                         -- ISO 10303-42
  (curve,
   dimension_of,
   point,
   surface,
   volume);

CONSTANT
  schema_prefix : STRING := 'MATHEMATICAL_FUNCTIONS_SCHEMA.';
  the_integers        : elementary_space := make_elementary_space(es_integers);
  the_reals           : elementary_space := make_elementary_space(es_reals);
  the_complex_numbers : elementary_space := make_elementary_space(es_complex_numbers);
  the_numbers         : elementary_space := make_elementary_space(es_numbers);
  the_logicals        : elementary_space := make_elementary_space(es_logicals);
  the_booleans        : elementary_space := make_elementary_space(es_booleans);
  the_strings         : elementary_space := make_elementary_space(es_strings);
  the_binarys         : elementary_space := make_elementary_space(es_binarys);
  the_maths_spaces    : elementary_space := make_elementary_space(es_maths_spaces);
  the_generics        : elementary_space := make_elementary_space(es_generics);
  the_empty_space : finite_space := make_finite_space([]);
  the_nonnegative_reals         : real_interval_from_min :=
    make_real_interval_from_min(0.0, closed);
  the_zero_one_interval         : finite_real_interval := make_finite_real_interval(
    0.0, closed, 1.0, closed);
  the_zero_pi_interval          : finite_real_interval := make_finite_real_interval(
    0.0, closed, pi, closed);
  the_neg1_one_interval         : finite_real_interval := make_finite_real_interval(
    -1.0, closed, 1.0, closed);
  the_neghalfpi_halfpi_interval : finite_real_interval := make_finite_real_interval(
    -0.5*pi, closed, 0.5*pi, closed);
  the_negpi_pi_interval         : finite_real_interval := make_finite_real_interval(
    -pi, open, pi, closed);
  the_zero_tuple_space : listed_product_space := make_listed_product_space([]);
  the_tuples           : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_generics);
  the_integer_tuples   : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_integers);
  the_real_tuples      : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_reals);
  the_complex_tuples   : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_complex_numbers);
  the_empty_maths_tuple      : maths_tuple := [];
  the_empty_maths_value      : maths_value := the_empty_maths_tuple;
  the_empty_atom_based_tuple : atom_based_tuple := [];
  the_empty_atom_based_value : atom_based_value := the_empty_atom_based_tuple;
END_CONSTANT;
TYPE nonnegative_integer = INTEGER;
WHERE 
nonnegativity: SELF >= 0;
END_TYPE;
TYPE positive_integer = nonnegative_integer;
WHERE positivity: SELF > 0;
END_TYPE;
TYPE zero_or_one = nonnegative_integer;
WHERE in_range: (SELF = 0) OR (SELF = 1);
END_TYPE;
TYPE one_or_two = positive_integer;
WHERE in_range: (SELF = 1) OR (SELF = 2);
END_TYPE;
TYPE maths_number = NUMBER;
END_TYPE;
TYPE maths_real = REAL;
END_TYPE;
TYPE maths_integer = INTEGER;
END_TYPE;
TYPE maths_logical = LOGICAL;
END_TYPE;
TYPE maths_boolean = BOOLEAN;
END_TYPE;
TYPE maths_string = STRING;
END_TYPE;
TYPE maths_binary = BINARY;
END_TYPE;

TYPE maths_simple_atom = SELECT
  (maths_number,
   maths_real,
   maths_integer,
   maths_logical,
   maths_boolean,
   maths_string,
   maths_binary);
END_TYPE;
TYPE maths_atom = SELECT
  (maths_simple_atom,
   maths_enum_atom);
END_TYPE;
TYPE atom_based_tuple = LIST OF atom_based_value;
END_TYPE;
TYPE atom_based_value = SELECT
  (maths_atom,
   atom_based_tuple);
END_TYPE;
TYPE maths_tuple = LIST [0:?] OF maths_value;
END_TYPE;
TYPE maths_value = SELECT
  (atom_based_value,
   maths_tuple,
   generic_expression);
WHERE
  constancy: NOT ('GENERIC_EXPRESSION' IN stripped_typeof(SELF)) OR
             expression_is_constant(SELF);
END_TYPE;
TYPE maths_expression = SELECT
  (atom_based_value,
   maths_tuple,
   generic_expression);
END_TYPE;
TYPE maths_function_select = SELECT
  (maths_function,
   elementary_function_enumerators);
END_TYPE;
TYPE input_selector = positive_integer;
END_TYPE;
TYPE elementary_space_enumerators = ENUMERATION OF
  (es_numbers,
   es_complex_numbers,
   es_reals,
   es_integers,
   es_logicals,
   es_booleans,
   es_strings,
   es_binarys,
   es_maths_spaces,
   es_maths_functions,
   es_generics);
END_TYPE;
TYPE ordering_type = ENUMERATION OF
  (by_rows,
   by_columns);
END_TYPE;
TYPE lower_upper = ENUMERATION OF
  (lower,
   upper);
END_TYPE;
TYPE symmetry_type = ENUMERATION OF
  (identity,
   skew,
   hermitian,
   skew_hermitian);
END_TYPE;
TYPE elementary_function_enumerators = ENUMERATION OF
  (ef_and, ef_or, ef_not, ef_xor,
   ef_negate_i, ef_add_i, ef_subtract_i, ef_multiply_i, ef_divide_i, ef_mod_i,
   ef_exponentiate_i, ef_eq_i, ef_ne_i, ef_gt_i, ef_lt_i, ef_ge_i, ef_le_i,
   ef_abs_i, ef_max_i, ef_min_i, ef_if_i,
   ef_negate_r, ef_reciprocal_r, ef_add_r, ef_subtract_r, ef_multiply_r,
   ef_divide_r, ef_mod_r, ef_exponentiate_r, ef_exponentiate_ri,
   ef_eq_r, ef_ne_r, ef_gt_r, ef_lt_r, ef_ge_r, ef_le_r, ef_abs_r,
   ef_max_r, ef_min_r, ef_acos_r, ef_asin_r, ef_atan2_r, ef_cos_r, ef_exp_r,
   ef_ln_r, ef_log2_r, ef_log10_r, ef_sin_r, ef_sqrt_r, ef_tan_r, ef_if_r,
   ef_form_c, ef_rpart_c, ef_ipart_c,
   ef_negate_c, ef_reciprocal_c, ef_add_c, ef_subtract_c, ef_multiply_c,
   ef_divide_c, ef_exponentiate_c, ef_exponentiate_ci, ef_eq_c, ef_ne_c,
   ef_conjugate_c, ef_abs_c, ef_arg_c, ef_cos_c, ef_exp_c, ef_ln_c, ef_sin_c,
   ef_sqrt_c, ef_tan_c, ef_if_c,
   ef_subscript_s, ef_eq_s, ef_ne_s, ef_gt_s, ef_lt_s, ef_ge_s, ef_le_s,
   ef_subsequence_s, ef_concat_s, ef_size_s, ef_format, ef_value, ef_like, ef_if_s,
   ef_subscript_b, ef_eq_b, ef_ne_b, ef_gt_b, ef_lt_b, ef_ge_b, ef_le_b,
   ef_subsequence_b, ef_concat_b, ef_size_b, ef_if_b,
   ef_subscript_t, ef_eq_t, ef_ne_t, ef_concat_t, ef_size_t,
   ef_entuple, ef_detuple, ef_insert, ef_remove, ef_if_t,
   ef_sum_it, ef_product_it,
   ef_add_it, ef_subtract_it, ef_scalar_mult_it, ef_dot_prod_it,
   ef_sum_rt, ef_product_rt,
   ef_add_rt, ef_subtract_rt, ef_scalar_mult_rt, ef_dot_prod_rt, ef_norm_rt,
   ef_sum_ct, ef_product_ct,
   ef_add_ct, ef_subtract_ct, ef_scalar_mult_ct, ef_dot_prod_ct, ef_norm_ct,
   ef_if, ef_ensemble, ef_member_of);
END_TYPE;
TYPE open_closed = ENUMERATION OF
  (open,
   closed);
END_TYPE;
TYPE space_constraint_type = ENUMERATION OF
  (sc_equal,
   sc_subspace,
   sc_member);
END_TYPE;
TYPE repackage_options = ENUMERATION OF
  (ro_nochange,
   ro_wrap_as_tuple,
   ro_unwrap_tuple);
END_TYPE;
TYPE extension_options = ENUMERATION OF
  (eo_none,
   eo_cont,
   eo_cont_right,
   eo_cont_left);
END_TYPE;
TYPE maths_enum_atom = SELECT
  (elementary_space_enumerators,
   ordering_type,
   lower_upper,
   symmetry_type,
   elementary_function_enumerators,
   open_closed,
   space_constraint_type,
   repackage_options,
   extension_options);
END_TYPE;
TYPE dotted_express_identifier = STRING;
WHERE syntax: dotted_identifiers_syntax(SELF);
END_TYPE;
TYPE express_identifier = dotted_express_identifier;
WHERE syntax: dot_count(SELF) = 0;
END_TYPE;
TYPE product_space = SELECT
  (uniform_product_space,
   listed_product_space);
END_TYPE;
TYPE tuple_space = EXTENSIBLE GENERIC_ENTITY SELECT
   (product_space,
   extended_tuple_space);
END_TYPE;
TYPE maths_space_or_function = SELECT
  (maths_space,
   maths_function);
END_TYPE;
TYPE real_interval = SELECT
  (real_interval_from_min,
   real_interval_to_max,
   finite_real_interval,
   elementary_space);
WHERE
  WR1: NOT ('ELEMENTARY_SPACE' IN stripped_typeof(SELF)) OR
    (SELF\elementary_space.space_id = es_reals);
END_TYPE;
ENTITY quantifier_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (multiple_arity_generic_expression);
  variables : LIST [1:?] OF UNIQUE generic_variable;
WHERE
  WR1: SIZEOF (QUERY (vrbl <* variables | NOT (vrbl IN
       SELF\multiple_arity_generic_expression.operands))) = 0;
  WR2: SIZEOF (QUERY (vrbl <* variables | NOT ((schema_prefix +
       'BOUND_VARIABLE_SEMANTICS') IN TYPEOF (vrbl.interpretation.semantics)))) = 0;
END_ENTITY;
ENTITY dependent_variable_definition
  SUBTYPE OF (unary_generic_expression);
  name        : label;
  description : text;
END_ENTITY;
ENTITY bound_variable_semantics
  SUBTYPE OF (variable_semantics);
END_ENTITY;
ENTITY free_variable_semantics
  SUBTYPE OF (variable_semantics);
END_ENTITY;
ENTITY complex_number_literal
  SUBTYPE OF (generic_literal);
  real_part : REAL;
  imag_part : REAL;
END_ENTITY;

ENTITY complex_number_literal_polar
  SUBTYPE OF (complex_number_literal);
    modulus : REAL;  
    argument : REAL; 
DERIVE
  SELF\complex_number_literal.real_part : REAL := modulus * cos(argument);
  SELF\complex_number_literal.imag_part : REAL := modulus * sin(argument);
WHERE
  WR1: modulus  >= 0;
  WR2: {0 <= argument <= 2*PI};
END_ENTITY;

ENTITY logical_literal
  SUBTYPE OF (generic_literal);
  lit_value : LOGICAL;
END_ENTITY;
ENTITY binary_literal
  SUBTYPE OF (generic_literal);
  lit_value : BINARY;
END_ENTITY;
ENTITY maths_enum_literal
  SUBTYPE OF (generic_literal);
  lit_value : maths_enum_atom;
END_ENTITY;
ENTITY real_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST [1:?] OF REAL;
END_ENTITY;
ENTITY integer_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST [1:?] OF INTEGER;
END_ENTITY;
ENTITY atom_based_literal
  SUBTYPE OF (generic_literal);
  lit_value : atom_based_value;
END_ENTITY;
ENTITY maths_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST OF maths_value;
END_ENTITY;
ENTITY maths_variable
  SUBTYPE OF (generic_variable);
  values_space : maths_space;
  name         : label;
WHERE
  WR1: expression_is_constant(values_space);
END_ENTITY;
ENTITY maths_real_variable
  SUBTYPE OF (maths_variable, real_numeric_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space,es_reals);
END_ENTITY;
ENTITY maths_integer_variable
  SUBTYPE OF (maths_variable, int_numeric_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space,es_integers);
END_ENTITY;
ENTITY maths_boolean_variable
  SUBTYPE OF (maths_variable, boolean_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space,es_booleans);
END_ENTITY;
ENTITY maths_string_variable
  SUBTYPE OF (maths_variable, string_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space,es_strings);
END_ENTITY;
ENTITY function_application
  SUBTYPE OF (multiple_arity_generic_expression);
  func      : maths_function_select;
  arguments : LIST [1:?] OF maths_expression;
DERIVE
  SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF generic_expression
    := [convert_to_maths_function(func)] + convert_to_operands(arguments);
WHERE
  WR1: function_applicability(func, arguments);
END_ENTITY;
ENTITY maths_space
  ABSTRACT SUPERTYPE OF (ONEOF (elementary_space,
                                finite_integer_interval,
                                integer_interval_from_min,
                                integer_interval_to_max,
                                finite_real_interval,
                                real_interval_from_min,
                                real_interval_to_max,
                                cartesian_complex_number_region,
                                polar_complex_number_region,
                                finite_space,
                                uniform_product_space,
                                listed_product_space,
                                extended_tuple_space,
                                function_space))
  SUBTYPE OF (generic_expression);
END_ENTITY;
ENTITY elementary_space
  SUBTYPE OF (maths_space, generic_literal);
  space_id : elementary_space_enumerators;
END_ENTITY;
ENTITY finite_integer_interval
  SUBTYPE OF (maths_space, generic_literal);
  min  : INTEGER;
  max  : INTEGER;
DERIVE
  size : positive_integer := max - min + 1;
WHERE
  WR1: min <= max;
END_ENTITY;
ENTITY integer_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min : INTEGER;
END_ENTITY;
ENTITY integer_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max : INTEGER;
END_ENTITY;
ENTITY finite_real_interval
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
  max         : REAL;
  max_closure : open_closed;
WHERE
  WR1: min < max;
END_ENTITY;
ENTITY real_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
END_ENTITY;
ENTITY real_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max         : REAL;
  max_closure : open_closed;
END_ENTITY;
ENTITY cartesian_complex_number_region
  SUBTYPE OF (maths_space, generic_literal);
  real_constraint : real_interval;
  imag_constraint : real_interval;
WHERE
  WR1: min_exists(real_constraint) OR max_exists(real_constraint) OR
       min_exists(imag_constraint) OR max_exists(imag_constraint);
END_ENTITY;
ENTITY polar_complex_number_region
  SUBTYPE OF (maths_space, generic_literal);
  centre               : complex_number_literal;
  distance_constraint  : real_interval;
  direction_constraint : finite_real_interval;
WHERE
  WR1: min_exists(distance_constraint) AND (real_min(distance_constraint) >= 0.0);
  WR2: {-PI <= direction_constraint.min < PI};
  WR3: direction_constraint.max - direction_constraint.min <= 2.0*PI;
  WR4: (direction_constraint.max - direction_constraint.min < 2.0*PI) OR
       (direction_constraint.min_closure = open);
  WR5: (direction_constraint.max - direction_constraint.min < 2.0*PI) OR
       (direction_constraint.max_closure = open) OR
       (direction_constraint.min = -PI);
  WR6: (real_min(distance_constraint) > 0.0) OR max_exists(distance_constraint) OR
       (direction_constraint.max - direction_constraint.min < 2.0*PI) OR
       (direction_constraint.max_closure = open);
END_ENTITY;
ENTITY finite_space
  SUBTYPE OF (maths_space, generic_literal);
  members : SET OF maths_value;
WHERE
  WR1: VALUE_UNIQUE(members);
  WR2: SIZEOF (QUERY (expr <* QUERY (member <* members |
       'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.GENERIC_EXPRESSION' IN TYPEOF (member))
       | NOT expression_is_constant(expr))) = 0;
  WR3: no_cyclic_space_reference(SELF, []);
END_ENTITY;
ENTITY uniform_product_space
  SUBTYPE OF (maths_space, generic_literal);
  base     : maths_space;
  exponent : positive_integer;
WHERE
  WR1: expression_is_constant(base);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: base <> the_empty_space;
END_ENTITY;
ENTITY listed_product_space
  SUBTYPE OF (maths_space, generic_literal);
  factors : LIST OF maths_space;
WHERE
  WR1: SIZEOF (QUERY (space <* factors |
       NOT (expression_is_constant(space)))) = 0;
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: NOT (the_empty_space IN factors);
END_ENTITY;
ENTITY extended_tuple_space
   SUBTYPE OF (maths_space, generic_literal);
   base : tuple_space;
  extender : maths_space;
WHERE
  WR1: expression_is_constant(base) AND
       expression_is_constant(extender);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: extender <> the_empty_space;
END_ENTITY;
ENTITY function_space
  SUBTYPE OF (maths_space, generic_literal);
  domain_constraint : space_constraint_type;
  domain_argument  : maths_space;
  range_constraint : space_constraint_type;
  range_argument   : maths_space;
WHERE
  WR1: expression_is_constant(domain_argument) AND
       expression_is_constant(range_argument);
  WR2: (domain_argument <> the_empty_space) AND
       (range_argument <> the_empty_space);
  WR3: (domain_constraint <> sc_member) OR NOT
       member_of(the_empty_space,domain_argument);
  WR4: (range_constraint <> sc_member) OR NOT
       member_of(the_empty_space,range_argument);
  WR5: NOT (any_space_satisfies(domain_constraint,domain_argument) AND
       any_space_satisfies(range_constraint,range_argument));
END_ENTITY;
ENTITY maths_function
  ABSTRACT SUPERTYPE OF (ONEOF (finite_function,
                                constant_function,
                                selector_function,
                                elementary_function,
                                restriction_function,
                                repackaging_function,
                                reindexed_array_function,
                                series_composed_function,
                                parallel_composed_function,
                                explicit_table_function,
                                homogeneous_linear_function,
                                general_linear_function,
                                b_spline_basis,
                                b_spline_function,
                                rationalize_function,
                                partial_derivative_function,
                                definite_integral_function,
                                abstracted_expression_function,
                                expression_denoted_function,
                                imported_point_function,
                                imported_curve_function,
                                imported_surface_function,
                                imported_volume_function,
                                application_defined_function))
  SUBTYPE OF (generic_expression);
DERIVE
  domain : tuple_space := derive_function_domain(SELF);
  range : tuple_space := derive_function_range(SELF);
END_ENTITY;
ENTITY finite_function
  SUBTYPE OF (maths_function, generic_literal);
  pairs : SET [1:?] OF LIST [2:2] OF maths_value;
WHERE
  WR1: VALUE_UNIQUE(list_selected_components(pairs, 1));
END_ENTITY;
ENTITY constant_function
  SUBTYPE OF (maths_function, generic_literal);
  sole_output      : maths_value;
  source_of_domain : maths_space_or_function;
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
END_ENTITY;
ENTITY selector_function
  SUBTYPE OF (maths_function, generic_literal);
  selector : input_selector;
  source_of_domain : maths_space_or_function;
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
END_ENTITY;
ENTITY elementary_function
  SUBTYPE OF (maths_function, generic_literal);
  func_id : elementary_function_enumerators;
END_ENTITY;
ENTITY restriction_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_space;
END_ENTITY;
ENTITY repackaging_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  input_repack    : repackage_options;
  output_repack   : repackage_options;
  selected_output : nonnegative_integer;
WHERE
  WR1: (input_repack <> ro_wrap_as_tuple) OR
       ((space_dimension(operand.domain) = 1) AND
         ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF (factor1(operand.domain))));
  WR2: (output_repack <> ro_unwrap_tuple) OR
       ((space_dimension(operand.range) = 1) AND
         ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF (factor1(operand.range))));
  WR3: selected_output <= space_dimension( repackage(
       operand.range, output_repack));
END_ENTITY;
ENTITY reindexed_array_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  starting_indices : LIST [1:?] OF INTEGER;
WHERE
  WR1: function_is_array(SELF\unary_generic_expression.operand);
  WR2: SIZEOF(starting_indices) = SIZEOF(shape_of_array(
       SELF\unary_generic_expression.operand));
END_ENTITY;
ENTITY series_composed_function
  SUBTYPE OF (maths_function, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [2:?] of maths_function;
WHERE
  WR1: composable_sequence(SELF\multiple_arity_generic_expression.operands);
END_ENTITY;
ENTITY parallel_composed_function
  SUBTYPE OF (maths_function, multiple_arity_generic_expression);
  source_of_domain  : maths_space_or_function;
  prep_functions : LIST [1:?] OF maths_function;
  final_function : maths_function_select;
DERIVE
  SELF\multiple_arity_generic_expression.operands : LIST [2:?] of generic_expression
    := convert_to_operands_prcmfn(source_of_domain, prep_functions, final_function);
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
  WR3: parallel_composed_function_domain_check(domain_from(source_of_domain),
       prep_functions);
  WR4: parallel_composed_function_composability_check(prep_functions, final_function);
END_ENTITY;
ENTITY explicit_table_function
  ABSTRACT SUPERTYPE OF (ONEOF (listed_real_data,
                                listed_integer_data,
                                listed_logical_data,
                                listed_string_data,
                                listed_complex_number_data,
                                listed_data,
                                externally_listed_data,
                                linearized_table_function,
                                basic_sparse_matrix))
  SUBTYPE OF (maths_function);
  index_base : zero_or_one;
  shape      : LIST [1:?] OF positive_integer;
END_ENTITY;
ENTITY listed_real_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1:?] OF REAL;
DERIVE
  self\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
END_ENTITY;
ENTITY listed_integer_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1:?] OF INTEGER;
DERIVE
  self\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
END_ENTITY;
ENTITY listed_logical_data
  SUBTYPE OF(explicit_table_function, generic_literal);
  values : LIST [1:?] OF LOGICAL;
DERIVE
  self\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
END_ENTITY;
ENTITY listed_string_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1:?] OF STRING;
DERIVE
  self\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
END_ENTITY;
ENTITY listed_complex_number_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [2:?] OF REAL;
DERIVE
      SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer := [ SIZEOF(values) DIV 2 ];
WHERE
      WR1:
         NOT ODD(SIZEOF(values));
END_ENTITY;
ENTITY listed_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values      : LIST [1:?] OF maths_value;
  value_range : maths_space;
DERIVE
  SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
WHERE
  WR1: expression_is_constant(value_range);
  WR2: SIZEOF (QUERY (val <* values | NOT (member_of( val, value_range)))) = 0;
END_ENTITY;
ENTITY externally_listed_data
  SUBTYPE OF (explicit_table_function, generic_literal, externally_defined_item);
  value_range : maths_space;
WHERE
  WR1: expression_is_constant(value_range);
END_ENTITY;
ENTITY linearized_table_function
  SUPERTYPE OF (ONEOF (standard_table_function,
                       regular_table_function,
                       triangular_matrix,
                       symmetric_matrix,
                       banded_matrix))
  SUBTYPE OF (explicit_table_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  first  : integer;
DERIVE
  source : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_1d_array(source);
  WR2: member_of(first, source\maths_function.domain);
END_ENTITY;
ENTITY standard_table_function
  SUBTYPE OF (linearized_table_function);
  order : ordering_type;
WHERE
  WR1: extremal_position_check(SELF);
END_ENTITY;
ENTITY regular_table_function
  SUBTYPE OF (linearized_table_function);
  increments : LIST [1:?] OF INTEGER;
WHERE
  WR1: SIZEOF (increments) = SIZEOF (self\explicit_table_function.shape);
  WR2: extremal_position_check(self);
END_ENTITY;
ENTITY triangular_matrix
  SUBTYPE OF (linearized_table_function);
  default_entry : maths_value;
  lo_up         : lower_upper;
  order         : ordering_type;
WHERE
  WR1: SIZEOF (SELF\explicit_table_function.shape) = 2;
  WR2: member_of(default_entry, SELF\maths_function.range);
END_ENTITY;
ENTITY strict_triangular_matrix
  SUBTYPE OF (triangular_matrix);
  main_diagonal_value : maths_value;
END_ENTITY;
ENTITY symmetric_matrix
  SUBTYPE OF (linearized_table_function);
  symmetry : symmetry_type;
  triangle : lower_upper;
  order    : ordering_type;
WHERE
  WR1: SIZEOF (SELF\explicit_table_function.shape) = 2;
  WR2: SELF\explicit_table_function.shape[1] =
       SELF\explicit_table_function.shape[2];
  WR3: NOT (symmetry = symmetry_type.skew) OR (
       (space_dimension(SELF\linearized_table_function.source.range) = 1) AND
        subspace_of_es(factor1(SELF\linearized_table_function.source.range),
        es_numbers));
  WR4: NOT ((symmetry = symmetry_type.hermitian) OR (symmetry = symmetry_type.skew_hermitian)) OR (
       (space_dimension(SELF\linearized_table_function.source.range) = 1) AND
        subspace_of_es(factor1(SELF\linearized_table_function.source.range),
        es_complex_numbers));
END_ENTITY;
ENTITY symmetric_banded_matrix
  SUBTYPE OF (symmetric_matrix);
  default_entry : maths_value;
  above         : nonnegative_integer;
WHERE
  WR1: member_of(default_entry,
       factor1(SELF\linearized_table_function.source.range));
END_ENTITY;
ENTITY banded_matrix
  SUBTYPE OF (linearized_table_function);
  default_entry : maths_value;
  below         : integer;
  above         : integer;
  order         : ordering_type;
WHERE
  WR1: SIZEOF (self\explicit_table_function.shape) = 2;
  WR2: -below <= above;
  WR3: member_of(default_entry,
       factor1(SELF\linearized_table_function.source.range));
END_ENTITY;
ENTITY basic_sparse_matrix
  SUBTYPE OF (explicit_table_function, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [3:3] OF maths_function;
  default_entry : maths_value;
  order : ordering_type;
DERIVE
  index : maths_function := SELF\multiple_arity_generic_expression.operands[1];
  loc   : maths_function := SELF\multiple_arity_generic_expression.operands[2];
  val   : maths_function := SELF\multiple_arity_generic_expression.operands[3];
WHERE
  WR1: function_is_1d_table(index);
  WR2: function_is_1d_table(loc);
  WR3: function_is_1d_table(val);
  WR4: check_sparse_index_domain(index.domain, index_base, shape, order);
  WR5: check_sparse_index_to_loc(index.range, loc.domain);
  WR6: loc.domain = val.domain;
  WR7: check_sparse_loc_range(loc.range, index_base, shape, order);
  WR8: member_of(default_entry, val.range);
END_ENTITY;
ENTITY homogeneous_linear_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  sum_index : one_or_two;
DERIVE
  mat       : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_2d_table(mat);
  WR2: (space_dimension(mat.range) = 1) AND
       subspace_of_es(factor1(mat.range),es_numbers);
END_ENTITY;
ENTITY general_linear_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  sum_index : one_or_two;
DERIVE
  mat       : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_2d_table(mat);
  WR2: (space_dimension(mat.range) = 1) AND
       subspace_of_es(factor1(mat.range),es_numbers);
END_ENTITY;
ENTITY b_spline_basis
  SUBTYPE OF (maths_function, generic_literal);
  degree         : nonnegative_integer;
  repeated_knots : LIST [2:?] OF REAL;
DERIVE
  order          : positive_integer := degree + 1;
  num_basis      : positive_integer := SIZEOF (repeated_knots) - order;
WHERE
  WR1: num_basis >= order;
  WR2: nondecreasing(repeated_knots);
  WR3: repeated_knots[order] < repeated_knots[num_basis+1];
END_ENTITY;
ENTITY b_spline_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  basis : LIST [1:?] OF b_spline_basis;
DERIVE
  coef  : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_table(coef);
  WR2: (space_dimension(coef.range) = 1) AND
       (number_superspace_of(factor1(coef.range)) = the_reals);
  WR3: SIZEOF (basis) <=
       SIZEOF (shape_of_array(coef));
  WR4: compare_basis_and_coef(basis, coef);
END_ENTITY;
ENTITY rationalize_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
DERIVE
  fun : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: (space_dimension(fun.domain) = 1) AND (space_dimension(fun.range) = 1);
  WR2: number_tuple_subspace_check(factor1(fun.range));
  WR3: space_dimension(factor1(fun.range)) > 1;
END_ENTITY;
ENTITY partial_derivative_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  d_variables : LIST [1:?] OF input_selector;
  extension : extension_options;
DERIVE
  derivand : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: space_is_continuum (derivand.range);
  WR2: partial_derivative_check (derivand.domain, d_variables);
END_ENTITY;
ENTITY partial_derivative_expression
  SUBTYPE OF (unary_generic_expression);
  d_variables : LIST [1:?] OF maths_variable;
  extension : extension_options;
DERIVE
  derivand : generic_expression := SELF\unary_generic_expression.operand;
WHERE
  WR1: has_values_space (derivand);
  WR2: space_is_continuum (values_space_of (derivand));
  WR3: SIZEOF (QUERY (vbl <* d_variables | (NOT subspace_of (values_space_of (vbl),
    the_reals)) AND (NOT subspace_of (values_space_of (vbl), the_complex_numbers))
    )) = 0;
END_ENTITY;
ENTITY definite_integral_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  variable_of_integration : input_selector;
  lower_limit_neg_infinity : BOOLEAN;
  upper_limit_pos_infinity : BOOLEAN;
DERIVE
  integrand : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: space_is_continuum (integrand.range);
  WR2: definite_integral_check (integrand.domain, variable_of_integration,
    lower_limit_neg_infinity, upper_limit_pos_infinity);
END_ENTITY;
ENTITY definite_integral_expression
  SUBTYPE OF (quantifier_expression);
  lower_limit_neg_infinity : BOOLEAN;
  upper_limit_pos_infinity : BOOLEAN;
DERIVE
  integrand : generic_expression
    := SELF\multiple_arity_generic_expression.operands[1];
  variable_of_integration : maths_variable
    := SELF\multiple_arity_generic_expression.operands[2];
  SELF\quantifier_expression.variables : LIST [1:1] OF UNIQUE generic_variable
    := [variable_of_integration];
WHERE
  WR1: has_values_space (integrand);
  WR2: space_is_continuum (values_space_of (integrand));
  WR3: definite_integral_expr_check (SELF\multiple_arity_generic_expression.operands,
    lower_limit_neg_infinity, upper_limit_pos_infinity);
END_ENTITY;
ENTITY abstracted_expression_function
  SUBTYPE OF (maths_function, quantifier_expression);
DERIVE
  SELF\quantifier_expression.variables : LIST [1:?] OF UNIQUE generic_variable :=
    remove_first(SELF\multiple_arity_generic_expression.operands);
  expr : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
WHERE
  WR1: SIZEOF (QUERY ( operand <*
       SELF\multiple_arity_generic_expression.operands | NOT (
       has_values_space( operand)))) = 0;
END_ENTITY;
ENTITY expression_denoted_function
  SUBTYPE OF (maths_function, unary_generic_expression);
DERIVE
  expr : generic_expression := SELF\unary_generic_expression.operand;
WHERE
  WR1: (schema_prefix + 'FUNCTION_SPACE') IN TYPEOF (values_space_of(expr));
END_ENTITY;
ENTITY imported_point_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry : point;
END_ENTITY;
ENTITY imported_curve_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : curve;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;
ENTITY imported_surface_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : surface;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;
ENTITY imported_volume_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : volume;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;
ENTITY application_defined_function
  SUBTYPE OF (maths_function);
  explicit_domain : tuple_space;
  explicit_range  : tuple_space;
  parameters      : LIST OF maths_value;
WHERE
  WR1: expression_is_constant(explicit_domain);
  WR2: expression_is_constant(explicit_range);
END_ENTITY;
ENTITY mathematical_description;
  described  : maths_expression;
  describing : STRING;
  encoding   : label;
END_ENTITY;
FUNCTION all_members_of_es(sv : SET OF maths_value;
                           es : elementary_space_enumerators) : LOGICAL;
  CONSTANT
    base_types : SET OF STRING := ['NUMBER','COMPLEX_NUMBER_LITERAL','REAL',
      'INTEGER','LOGICAL','BOOLEAN','STRING','BINARY','MATHS_SPACE',
      'MATHS_FUNCTION','LIST','ELEMENTARY_SPACE_ENUMERATORS','ORDERING_TYPE',
      'LOWER_UPPER','SYMMETRY_TYPE','ELEMENTARY_FUNCTION_ENUMERATORS',
      'OPEN_CLOSED','SPACE_CONSTRAINT_TYPE','REPACKAGE_OPTIONS',
      'EXTENSION_OPTIONS'];
  END_CONSTANT;
  LOCAL
    v : maths_value;
    key_type : STRING := '';
    types : SET OF STRING;
    ge : generic_expression;
    cum : LOGICAL := TRUE;
    vspc : maths_space;
  END_LOCAL;
  IF NOT EXISTS (sv) OR NOT EXISTS (es) THEN  RETURN (FALSE);  END_IF;
  CASE es OF
  es_numbers :         key_type := 'NUMBER';
  es_complex_numbers : key_type := 'COMPLEX_NUMBER_LITERAL';
  es_reals :           key_type := 'REAL';
  es_integers :        key_type := 'INTEGER';
  es_logicals :        key_type := 'LOGICAL';
  es_booleans :        key_type := 'BOOLEAN';
  es_strings :         key_type := 'STRING';
  es_binarys :         key_type := 'BINARY';
  es_maths_spaces :    key_type := 'MATHS_SPACE';
  es_maths_functions : key_type := 'MATHS_FUNCTION';
  es_generics :        RETURN (TRUE);
  END_CASE;
  REPEAT i := 1 TO SIZEOF (sv);
    IF NOT EXISTS (sv[i]) THEN  RETURN (FALSE);  END_IF;
    v := simplify_maths_value(sv[i]);
    types := stripped_typeof(v);
    IF key_type IN types THEN  SKIP;  END_IF;
    IF (es = es_numbers) AND ('COMPLEX_NUMBER_LITERAL' IN types) THEN  SKIP;  END_IF;
    IF SIZEOF (base_types * types) > 0 THEN  RETURN (FALSE);  END_IF;
    -- Must be a generic_expression which doesn't simplify and which is not a
    -- complex_number_literal, maths_space, or maths_function.
    ge := v;
    IF has_values_space(ge) THEN
      vspc := values_space_of(ge);
      IF NOT subspace_of_es(vspc,es) THEN
        IF NOT compatible_spaces(vspc,make_elementary_space(es)) THEN
          RETURN (FALSE);
        END_IF;
        cum := UNKNOWN;
      END_IF;
    ELSE
      cum := UNKNOWN;
    END_IF;
    IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (cum);
END_FUNCTION;  -- all_members_of_es
FUNCTION any_space_satisfies(sc  : space_constraint_type;
                             spc : maths_space) : BOOLEAN;
  LOCAL
    spc_id : elementary_space_enumerators;
  END_LOCAL;
  IF (sc = sc_equal) OR NOT ('ELEMENTARY_SPACE' IN stripped_typeof(spc)) THEN
    RETURN (FALSE);
  END_IF;
  spc_id := spc\elementary_space.space_id;
  IF sc = sc_subspace THEN
    RETURN (bool(spc_id = es_generics));
  END_IF;
  IF sc = sc_member THEN
    RETURN (bool((spc_id = es_generics) OR (spc_id = es_maths_spaces)));
  END_IF;
  -- Should be unreachable.
  RETURN (?);
END_FUNCTION;  -- any_space_satisfies
FUNCTION assoc_product_space(ts1, ts2 : tuple_space) : tuple_space;
  LOCAL
    types1 : SET OF STRING := stripped_typeof (ts1);
    types2 : SET OF STRING := stripped_typeof (ts2);
    up1, up2 : uniform_product_space := make_uniform_product_space(the_reals,1);
    lp1, lp2, lps : listed_product_space := the_zero_tuple_space;
    et1, et2, ets : extended_tuple_space := the_tuples;
    use_up1, use_up2, use_lp1, use_lp2 : BOOLEAN;
    factors : LIST OF maths_space := [];
    tspace : tuple_space;
  END_LOCAL;
  -- Identify type of first operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types1 THEN
    up1 := ts1;  use_up1 := true;  use_lp1 := false;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types1 THEN
      lp1 := ts1;  use_up1 := false;  use_lp1 := true;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types1) THEN
        -- Unreachable when this function was written.
        RETURN (?);
      END_IF;
      et1 := ts1;  use_up1 := false;  use_lp1 := false;
    END_IF;
  END_IF;
  -- Identify type of second operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
    up2 := ts2;  use_up2 := true;  use_lp2 := false;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      lp2 := ts2;  use_up2 := false;  use_lp2 := true;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types2) THEN
        -- Unreachable when this function was written.
        RETURN (?);
      END_IF;
      et2 := ts2;  use_up2 := false;  use_lp2 := false;
    END_IF;
  END_IF;
  -- Construction for each combination of cases
  IF use_up1 THEN
    IF use_up2 THEN
      IF up1.base = up2.base THEN
        tspace := make_uniform_product_space(up1.base, up1.exponent + up2.exponent);
      ELSE
        factors := [up1.base : up1.exponent, up2.base : up2.exponent];
        tspace := make_listed_product_space(factors);
      END_IF;
    ELSE
      IF use_lp2 THEN
        -- Avoid compiler confusion by breaking into two lines.
        factors := [up1.base : up1.exponent];
        factors := factors + lp2.factors;
        tspace := make_listed_product_space(factors);
      ELSE
        tspace := assoc_product_space(up1, et2.base);
        tspace := make_extended_tuple_space(tspace, et2.extender);
      END_IF;
    END_IF;
  ELSE
    IF use_lp1 THEN
      IF use_up2 THEN
        -- Avoid compiler confusion by breaking into two lines.
        factors := [up2.base : up2.exponent];
        factors := lp1.factors + factors;
        tspace := make_listed_product_space(factors);
      ELSE
        IF use_lp2 THEN
          tspace := make_listed_product_space(lp1.factors + lp2.factors);
        ELSE
          tspace := assoc_product_space(lp1, et2.base);
          tspace := make_extended_tuple_space(tspace, et2.extender);
        END_IF;
      END_IF;
    ELSE
      IF use_up2 THEN
        IF et1.extender = up2.base THEN
          tspace := assoc_product_space(et1.base, up2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          -- No subtype is available to represent this cartesian product.
          RETURN (?);
        END_IF;
      ELSE
        IF use_lp2 THEN
          factors := lp2.factors;
          REPEAT i := 1 TO SIZEOF (factors);
            IF et1.extender <> factors[i] THEN
              -- No subtype available to represent this cartesian product.
              RETURN (?);
            END_IF;
          END_REPEAT;
          tspace := assoc_product_space(et1.base, lp2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          IF et1.extender = et2.extender THEN
            -- Next line may assign indeterminate (?) to tspace.
            tspace := assoc_product_space(et1, et2.base);
          ELSE
            -- No subtype available to represent this cartesian product.
            RETURN (?);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (tspace);
END_FUNCTION;  -- assoc_product_space
FUNCTION atan2(y, x : REAL) : REAL;
  LOCAL
    r : REAL;
  END_LOCAL;
  IF (y = 0.0) AND (x = 0.0) THEN  RETURN (?);  END_IF;
  r := atan(y,x);
  IF x < 0.0 THEN
    IF y < 0.0 THEN  r := r - PI;
    ELSE             r := r + PI;  END_IF;
  END_IF;
  RETURN (r);
END_FUNCTION;  -- atan2
FUNCTION bool(lgcl: LOGICAL) : BOOLEAN;
  IF NOT EXISTS (lgcl) THEN  RETURN (FALSE);  END_IF;
  IF lgcl <> TRUE      THEN  RETURN (FALSE);  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- bool
FUNCTION check_sparse_index_domain(idxdom : tuple_space;
                                   base   : zero_or_one;
                                   shape  : LIST [1:?] OF positive_integer;
                                   order  : ordering_type) : BOOLEAN;
  LOCAL
    mthspc : maths_space;
    interval : finite_integer_interval;
    i : INTEGER;
  END_LOCAL;
  mthspc := factor1(idxdom);
  -- A consequence of WR1 of basic_sparse_matrix is that here we need only
  -- consider the case that mthspc is a finite integer interval and is the only
  -- factor space of idxdom.
  interval := mthspc;
  IF order = by_rows THEN  i := 1;  ELSE  i := 2;  END_IF;
  RETURN (bool((interval.min <= base) AND (interval.max >= base + shape[i])));
  -- The index function is evaluated at (base+shape[i]) when determining the
  -- upper search bound for entries of the last row or column, respectively.
END_FUNCTION;  -- check_sparse_index_domain;
FUNCTION check_sparse_loc_range(locrng : tuple_space;
                                base   : zero_or_one;
                                shape  : LIST [1:?] OF positive_integer;
                                order  : ordering_type) : BOOLEAN;
  LOCAL
    mthspc : maths_space;
    interval : finite_integer_interval;
    i : INTEGER;
  END_LOCAL;
  IF space_dimension(locrng) <> 1 THEN  RETURN (FALSE);  END_IF;
  mthspc := factor1(locrng);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (mthspc)) THEN
    RETURN (FALSE);
  END_IF;
  interval := mthspc;
  IF order = by_rows THEN  i := 2;  ELSE  i := 1;  END_IF;
  RETURN (bool((interval.min >= base) AND (interval.max <= base + shape[i] - 1)));
END_FUNCTION;  -- check_sparse_loc_range;
FUNCTION check_sparse_index_to_loc(index_range, loc_domain : tuple_space) : BOOLEAN;
  LOCAL
    temp : maths_space;
    idx_rng_itvl, loc_dmn_itvl : finite_integer_interval;
  END_LOCAL;
  temp := factor1 (index_range);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (temp) THEN
    temp := factor1 (temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  idx_rng_itvl := temp;
  temp := factor1 (loc_domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (temp) THEN
    temp := factor1 (temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  loc_dmn_itvl := temp;
  RETURN (bool((loc_dmn_itvl.min <= idx_rng_itvl.min) AND
    (idx_rng_itvl.max <= loc_dmn_itvl.max+1)));
END_FUNCTION;  -- check_sparse_index_to_loc
FUNCTION compare_basis_and_coef(basis : LIST [1:?] OF b_spline_basis;
                                coef  : maths_function) : BOOLEAN;
  LOCAL
    shape : LIST OF positive_integer;
  END_LOCAL;
  IF NOT EXISTS (basis) OR NOT EXISTS (coef) THEN  RETURN (FALSE);  END_IF;
  shape := shape_of_array(coef);
  IF NOT EXISTS (shape) THEN  RETURN (FALSE);  END_IF;
  IF SIZEOF (shape) < SIZEOF (basis) THEN  RETURN (FALSE);  END_IF;
  REPEAT i := 1 TO SIZEOF (basis);
    IF (basis[i].num_basis = shape[i]) <> TRUE THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- compare_basis_and_coef
FUNCTION compare_list_and_value(lv : LIST OF GENERIC:G;
                                op : elementary_function_enumerators;
                                v  : GENERIC:G) : BOOLEAN;
  IF NOT EXISTS (lv) OR NOT EXISTS (op) OR NOT EXISTS (v) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO SIZEOF (lv);
    IF NOT compare_values(lv[i], op, v) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- compare_list_and_value
FUNCTION compare_values(v1 : GENERIC:G;
                        op : elementary_function_enumerators;
                        v2 : GENERIC:G) : BOOLEAN;
  -- This algorithm assumes a comparison between "incompatible" types will
  -- produce the indeterminate value (or UNKNOWN?).
  LOCAL
    logl : LOGICAL := UNKNOWN;
  END_LOCAL;
  IF NOT EXISTS (v1) OR NOT EXISTS (op) OR NOT EXISTS (v2) THEN
    RETURN (FALSE);
  END_IF;
  CASE op OF
  ef_eq_i : logl := (v1 = v2);
  ef_ne_i : logl := (v1 <> v2);
  ef_gt_i : logl := (v1 > v2);
  ef_lt_i : logl := (v1 < v2);
  ef_ge_i : logl := (v1 >= v2);
  ef_le_i : logl := (v1 <= v2);
  END_CASE;
  IF EXISTS (logl) THEN
    IF logl = TRUE THEN  RETURN (TRUE);  END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- compare_values
FUNCTION compatible_complex_number_regions(sp1, sp2 : maths_space) : BOOLEAN;
  LOCAL
    typenames : SET OF string := stripped_typeof (sp1);
    crgn1, crgn2 : cartesian_complex_number_region;
    prgn1, prgn2, prgn1c2, prgn2c1 : polar_complex_number_region;
    sp1_is_crgn, sp2_is_crgn : BOOLEAN;
  END_LOCAL;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames THEN
    sp1_is_crgn := TRUE;
    crgn1 := sp1;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN
      sp1_is_crgn := FALSE;
      prgn1 := sp1;
    ELSE
      -- Improper usage: Default response is to assume compatibility.
      RETURN (TRUE);
    END_IF;
  END_IF;
  typenames := stripped_typeof (sp2);
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames THEN
    sp2_is_crgn := TRUE;
    crgn2 := sp2;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN
      sp2_is_crgn := FALSE;
      prgn2 := sp2;
    ELSE
      -- Improper usage: Default response is to assume compatibility.
      RETURN (TRUE);
    END_IF;
  END_IF;
  IF sp1_is_crgn AND sp2_is_crgn THEN
    -- two cartesian regions
    RETURN (compatible_intervals(crgn1.real_constraint, crgn2.real_constraint)
      AND compatible_intervals(crgn1.imag_constraint, crgn2.imag_constraint));
  END_IF;
  IF NOT sp1_is_crgn AND NOT sp2_is_crgn AND
    (prgn1.centre.real_part = prgn2.centre.real_part) AND
    (prgn1.centre.imag_part = prgn2.centre.imag_part) THEN
    -- two polar regions with common centre
    IF NOT compatible_intervals(prgn1.distance_constraint,
      prgn2.distance_constraint) THEN
      RETURN (FALSE);
    END_IF;
    IF compatible_intervals(prgn1.direction_constraint,
      prgn2.direction_constraint) THEN
      RETURN (TRUE);
    END_IF;
    -- Deal with direction ambiguity by 2 pi.
    IF (prgn1.direction_constraint.max > PI) AND (prgn2.direction_constraint.max < PI)
      THEN
      RETURN (compatible_intervals(prgn2.direction_constraint,
        make_finite_real_interval(-PI,open,prgn1.direction_constraint.max-2.0*PI,
        prgn1.direction_constraint.max_closure)));
    END_IF;
    IF (prgn2.direction_constraint.max > PI) AND (prgn1.direction_constraint.max < PI)
      THEN
      RETURN (compatible_intervals(prgn1.direction_constraint,
        make_finite_real_interval(-PI,open,prgn2.direction_constraint.max-2.0*PI,
        prgn2.direction_constraint.max_closure)));
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Make do with imperfect tests for remaining cases.
  IF sp1_is_crgn AND NOT sp2_is_crgn THEN
    crgn2 := enclose_pregion_in_cregion(prgn2);
    prgn1 := enclose_cregion_in_pregion(crgn1,prgn2.centre);
    RETURN (compatible_complex_number_regions(crgn1,crgn2)
      AND compatible_complex_number_regions(prgn1,prgn2));
  END_IF;
  IF NOT sp1_is_crgn AND sp2_is_crgn THEN
    crgn1 := enclose_pregion_in_cregion(prgn1);
    prgn2 := enclose_cregion_in_pregion(crgn2,prgn1.centre);
    RETURN (compatible_complex_number_regions(crgn1,crgn2)
      AND compatible_complex_number_regions(prgn1,prgn2));
  END_IF;
  -- Two polar regions with different centres
  prgn1c2 := enclose_pregion_in_pregion(prgn1,prgn2.centre);
  prgn2c1 := enclose_pregion_in_pregion(prgn2,prgn1.centre);
  RETURN (compatible_complex_number_regions(prgn1,prgn2c1)
    AND compatible_complex_number_regions(prgn1c2,prgn2));
END_FUNCTION;  -- compatible_complex_number_regions
FUNCTION compatible_es_values(esval1, esval2 : elementary_space_enumerators) : BOOLEAN;
  LOCAL
    esval1_is_numeric, esval2_is_numeric : LOGICAL;
  END_LOCAL;
  IF (esval1 = esval2) OR (esval1 = es_generics) OR (esval2 = es_generics) THEN
    RETURN (TRUE);
  END_IF;
  esval1_is_numeric := (esval1 >= es_numbers) AND (esval1 <= es_integers);
  esval2_is_numeric := (esval2 >= es_numbers) AND (esval2 <= es_integers);
  IF (esval1_is_numeric AND (esval2 = es_numbers)) OR
    (esval2_is_numeric AND (esval1 = es_numbers)) THEN
    RETURN (TRUE);
  END_IF;
  IF esval1_is_numeric XOR esval2_is_numeric THEN
    RETURN (FALSE);
  END_IF;
  IF ((esval1 = es_logicals) AND (esval2 = es_booleans)) OR
    ((esval1 = es_booleans) AND (esval2 = es_logicals)) THEN
    RETURN (TRUE);
  END_IF;
  -- All other cases are incompatible
  RETURN (FALSE);
END_FUNCTION;  -- compatible_es_values
FUNCTION compatible_intervals(sp1, sp2 : maths_space) : BOOLEAN;
  LOCAL
    amin, amax : REAL;
  END_LOCAL;
  IF min_exists(sp1) AND max_exists(sp2) THEN
    amin := real_min(sp1);  amax := real_max(sp2);
    IF amin > amax THEN  RETURN (FALSE);  END_IF;
    IF amin = amax THEN
      RETURN (min_included(sp1) AND max_included(sp2));
    END_IF;
  END_IF;
  IF min_exists(sp2) AND max_exists(sp1) THEN
    amin := real_min(sp2);  amax := real_max(sp1);
    IF amin > amax THEN  RETURN (FALSE);  END_IF;
    IF amin = amax THEN
      RETURN (min_included(sp2) AND max_included(sp1));
    END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- compatible_intervals
FUNCTION compatible_spaces(sp1, sp2 : maths_space) : BOOLEAN;
  LOCAL
    types1 : SET OF STRING := stripped_typeof (sp1);
    types2 : SET OF STRING := stripped_typeof (sp2);
    lgcl : LOGICAL := UNKNOWN;
    m, n : INTEGER;
    s1, s2 : maths_space;
  END_LOCAL;
  IF 'FINITE_SPACE' IN types1 THEN
    REPEAT i := 1 TO SIZEOF (sp1\finite_space.members);
      lgcl := member_of(sp1\finite_space.members[i], sp2);
      IF lgcl <> FALSE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types2 THEN
    REPEAT i := 1 TO SIZEOF (sp2\finite_space.members);
      lgcl := member_of(sp2\finite_space.members[i], sp1);
      IF lgcl <> FALSE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (FALSE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1 THEN
    IF sp1\elementary_space.space_id = es_generics THEN
      RETURN (TRUE);
    END_IF;
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id,
        sp2\elementary_space.space_id));
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types2) OR
      ('INTEGER_INTERVAL_FROM_MIN' IN types2) OR
      ('INTEGER_INTERVAL_TO_MAX' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR
      ('REAL_INTERVAL_FROM_MIN' IN types2) OR
      ('REAL_INTERVAL_TO_MAX' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types2) OR
      ('POLAR_COMPLEX_NUMBER_REGION' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (bool(sp1\elementary_space.space_id = es_maths_functions));
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types2 THEN
    IF sp2\elementary_space.space_id = es_generics THEN
      RETURN (TRUE);
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types1) OR
      ('INTEGER_INTERVAL_FROM_MIN' IN types1) OR
      ('INTEGER_INTERVAL_TO_MAX' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types1) OR
      ('REAL_INTERVAL_FROM_MIN' IN types1) OR
      ('REAL_INTERVAL_TO_MAX' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types1) OR
      ('POLAR_COMPLEX_NUMBER_REGION' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types1 THEN
      RETURN (FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types1 THEN
      RETURN (bool(sp2\elementary_space.space_id = es_maths_functions));
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF subspace_of_es(sp1,es_integers) THEN  -- Note that sp1 finite already handled.
    IF subspace_of_es(sp2,es_integers) THEN  -- Note that sp2 finite already handled.
      RETURN (compatible_intervals(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_integers) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp1,es_reals) THEN  -- Note that sp1 finite already handled.
    IF subspace_of_es(sp2,es_reals) THEN  -- Note that sp2 finite already handled.
      RETURN (compatible_intervals(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_reals) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp1,es_complex_numbers) THEN  -- Note sp1 finite already handled.
    IF subspace_of_es(sp2,es_complex_numbers) THEN  -- Note sp2 finite already handled.
      RETURN (compatible_complex_number_regions(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_complex_numbers) THEN
    RETURN (FALSE);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN types1 THEN
    IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
      IF sp1\uniform_product_space.exponent <> sp2\uniform_product_space.exponent THEN
        RETURN (FALSE);
      END_IF;
      RETURN (compatible_spaces(sp1\uniform_product_space.base,
        sp2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      n := SIZEOF (sp2\listed_product_space.factors);
      IF sp1\uniform_product_space.exponent <> n THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\uniform_product_space.base,
          sp2\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      m := sp1\uniform_product_space.exponent;
      n := space_dimension(sp2\extended_tuple_space.base);
      IF m < n THEN
        RETURN (FALSE);
      END_IF;
      IF m = n THEN
        RETURN (compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN (compatible_spaces(sp1, assoc_product_space(
        sp2\extended_tuple_space.base, make_uniform_product_space(
        sp2\extended_tuple_space.extender, m - n))));
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types1 THEN
    n := SIZEOF (sp1\listed_product_space.factors);
    IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
      IF n <> sp2\uniform_product_space.exponent THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp2\uniform_product_space.base,
          sp1\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      IF n <> SIZEOF (sp2\listed_product_space.factors) THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\listed_product_space.factors[i],
          sp2\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n < m THEN
        RETURN (FALSE);
      END_IF;
      IF n = m THEN
        RETURN (compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN (compatible_spaces(sp1, assoc_product_space(
        sp2\extended_tuple_space.base, make_uniform_product_space(
        sp2\extended_tuple_space.extender, n - m))));
    END_IF;
    IF (schema_prefix + 'FUNCTION_SPACE') IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
    IF ('UNIFORM_PRODUCT_SPACE' IN types2) OR
      ('LISTED_PRODUCT_SPACE' IN types2) THEN
      RETURN (compatible_spaces(sp2, sp1));
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      IF NOT compatible_spaces(sp1\extended_tuple_space.extender,
        sp2\extended_tuple_space.extender) THEN
        RETURN (FALSE);
      END_IF;
      n := space_dimension(sp1\extended_tuple_space.base);
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n < m THEN
        RETURN (compatible_spaces(assoc_product_space(sp1\extended_tuple_space.base,
          make_uniform_product_space(sp1\extended_tuple_space.extender, m - n)),
          sp2\extended_tuple_space.base));
      END_IF;
      IF n = m THEN
        RETURN (compatible_spaces(sp1\extended_tuple_space.base,
          sp2\extended_tuple_space.base));
      END_IF;
      IF n > m THEN
        RETURN (compatible_spaces(sp1\extended_tuple_space.base,
          assoc_product_space(sp2\extended_tuple_space.base,
          make_uniform_product_space(sp2\extended_tuple_space.extender, n - m))));
      END_IF;
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1 THEN
    IF 'FUNCTION_SPACE' IN types2 THEN
      s1 := sp1\function_space.domain_argument;
      s2 := sp2\function_space.domain_argument;
      CASE sp1\function_space.domain_constraint OF
      sc_equal : BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
        sc_subspace : lgcl := subspace_of(s1, s2);
        sc_member : lgcl := member_of(s1, s2);
        END_CASE;
        END;
      sc_subspace :BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := subspace_of(s2, s1);
        sc_subspace : lgcl := compatible_spaces(s1, s2);
        sc_member : lgcl := UNKNOWN;
        END_CASE;
        END;
      sc_member :BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := member_of(s2, s1);
        sc_subspace : lgcl := UNKNOWN;
        sc_member : lgcl := compatible_spaces(s1, s2);
        END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE THEN
        RETURN (FALSE);
      END_IF;
      s1 := sp1\function_space.range_argument;
      s2 := sp2\function_space.range_argument;
      CASE sp1\function_space.range_constraint OF
      sc_equal : BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
        sc_subspace : lgcl := subspace_of(s1, s2);
        sc_member : lgcl := member_of(s1, s2);
        END_CASE;
        END;
      sc_subspace :BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := subspace_of(s2, s1);
        sc_subspace : lgcl := compatible_spaces(s1, s2);
        sc_member : lgcl := UNKNOWN;
        END_CASE;
        END;
      sc_member :BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := member_of(s2, s1);
        sc_subspace : lgcl := UNKNOWN;
        sc_member : lgcl := compatible_spaces(s1, s2);
        END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE THEN
        RETURN (FALSE);
      END_IF;
      RETURN (TRUE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  -- Should be unreachable.
  RETURN (TRUE);
END_FUNCTION;  -- compatible_spaces
FUNCTION composable_sequence(operands : LIST [2:?] OF maths_function) : BOOLEAN;
  REPEAT i := 1 TO SIZEOF (operands) - 1;
    IF NOT compatible_spaces (operands[i].range, operands[i+1].domain) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- composable_sequence
FUNCTION convert_to_literal(val : maths_atom) : generic_literal;
  LOCAL
    types : SET OF STRING := TYPEOF (val);
  END_LOCAL;
  IF 'INTEGER' IN types THEN  RETURN (make_int_literal (val));      END_IF;
  IF 'REAL'    IN types THEN  RETURN (make_real_literal (val));     END_IF;
  IF 'BOOLEAN' IN types THEN  RETURN (make_boolean_literal (val));  END_IF;
  IF 'STRING'  IN types THEN  RETURN (make_string_literal (val));   END_IF;
  IF 'LOGICAL' IN types THEN  RETURN (make_logical_literal (val));  END_IF;
  IF 'BINARY'  IN types THEN  RETURN (make_binary_literal (val));   END_IF;
  IF (schema_prefix + 'MATHS_ENUM_ATOM') IN types THEN
    RETURN (make_maths_enum_literal (val));
  END_IF;
  -- Should be unreachable
  RETURN (?);
END_FUNCTION;  -- convert_to_literal
FUNCTION convert_to_maths_function(func : maths_function_select) : maths_function;
  LOCAL
    efenum : elementary_function_enumerators;
    mthfun : maths_function;
  END_LOCAL;
  IF (schema_prefix + 'MATHS_FUNCTION') IN TYPEOF (func) THEN
    mthfun := func;
  ELSE
    efenum := func;
    mthfun := make_elementary_function (efenum);
  END_IF;
  RETURN (mthfun);
END_FUNCTION;  -- convert_to_maths_function
FUNCTION convert_to_maths_value(val : GENERIC:G) : maths_value;
  LOCAL
    types : SET OF STRING := TYPEOF (val);
    ival  : maths_integer;
    rval  : maths_real;
    nval  : maths_number;
    tfval : maths_boolean;
    lval  : maths_logical;
    sval  : maths_string;
    bval  : maths_binary;
    tval  : maths_tuple := the_empty_maths_tuple;
    mval  : maths_value;
  END_LOCAL;
  IF (schema_prefix + 'MATHS_VALUE') IN types THEN  RETURN (val);  END_IF;
  IF 'INTEGER' IN types THEN  ival := val;   RETURN (ival);   END_IF;
  IF 'REAL'    IN types THEN  rval := val;   RETURN (rval);   END_IF;
  IF 'NUMBER'  IN types THEN  nval := val;   RETURN (nval);   END_IF;
  IF 'BOOLEAN' IN types THEN  tfval := val;  RETURN (tfval);  END_IF;
  IF 'LOGICAL' IN types THEN  lval := val;   RETURN (lval);   END_IF;
  IF 'STRING'  IN types THEN  sval := val;   RETURN (sval);   END_IF;
  IF 'BINARY'  IN types THEN  bval := val;   RETURN (bval);   END_IF;
  IF 'LIST' IN types THEN
    REPEAT i := 1 TO SIZEOF (val);
      mval := convert_to_maths_value (val[i]);
      IF NOT EXISTS (mval) THEN  RETURN (?);  END_IF;
      INSERT (tval, mval, i-1);
    END_REPEAT;
    RETURN (tval);
  END_IF;
  RETURN (?);
END_FUNCTION;  -- convert_to_maths_value
FUNCTION convert_to_operand(val : maths_value) : generic_expression;
  LOCAL
    types  : SET OF STRING := stripped_typeof (val);
  END_LOCAL;
  -- Use intermediate variables of appropriate declared types to help the compilers.
  IF 'GENERIC_EXPRESSION' IN types THEN  RETURN (val);  END_IF;
  IF 'MATHS_ATOM' IN types THEN  RETURN (convert_to_literal (val));  END_IF;
  IF 'ATOM_BASED_VALUE' IN types THEN  RETURN (make_atom_based_literal(val));  END_IF;
  IF 'MATHS_TUPLE' IN types THEN  RETURN (make_maths_tuple_literal(val));  END_IF;
  -- Should be unreachable
  RETURN (?);
END_FUNCTION;  -- convert_to_operand
FUNCTION convert_to_operands(values : AGGREGATE OF maths_value)
                            : LIST OF generic_expression;
  LOCAL
    operands : LIST OF generic_expression := [];
    loc : INTEGER := 0;
  END_LOCAL;
  IF NOT EXISTS (values) THEN  RETURN (?);  END_IF;
  REPEAT i := LOINDEX (values) TO HIINDEX (values);
    INSERT (operands, convert_to_operand (values[i]), loc);
    loc := loc + 1;
  END_REPEAT;
  RETURN (operands);
END_FUNCTION;  -- convert_to_operands
FUNCTION convert_to_operands_prcmfn(srcdom  : maths_space_or_function;
                                    prepfun : LIST OF maths_function;
                                    finfun  : maths_function_select)
                                   : LIST [2:?] OF generic_expression;
  LOCAL
    operands : LIST OF generic_expression := [];
  END_LOCAL;
  INSERT (operands, srcdom, 0);
  REPEAT i := 1 TO SIZEOF (prepfun);
    INSERT (operands, prepfun[i], i);
  END_REPEAT;
  INSERT (operands, convert_to_maths_function (finfun), SIZEOF (prepfun)+1);
  RETURN (operands);
END_FUNCTION;  -- convert_to_operands_prcmfn
FUNCTION definite_integral_check(domain   : tuple_space;
                                 vrblint  : input_selector;
                                 lowerinf : BOOLEAN;
                                 upperinf : BOOLEAN) : BOOLEAN;
  LOCAL
    domn : tuple_space := domain;
    fspc : maths_space;
    dim : nonnegative_integer;
    k : positive_integer;
  END_LOCAL;
  IF (space_dimension (domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (domain))) THEN
    domn := factor1 (domain);
  END_IF;
  dim := space_dimension (domn);
  k := vrblint;
  IF k > dim THEN  RETURN (FALSE);  END_IF;
  fspc := factor_space (domn, k);
  IF NOT ((schema_prefix + 'REAL_INTERVAL') IN TYPEOF (fspc)) THEN
    RETURN (FALSE);
  END_IF;
  IF lowerinf AND min_exists (fspc) THEN  RETURN (FALSE);  END_IF;
  IF upperinf AND max_exists (fspc) THEN  RETURN (FALSE);  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- definite_integral_check
FUNCTION definite_integral_expr_check(operands : LIST [2:?] OF generic_expression;
                                      lowerinf : BOOLEAN;
                                      upperinf : BOOLEAN) : BOOLEAN;
  LOCAL
    nops : INTEGER := 2;
    vspc : maths_space;
    dim : nonnegative_integer;
    k : positive_integer;
    bspc : maths_space;
  END_LOCAL;
  IF NOT lowerinf THEN  nops := nops + 1;  END_IF;
  IF NOT upperinf THEN  nops := nops + 1;  END_IF;
  IF SIZEOF (operands) <> nops THEN  RETURN (FALSE);  END_IF;
  IF NOT ('GENERIC_VARIABLE' IN stripped_typeof(operands[2])) THEN
    RETURN (FALSE);
  END_IF;
  IF NOT has_values_space (operands[2]) THEN  RETURN (FALSE);  END_IF;
  vspc := values_space_of (operands[2]);
  IF NOT ('REAL_INTERVAL' IN stripped_typeof(vspc)) THEN  RETURN (FALSE);  END_IF;
  IF lowerinf THEN
    IF min_exists (vspc) THEN  RETURN (FALSE);  END_IF;
    k := 3;
  ELSE
    IF NOT has_values_space (operands[3]) THEN  RETURN (FALSE);  END_IF;
    bspc := values_space_of (operands[3]);
    IF NOT compatible_spaces (bspc, vspc) THEN  RETURN (FALSE);  END_IF;
    k := 4;
  END_IF;
  IF upperinf THEN
    IF max_exists (vspc) THEN  RETURN (FALSE);  END_IF;
  ELSE
    IF NOT has_values_space (operands[k]) THEN  RETURN (FALSE);  END_IF;
    bspc := values_space_of (operands[k]);
    IF NOT compatible_spaces (bspc, vspc) THEN  RETURN (FALSE);  END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- definite_integral_expr_check
FUNCTION derive_definite_integral_domain(igrl : definite_integral_function)
                                        : tuple_space;

  -- Internal utility function:
  FUNCTION process_product_space(spc         : product_space;
                                 idx, prefix : INTEGER;
                                 vdomn       : maths_space) : product_space;
    LOCAL
      uspc : uniform_product_space;
      expnt : INTEGER;
      factors : LIST OF maths_space;
    END_LOCAL;
    IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN TYPEOF (spc) THEN
      uspc := spc;
      expnt := uspc.exponent + prefix;
      IF idx <= uspc.exponent THEN  expnt := expnt - 1;  END_IF;
      IF expnt = 0 THEN
        RETURN (make_listed_product_space([]));
      ELSE
        RETURN (make_uniform_product_space(uspc.base,expnt));
      END_IF;
    ELSE
      factors := spc\listed_product_space.factors;
      IF idx <= SIZEOF (factors) THEN  REMOVE (factors, idx);  END_IF;
      IF prefix > 0 THEN
        INSERT (factors, vdomn, 0);
        IF prefix > 1 THEN  INSERT (factors, vdomn, 0);  END_IF;
      END_IF;
      RETURN (make_listed_product_space(factors));
    END_IF;
  END_FUNCTION;  -- process_product_space

  -- Resume body of derive_definite_integral_domain function
  LOCAL
    idomn : tuple_space := igrl.integrand.domain;
    types : SET OF STRING := TYPEOF (idomn);
    idx : INTEGER := igrl.variable_of_integration;
    tupled : BOOLEAN := bool(((space_dimension(idomn) = 1) AND
                             ((schema_prefix + 'TUPLE_SPACE') IN types)));
    prefix : INTEGER := 0;
    espc : extended_tuple_space;
    vdomn : maths_space;
  END_LOCAL;
  IF tupled THEN
    idomn := factor1(idomn);
    types := TYPEOF (idomn);
  END_IF;
  IF igrl.lower_limit_neg_infinity THEN  prefix := prefix + 1;  END_IF;
  IF igrl.upper_limit_pos_infinity THEN  prefix := prefix + 1;  END_IF;
  vdomn := factor_space(idomn,idx);
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    espc := idomn;
    idomn := make_extended_tuple_space(process_product_space(espc.base,idx,
      prefix,vdomn),espc.extender);
  ELSE
    idomn := process_product_space(idomn,idx,prefix,vdomn);
  END_IF;
  IF tupled THEN  RETURN (one_tuples_of(idomn));
  ELSE            RETURN (idomn);                 END_IF;
END_FUNCTION;  -- derive_definite_integral_domain
FUNCTION derive_elementary_function_domain(ef_val : elementary_function_enumerators)
                                          : tuple_space;
  IF NOT EXISTS (ef_val) THEN  RETURN (?);  END_IF;
  CASE ef_val OF
  ef_and : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_logicals));
  ef_or : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_logicals));
  ef_not : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_xor : RETURN (make_uniform_product_space (the_logicals, 2));
  ef_negate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_i : RETURN (the_integer_tuples);
  ef_subtract_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_multiply_i : RETURN (the_integer_tuples);
  ef_divide_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_mod_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_exponentiate_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_eq_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_ne_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_gt_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_lt_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_ge_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_le_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_abs_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_i : RETURN (make_listed_product_space ([the_logicals, the_integers,
    the_integers]));
  ef_negate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_reciprocal_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_r : RETURN (the_real_tuples);
  ef_subtract_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_multiply_r : RETURN (the_real_tuples);
  ef_divide_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_mod_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_exponentiate_r : RETURN (make_listed_product_space ([the_nonnegative_reals,
    the_reals]));
  ef_exponentiate_ri : RETURN (make_listed_product_space ([the_reals, the_integers]));
  ef_eq_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_ne_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_gt_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_lt_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_ge_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_le_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_abs_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_acos_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_asin_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_atan2_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_cos_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exp_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_ln_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_log2_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_log10_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_sin_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sqrt_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_tan_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_if_r : RETURN (make_listed_product_space ([the_logicals, the_reals, the_reals]));
  ef_negate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_reciprocal_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_c : RETURN (the_complex_tuples);
  ef_subtract_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_multiply_c : RETURN (the_complex_tuples);
  ef_divide_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_exponentiate_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_exponentiate_ci : RETURN (make_listed_product_space ([the_complex_numbers,
    the_integers]));
  ef_eq_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_ne_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_conjugate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_abs_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_arg_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_cos_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exp_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_ln_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sin_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sqrt_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_tan_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_if_c : RETURN (make_listed_product_space ([the_logicals, the_complex_numbers,
    the_complex_numbers]));
  ef_subscript_s : RETURN (make_listed_product_space ([the_strings, the_integers]));
  ef_eq_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_ne_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_gt_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_lt_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_ge_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_le_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_subsequence_s : RETURN (make_listed_product_space ([the_strings, the_integers,
    the_integers]));
  ef_concat_s : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_strings));
  ef_size_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_format : RETURN (make_listed_product_space ([the_numbers, the_strings]));
  ef_value : RETURN (make_uniform_product_space (the_strings, 1));
  ef_like : RETURN (make_uniform_product_space (the_strings, 2));
  ef_if_s : RETURN (make_listed_product_space ([the_logicals, the_strings,
    the_strings]));
  ef_subscript_b : RETURN (make_listed_product_space ([the_binarys, the_integers]));
  ef_eq_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_ne_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_gt_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_lt_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_ge_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_le_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_subsequence_b : RETURN (make_listed_product_space ([the_binarys, the_integers,
    the_integers]));
  ef_concat_b : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_binarys));
  ef_size_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_if_b : RETURN (make_listed_product_space ([the_logicals, the_binarys,
    the_binarys]));
  ef_subscript_t : RETURN (make_listed_product_space ([the_tuples, the_integers]));
  ef_eq_t : RETURN (make_uniform_product_space (the_tuples, 2));
  ef_ne_t : RETURN (make_uniform_product_space (the_tuples, 2));
  ef_concat_t : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_tuples));
  ef_size_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_entuple : RETURN (the_tuples);
  ef_detuple : RETURN (make_uniform_product_space (the_generics, 1));
  ef_insert : RETURN (make_listed_product_space ([the_tuples, the_generics,
    the_integers]));
  ef_remove : RETURN (make_listed_product_space ([the_tuples, the_integers]));
  ef_if_t : RETURN (make_listed_product_space ([the_logicals, the_tuples,
    the_tuples]));
  ef_sum_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_product_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_add_it : RETURN (make_extended_tuple_space (the_integer_tuples,
    the_integer_tuples));
  ef_subtract_it : RETURN (make_uniform_product_space (the_integer_tuples, 2));
  ef_scalar_mult_it : RETURN (make_listed_product_space ([the_integers,
    the_integer_tuples]));
  ef_dot_prod_it : RETURN (make_uniform_product_space (the_integer_tuples, 2));
  ef_sum_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_product_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_add_rt : RETURN (make_extended_tuple_space (the_real_tuples, the_real_tuples));
  ef_subtract_rt : RETURN (make_uniform_product_space (the_real_tuples, 2));
  ef_scalar_mult_rt : RETURN (make_listed_product_space ([the_reals,
    the_real_tuples]));
  ef_dot_prod_rt : RETURN (make_uniform_product_space (the_real_tuples, 2));
  ef_norm_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_sum_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_product_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_add_ct : RETURN (make_extended_tuple_space (the_complex_tuples,
    the_complex_tuples));
  ef_subtract_ct : RETURN (make_uniform_product_space (the_complex_tuples, 2));
  ef_scalar_mult_ct : RETURN (make_listed_product_space ([the_complex_numbers,
    the_complex_tuples]));
  ef_dot_prod_ct : RETURN (make_uniform_product_space (the_complex_tuples, 2));
  ef_norm_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_if : RETURN (make_listed_product_space ([the_logicals, the_generics,
    the_generics]));
  ef_ensemble : RETURN (the_tuples);
  ef_member_of : RETURN (make_listed_product_space ([the_generics, the_maths_spaces]));
  OTHERWISE : RETURN (?);
  END_CASE;
END_FUNCTION;  -- derive_elementary_function_domain
FUNCTION derive_elementary_function_range(ef_val : elementary_function_enumerators)
                                         : tuple_space;
  IF NOT EXISTS (ef_val) THEN  RETURN (?);  END_IF;
  CASE ef_val OF
  ef_and : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_or : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_not : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_xor : RETURN (make_uniform_product_space (the_logicals, 2));
  ef_negate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_subtract_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_multiply_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_divide_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_mod_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_exponentiate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_eq_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_abs_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_negate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_reciprocal_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_subtract_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_multiply_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_divide_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_mod_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exponentiate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exponentiate_ri : RETURN (make_uniform_product_space (the_reals, 1));
  ef_eq_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_abs_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_acos_r : RETURN (make_uniform_product_space (the_zero_pi_interval, 1));
  ef_asin_r : RETURN (make_uniform_product_space (the_neghalfpi_halfpi_interval, 1));
  ef_atan2_r : RETURN (make_uniform_product_space (the_negpi_pi_interval, 1));
  ef_cos_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_exp_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_ln_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_log2_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_log10_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sin_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_sqrt_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_tan_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_if_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_negate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_reciprocal_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_subtract_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_multiply_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_divide_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exponentiate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exponentiate_ci : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_eq_c : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_c : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_conjugate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_abs_c : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_arg_c : RETURN (make_uniform_product_space (the_negpi_pi_interval, 1));
  ef_cos_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exp_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_ln_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sin_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sqrt_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_tan_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_if_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_subscript_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_eq_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_subsequence_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_concat_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_size_s : RETURN (make_uniform_product_space (the_integers, 1));
  ef_format : RETURN (make_uniform_product_space (the_strings, 1));
  ef_value : RETURN (make_uniform_product_space (the_reals, 1));
  ef_like : RETURN (make_uniform_product_space (the_booleans, 1));
  ef_if_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_subscript_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_eq_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_subsequence_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_concat_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_size_b : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_subscript_t : RETURN (make_uniform_product_space (the_generics, 1));
  ef_eq_t : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_t : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_concat_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_size_t : RETURN (make_uniform_product_space (the_integers, 1));
  ef_entuple : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_detuple : RETURN (the_tuples);
  ef_insert : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_remove : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_if_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_sum_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_product_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_subtract_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_scalar_mult_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_dot_prod_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_sum_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_product_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_subtract_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_scalar_mult_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_dot_prod_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_norm_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sum_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_product_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_subtract_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_scalar_mult_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_dot_prod_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_norm_ct : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_if : RETURN (make_uniform_product_space (the_generics, 1));
  ef_ensemble : RETURN (make_uniform_product_space (the_maths_spaces, 1));
  ef_member_of : RETURN (make_uniform_product_space (the_logicals, 1));
  OTHERWISE : RETURN (?);
  END_CASE;
END_FUNCTION;  -- derive_elementary_function_range
FUNCTION derive_finite_function_domain(pairs : SET [1:?] OF LIST [2:2] OF maths_value)
                                      : tuple_space;
  LOCAL
    result : SET OF maths_value := [];
  END_LOCAL;
-- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
-- three lines ambiguous in those cases where an operand is simultaneously a member
-- of the base type and the aggregate type.
-- REPEAT i := 1 TO SIZEOF (pairs);
--   result := result + pairs[i][1];
-- END_REPEAT;
-- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components (pairs, 1);
  RETURN (one_tuples_of (make_finite_space (result)));
END_FUNCTION;  -- derive_finite_function_domain
FUNCTION derive_finite_function_range(pairs : SET [1:?] OF LIST [2:2] OF maths_value)
                                     : tuple_space;
  LOCAL
    result : SET OF maths_value := [];
  END_LOCAL;
-- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
-- three lines ambiguous in those cases where an operand is simultaneously a member
-- of the base type and the aggregate type.
-- REPEAT i := 1 TO SIZEOF (pairs);
--   result := result + pairs[i][2];
-- END_REPEAT;
-- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components (pairs, 2);
  RETURN (one_tuples_of (make_finite_space (result)));
END_FUNCTION;  -- derive_finite_function_range
FUNCTION derive_function_domain(func : maths_function) : tuple_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(func);
    tspace : tuple_space := make_listed_product_space ([]);
    shape : LIST OF positive_integer;
    sidxs  : LIST OF INTEGER := [0];
    itvl   : finite_integer_interval;
    factors : LIST OF finite_integer_interval := [];
    is_uniform : BOOLEAN := TRUE;
  END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames THEN
    RETURN (derive_finite_function_domain (func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\selector_function.source_of_domain));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames THEN
    RETURN (derive_elementary_function_domain (func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames THEN
    IF func\repackaging_function.input_repack = ro_nochange THEN
      RETURN (func\repackaging_function.operand.domain);
    END_IF;
    IF func\repackaging_function.input_repack = ro_wrap_as_tuple THEN
      RETURN (factor1 (func\repackaging_function.operand.domain));
    END_IF;
    IF func\repackaging_function.input_repack = ro_unwrap_tuple THEN
      RETURN (one_tuples_of (func\repackaging_function.operand.domain));
    END_IF;
    -- Unreachable, as there is no other possible value for input_repack.
    RETURN (?);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames THEN
    shape := shape_of_array(func\unary_generic_expression.operand);
    sidxs := func\reindexed_array_function.starting_indices;
    REPEAT i := 1 TO SIZEOF (shape);
      itvl := make_finite_integer_interval (sidxs[i], sidxs[i]+shape[i]-1);
      INSERT (factors, itvl, i-1);
      IF shape[i] <> shape[1] THEN  is_uniform := FALSE;  END_IF;
    END_REPEAT;
    IF is_uniform THEN
      RETURN (make_uniform_product_space (factors[1], SIZEOF (shape)));
    END_IF;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\series_composed_function.operands[1].domain);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\parallel_composed_function.source_of_domain));
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames THEN
    shape := func\explicit_table_function.shape;
    sidxs[1] := func\explicit_table_function.index_base;
    REPEAT i := 1 TO SIZEOF (shape);
      itvl := make_finite_integer_interval (sidxs[1], sidxs[1]+shape[i]-1);
      INSERT (factors, itvl, i-1);
      IF shape[i] <> shape[1] THEN  is_uniform := FALSE;  END_IF;
    END_REPEAT;
    IF is_uniform THEN
      RETURN (make_uniform_product_space (factors[1], SIZEOF (shape)));
    END_IF;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\homogeneous_linear_function.mat.range),
      func\homogeneous_linear_function.mat\explicit_table_function.shape
      [func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\general_linear_function.mat.range),
      func\general_linear_function.mat\explicit_table_function.shape
      [func\general_linear_function.sum_index] - 1)));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames THEN
    RETURN (one_tuples_of (make_finite_real_interval
      (func\b_spline_basis.repeated_knots[func\b_spline_basis.order], closed,
      func\b_spline_basis.repeated_knots[func\b_spline_basis.num_basis+1], closed)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (func\b_spline_function.basis);
      tspace := assoc_product_space (tspace, func\b_spline_function.basis[i].domain);
    END_REPEAT;
    RETURN (one_tuples_of (tspace));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames THEN
    RETURN (func\rationalize_function.fun.domain);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames THEN
    RETURN (func\partial_derivative_function.derivand.domain);
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames THEN
    RETURN (derive_definite_integral_domain(func));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (func\abstracted_expression_function.variables);
      tspace := assoc_product_space (tspace, one_tuples_of (values_space_of
        (func\abstracted_expression_function.variables[i])));
    END_REPEAT;
    RETURN (tspace);
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames THEN
    RETURN (values_space_of (func\expression_denoted_function.expr)\function_space.
      domain_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_listed_product_space ([])));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames THEN
    RETURN (func\imported_curve_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames THEN
    RETURN (func\imported_surface_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames THEN
    RETURN (func\imported_volume_function.parametric_domain);
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN
    RETURN (func\application_defined_function.explicit_domain);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN (?);
END_FUNCTION;  -- derive_function_domain
FUNCTION derive_function_range(func : maths_function) : tuple_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(func);
    tspace : tuple_space := make_listed_product_space ([]);
    m, n : nonnegative_integer := 0;
    temp : INTEGER := 0;
  END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames THEN
    RETURN (derive_finite_function_range (func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_finite_space ([func\constant_function.sole_output])));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    tspace := func.domain;
    IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
      TYPEOF (tspace)) THEN
      tspace := factor1 (tspace);
    END_IF;
    RETURN (one_tuples_of (factor_space (tspace, func\selector_function.selector)));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames THEN
    RETURN (derive_elementary_function_range (func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames THEN
    tspace := func\repackaging_function.operand.range;
    IF func\repackaging_function.output_repack = ro_wrap_as_tuple THEN
      tspace := one_tuples_of (tspace);
    END_IF;
    IF func\repackaging_function.output_repack = ro_unwrap_tuple THEN
      tspace := factor1 (tspace);
    END_IF;
    IF func\repackaging_function.selected_output > 0 THEN
      tspace := one_tuples_of (factor_space (tspace,
        func\repackaging_function.selected_output));
    END_IF;
    RETURN (tspace);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames THEN
    RETURN (func\unary_generic_expression.operand\maths_function.range);
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\series_composed_function.operands[SIZEOF
      (func\series_composed_function.operands)].range);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\parallel_composed_function.final_function.range);
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames THEN
    IF 'LISTED_REAL_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_reals));
    END_IF;
    IF 'LISTED_INTEGER_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_integers));
    END_IF;
    IF 'LISTED_LOGICAL_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_logicals));
    END_IF;
    IF 'LISTED_STRING_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_strings));
    END_IF;
    IF 'LISTED_COMPLEX_NUMBER_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_complex_numbers));
    END_IF;
    IF 'LISTED_DATA' IN typenames THEN
      RETURN (one_tuples_of (func\listed_data.value_range));
    END_IF;
    IF 'EXTERNALLY_LISTED_DATA' IN typenames THEN
      RETURN (one_tuples_of (func\externally_listed_data.value_range));
    END_IF;
    IF 'LINEARIZED_TABLE_FUNCTION' IN typenames THEN
      RETURN (func\linearized_table_function.source.range);
    END_IF;
    IF 'BASIC_SPARSE_MATRIX' IN typenames THEN
      RETURN (func\basic_sparse_matrix.val.range);
    END_IF;
    -- Unreachable, as no other subtypes of explicit_table_function are permissible
    -- without first modifying this function to account for them.
    RETURN (?);
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\homogeneous_linear_function.mat.range),
      func\homogeneous_linear_function.mat\explicit_table_function.shape
      [3 - func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\general_linear_function.mat.range),
      func\general_linear_function.mat\explicit_table_function.shape
      [3 - func\general_linear_function.sum_index])));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space (the_reals,
      func\b_spline_basis.num_basis)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames THEN
    tspace := factor1 (func\b_spline_function.coef.domain);
    m := SIZEOF (func\b_spline_function.basis);
    n := space_dimension (tspace);
    IF m = n THEN
      RETURN (one_tuples_of (the_reals));
    END_IF;
    IF m = n - 1 THEN
      RETURN (one_tuples_of (make_uniform_product_space (the_reals,
        factor_space (tspace, n)\finite_integer_interval.size)));
    END_IF;
    tspace := extract_factors (tspace, m+1, n);
    RETURN (one_tuples_of (make_function_space (sc_equal, tspace, sc_subspace,
      number_superspace_of (func\b_spline_function.coef.range))));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames THEN
    tspace := factor1 (func\rationalize_function.fun.range);
    n := space_dimension (tspace);
    RETURN (one_tuples_of (make_uniform_product_space (number_superspace_of (
      factor1 (tspace)), n-1)));
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames THEN
    RETURN (drop_numeric_constraints (
      func\partial_derivative_function.derivand.range));
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames THEN
    RETURN (drop_numeric_constraints (
      func\definite_integral_function.integrand.range));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of(values_space_of(func\abstracted_expression_function.expr)));
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames THEN
    RETURN (values_space_of (func\expression_denoted_function.expr)\function_space.
      range_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_point_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_curve_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_surface_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_volume_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN
    RETURN (func\application_defined_function.explicit_range);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN (?);
END_FUNCTION;  -- derive_function_range
FUNCTION domain_from(ref : maths_space_or_function) : tuple_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(ref);
    func      : maths_function;
  END_LOCAL;
  IF NOT EXISTS (ref) THEN  RETURN (?);  END_IF;
  IF 'TUPLE_SPACE' IN typenames THEN  RETURN (ref);                  END_IF;
  IF 'MATHS_SPACE' IN typenames THEN  RETURN (one_tuples_of (ref));  END_IF;
  func := ref;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\selector_function.source_of_domain));
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\parallel_composed_function.source_of_domain));
  END_IF;
  RETURN (func.domain);
END_FUNCTION;  -- domain_from
FUNCTION dot_count(str : STRING) : INTEGER;
  LOCAL
    n : INTEGER := 0;
  END_LOCAL;
  REPEAT i := 1 TO LENGTH (str);
    IF str[i] = '.' THEN  n := n + 1;  END_IF;
  END_REPEAT;
  RETURN (n);
END_FUNCTION;  -- dot_count
FUNCTION dotted_identifiers_syntax(str : STRING) : BOOLEAN;
  LOCAL
    k : positive_integer;
    m : positive_integer;
  END_LOCAL;
  IF NOT EXISTS (str) THEN  RETURN (FALSE);  END_IF;
  k := parse_express_identifier (str, 1);
  IF k = 1 THEN  RETURN (FALSE);  END_IF;
  REPEAT WHILE k <= LENGTH (str);
    IF (str[k] <> '.') OR (k = LENGTH (str)) THEN  RETURN (FALSE);  END_IF;
    m := parse_express_identifier (str, k+1);
    IF m = k + 1 THEN  RETURN (FALSE);  END_IF;
    k := m;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- dotted_identifiers_syntax
FUNCTION drop_numeric_constraints(spc : maths_space) : maths_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(spc);
    tspc : listed_product_space;
    factors : LIST OF maths_space := [];
    xspc : extended_tuple_space;
  END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN typenames THEN
    RETURN (make_uniform_product_space (drop_numeric_constraints (
      spc\uniform_product_space.base), spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN typenames THEN
    tspc := spc;
    REPEAT i := 1 TO SIZEOF (tspc.factors);
      INSERT (factors, drop_numeric_constraints (tspc.factors[i]), i-1);
    END_REPEAT;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN typenames THEN
    xspc := spc;
    RETURN (make_extended_tuple_space (drop_numeric_constraints (xspc.base),
      drop_numeric_constraints (xspc.extender)));
  END_IF;
  IF subspace_of_es (spc, es_numbers) THEN
    RETURN (number_superspace_of (spc));
  END_IF;
  RETURN (spc);
END_FUNCTION;  -- drop_numeric_constraints
FUNCTION enclose_cregion_in_pregion(crgn   : cartesian_complex_number_region;
                                    centre : complex_number_literal)
                                   : polar_complex_number_region;
  -- Find equivalent direction in range -PI < a <= PI.
  FUNCTION angle(a : REAL) : REAL;
    REPEAT WHILE a > PI;    a := a - 2.0*PI;  END_REPEAT;
    REPEAT WHILE a <= -PI;  a := a + 2.0*PI;  END_REPEAT;
    RETURN (a);
  END_FUNCTION;
  -- Determine whether a real is strictly within a real interval
  FUNCTION strictly_in(z    : REAL;
                       zitv : real_interval) : LOGICAL;
    RETURN ((NOT min_exists(zitv) OR (z > real_min(zitv))) AND
      (NOT max_exists(zitv) OR (z < real_max(zitv))));
  END_FUNCTION;
  -- Include direction in minmax collection
  PROCEDURE angle_minmax(    ab, a            : REAL;
                             a_in             : BOOLEAN;
                         VAR amin, amax       : REAL;
                         VAR amin_in, amax_in : BOOLEAN);
    a := angle(a - ab);
    IF amin = a THEN  amin_in := amin_in OR a_in;  END_IF;
    IF amin > a THEN  amin := a;  amin_in := a_in;  END_IF;
    IF amax = a THEN  amax_in := amax_in OR a_in;  END_IF;
    IF amax < a THEN  amax := a;  amax_in := a_in;  END_IF;
  END_PROCEDURE;
  -- Include distance in max collection
  PROCEDURE range_max(    r       : REAL;
                          incl    : BOOLEAN;
                      VAR rmax    : REAL;
                      VAR rmax_in : BOOLEAN);
    IF rmax = r THEN  rmax_in := rmax_in OR incl;   END_IF;
    IF rmax < r THEN  rmax := r;  rmax_in := incl;  END_IF;
  END_PROCEDURE;
  -- Include distance in min collection
  PROCEDURE range_min(    r       : REAL;
                          incl    : BOOLEAN;
                      VAR rmin    : REAL;
                      VAR rmin_in : BOOLEAN);
    IF rmin = r THEN  rmin_in := rmin_in OR incl;  END_IF;
    IF (rmin < 0.0) OR (rmin > r) THEN  rmin := r;  rmin_in := incl;  END_IF;
  END_PROCEDURE;
  LOCAL
    xitv, yitv : real_interval;
    is_xmin, is_xmax, is_ymin, is_ymax : BOOLEAN;
    xmin, xmax, ymin, ymax, xc, yc : REAL := 0.0;
    xmin_in, xmax_in, ymin_in, ymax_in : BOOLEAN := FALSE;
    rmin, rmax : REAL := -1.0;
    amin : REAL := 4.0;
    amax : REAL := -4.0;
    rmax_exists, outside : BOOLEAN := TRUE;
    rmin_in, rmax_in, amin_in, amax_in : BOOLEAN := FALSE;
    ab, a, r : REAL := 0.0;
    incl : BOOLEAN;
    ritv : real_interval;
    aitv : finite_real_interval;
    minclo, maxclo : open_closed := open;
  END_LOCAL;
  IF NOT EXISTS (crgn) OR NOT EXISTS (centre) THEN  RETURN (?);  END_IF;
  -- Extract elementary input information
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  is_xmin := min_exists(xitv);
  is_xmax := max_exists(xitv);
  is_ymin := min_exists(yitv);
  is_ymax := max_exists(yitv);
  IF is_xmin THEN  xmin := real_min(xitv);  xmin_in := min_included(xitv);  END_IF;
  IF is_xmax THEN  xmax := real_max(xitv);  xmax_in := max_included(xitv);  END_IF;
  IF is_ymin THEN  ymin := real_min(yitv);  ymin_in := min_included(yitv);  END_IF;
  IF is_ymax THEN  ymax := real_max(yitv);  ymax_in := max_included(yitv);  END_IF;
  rmax_exists := is_xmin AND is_xmax AND is_ymin AND is_ymax;
  -- Identify base direction with respect to which all relevant directions lie
  -- within +/- 0.5*PI, or that the centre lies properly inside crgn.
  IF       is_xmin AND (xc <= xmin)  THEN  ab := 0.0;
  ELSE IF  is_ymin AND (yc <= ymin)  THEN  ab := 0.5*PI;
  ELSE IF  is_ymax AND (yc >= ymax)  THEN  ab := -0.5*PI;
  ELSE IF  is_xmax AND (xc >= xmax)  THEN  ab := PI;
  ELSE                                     outside := FALSE;
  END_IF;  END_IF;  END_IF;  END_IF;
  IF NOT outside AND NOT rmax_exists THEN
    RETURN (?);  -- No enclosing polar region exists (requires whole plane)
  END_IF;
  -- Identify any closest point on a side but not a corner.
  IF       is_xmin AND (xc <= xmin) AND strictly_in(yc,yitv) THEN
    rmin := xmin - xc;  rmin_in := xmin_in;
  ELSE IF  is_ymin AND (yc <= ymin) AND strictly_in(xc,xitv) THEN
    rmin := ymin - yc;  rmin_in := ymin_in;
  ELSE IF  is_ymax AND (yc >= ymax) AND strictly_in(xc,xitv) THEN
    rmin := yc - ymax;  rmin_in := ymax_in;
  ELSE IF  is_xmax AND (xc >= xmax) AND strictly_in(yc,yitv) THEN
    rmin := xc - xmax;  rmin_in := xmax_in;
  END_IF;  END_IF;  END_IF;  END_IF;
  IF is_xmin THEN
    IF is_ymin THEN  -- Consider lower left corner
      r := SQRT((xmin-xc)**2 + (ymin-yc)**2);
      incl := xmin_in AND ymin_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymin-yc,xmin-xc) - ab);
          IF xc = xmin THEN  incl := xmin_in;  END_IF;
          IF yc = ymin THEN  incl := ymin_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower left corner
          rmin := 0.0;                rmin_in := xmin_in AND ymin_in;
          amin := angle(0.0-ab);      amin_in := ymin_in;
          amax := angle(0.5*PI-ab);   amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE IF xc <= xmin THEN  -- Consider points near (xmin, -infinity)
      angle_minmax(ab,-0.5*PI,(xc=xmin) AND xmin_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_ymax AND (xc <= xmin) THEN  -- Consider points near (xmin, +infinity)
      angle_minmax(ab,0.5*PI,(xc=xmin) AND xmin_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_ymin THEN
    IF is_xmax THEN  -- Consider lower right corner
      r := SQRT((xmax-xc)**2 + (ymin-yc)**2);
      incl := xmax_in AND ymin_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymin-yc,xmax-xc) - ab);
          IF xc = xmax THEN  incl := xmax_in;  END_IF;
          IF yc = ymin THEN  incl := ymin_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower right corner
          rmin := 0.0;                rmin_in := xmax_in AND ymin_in;
          amin := angle(0.5*PI-ab);   amin_in := ymin_in;
          amax := angle(PI-ab);       amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE IF yc <= ymin THEN  -- Consider points near (+infinity, ymin)
      angle_minmax(ab,0.0,(yc=ymin) AND ymin_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_xmin AND (yc <= ymin) THEN  -- Consider points near (-infinity, ymin)
      angle_minmax(ab,PI,(yc=ymin) AND ymin_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_xmax THEN
    IF is_ymax THEN  -- Consider upper right corner
      r := SQRT((xmax-xc)**2 + (ymax-yc)**2);
      incl := xmax_in AND ymax_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymax-yc,xmax-xc) - ab);
          IF xc = xmax THEN  incl := xmax_in;  END_IF;
          IF yc = ymax THEN  incl := ymax_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower left corner
          rmin := 0.0;                rmin_in := xmax_in AND ymax_in;
          amin := angle(-PI-ab);      amin_in := ymax_in;
          amax := angle(-0.5*PI-ab);  amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE IF xc >= xmax THEN  -- Consider points near (xmax, +infinity)
      angle_minmax(ab,0.5*PI,(xc=xmax) AND xmax_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_ymin AND (xc >= xmax) THEN  -- Consider points near (xmax, -infinity)
      angle_minmax(ab,-0.5*PI,(xc=xmax) AND xmax_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_ymax THEN
    IF is_xmin THEN  -- Consider upper left corner
      r := SQRT((xmin-xc)**2 + (ymax-yc)**2);
      incl := xmin_in AND ymax_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymax-yc,xmin-xc) - ab);
          IF xc = xmin THEN  incl := xmin_in;  END_IF;
          IF yc = ymax THEN  incl := ymax_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower right corner
          rmin := 0.0;                rmin_in := xmin_in AND ymax_in;
          amin := angle(0.5*PI-ab);   amin_in := ymax_in;
          amax := angle(PI-ab);       amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE IF yc >= ymax THEN  -- Consider points near (-infinity, ymax)
      angle_minmax(ab,PI,(yc=ymax) AND ymax_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_xmax AND (yc >= ymax) THEN  -- Consider points near (+infinity, ymax)
      angle_minmax(ab,0.0,(yc=ymax) AND ymax_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF outside THEN  -- Change direction origin from ab back to zero
    amin := angle(amin+ab);
    IF amin = PI THEN  amin := -PI;  END_IF;
    amax := angle(amax+ab);
    IF amax <= amin THEN  amax := amax + 2.0*PI;  END_IF;
  ELSE
    amin := -PI;  amin_in := FALSE;
    amax := PI;   amax_in := FALSE;
  END_IF;
  IF amin_in THEN  minclo := closed;  END_IF;
  IF amax_in THEN  maxclo := closed;  END_IF;
  aitv := make_finite_real_interval(amin,minclo,amax,maxclo);
  minclo := open;
  IF rmin_in THEN  minclo := closed;  END_IF;
  IF rmax_exists THEN
    maxclo := open;
    IF rmax_in THEN  maxclo := closed;  END_IF;
    ritv := make_finite_real_interval(rmin,minclo,rmax,maxclo);
  ELSE
    ritv := make_real_interval_from_min(rmin,minclo);
  END_IF;
  RETURN (make_polar_complex_number_region(centre,ritv,aitv));
END_FUNCTION;  -- enclose_cregion_in_pregion
FUNCTION enclose_pregion_in_cregion(prgn : polar_complex_number_region)
                                   : cartesian_complex_number_region;
  PROCEDURE nearest_good_direction(acart    : REAL;
                                   aitv     : finite_real_interval;
                                   VAR a    : REAL;
                                   VAR a_in : BOOLEAN);
    a := acart;                    a_in := TRUE;
    IF      a < aitv.min THEN
      -- a+2.0*PI > aitv.min automatically!
      IF a+2.0*PI < aitv.max THEN                               RETURN;  END_IF;
      IF a+2.0*PI = aitv.max THEN  a_in := max_included(aitv);  RETURN;  END_IF;
    ELSE IF a = aitv.min THEN      a_in := min_included(aitv);  RETURN;
    ELSE IF a < aitv.max THEN                                   RETURN;
    ELSE IF a = aitv.max THEN      a_in := max_included(aitv);  RETURN;
    END_IF;  END_IF;  END_IF;  END_IF;
    IF COS(acart - aitv.max) >= COS(acart - aitv.min) THEN
      a := aitv.max;               a_in := max_included(aitv);
    ELSE
      a := aitv.min;               a_in := min_included(aitv);
    END_IF;
  END_PROCEDURE;
  LOCAL
    xc, yc, xmin, xmax, ymin, ymax : REAL := 0.0;
    ritv, xitv, yitv : real_interval;
    aitv : finite_real_interval;
    xmin_exists, xmax_exists, ymin_exists, ymax_exists : BOOLEAN;
    xmin_in, xmax_in, ymin_in, ymax_in : BOOLEAN := FALSE;
    a, r : REAL := 0.0;
    a_in : BOOLEAN := FALSE;
    min_clo, max_clo : open_closed := open;
  END_LOCAL;
  IF NOT EXISTS (prgn) THEN  RETURN (?);  END_IF;
  -- Extract elementary input data
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  ritv := prgn.distance_constraint;
  aitv := prgn.direction_constraint;
  -- Determine xmin data
  nearest_good_direction(PI,aitv,a,a_in);
  IF COS(a) >= 0.0 THEN
    xmin_exists := TRUE;
    xmin := xc + real_min(ritv)*COS(a);
    xmin_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      xmin_exists := TRUE;
      xmin := xc + real_max(ritv)*COS(a);
      xmin_in := a_in AND max_included(ritv);
    ELSE
      xmin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine xmax data
  nearest_good_direction(0.0,aitv,a,a_in);
  IF COS(a) <= 0.0 THEN
    xmax_exists := TRUE;
    xmax := xc + real_min(ritv)*COS(a);
    xmax_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      xmax_exists := TRUE;
      xmax := xc + real_max(ritv)*COS(a);
      xmax_in := a_in AND max_included(ritv);
    ELSE
      xmax_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymin data
  nearest_good_direction(-0.5*PI,aitv,a,a_in);
  IF SIN(a) >= 0.0 THEN
    ymin_exists := TRUE;
    ymin := yc + real_min(ritv)*SIN(a);
    ymin_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      ymin_exists := TRUE;
      ymin := yc + real_max(ritv)*SIN(a);
      ymin_in := a_in AND max_included(ritv);
    ELSE
      ymin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymax data
  nearest_good_direction(0.5*PI,aitv,a,a_in);
  IF SIN(a) <= 0.0 THEN
    ymax_exists := TRUE;
    ymax := yc + real_min(ritv)*SIN(a);
    ymax_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      ymax_exists := TRUE;
      ymax := yc + real_max(ritv)*SIN(a);
      ymax_in := a_in AND max_included(ritv);
    ELSE
      ymax_exists := FALSE;
    END_IF;
  END_IF;
  -- Construct result
  IF NOT (xmin_exists OR xmax_exists OR ymin_exists OR ymax_exists) THEN
    RETURN (?);  -- No finite boundaries exist
  END_IF;
  -- Construct real_constraint
  IF xmin_exists THEN
    IF xmin_in THEN  min_clo := closed;  ELSE  min_clo := open;  END_IF;
    IF xmax_exists THEN
      IF xmax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      xitv := make_finite_real_interval(xmin,min_clo,xmax,max_clo);
    ELSE
      xitv := make_real_interval_from_min(xmin,min_clo);
    END_IF;
  ELSE
    IF xmax_exists THEN
      IF xmax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      xitv := make_real_interval_to_max(xmax,max_clo);
    ELSE
      xitv := the_reals;
    END_IF;
  END_IF;
  -- Construct imag_constraint
  IF ymin_exists THEN
    IF ymin_in THEN  min_clo := closed;  ELSE  min_clo := open;  END_IF;
    IF ymax_exists THEN
      IF ymax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      yitv := make_finite_real_interval(ymin,min_clo,ymax,max_clo);
    ELSE
      yitv := make_real_interval_from_min(ymin,min_clo);
    END_IF;
  ELSE
    IF ymax_exists THEN
      IF ymax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      yitv := make_real_interval_to_max(ymax,max_clo);
    ELSE
      yitv := the_reals;
    END_IF;
  END_IF;
  -- Construct cartesian region
  RETURN (make_cartesian_complex_number_region(xitv,yitv));
END_FUNCTION;  -- enclose_pregion_in_cregion
FUNCTION enclose_pregion_in_pregion(prgn   : polar_complex_number_region;
                                    centre : complex_number_literal)
                                   : polar_complex_number_region;
  -- Find equivalent direction in range -PI < a <= PI.
  FUNCTION angle(a : REAL) : REAL;
    REPEAT WHILE a > PI;    a := a - 2.0*PI;  END_REPEAT;
    REPEAT WHILE a <= -PI;  a := a + 2.0*PI;  END_REPEAT;
    RETURN (a);
  END_FUNCTION;
  -- Find proper limits for direction interval
  PROCEDURE angle_range(VAR amin, amax : REAL);
    amin := angle(amin);
    IF amin = PI THEN  amin := -PI;  END_IF;
    amax := angle(amax);
    IF amax <= amin THEN  amax := amax + 2.0*PI;  END_IF;
  END_PROCEDURE;
  -- Determine whether a direction is strictly within a direction interval
  FUNCTION strictly_in(a    : REAL;
                       aitv : finite_real_interval) : LOGICAL;
    a := angle(a);
    RETURN ({aitv.min < a < aitv.max} OR {aitv.min < a+2.0*PI < aitv.max});
  END_FUNCTION;
  -- Find min and max and related inclusion booleans among four candidates,
  -- using a base direction chosen to ensure the algebraic comparisons are valid.
  PROCEDURE find_aminmax(    ab,a0,a1,a2,a3  : REAL;
                             in0,in1,in2,in3 : BOOLEAN;
                         VAR amin,amax       : REAL;
                         VAR amin_in,amax_in : BOOLEAN);
    LOCAL
      a : REAL;
    END_LOCAL;
    amin := angle(a0-ab);                  amin_in := in0;
    amax := amin;                          amax_in := in0;
    a := angle(a1-ab);
    IF a = amin THEN                       amin_in := amin_in OR in1;  END_IF;
    IF a < amin THEN  amin := a;           amin_in := in1;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in1;  END_IF;
    IF a > amax THEN  amax := a;           amax_in := in1;             END_IF;
    a := angle(a2-ab);
    IF a = amin THEN                       amin_in := amin_in OR in2;  END_IF;
    IF a < amin THEN  amin := a;           amin_in := in2;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in2;  END_IF;
    IF a > amax THEN  amax := a;           amax_in := in2;             END_IF;
    a := angle(a3-ab);
    IF a = amin THEN                       amin_in := amin_in OR in3;  END_IF;
    IF a < amin THEN  amin := a;           amin_in := in3;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in3;  END_IF;
    IF a > amax THEN  amax := a;           amax_in := in3;             END_IF;
    amin := amin+ab;
    amax := amax+ab;
    angle_range(amin,amax);
  END_PROCEDURE;

  LOCAL
    ritp, ritv : real_interval;
    aitp, aitv : finite_real_interval;
    xp, yp, xc, yc, rmax, rmin, amin, amax, rc, acp, apc : REAL := 0.0;
    rmax_in, rmin_in, amin_in, amax_in : BOOLEAN := FALSE;
    rmxp, rmnp, x, y, r, a, ab, r0, a0, r1, a1, r2, a2, r3, a3 : REAL := 0.0;
    in0, in1, in2, in3, inn : BOOLEAN := FALSE;
    minclo, maxclo : open_closed := open;
  END_LOCAL;
  -- Extract elementary input information
  IF NOT EXISTS (prgn) OR NOT EXISTS (centre) THEN  RETURN (?);  END_IF;
  xp := prgn.centre.real_part;
  yp := prgn.centre.imag_part;
  ritp := prgn.distance_constraint;
  aitp := prgn.direction_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  IF (xc = xp) AND (yc = yp) THEN  RETURN (prgn);  END_IF;
  rc := SQRT((xp-xc)**2 + (yp-yc)**2);
  acp := atan2(yp-yc,xp-xc);
  apc := atan2(yc-yp,xc-xp);
  rmnp := real_min(ritp);
  -- Analyse cases by existence of max distance and direction limits
  IF max_exists(ritp) THEN
    rmxp := real_max(ritp);
    IF aitp.max - aitp.min = 2.0*PI THEN
      -- annulus or disk, with or without slot or puncture
      inn := NOT max_included(aitp);  -- slot exists;
      a := angle(aitp.min);  -- slot direction
      rmax := rc+rmxp;                    rmax_in := max_included(ritp);
      IF inn AND (acp = a) THEN  rmax_in := FALSE;  END_IF;
      IF rc > rmxp THEN
        a0 := ASIN(rmxp/rc);
        amin := angle(acp-a0);            amin_in := max_included(ritp);
        IF amin = PI THEN  amin := -PI;  END_IF;
        amax := angle(acp+a0);            amax_in := amin_in;
        IF amax < amin THEN  amax := amax + 2.0*PI;  END_IF;
        rmin := rc-rmxp;                  rmin_in := amin_in;
        IF inn THEN
          -- slotted case
          IF apc = a THEN  rmin_in := FALSE;  END_IF;
          IF angle(amin+0.5*PI) = a THEN  amin_in := FALSE;  END_IF;
          IF angle(amax-0.5*PI) = a THEN  amax_in := FALSE;  END_IF;
        END_IF;
      ELSE IF rc = rmxp THEN
        amin := angle(acp-0.5*PI);        amin_in := FALSE;
        IF amin = PI THEN  amin := -PI;  END_IF;
        amax := angle(acp+0.5*PI);        amax_in := FALSE;
        IF amax < amin THEN  amax := amax + 2.0*PI;  END_IF;
        rmin := 0.0;                      rmin_in := max_included(ritp);
        IF inn AND (apc = a) THEN  rmin_in := FALSE;  END_IF;
      ELSE IF rc > rmnp THEN
        IF inn AND (apc = a) THEN  -- in the slot
          rmin := 0.0;                    rmin_in := FALSE;
          amin := aitp.min;               amin_in := FALSE;
          amax := aitp.max;               amax_in := FALSE;
        ELSE
          rmin := 0.0;                    rmin_in := TRUE;
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
        END_IF;
      ELSE
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
        amin := -PI;                      amin_in := FALSE;
        amax := PI;                       amax_in := TRUE;
        IF inn THEN  -- Special cases when aligned with slot
          IF apc = a THEN
                                          rmin_in := FALSE;
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          ELSE IF acp = a THEN
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          END_IF;  END_IF;
        END_IF;
      END_IF;  END_IF;  END_IF;
    ELSE  -- direction range < 2*PI
      -- Compute data for corners with respect to xc,yc
      x := xp + rmxp*cos(aitp.min) - xc;
      y := yp + rmxp*sin(aitp.min) - yc;
      r0 := SQRT(x**2 + y**2);
      in0 := max_included(ritp) AND min_included(aitp);
      IF r0 <> 0.0 THEN  a0 := atan2(y,x);  END_IF;
      x := xp + rmxp*cos(aitp.max) - xc;
      y := yp + rmxp*sin(aitp.max) - yc;
      r1 := SQRT(x**2 + y**2);
      in1 := max_included(ritp) AND max_included(aitp);
      IF r1 <> 0.0 THEN  a1 := atan2(y,x);  END_IF;
      x := xp + rmnp*cos(aitp.max) - xc;
      y := yp + rmnp*sin(aitp.max) - yc;
      r2 := SQRT(x**2 + y**2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 <> 0.0 THEN  a2 := atan2(y,x);  ELSE  a2 := a1;  in2 := in1;  END_IF;
      IF r1 = 0.0 THEN  a1 := a2;  in1 := in2;  END_IF;
      x := xp + rmnp*cos(aitp.min) - xc;
      y := yp + rmnp*sin(aitp.min) - yc;
      r3 := SQRT(x**2 + y**2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 <> 0.0 THEN  a3 := atan2(y,x);  ELSE  a3 := a0;  in3 := in0;  END_IF;
      IF r0 = 0.0 THEN  a0 := a3;  in0 := in3;  END_IF;
      IF rmnp = 0.0 THEN  in2 := min_included(ritp);  in3 := in2;  END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min)) THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max)) THEN
        in1 := max_included(aitp);
        in2 := in1;
      END_IF;  END_IF;
      -- Find rmax
      IF strictly_in(acp,aitp) THEN
        rmax := rc+rmxp;                  rmax_in := max_included(ritp);
      ELSE
        rmax := r0;                       rmax_in := in0;
        IF rmax = r1 THEN                 rmax_in := rmax_in OR in1;  END_IF;
        IF rmax < r1 THEN  rmax := r1;    rmax_in := in1;             END_IF;
        IF rmax = r2 THEN                 rmax_in := rmax_in OR in2;  END_IF;
        IF rmax < r2 THEN  rmax := r2;    rmax_in := in2;             END_IF;
        IF rmax = r3 THEN                 rmax_in := rmax_in OR in3;  END_IF;
        IF rmax < r3 THEN  rmax := r3;    rmax_in := in3;             END_IF;
      END_IF;
      -- Find rmin
      IF strictly_in(apc,aitp) THEN
        IF rc >= rmxp THEN
          rmin := rc-rmxp;                rmin_in := max_included(ritp);
        ELSE IF rc <= rmnp THEN
          rmin := rmnp-rc;                rmin_in := min_included(ritp);
        ELSE
          rmin := 0.0;                    rmin_in := TRUE;
        END_IF;  END_IF;
      ELSE
        rmin := r0;                       rmin_in := in0;
        a := apc-aitp.min;
        r := rc*COS(a);
        IF {rmnp < r < rmxp} THEN  -- use nearest point on line segment
          rmin := rc*SIN(ABS(a));         rmin_in := min_included(aitp);
        END_IF;
        a := apc-aitp.max;
        r := rc*COS(a);
        IF {rmnp < r < rmxp} THEN  -- try nearest point on line segment
          r := rc*SIN(ABS(a));            inn := max_included(aitp);
          IF r = rmin THEN                rmin_in := rmin_in OR inn;  END_IF;
          IF r < rmin THEN  rmin := r;    rmin_in := inn;             END_IF;
        END_IF;
        IF r1 = rmin THEN                 rmin_in := rmin_in OR in1;  END_IF;
        IF r1 < rmin THEN  rmin := r1;    rmin_in := in1;             END_IF;
        IF r2 = rmin THEN                 rmin_in := rmin_in OR in2;  END_IF;
        IF r2 < rmin THEN  rmin := r2;    rmin_in := in2;             END_IF;
        IF r3 = rmin THEN                 rmin_in := rmin_in OR in3;  END_IF;
        IF r3 < rmin THEN  rmin := r3;    rmin_in := in3;             END_IF;
      END_IF;
      -- Find amin and amax, initially with respect to base direction ab.
      IF rc >= rmxp THEN  -- outside outer circle
        ab := acp;
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
        a := ACOS(rmxp/rc);
        IF strictly_in(apc-a,aitp) THEN
          amin := ab-ASIN(rmxp/rc);       amin_in := max_included(ritp);
        END_IF;
        IF strictly_in(apc+a,aitp) THEN
          amax := ab+ASIN(rmxp/rc);       amax_in := max_included(ritp);
        END_IF;
        angle_range(amin,amax);
      ELSE IF rc > rmnp THEN
        ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
      ELSE
        -- Using base direction midway in prgn, compute all directions using
        -- values which ensure a3 < a2 and a0 < a1 algebraically.
        ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
        a0 := angle(a0-ab);
        a1 := angle(a1-ab);
        a2 := angle(a2-ab);
        a3 := angle(a3-ab);
        IF a3 > a2 THEN  a2 := a2 + 2.0*PI;  END_IF;
        IF a0 > a1 THEN  a0 := a0 + 2.0*PI;  END_IF;
        IF a3 < a0 THEN  amin := a3;      amin_in := in3;
        ELSE             amin := a0;      amin_in := in0;  END_IF;
        IF a2 > a1 THEN  amax := a2;      amax_in := in2;
        ELSE             amax := a1;      amax_in := in1;  END_IF;
        IF (amax - amin > 2.0*PI) OR
          ((amax - amin = 2.0*PI) AND (amin_in OR amax_in)) THEN
          -- Cannot see out
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
        ELSE
          amin := amin + ab;
          amax := amax + ab;
          angle_range(amin,amax);
        END_IF;
      END_IF;  END_IF;
    END_IF;
    IF rmin_in THEN  minclo := closed;  END_IF;
    IF rmax_in THEN  maxclo := closed;  END_IF;
    ritv := make_finite_real_interval(rmin,minclo,rmax,maxclo);
  ELSE  -- Not max_exists(ritp)
    IF (rc > rmnp) AND strictly_in(apc,aitp) THEN
      RETURN (?);  -- No pregion exists.  (Would require whole plane.)
    END_IF;
    IF aitp.max - aitp.min = 2.0*PI THEN
      -- complement of disk, with or without slot
      a := angle(aitp.min);  -- slot direction
      IF rc > rmnp THEN  -- already excluded if not aligned with slot
        IF max_included(aitp) THEN
          RETURN (?);  -- No pregion exists.  (Would require whole plane.)
        END_IF;
        rmin := 0.0;                      rmin_in := FALSE;
        amin := aitp.min;                 amin_in := FALSE;
        amax := aitp.max;                 amax_in := FALSE;
      ELSE
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
        amin := -PI;                      amin_in := FALSE;
        amax := PI;                       amax_in := TRUE;
        IF NOT max_included(aitp) THEN  -- Special cases when aligned with slot
          IF apc = a THEN
                                          rmin_in := FALSE;
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          ELSE IF acp = a THEN
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          END_IF;  END_IF;
        END_IF;
      END_IF;
    ELSE  -- direction range < 2*PI
      -- Compute data for corners with respect to xc,yc (two at infinity)
      a0 := angle(aitp.min);
      in0 := FALSE;
      a1 := angle(aitp.max);
      in1 := FALSE;
      x := xp + rmnp*cos(aitp.max) - xc;
      y := yp + rmnp*sin(aitp.max) - yc;
      r2 := SQRT(x**2 + y**2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 <> 0.0 THEN  a2 := atan2(y,x);  ELSE  a2 := a1;  in2 := in1;  END_IF;
      x := xp + rmnp*cos(aitp.min) - xc;
      y := yp + rmnp*sin(aitp.min) - yc;
      r3 := SQRT(x**2 + y**2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 <> 0.0 THEN  a3 := atan2(y,x);  ELSE  a3 := a0;  in3 := in0;  END_IF;
      IF rmnp = 0.0 THEN  in2 := min_included(ritp);  in3 := in2;  END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min)) THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max)) THEN
        in1 := max_included(aitp);
        in2 := in1;
      END_IF;  END_IF;
      -- Find rmin
      IF strictly_in(apc,aitp) THEN
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
      ELSE
        rmin := r2;                       rmin_in := in2;
        a := apc-aitp.min;
        r := rc*COS(a);
        IF rmnp < r THEN  -- use nearest point on aitp.min ray
          rmin := rc*SIN(ABS(a));         rmin_in := min_included(aitp);
        END_IF;
        a := apc-aitp.max;
        r := rc*COS(a);
        IF rmnp < r THEN  -- try nearest point on aitp.max ray
          r := rc*SIN(ABS(a));            inn := max_included(aitp);
          IF r = rmin THEN                rmin_in := rmin_in OR inn;  END_IF;
          IF r < rmin THEN  rmin := r;    rmin_in := inn;             END_IF;
        END_IF;
        IF r3 = rmin THEN                 rmin_in := rmin_in OR in3;  END_IF;
        IF r3 < rmin THEN  rmin := r3;    rmin_in := in3;             END_IF;
      END_IF;
      -- Find amin and amax
      ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
      IF rc > rmnp THEN
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
      ELSE
        -- Using base direction midway in prgn, compute all directions using
        -- values which ensure a3 < a2 and a0 < a1 algebraically.
        a0 := angle(a0-ab);
        a1 := angle(a1-ab);
        a2 := angle(a2-ab);
        a3 := angle(a3-ab);
        IF a3 > a2 THEN  a2 := a2 + 2.0*PI;  END_IF;
        IF a0 > a1 THEN  a0 := a0 + 2.0*PI;  END_IF;
        IF a3 < a0 THEN  amin := a3;      amin_in := in3;
        ELSE             amin := a0;      amin_in := in0;  END_IF;
        IF a2 > a1 THEN  amax := a2;      amax_in := in2;
        ELSE             amax := a1;      amax_in := in1;  END_IF;
        IF (amax - amin > 2.0*PI) OR
          ((amax - amin = 2.0*PI) AND (amin_in OR amax_in)) THEN
          -- Cannot see out
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
          IF (rmin = 0.0) AND rmin_in THEN
            RETURN (?);  -- No pregion exists.  (Would require whole plane.)
          END_IF;
        ELSE
          amin := amin + ab;
          amax := amax + ab;
          angle_range(amin,amax);
        END_IF;
      END_IF;
    END_IF;
    IF rmin_in THEN  minclo := closed;  END_IF;
    ritv := make_real_interval_from_min(rmin,minclo);
  END_IF;
  minclo := open;  maxclo := open;
  IF amin_in THEN  minclo := closed;  END_IF;
  IF amax_in THEN  maxclo := closed;  END_IF;
  aitv := make_finite_real_interval(amin,minclo,amax,maxclo);
  -- Construct polar region
  RETURN (make_polar_complex_number_region(centre,ritv,aitv));
END_FUNCTION;  -- enclose_pregion_in_pregion
FUNCTION equal_cregion_pregion(crgn : cartesian_complex_number_region;
                               prgn : polar_complex_number_region) : LOGICAL;
  LOCAL
    arng, amin, xc, yc : REAL;
    aitv, xitv, yitv : real_interval;
    c_in : BOOLEAN;
  END_LOCAL;
  IF NOT EXISTS (crgn) OR NOT EXISTS (prgn) THEN  RETURN (FALSE);  END_IF;
  IF max_exists(prgn.distance_constraint) THEN  RETURN (FALSE);  END_IF;
  IF real_min(prgn.distance_constraint) <> 0.0 THEN  RETURN (FALSE);  END_IF;
  c_in := min_included(prgn.distance_constraint);
  aitv := prgn.direction_constraint;
  amin := aitv.min;
  arng := aitv.max - amin;
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  IF arng = 0.5*PI THEN
    IF amin = 0.0 THEN  -- quadrant to upper right
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv)
        AND min_exists(yitv) AND (real_min(xitv) = xc) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND NOT min_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5*PI THEN  -- quadrant to upper left
      RETURN (max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND min_exists(yitv) AND (real_max(xitv) = xc) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND NOT min_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = -PI THEN  -- quadrant to lower left
      RETURN (max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(xitv) = xc) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND NOT max_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5*PI THEN  -- quadrant to lower right
      RETURN (NOT max_exists(xitv) AND max_exists(yitv) AND min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_min(xitv) = xc) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND NOT max_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND NOT max_included(yitv))));
    END_IF;
  END_IF;
  IF arng = PI THEN
    IF amin = 0.0 THEN  -- upper half space
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND min_exists(yitv) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5*PI THEN  -- left half space
      RETURN (max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(xitv) = xc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv))));
    END_IF;
    IF amin = -PI THEN  -- lower half space
      RETURN (NOT max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5*PI THEN  -- right half space
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_min(xitv) = xc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv))));
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- equal_cregion_pregion
FUNCTION equal_maths_functions(fun1, fun2 : maths_function) : LOGICAL;
  LOCAL
    cum : LOGICAL;
  END_LOCAL;
  IF fun1 = fun2 THEN  RETURN (TRUE);   END_IF;
  cum := equal_maths_spaces(fun1.domain,fun2.domain);
  IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  cum := cum AND equal_maths_spaces(fun1.range,fun2.range);
  IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  -- A lot of further analysis is possible, but not required.
  RETURN (UNKNOWN);
END_FUNCTION;  -- equal_maths_functions
FUNCTION equal_maths_spaces(spc1, spc2 : maths_space) : LOGICAL;
  LOCAL
    spc1types : SET OF STRING := stripped_typeof(spc1);
    spc2types : SET OF STRING := stripped_typeof(spc2);
    set1, set2 : SET OF maths_value;
    cum : LOGICAL := TRUE;
    base : maths_space;
    expnt : INTEGER;
    factors : LIST OF maths_space;
    factors2 : LIST OF maths_space;
    fs1, fs2 : function_space;
    cum2 : LOGICAL;
  END_LOCAL;
  IF spc1 = spc2 THEN  RETURN (TRUE);  END_IF;
  -- Consider cases where it is not yet certain that spc1 <> spc2.
  IF 'FINITE_SPACE' IN spc1types THEN
    set1 := spc1\finite_space.members;
    IF 'FINITE_SPACE' IN spc2types THEN
      -- Members may have different but equivalent representations and in
      -- different orders.  May also have disguised repeats in same set of members.
      set2 := spc2\finite_space.members;
      REPEAT i := 1 TO SIZEOF (set1);
        cum := cum AND member_of (set1[i], spc2);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      IF cum = TRUE THEN
        REPEAT i := 1 TO SIZEOF (set2);
          cum := cum AND member_of (set2[i], spc1);
          IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
        END_REPEAT;
      END_IF;
      RETURN (cum);
    END_IF;
    IF 'FINITE_INTEGER_INTERVAL' IN spc2types THEN
      set2 := [];
      REPEAT i := spc2\finite_integer_interval.min TO spc2\finite_integer_interval.max;
        set2 := set2 + [i];
      END_REPEAT;
      RETURN (equal_maths_spaces(spc1,make_finite_space(set2)));
    END_IF;
  END_IF;
  IF ('FINITE_INTEGER_INTERVAL' IN spc1types) AND ('FINITE_SPACE' IN spc2types) THEN
    set1 := [];
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      set1 := set1 + [i];
    END_REPEAT;
    RETURN (equal_maths_spaces(make_finite_space(set1),spc2));
  END_IF;
  IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc1types) AND
    ('POLAR_COMPLEX_NUMBER_REGION' IN spc2types) THEN
    -- Quadrants and half spaces have two representations
    RETURN (equal_cregion_pregion(spc1,spc2));
  END_IF;
  IF ('POLAR_COMPLEX_NUMBER_REGION' IN spc1types) AND
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc2types) THEN
    -- Quadrants and half spaces have two representations
    RETURN (equal_cregion_pregion(spc2,spc1));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN spc1types THEN
    base := spc1\uniform_product_space.base;
    expnt := spc1\uniform_product_space.exponent;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
      IF expnt <> spc2\uniform_product_space.exponent THEN  RETURN (FALSE);  END_IF;
      RETURN (equal_maths_spaces(base,spc2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
      factors := spc2\listed_product_space.factors;
      IF expnt <> SIZEOF (factors) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(base,factors[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN spc1types THEN
    factors := spc1\listed_product_space.factors;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
      IF spc2\uniform_product_space.exponent <> SIZEOF (factors) THEN
        RETURN (FALSE);
      END_IF;
      base := spc2\uniform_product_space.base;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(base,factors[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
      factors2 := spc2\listed_product_space.factors;
      IF SIZEOF (factors) <> SIZEOF (factors2) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(factors[i],factors2[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
  END_IF;
  IF ('EXTENDED_TUPLE_SPACE' IN spc1types) AND
    ('EXTENDED_TUPLE_SPACE' IN spc2types) THEN
    RETURN (equal_maths_spaces(spc1\extended_tuple_space.extender,
      spc2\extended_tuple_space.extender) AND equal_maths_spaces(
      spc1\extended_tuple_space.base, spc2\extended_tuple_space.base));
  END_IF;
  IF ('FUNCTION_SPACE' IN spc1types) AND
    ('FUNCTION_SPACE' IN spc2types) THEN
    fs1 := spc1;
    fs2 := spc2;
    IF fs1.domain_constraint <> fs2.domain_constraint THEN
      IF (fs1.domain_constraint = sc_equal) OR (fs2.domain_constraint = sc_equal) THEN
        RETURN (FALSE);
      END_IF;
      IF (fs1.domain_constraint <> sc_subspace) THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.domain_constraint <> sc_subspace) OR
        (fs2.domain_constraint <> sc_member) THEN
        -- Safety check.  Should be unreachable.
        RETURN (UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.domain_constraint,fs1.domain_argument) <>
        any_space_satisfies(fs2.domain_constraint,fs2.domain_argument) THEN
        RETURN (FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.domain_argument)) THEN
        RETURN (FALSE);
      END_IF;
      IF SIZEOF (['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] *
        stripped_typeof(fs1.domain_argument)) = 0 THEN
        RETURN (FALSE);
      END_IF;
      -- Remaining cases too complex.
      RETURN (UNKNOWN);
    END_IF;
    cum := equal_maths_spaces(fs1.domain_argument,fs2.domain_argument);
    IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
    IF fs1.range_constraint <> fs2.range_constraint THEN
      IF (fs1.range_constraint = sc_equal) OR (fs2.range_constraint = sc_equal) THEN
        RETURN (FALSE);
      END_IF;
      IF (fs1.range_constraint <> sc_subspace) THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.range_constraint <> sc_subspace) OR
        (fs2.range_constraint <> sc_member) THEN
        -- Safety check.  Should be unreachable.
        RETURN (UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.range_constraint,fs1.range_argument) <>
        any_space_satisfies(fs2.range_constraint,fs2.range_argument) THEN
        RETURN (FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.range_argument)) THEN
        RETURN (FALSE);
      END_IF;
      IF SIZEOF (['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] *
        stripped_typeof(fs1.range_argument)) = 0 THEN
        RETURN (FALSE);
      END_IF;
      -- Remaining cases too complex.
      RETURN (UNKNOWN);
    END_IF;
    cum := cum AND equal_maths_spaces(fs1.range_argument,fs2.range_argument);
    RETURN (cum);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- equal_maths_spaces
FUNCTION equal_maths_values(val1, val2 : maths_value) : LOGICAL;
  FUNCTION mem_of_vs(val1, val2 : maths_value) : LOGICAL;
    IF NOT has_values_space(val2) THEN RETURN (UNKNOWN);  END_IF;
    IF NOT member_of(val1,values_space_of(val2)) THEN  RETURN (FALSE);  END_IF;
    RETURN (UNKNOWN);
  END_FUNCTION;  -- mem_of_vs
  LOCAL
    types1, types2 : SET OF STRING;
    list1, list2 : LIST OF maths_value;
    cum : LOGICAL := TRUE;
  END_LOCAL;
  IF NOT EXISTS (val1) OR NOT EXISTS (val2) THEN  RETURN (FALSE);  END_IF;
  IF val1 = val2 THEN  RETURN (TRUE);  END_IF;
  types1 := stripped_typeof (val1);
  types2 := stripped_typeof (val2);
  IF ('MATHS_ATOM' IN types1) OR ('COMPLEX_NUMBER_LITERAL' IN types1) THEN
    IF 'MATHS_ATOM'             IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'COMPLEX_NUMBER_LITERAL' IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'LIST'                   IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_SPACE'            IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF ('MATHS_ATOM' IN types2) OR ('COMPLEX_NUMBER_LITERAL' IN types2) THEN
    RETURN (equal_maths_values(val2,val1));
  END_IF;
  IF 'LIST' IN types1 THEN
    IF 'LIST' IN types2 THEN
      list1 := val1;
      list2 := val2;
      IF SIZEOF (list1) <> SIZEOF (list2) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (list1);
        cum := cum AND equal_maths_values (list1[i], list2[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    IF 'MATHS_SPACE'            IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'LIST' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF 'MATHS_SPACE' IN types1 THEN
    IF 'MATHS_SPACE' IN types2 THEN
      RETURN (equal_maths_spaces(val1,val2));
    END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'MATHS_SPACE' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF 'MATHS_FUNCTION' IN types1 THEN
    IF 'MATHS_FUNCTION' IN types2 THEN
      RETURN (equal_maths_functions(val1,val2));
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'MATHS_FUNCTION' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF ('GENERIC_EXPRESSION' IN types1) AND ('GENERIC_EXPRESSION' IN types2) THEN
    IF NOT has_values_space(val1) OR NOT has_values_space(val2) THEN
      RETURN (UNKNOWN);
    END_IF;
    IF NOT compatible_spaces(values_space_of(val1),values_space_of(val2)) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (UNKNOWN);
END_FUNCTION;  -- equal_maths_values
FUNCTION es_subspace_of_es(es1, es2 : elementary_space_enumerators) : BOOLEAN;
  IF NOT EXISTS (es1) OR NOT EXISTS (es2) THEN  RETURN (FALSE);  END_IF;
  IF es1 = es2 THEN  RETURN (TRUE);  END_IF;
  IF es2 = es_generics THEN  RETURN (TRUE);  END_IF;
  IF (es1 = es_booleans) AND (es2 = es_logicals) THEN  RETURN (TRUE);  END_IF;
  IF (es2 = es_numbers) AND ((es1 = es_complex_numbers) OR (es1 = es_reals) OR
    (es1 = es_integers)) THEN  RETURN (TRUE);  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- es_subspace_of_es
FUNCTION expression_is_constant(expr : generic_expression) : BOOLEAN;
  RETURN (bool(SIZEOF (free_variables_of (expr)) = 0));
END_FUNCTION;  -- expression_is_constant
FUNCTION extract_factors(tspace : tuple_space;
                         m, n   : INTEGER) : tuple_space;
  LOCAL
    tsp : tuple_space := the_zero_tuple_space;
  END_LOCAL;
  REPEAT i := m TO n;
    tsp := assoc_product_space (tsp, factor_space (tspace, i));
  END_REPEAT;
  RETURN (tsp);
END_FUNCTION;  -- extract_factors
FUNCTION extremal_position_check(fun : linearized_table_function) : BOOLEAN;
  LOCAL
    source_domain : maths_space;
    source_interval : finite_integer_interval;
    index : INTEGER := 1;
    base : INTEGER;
    shape : LIST OF positive_integer;
    ndim : positive_integer;
    slo, shi : INTEGER;
    sublo : LIST OF INTEGER := [];
    subhi : LIST OF INTEGER := [];
  END_LOCAL;
  IF NOT EXISTS (fun) THEN  RETURN (FALSE);  END_IF;
  source_domain := factor1 (fun.source.domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (source_domain) THEN
    source_domain := factor1 (source_domain);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (source_domain)) THEN
    RETURN (FALSE);
  END_IF;
  source_interval := source_domain;
  base := fun\explicit_table_function.index_base;
  shape := fun\explicit_table_function.shape;
  IF (schema_prefix + 'STANDARD_TABLE_FUNCTION') IN TYPEOF (fun) THEN
    REPEAT j := 1 TO SIZEOF (shape);
      index := index * shape[j];
    END_REPEAT;
    index := fun.first + index - 1;
    RETURN (bool({source_interval.min <= index <= source_interval.max}));
  END_IF;
  IF (schema_prefix + 'REGULAR_TABLE_FUNCTION') IN TYPEOF (fun) THEN
    ndim := SIZEOF (fun\explicit_table_function.shape);
    REPEAT j:= 1 TO ndim;
      slo := base;
      shi := base + shape[j] - 1;
      IF fun\regular_table_function.increments[j] >= 0 THEN
        INSERT (sublo, slo, j-1);
        INSERT (subhi, shi, j-1);
      ELSE
        INSERT (sublo, shi, j-1);
        INSERT (subhi, slo, j-1);
      END_IF;
    END_REPEAT;
    index := regular_indexing (sublo, base, shape,
      fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min <= index <= source_interval.max}) THEN
      RETURN (FALSE);
    END_IF;
    index := regular_indexing (subhi, base, shape,
      fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min <= index <= source_interval.max}) THEN
      RETURN (FALSE);
    END_IF;
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- extremal_position_check
FUNCTION factor1(tspace : tuple_space) : maths_space;
  LOCAL
    typenames : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    RETURN (tspace\uniform_product_space.base);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    RETURN (tspace\listed_product_space.factors[1]);
    -- This path could return the indeterminate value if the list is empty.
    -- This is the correct result for this case.
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames THEN
    RETURN (factor1 (tspace\extended_tuple_space.base));
  END_IF;
  -- Should not be reachable.
  RETURN (?);
END_FUNCTION;  -- factor1
FUNCTION factor_space(tspace : tuple_space;
                      idx    : positive_integer) : maths_space;
  LOCAL
    typenames : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    IF idx <= tspace\uniform_product_space.exponent THEN
      RETURN (tspace\uniform_product_space.base);
    END_IF;
    RETURN (?);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    IF idx <= SIZEOF (tspace\listed_product_space.factors) THEN
      RETURN (tspace\listed_product_space.factors[idx]);
    END_IF;
    RETURN (?);
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames THEN
    IF idx <= space_dimension (tspace\extended_tuple_space.base) THEN
      RETURN (factor_space (tspace\extended_tuple_space.base, idx));
    END_IF;
    RETURN (tspace\extended_tuple_space.extender);
  END_IF;
  -- Should not be reachable.
  RETURN (?);
END_FUNCTION;  -- factor_space
FUNCTION free_variables_of(expr : generic_expression) : SET OF generic_variable;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(expr);
    result : SET OF generic_variable := [];
    exprs : LIST OF generic_expression := [];
  END_LOCAL;
  IF 'GENERIC_LITERAL' IN typenames THEN
    RETURN (result);
  END_IF;
  IF 'GENERIC_VARIABLE' IN typenames THEN
    result := result + expr;
    RETURN (result);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN typenames THEN
    exprs := QUERY (ge <* expr\multiple_arity_generic_expression.operands |
      NOT (ge IN expr\quantifier_expression.variables));
    REPEAT i := 1 TO SIZEOF (exprs);
      result := result + free_variables_of (exprs[i]);
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF (expr\quantifier_expression.variables);
      result := result - expr\quantifier_expression.variables[i];
    END_REPEAT;
    RETURN (result);
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN typenames THEN
    RETURN (free_variables_of (expr\unary_generic_expression.operand));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN typenames THEN
    result := free_variables_of (expr\binary_generic_expression.operands[1]);
    RETURN (result + free_variables_of (expr\binary_generic_expression.operands[2]));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (expr\multiple_arity_generic_expression.operands);
      result := result + free_variables_of (
        expr\multiple_arity_generic_expression.operands[i]);
    END_REPEAT;
    RETURN (result);
  END_IF;
  -- In this case the subtype shall not contain any variable (see IP1 in
  -- generic_expression).
  RETURN (result);
END_FUNCTION;  -- free_variables_of
FUNCTION function_applicability(func      : maths_function_select;
                                arguments : LIST [1:?] OF maths_value) : BOOLEAN;
  LOCAL
    domain : tuple_space := convert_to_maths_function(func).domain;
    domain_types : SET OF STRING := TYPEOF (domain);
    narg : positive_integer := SIZEOF (arguments);
    arg : generic_expression;
  END_LOCAL;
  IF (schema_prefix + 'PRODUCT_SPACE') IN domain_types THEN
    IF space_dimension (domain) <> narg THEN  RETURN (FALSE);  END_IF;
  ELSE
    IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN domain_types THEN
      IF space_dimension (domain) > narg THEN  RETURN (FALSE);  END_IF;
    ELSE
      RETURN (FALSE);  -- Should be unreachable
    END_IF;
  END_IF;
  REPEAT i := 1 TO narg;
    arg := convert_to_operand (arguments[i]);
    IF NOT has_values_space (arg) THEN  RETURN (FALSE);  END_IF;
    IF NOT compatible_spaces (factor_space (domain, i), values_space_of (arg)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- function_applicability
FUNCTION function_is_1d_array(func : maths_function) : BOOLEAN;
  LOCAL
    temp : maths_space;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) <> 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (temp) THEN
    IF space_dimension (temp) <> 1 THEN  RETURN (FALSE);  END_IF;
    temp := factor1 (temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp) THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- function_is_1d_array
FUNCTION function_is_1d_table(func : maths_function) : BOOLEAN;
  LOCAL
    temp : maths_space;
    itvl : finite_integer_interval;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) <> 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (temp) THEN
    IF space_dimension (temp) <> 1 THEN  RETURN (FALSE);  END_IF;
    temp := factor1 (temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp) THEN
    itvl := temp;
    RETURN (bool((itvl.min = 0) OR (itvl.min = 1)));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- function_is_1d_table
FUNCTION function_is_2d_table(func : maths_function) : BOOLEAN;
  LOCAL
    temp : maths_space;
    pspace : product_space;
    itvl1, itvl2 : finite_integer_interval;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) <> 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF NOT ('PRODUCT_SPACE' IN stripped_typeof(temp)) THEN  RETURN (FALSE);  END_IF;
  pspace := temp;
  IF space_dimension (pspace) <> 2 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (pspace);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp)) THEN
    RETURN (FALSE);
  END_IF;
  itvl1 := temp;
  temp := factor_space (pspace, 2);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp)) THEN
    RETURN (FALSE);
  END_IF;
  itvl2 := temp;
  RETURN (bool((itvl1.min = itvl2.min) AND ((itvl1.min = 0) OR (itvl1.min = 1))));
END_FUNCTION;  -- function_is_2d_table
FUNCTION function_is_array(func : maths_function) : BOOLEAN;
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (tspace)) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- function_is_array
FUNCTION function_is_table(func : maths_function) : BOOLEAN;
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
    base : INTEGER;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (tspace)) THEN
    RETURN (FALSE);
  END_IF;
  temp := factor1 (tspace);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  base := temp\finite_integer_interval.min;
  IF (base <> 0) AND (base <> 1) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 2 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (FALSE);
    END_IF;
    IF temp\finite_integer_interval.min <> base THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- function_is_table
FUNCTION has_values_space(expr : generic_expression) : BOOLEAN;
  LOCAL
    typenames : SET OF STRING := stripped_typeof (expr);
  END_LOCAL;
  IF 'EXPRESSION' IN typenames THEN
    RETURN (bool(('NUMERIC_EXPRESSION' IN typenames) OR
      ('STRING_EXPRESSION' IN typenames) OR
      ('BOOLEAN_EXPRESSION' IN typenames)));
  END_IF;
  IF 'MATHS_FUNCTION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'FUNCTION_APPLICATION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_SPACE' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_VARIABLE' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'DEPENDENT_VARIABLE_DEFINITION' IN typenames THEN
    RETURN (has_values_space (expr\unary_generic_expression.operand));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'LOGICAL_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'BINARY_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_EXPRESSION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'DEFINITE_INTEGRAL_EXPRESSION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- has_values_space
FUNCTION list_selected_components(aggr : AGGREGATE OF LIST OF maths_value;
                                  k    : positive_integer) : LIST OF maths_value;
  LOCAL
    result : LIST OF maths_value := [];
    j : INTEGER := 0;
  END_LOCAL;
  REPEAT i := LOINDEX (aggr) TO HIINDEX (aggr);
    IF k <= SIZEOF (aggr[i]) THEN
      INSERT (result, aggr[i][k], j);
      j := j + 1;
    END_IF;
  END_REPEAT;
  RETURN (result);
END_FUNCTION;  -- list_selected_components
FUNCTION make_abstracted_expression_function(
                                    operands : LIST [2:?] OF generic_expression)
                                   : abstracted_expression_function;
  RETURN (abstracted_expression_function()
    || maths_function()
      || generic_expression()
    || quantifier_expression (remove_first (operands))  -- derived
      || multiple_arity_generic_expression (operands) );
END_FUNCTION;  -- make_abstracted_expression_function
FUNCTION make_atom_based_literal(lit_value : atom_based_value) : atom_based_literal;
  RETURN (atom_based_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_atom_based_literal
FUNCTION make_b_spline_basis(degree         : nonnegative_integer;
                             repeated_knots : LIST [2:?] OF REAL) : b_spline_basis;
  RETURN (b_spline_basis (degree, repeated_knots)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_b_spline_basis
FUNCTION make_b_spline_function(coef  : maths_function;
                                bases : LIST [1:?] OF b_spline_basis)
                               : b_spline_function;
  RETURN (b_spline_function (bases)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (coef) );
END_FUNCTION;  -- make_b_spline_function
FUNCTION make_banded_matrix(index_base    : zero_or_one;
                            shape         : LIST [1:?] OF positive_integer;
                            source        : maths_function;
                            first         : INTEGER;
                            default_entry : maths_value;
                            below         : INTEGER;
                            above         : INTEGER;
                            order         : ordering_type) : banded_matrix;
  RETURN (banded_matrix (default_entry, below, above, order)
    || linearized_table_function (first)
      || explicit_table_function (index_base, shape)
        || maths_function()
          || generic_expression()
      || unary_generic_expression (source) );
END_FUNCTION;  -- make_banded_matrix
FUNCTION make_basic_sparse_matrix(index_base    : zero_or_one;
                                  shape         : LIST [1:?] OF positive_integer;
                                  operands      : LIST [3:3] OF maths_function;
                                  default_entry : maths_value;
                                  order         : ordering_type)
                                 : basic_sparse_matrix;
  RETURN (basic_sparse_matrix (default_entry, order)
    || explicit_table_function (index_base, shape)
      || maths_function()
        || generic_expression()
    || multiple_arity_generic_expression (operands) );
END_FUNCTION;  -- make_basic_sparse_matrix
FUNCTION make_binary_literal(lit_value : BINARY) : binary_literal;
  RETURN (binary_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_binary_literal
FUNCTION make_boolean_literal(lit_value : BOOLEAN) : boolean_literal;
  RETURN (boolean_literal (lit_value)
    || simple_boolean_expression()
      || boolean_expression()
        || expression()
          || generic_expression()
      || simple_generic_expression()
    || generic_literal() );
END_FUNCTION;  -- make_boolean_literal
FUNCTION make_cartesian_complex_number_region(real_constraint : real_interval;
                                              imag_constraint : real_interval)
                                             : cartesian_complex_number_region;
  RETURN (cartesian_complex_number_region (real_constraint, imag_constraint)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_cartesian_complex_number_region
FUNCTION make_complex_number_literal(rpart, ipart : REAL) : complex_number_literal;
  RETURN (complex_number_literal (rpart, ipart)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_complex_number_literal
FUNCTION make_constant_function(sole_value   : maths_value;
                                src_of_domn  : maths_space_or_function)
                               : constant_function;
  RETURN (constant_function (sole_value, src_of_domn)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_constant_function
FUNCTION make_cos_expression(operand : numeric_expression) : cos_expression;
  RETURN (cos_expression()
    || unary_numeric_call_expression()
      || unary_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || unary_generic_expression (operand) );
END_FUNCTION;  -- make_cos_expression
FUNCTION make_definite_integral_expression(
                                   operands     : LIST [2:4] OF generic_expression;
                                   loinf, upinf : BOOLEAN)
                                          : definite_integral_expression;
  RETURN (definite_integral_expression (loinf, upinf)
    || quantifier_expression ([operands[2]])
      || multiple_arity_generic_expression (operands)
        || generic_expression() );
END_FUNCTION;  -- make_definite_integral_expression
FUNCTION make_definite_integral_function(integrand    : maths_function;
                                         varintg      : input_selector;
                                         loinf, upinf : BOOLEAN)
                                        : definite_integral_function;
  RETURN (definite_integral_function (varintg, loinf, upinf)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (integrand) );
END_FUNCTION;  -- make_definite_integral_function
FUNCTION make_elementary_function(func_id : elementary_function_enumerators)
                                 : elementary_function;
  RETURN (elementary_function (func_id)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_elementary_function
FUNCTION make_elementary_space(space_id : elementary_space_enumerators)
                              : elementary_space;
  RETURN (elementary_space (space_id)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_elementary_space
FUNCTION make_environment(varbl : generic_variable;
                          sem   : variable_semantics) : environment;
  RETURN (environment (varbl, sem) );
END_FUNCTION;  -- make_environment
FUNCTION make_expression_denoted_function(expression : generic_expression)
                                         : expression_denoted_function;
  RETURN (expression_denoted_function()
    || maths_function()
      || generic_expression()
    || unary_generic_expression (expression) );
END_FUNCTION;  -- make_expression_denoted_function
 FUNCTION make_extended_tuple_space(base : tuple_space;
                                   extender : maths_space) : extended_tuple_space;
  RETURN (extended_tuple_space (base, extender)
    || maths_space ()
      || generic_expression()
    || generic_literal ()
      || simple_generic_expression() );
END_FUNCTION;  -- make_extended_tuple_space
FUNCTION make_finite_function(pairs : SET [1:?] OF LIST [2:2] OF maths_value)
                             : finite_function;
  RETURN (finite_function (pairs)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_finite_function
FUNCTION make_finite_integer_interval(min : INTEGER;
                                      max : INTEGER) : finite_integer_interval;
  RETURN (finite_integer_interval (min, max)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_finite_integer_interval
FUNCTION make_finite_real_interval(min    : REAL;
                                   minclo : open_closed;
                                   max    : REAL;
                                   maxclo : open_closed) : finite_real_interval;
  RETURN (finite_real_interval (min, minclo, max, maxclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_finite_real_interval
FUNCTION make_finite_space(members : SET OF maths_value) : finite_space;
  RETURN (finite_space (members)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_finite_space
FUNCTION make_function_application(afunction : maths_function_select;
                                   arguments : LIST [1:?] OF maths_value)
                                  : function_application;
  RETURN (function_application (afunction, arguments)
    || multiple_arity_generic_expression (convert_to_maths_function (afunction) +
      convert_to_operands (arguments))  -- derived
      || generic_expression() );
END_FUNCTION;  -- make_function_application
FUNCTION make_function_space(domain_constraint : space_constraint_type;
                             domain_argument   : maths_space;
                             range_constraint  : space_constraint_type;
                             range_argument    : maths_space) : function_space;
  RETURN (function_space (domain_constraint, domain_argument, range_constraint,
    range_argument)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_function_space
FUNCTION make_general_linear_function(mat       : maths_function;
                                      sum_index : one_or_two)
                                     : general_linear_function;
  RETURN (general_linear_function (sum_index)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (mat) );
END_FUNCTION;  -- make_general_linear_function
FUNCTION make_int_literal(lit_value : INTEGER) : int_literal;
  RETURN (int_literal ()
    || literal_number(lit_value)
      || simple_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || simple_generic_expression()
      || generic_literal() );
END_FUNCTION;  -- make_int_literal
FUNCTION make_integer_interval_from_min(min : INTEGER)
  : integer_interval_from_min;
  RETURN (integer_interval_from_min (min)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_integer_interval_from_min
FUNCTION make_listed_complex_number_data(index_base : zero_or_one;
                                         values     : LIST [2:?] OF REAL)
                                        : listed_complex_number_data;
  RETURN (listed_complex_number_data (values)
    || explicit_table_function (index_base, [SIZEOF (values)/2])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_complex_number_data
FUNCTION make_listed_data(index_base  : zero_or_one;
                          values      : LIST [2:?] OF maths_value;
                          value_range : maths_space) : listed_data;
  RETURN (listed_data (values, value_range)
    || explicit_table_function (index_base, [SIZEOF (values)])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_data
FUNCTION make_listed_integer_data(index_base : zero_or_one;
                                  values     : LIST [1:?] OF INTEGER)
                                 : listed_integer_data;
  RETURN (listed_integer_data (values)
    || explicit_table_function (index_base, [SIZEOF (values)])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_integer_data
FUNCTION make_listed_product_space(factors : LIST OF maths_space)
                                  : listed_product_space;
  RETURN (listed_product_space (factors)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_product_space
FUNCTION make_listed_real_data(index_base : zero_or_one;
                               values     : LIST [1:?] OF REAL)
                              : listed_real_data;
  RETURN (listed_real_data (values)
    || explicit_table_function (index_base, [SIZEOF (values)])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_real_data
FUNCTION make_logical_literal(lit_value : LOGICAL) : logical_literal;
  RETURN (logical_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_logical_literal
FUNCTION make_maths_enum_literal(lit_value : maths_enum_atom) : maths_enum_literal;
  RETURN (maths_enum_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_maths_enum_literal

FUNCTION make_maths_real_variable(values_space : maths_space;
                                  name         : label) : maths_real_variable;
    
   RETURN (expression() || numeric_expression() || simple_numeric_expression() 
   ||  maths_real_variable() 
    || maths_variable (values_space, name)
      || generic_variable()
        || simple_generic_expression()
          || generic_expression()
    || real_numeric_variable()
      || numeric_variable()
        || variable() );
  END_FUNCTION;

FUNCTION make_maths_tuple_literal(lit_value : LIST OF maths_value)
                                 : maths_tuple_literal;
  RETURN (maths_tuple_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_maths_tuple_literal
FUNCTION make_mult_expression(operands : LIST [2:?] OF generic_expression)
                             : mult_expression;
  RETURN (mult_expression()
    || multiple_arity_numeric_expression()
      || numeric_expression()
        || expression()
          || generic_expression()
      || multiple_arity_generic_expression (operands) );
END_FUNCTION;  -- make_mult_expression
FUNCTION make_parallel_composed_function(srcdom    : maths_space_or_function;
                                         prepfuncs : LIST [2:?] OF maths_function;
                                         finfunc   : maths_function_select)
                                        : parallel_composed_function;
  RETURN (parallel_composed_function (srcdom, prepfuncs, finfunc)
    || maths_function()
      || generic_expression()
    || multiple_arity_generic_expression (convert_to_operands_prcmfn (
      srcdom, prepfuncs, finfunc)) );  -- derived
END_FUNCTION;  -- make_parallel_composed_function
FUNCTION make_partial_derivative_expression(derivand : generic_expression;
                                            dvars    : LIST [1:?] OF maths_variable;
                                            extend   : extension_options)
                                           : partial_derivative_expression;
  RETURN (partial_derivative_expression (dvars, extend)
    || unary_generic_expression (derivand)
      || generic_expression() );
END_FUNCTION;  -- make_partial_derivative_expression
FUNCTION make_partial_derivative_function(derivand : maths_function;
                                          dvars    : LIST [1:?] OF input_selector;
                                          extend   : extension_options)
                                         : partial_derivative_function;
  RETURN (partial_derivative_function (dvars, extend)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (derivand) );
END_FUNCTION;  -- make_partial_derivative_function
FUNCTION make_polar_complex_number_region(centre         : complex_number_literal;
                                          dis_constraint : real_interval;
                                          dir_constraint : finite_real_interval)
                                         : polar_complex_number_region;
  RETURN (polar_complex_number_region (centre, dis_constraint, dir_constraint)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_polar_complex_number_region
FUNCTION make_rationalize_function(fun : maths_function) : rationalize_function;
  RETURN (rationalize_function()
    || maths_function()
      || generic_expression()
    || unary_generic_expression (fun) );
END_FUNCTION;  -- make_rationalize_function
FUNCTION make_real_interval_from_min(min    : REAL;
                                     minclo : open_closed) : real_interval_from_min;
  RETURN (real_interval_from_min (min, minclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_real_interval_from_min
FUNCTION make_real_interval_to_max(max    : REAL;
                                   maxclo : open_closed) : real_interval_to_max;
  RETURN (real_interval_to_max (max, maxclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_real_interval_to_max
FUNCTION make_real_literal(lit_value : REAL) : real_literal;
  RETURN (real_literal ()
    || literal_number(lit_value)
      || simple_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || simple_generic_expression()
      || generic_literal() );
END_FUNCTION;  -- make_real_literal
FUNCTION make_regular_table_function(index_base : zero_or_one;
                                     shape      : LIST [1:?] OF positive_integer;
                                     operand    : maths_function;
                                     first      : INTEGER;
                                     increments : LIST [1:?] OF INTEGER)
                                    : regular_table_function;
  RETURN (regular_table_function (increments)
    || linearized_table_function (first)
      || explicit_table_function (index_base, shape)
        || maths_function()
          || generic_expression()
      || unary_generic_expression (operand) );
END_FUNCTION;  -- make_regular_table_function
FUNCTION make_reindexed_array_function(func       : maths_function;
                                       start_idxs : LIST [1:?] OF INTEGER)
                                      : reindexed_array_function;
  RETURN (reindexed_array_function(start_idxs)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (func) );
END_FUNCTION;  -- make_reindexed_array_function
FUNCTION make_repackaging_function(operand         : maths_function;
                                   input_repack    : repackage_options;
                                   output_repack   : repackage_options;
                                   selected_output : nonnegative_integer)
                                  : repackaging_function;
  RETURN (repackaging_function (input_repack, output_repack, selected_output)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (operand) );
END_FUNCTION;  -- make_repackaging_function
FUNCTION make_selector_function(selector    : input_selector;
                                src_of_domn : maths_space_or_function)
                               : selector_function;
  RETURN (selector_function (selector, src_of_domn)
    || maths_function()
       || generic_expression()
    || generic_literal()
       || simple_generic_expression() );
END_FUNCTION;  -- make_selector_function
FUNCTION make_series_composed_function(functions : LIST [2:?] OF maths_function)
                                      : series_composed_function;
  RETURN (series_composed_function()
    || maths_function()
      || generic_expression()
    || multiple_arity_generic_expression (functions) );
END_FUNCTION;  -- make_series_composed_function
FUNCTION make_sin_expression(operand : numeric_expression) : sin_expression;
  RETURN (sin_expression()
    || unary_numeric_call_expression()
      || unary_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || unary_generic_expression (operand) );
END_FUNCTION;  -- make_sin_expression
FUNCTION make_standard_table_function(index_base : zero_or_one;
                                      shape      : LIST [1:?] OF positive_integer;
                                      operand    : maths_function;
                                      first      : INTEGER;
                                      order      : ordering_type)
                                     : standard_table_function;
  RETURN (standard_table_function (order)
    || linearized_table_function (first)
      || explicit_table_function (index_base, shape)
        || maths_function()
          || generic_expression()
      || unary_generic_expression (operand) );
END_FUNCTION;  -- make_standard_table_function
FUNCTION make_strict_triangular_matrix(index_base    : zero_or_one;
                                       shape         : LIST [1:?] OF positive_integer;
                                       source        : maths_function;
                                       first         : INTEGER;
                                       default_entry : maths_value;
                                       lo_up         : lower_upper;
                                       order         : ordering_type;
                                       main_diagonal_value : maths_value)
                                      : strict_triangular_matrix;
  RETURN (strict_triangular_matrix (main_diagonal_value)
    || triangular_matrix (default_entry, lo_up, order)
      || linearized_table_function (first)
        || explicit_table_function (index_base, shape)
          || maths_function()
            || generic_expression()
        || unary_generic_expression (source) );
END_FUNCTION;  -- make_strict_triangular_matrix
FUNCTION make_string_literal(lit_value : STRING) : string_literal;
  RETURN (string_literal (lit_value)
    || simple_string_expression()
      || string_expression()
        || expression()
          || generic_expression()
      || simple_generic_expression()
    || generic_literal() );
END_FUNCTION;  -- make_string_literal
FUNCTION make_unary_minus_expression(operand : numeric_expression)
  : unary_minus_expression;
  RETURN (unary_minus_expression()
    || unary_numeric_call_expression()
      || unary_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || unary_generic_expression (operand) );
END_FUNCTION;  -- make_unary_minus_expression
FUNCTION make_uniform_product_space(base     : maths_space;
                                    exponent : positive_integer)
                                   : uniform_product_space;
  RETURN (uniform_product_space (base, exponent)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_uniform_product_space
FUNCTION max_exists(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  RETURN (bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) OR
    ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
    ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types)));
END_FUNCTION;  -- max_exists
FUNCTION max_included(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) THEN
    RETURN (TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (bool(spc\finite_real_interval.max_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types) THEN
    RETURN (bool(spc\real_interval_to_max.max_closure = closed));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- max_included
FUNCTION member_of(val : GENERIC:G;
                   spc : maths_space) : LOGICAL;

  -- Trivial function introduced to avoid NIST Fedex compiler error
  FUNCTION fedex(val : AGGREGATE OF GENERIC:X;
                 i   : INTEGER) : GENERIC:X;
    RETURN (val[i]);
  END_FUNCTION;  -- fedex

  LOCAL
    v : maths_value := simplify_maths_value (convert_to_maths_value (val));
    vtypes : SET OF STRING := stripped_typeof (v);
    s : maths_space := simplify_maths_space (spc);
    stypes : SET OF STRING := stripped_typeof (s);
    tmp_int : INTEGER;
    tmp_real : REAL;
    tmp_cmplx : complex_number_literal;
    lgcl, cum : LOGICAL;
    vspc, sspc : maths_space;
    smem : SET OF maths_value;
    factors : LIST OF maths_space;
  END_LOCAL;
  IF NOT EXISTS (s) THEN
    RETURN (FALSE);
  END_IF;
  IF NOT EXISTS (v) THEN
    RETURN (s = the_generics);
  END_IF;
  IF ('GENERIC_EXPRESSION' IN vtypes) AND
    NOT ('MATHS_SPACE' IN vtypes) AND
    NOT ('MATHS_FUNCTION' IN vtypes) AND
    NOT ('COMPLEX_NUMBER_LITERAL' IN vtypes) THEN
    IF has_values_space (v) THEN
      vspc := values_space_of (v);
      IF subspace_of (vspc, s) THEN
        RETURN (TRUE);
      END_IF;
      IF NOT compatible_spaces (vspc, s) THEN
        RETURN (FALSE);
      END_IF;
      RETURN (UNKNOWN);
    END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN stypes THEN
    CASE s\elementary_space.space_id OF
    es_numbers :  RETURN (('NUMBER' IN vtypes) OR
                          ('COMPLEX_NUMBER_LITERAL' IN vtypes));
    es_complex_numbers :  RETURN ('COMPLEX_NUMBER_LITERAL' IN vtypes);
    es_reals :  RETURN (('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes));
    es_integers :  RETURN ('INTEGER' IN vtypes);
    es_logicals :  RETURN ('LOGICAL' IN vtypes);
    es_booleans :  RETURN ('BOOLEAN' IN vtypes);
    es_strings :  RETURN ('STRING' IN vtypes);
    es_binarys :  RETURN ('BINARY' IN vtypes);
    es_maths_spaces :  RETURN ('MATHS_SPACE' IN vtypes);
    es_maths_functions :  RETURN ('MATHS_FUNCTION' IN vtypes);
    es_generics :  RETURN (TRUE);
    END_CASE;
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN ({s\finite_integer_interval.min <= tmp_int <=
        s\finite_integer_interval.max});
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN (s\integer_interval_from_min.min <= tmp_int);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN (tmp_int <= s\integer_interval_to_max.max);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\finite_real_interval.min_closure = closed THEN
        IF s\finite_real_interval.max_closure = closed THEN
          RETURN ({s\finite_real_interval.min <= tmp_real <=
            s\finite_real_interval.max});
        ELSE
          RETURN ({s\finite_real_interval.min <= tmp_real <
            s\finite_real_interval.max});
        END_IF;
      ELSE
        IF s\finite_real_interval.max_closure = closed THEN
          RETURN ({s\finite_real_interval.min < tmp_real <=
            s\finite_real_interval.max});
        ELSE
          RETURN ({s\finite_real_interval.min < tmp_real <
            s\finite_real_interval.max});
        END_IF;
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\real_interval_from_min.min_closure = closed THEN
        RETURN (s\real_interval_from_min.min <= tmp_real);
      ELSE
        RETURN (s\real_interval_from_min.min < tmp_real);
     END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\real_interval_to_max.max_closure = closed THEN
        RETURN (tmp_real <= s\real_interval_to_max.max);
      ELSE
        RETURN (tmp_real < s\real_interval_to_max.max);
     END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN stypes THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes THEN
      RETURN (member_of(v\complex_number_literal.real_part,
        s\cartesian_complex_number_region.real_constraint) AND
        member_of(v\complex_number_literal.imag_part,
        s\cartesian_complex_number_region.imag_constraint));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN stypes THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes THEN
      tmp_cmplx := v;
      tmp_cmplx.real_part := tmp_cmplx.real_part -
        s\polar_complex_number_region.centre.real_part;
      tmp_cmplx.imag_part := tmp_cmplx.imag_part -
        s\polar_complex_number_region.centre.imag_part;
      tmp_real := SQRT (tmp_cmplx.real_part**2 + tmp_cmplx.imag_part**2);
      IF NOT member_of(tmp_real,
        s\polar_complex_number_region.distance_constraint) THEN
        RETURN (FALSE);
      END_IF;
      IF tmp_real = 0.0 THEN
        RETURN (TRUE);  -- The centre has no direction.
      END_IF;
      tmp_real := atan2(tmp_cmplx.imag_part,tmp_cmplx.real_part);
      RETURN (member_of(tmp_real,
        s\polar_complex_number_region.direction_constraint) OR
        member_of(tmp_real + 2.0*PI,
        s\polar_complex_number_region.direction_constraint));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN stypes THEN
    smem := s\finite_space.members;
    cum := FALSE;
    REPEAT i := 1 TO SIZEOF (smem);
      cum := cum OR equal_maths_values(v,smem[i]);
      IF cum = TRUE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      IF SIZEOF (v) = s\uniform_product_space.exponent THEN
        sspc := s\uniform_product_space.base;
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],sspc);
--          cum := cum AND member_of (fedex (v, i), sspc);
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      factors := s\listed_product_space.factors;
      IF SIZEOF (v) = SIZEOF (factors) THEN
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],factors[i]);
--          cum := cum AND member_of (fedex (v, i), factors[i]);
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      sspc := s\extended_tuple_space.base;
      tmp_int := space_dimension(sspc);
      IF SIZEOF (v) >= tmp_int THEN
        cum := TRUE;
        REPEAT i := 1 TO tmp_int;
          cum := cum AND member_of(v[i],factor_space(sspc,i));
--          cum := cum AND member_of (fedex (v, i), factor_space (sspc, i));
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        sspc := s\extended_tuple_space.extender;
        REPEAT i := tmp_int+1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],sspc);
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes THEN
    IF 'MATHS_FUNCTION' IN vtypes THEN
      vspc := v\maths_function.domain;
      sspc := s\function_space.domain_argument;
      CASE s\function_space.domain_constraint OF
      sc_equal : cum := equal_maths_spaces (vspc, sspc);
      sc_subspace : cum := subspace_of (vspc, sspc);
      sc_member : cum := member_of (vspc, sspc);
      END_CASE;
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
      vspc := v\maths_function.range;
      sspc := s\function_space.range_argument;
      CASE s\function_space.range_constraint OF
      sc_equal : cum := cum AND equal_maths_spaces (vspc, sspc);
      sc_subspace : cum := cum AND subspace_of (vspc, sspc);
      sc_member : cum := cum AND member_of (vspc, sspc);
      END_CASE;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Should be unreachable
  RETURN (UNKNOWN);
END_FUNCTION;  -- member_of
FUNCTION min_exists(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  RETURN (bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) OR
    ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
    ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types)));
END_FUNCTION;  -- min_exists
FUNCTION min_included(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (bool(spc\finite_real_interval.min_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (bool(spc\real_interval_from_min.min_closure = closed));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- min_included
FUNCTION no_cyclic_domain_reference(ref  : maths_space_or_function;
                                    used : SET OF maths_function) : BOOLEAN;
  LOCAL
    typenames : SET OF STRING := TYPEOF (ref);
    func      : maths_function;
  END_LOCAL;
  IF (NOT EXISTS (ref)) OR (NOT EXISTS (used)) THEN
    RETURN (FALSE);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames THEN
    RETURN (TRUE);
  END_IF;
  func := ref;
  IF func IN used THEN
    RETURN (FALSE);
  END_IF;
  IF (schema_prefix + 'CONSTANT_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (func\constant_function.source_of_domain,
      used + [func]));
  END_IF;
  IF (schema_prefix + 'SELECTOR_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (func\selector_function.source_of_domain,
      used + [func]));
  END_IF;
  IF (schema_prefix + 'PARALLEL_COMPOSED_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (
      func\parallel_composed_function.source_of_domain, used + [func]));
  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- no_cyclic_domain_reference
FUNCTION no_cyclic_space_reference(spc  : maths_space;
                                   refs : SET OF maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING;
    refs_plus : SET OF maths_space;
  END_LOCAL;
  IF (spc IN refs) THEN
    RETURN (FALSE);
  END_IF;
  types := TYPEOF (spc);
  refs_plus := refs + spc;
  IF (schema_prefix + 'FINITE_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (sp <* QUERY (mem <* spc\finite_space.members |
      (schema_prefix + 'MATHS_SPACE') IN TYPEOF (mem)) |
      NOT no_cyclic_space_reference (sp, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\uniform_product_space.base, refs_plus));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (fac <* spc\listed_product_space.factors |
      NOT no_cyclic_space_reference (fac, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\extended_tuple_space.base, refs_plus)
      AND no_cyclic_space_reference (spc\extended_tuple_space.extender, refs_plus));
  END_IF;
  -- spc contains no references to other spaces
  RETURN (TRUE);
END_FUNCTION;  -- no_cyclic_space_reference
FUNCTION nondecreasing(lr : LIST OF REAL) : BOOLEAN;
  IF NOT EXISTS (lr) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT j := 2 TO SIZEOF (lr);
    IF lr[j] < lr[j-1] THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
FUNCTION number_superspace_of(spc : maths_space) : elementary_space;
  IF subspace_of_es(spc,es_integers) THEN  RETURN (the_integers);  END_IF;
  IF subspace_of_es(spc,es_reals)    THEN  RETURN (the_reals);     END_IF;
  IF subspace_of_es(spc,es_complex_numbers) THEN  RETURN (the_complex_numbers); END_IF;
  IF subspace_of_es(spc,es_numbers)  THEN  RETURN (the_numbers);   END_IF;
  RETURN (?);
END_FUNCTION;  -- number_superspace_of
FUNCTION number_tuple_subspace_check(spc : maths_space) : LOGICAL;
  LOCAL
    types : SET OF STRING := stripped_typeof(spc);
    factors : LIST OF maths_space;
    cum : LOGICAL := TRUE;
  END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN types THEN
    RETURN (subspace_of_es(spc\uniform_product_space.base,es_numbers));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF (factors);
      cum := cum AND subspace_of_es(factors[i],es_numbers);
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types THEN
    cum := subspace_of_es(spc\extended_tuple_space.extender,es_numbers);
    cum := cum AND number_tuple_subspace_check(spc\extended_tuple_space.base);
    RETURN (cum);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;
FUNCTION one_tuples_of(spc : maths_space) : tuple_space;
  RETURN (make_uniform_product_space (spc, 1));
END_FUNCTION;  -- one_tuples_of
FUNCTION parallel_composed_function_composability_check(
                                      funcs  : LIST OF maths_function;
                                      final  : maths_function_select) : BOOLEAN;
  LOCAL
    tplsp : tuple_space := the_zero_tuple_space;
    finfun : maths_function := convert_to_maths_function (final);
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (funcs);
    tplsp := assoc_product_space (tplsp, funcs[i].range);
  END_REPEAT;
  RETURN (compatible_spaces (tplsp, finfun.domain));
END_FUNCTION;  -- parallel_composed_function_composability_check
FUNCTION parallel_composed_function_domain_check(
                                comdom : tuple_space;
                                funcs  : LIST OF maths_function) : BOOLEAN;
  REPEAT i := 1 TO SIZEOF (funcs);
    IF NOT (compatible_spaces (comdom, funcs[i].domain)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- parallel_composed_function_domain_check
FUNCTION parse_express_identifier(s : STRING;
                                  i : positive_integer) : positive_integer;
  LOCAL
    k : positive_integer;
  END_LOCAL;
  k := i;
  IF i <= LENGTH (s) THEN
    IF (s[i] LIKE '@') THEN
      REPEAT UNTIL (k > LENGTH (s)) OR
        ((s[k] <> '_') AND NOT (s[k] LIKE '@') AND NOT (s[k] LIKE '#'));
        k := k + 1;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN (k);
END_FUNCTION;  -- parse_express_identifier
FUNCTION partial_derivative_check(domain : tuple_space;
                                  d_vars : LIST [1:?] OF input_selector) : BOOLEAN;
  LOCAL
    domn : tuple_space := domain;
    fspc : maths_space;
    dim : INTEGER;
    k : INTEGER;
  END_LOCAL;
  IF (space_dimension (domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (domain))) THEN
    domn := factor1 (domain);
  END_IF;
  dim := space_dimension (domn);
  REPEAT i := 1 TO SIZEOF (d_vars);
    k := d_vars[i];
    IF k > dim THEN
       RETURN (FALSE);
    END_IF;
    fspc := factor_space (domn, k);
    IF (NOT subspace_of_es (fspc,es_reals)) AND
      (NOT subspace_of_es (fspc,es_complex_numbers)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- partial_derivative_check
FUNCTION real_max(spc : maths_space) : REAL;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) THEN
    RETURN (spc\finite_integer_interval.max);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) THEN
    RETURN (spc\integer_interval_to_max.max);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (spc\finite_real_interval.max);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types) THEN
    RETURN (spc\real_interval_to_max.max);
  END_IF;
  RETURN (?);
END_FUNCTION;  -- real_max
FUNCTION real_min(spc : maths_space) : REAL;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) THEN
    RETURN (spc\finite_integer_interval.min);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (spc\integer_interval_from_min.min);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (spc\finite_real_interval.min);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (spc\real_interval_from_min.min);
  END_IF;
  RETURN (?);
END_FUNCTION;  -- real_min
FUNCTION regular_indexing(sub   : LIST OF INTEGER;
                          base  : zero_or_one;
                          shape : LIST [1:?] OF positive_integer;
                          inc   : LIST [1:?] OF INTEGER;
                          first : INTEGER) : INTEGER;
  LOCAL
    k : INTEGER;
    index : INTEGER;
  END_LOCAL;
  IF NOT EXISTS (sub) OR NOT EXISTS (base) OR NOT EXISTS (shape) OR
    NOT EXISTS (inc) OR NOT EXISTS (first) THEN
    RETURN (?);
  END_IF;
  IF (SIZEOF (sub) <> SIZEOF (inc)) OR (SIZEOF (sub) <> SIZEOF (shape)) THEN
    RETURN (?);
  END_IF;
  index := first;
  REPEAT j := 1 TO SIZEOF (sub);
    IF NOT EXISTS (sub[j]) OR NOT EXISTS (inc[j]) THEN
      RETURN (?);
    END_IF;
    k := sub[j] - base;
    IF NOT ({0 <= k < shape[j]}) THEN
      RETURN (?);
    END_IF;
    index := index + k*inc[j];
  END_REPEAT;
  RETURN (index);
END_FUNCTION;
FUNCTION remove_first(alist : LIST OF GENERIC:GEN) : LIST OF GENERIC:GEN;
  LOCAL
    blist : LIST OF GENERIC:GEN := alist;
  END_LOCAL;
  IF SIZEOF (blist) > 0 THEN
    REMOVE (blist, 1);
  END_IF;
  RETURN (blist);
END_FUNCTION;  -- remove_first
FUNCTION repackage(tspace : tuple_space;
                   repckg : repackage_options) : tuple_space;
  CASE repckg OF
  ro_nochange : RETURN (tspace);
  ro_wrap_as_tuple : RETURN (one_tuples_of (tspace));
  ro_unwrap_tuple : RETURN (factor1 (tspace));
  OTHERWISE : RETURN (?);
  END_CASE;
END_FUNCTION;  -- repackage
FUNCTION shape_of_array(func : maths_function) : LIST OF positive_integer;
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
    result : LIST OF positive_integer := [];
  END_LOCAL;
  IF (schema_prefix + 'EXPLICIT_TABLE_FUNCTION') IN TYPEOF (func) THEN
    RETURN (func\explicit_table_function.shape);
  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  REPEAT i := 1 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (?);
    END_IF;
    INSERT (result, temp\finite_integer_interval.size, i-1);
  END_REPEAT;
  RETURN (result);
END_FUNCTION;  -- shape_of_array
FUNCTION simplify_function_application(expr : function_application) : maths_value;
  FUNCTION ctmv(x : GENERIC:G) : maths_value;
    RETURN (convert_to_maths_value(x));
  END_FUNCTION;  -- local abbreviation for convert_to_maths_value function
  PROCEDURE parts(       c : complex_number_literal;
                  VAR x, y : REAL);
    x := c.real_part;  y := c.imag_part;
  END_PROCEDURE;  -- parts
  FUNCTION makec(x, y : REAL) : complex_number_literal;
    RETURN (make_complex_number_literal(x,y));
  END_FUNCTION;  -- local abbreviation for make_complex_number_literal function
  FUNCTION good_t(v  : maths_value;
                  tn : STRING) : BOOLEAN;
    LOCAL
      tpl : LIST OF maths_value;
    END_LOCAL;
    IF 'LIST' IN TYPEOF (v) THEN
      tpl := v;
      REPEAT i := 1 TO SIZEOF (tpl);
        IF NOT (tn IN TYPEOF (tpl[i])) THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    RETURN (FALSE);
  END_FUNCTION;  -- good_t
  CONSTANT
    cnlit : STRING := schema_prefix + 'COMPLEX_NUMBER_LITERAL';
  END_CONSTANT;
  LOCAL
    types : SET OF STRING := stripped_typeof(expr.func);
    ef_val : elementary_function_enumerators;
    is_elementary : BOOLEAN := FALSE;
    v, v1, v2, v3 : maths_value;
    vlist : LIST OF maths_value := [];
    gexpr : generic_expression;
    pairs : SET [1:?] OF LIST [2:2] OF maths_value;
    boo : BOOLEAN;
    lgc, cum : LOGICAL;
    j, k, n : INTEGER;
    p, q, r, s, t, u : REAL;
    str, st2 : STRING;
    bin, bi2 : BINARY;
    tpl, tp2 : LIST OF maths_value;
    mem :SET OF maths_value := [];
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (expr.arguments);
    v := simplify_maths_value(expr.arguments[i]);
    INSERT (vlist, v, i-1);
  END_REPEAT;
  IF SIZEOF (vlist) >= 1 THEN  v1 := vlist[1];  END_IF;
  IF SIZEOF (vlist) >= 2 THEN  v2 := vlist[2];  END_IF;
  IF SIZEOF (vlist) >= 3 THEN  v3 := vlist[3];  END_IF;
  IF 'ELEMENTARY_FUNCTION_ENUMERATORS' IN types THEN
    ef_val := expr.func;
    is_elementary := TRUE;
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN types THEN
    ef_val := expr.func\elementary_function.func_id;
    is_elementary := TRUE;
  END_IF;
  IF is_elementary THEN
    CASE ef_val OF
    ef_and : BEGIN
      cum := TRUE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'LOGICAL' IN TYPEOF (vlist[i]) THEN
          lgc := vlist[i];  cum := cum AND lgc;
          IF lgc = FALSE THEN  RETURN (ctmv(FALSE));  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(cum));  END_IF;
      IF cum <> TRUE THEN  INSERT (vlist, ctmv(cum), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_or : BEGIN
      cum := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'LOGICAL' IN TYPEOF (vlist[i]) THEN
          lgc := vlist[i];  cum := cum OR lgc;
          IF lgc = TRUE THEN  RETURN (ctmv(TRUE));  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(cum));  END_IF;
      IF cum <> FALSE THEN  INSERT (vlist, ctmv(cum), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_not :
      IF 'LOGICAL' IN TYPEOF (v1) THEN  lgc := v1;  RETURN (ctmv(NOT lgc));  END_IF;
    ef_xor : BEGIN
      IF 'LOGICAL' IN TYPEOF (v1) THEN
        lgc := v1;
        IF 'LOGICAL' IN TYPEOF (v2) THEN  cum := v2;  RETURN (ctmv(lgc XOR cum));
        ELSE IF lgc = FALSE THEN  RETURN (ctmv(v2));
        ELSE IF lgc = UNKNOWN THEN  RETURN (ctmv(UNKNOWN));
        ELSE  RETURN (make_function_application(ef_not,[v2]));
        END_IF;  END_IF;  END_IF;
      ELSE IF 'LOGICAL' IN TYPEOF (v2) THEN
        lgc := v2;
        IF lgc = FALSE THEN  RETURN (ctmv(v1));
        ELSE IF lgc = UNKNOWN THEN  RETURN (ctmv(UNKNOWN));
        ELSE  RETURN (make_function_application(ef_not,[v1]));
        END_IF;  END_IF;
      END_IF;  END_IF;
      END;
    ef_negate_i :
      IF 'INTEGER' IN TYPEOF (v1) THEN  j := v1;  RETURN (ctmv(-j));  END_IF;
    ef_add_i : BEGIN
      j := 0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          k := vlist[i];  j := j + k;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF j <> 0 THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j - k));
      END_IF;
    ef_multiply_i : BEGIN
      j := 1;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          k := vlist[i];  j := j * k;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF j <> 1 THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j DIV k));
      END_IF;
    ef_mod_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j MOD k));
      END_IF;
    ef_exponentiate_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  n := 1;
        REPEAT i := 1 TO ABS(k);  n := n * j;  END_REPEAT;
        IF k < 0 THEN  n := 1 DIV n;  END_IF;
        RETURN (ctmv(n));
      END_IF;
    ef_eq_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j = k));
      END_IF;
    ef_ne_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j <> k));
      END_IF;
    ef_gt_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j > k));
      END_IF;
    ef_lt_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j < k));
      END_IF;
    ef_ge_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j >= k));
      END_IF;
    ef_le_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j <= k));
      END_IF;
    ef_abs_i :
      IF 'INTEGER' IN TYPEOF (v1) THEN  j := v1;  RETURN (ctmv(ABS(j)));  END_IF;
    ef_max_i : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  k := vlist[i];  IF k > j THEN  j := k;  END_IF;
          ELSE  j := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_min_i : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  k := vlist[i];  IF k < j THEN  j := k;  END_IF;
          ELSE  j := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    -- ef_if_i : combined with ef_if
    ef_negate_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(-r));  END_IF;
    ef_reciprocal_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(1.0/r));  END_IF;
    ef_add_r : BEGIN
      r := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          s := vlist[i];  r := r + s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF r <> 0.0 THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r - s));
      END_IF;
    ef_multiply_r : BEGIN
      r := 1.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          s := vlist[i];  r := r * s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF r <> 1.0 THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r / s));
      END_IF;
    ef_mod_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  t := r/s;  j := t DIV 1;
        IF (t < 0.0) AND (j <> t) THEN  j := j - 1;  END_IF;
        RETURN (ctmv(r - j * s));
      END_IF;
    ef_exponentiate_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r ** s));
      END_IF;
    ef_exponentiate_ri :
      IF ('REAL' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        r := v1;  k := v2;  t := 1.0;
        REPEAT i := 1 TO ABS(k);  t := t * r;  END_REPEAT;
        IF k < 0 THEN  t := 1.0/t;  END_IF;
        RETURN (ctmv(t));
      END_IF;
    ef_eq_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r = s));
      END_IF;
    ef_ne_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r <> s));
      END_IF;
    ef_gt_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r > s));
      END_IF;
    ef_lt_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r < s));
      END_IF;
    ef_ge_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r >= s));
      END_IF;
    ef_le_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r <= s));
      END_IF;
    ef_abs_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ABS(r)));  END_IF;
    ef_max_r : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  s := vlist[i];  IF s > r THEN  r := s;  END_IF;
          ELSE  r := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_min_r : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  s := vlist[i];  IF s < r THEN  r := s;  END_IF;
          ELSE  r := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_acos_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ACOS(r)));  END_IF;
    ef_asin_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ASIN(r)));  END_IF;
    ef_atan2_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(atan2(r,s)));
      END_IF;
    ef_cos_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(COS(r)));  END_IF;
    ef_exp_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(EXP(r)));  END_IF;
    ef_ln_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG(r)));  END_IF;
    ef_log2_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG2(r)));  END_IF;
    ef_log10_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG10(r)));  END_IF;
    ef_sin_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(SIN(r)));  END_IF;
    ef_sqrt_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(SQRT(r)));  END_IF;
    ef_tan_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(TAN(r)));  END_IF;
    -- ef_if_r : combined with ef_if
    ef_form_c :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (makec(r,s));
      END_IF;
    ef_rpart_c :
      IF cnlit IN TYPEOF (v1) THEN
        RETURN (ctmv(v1\complex_number_literal.real_part));
      END_IF;
    ef_ipart_c :
      IF cnlit IN TYPEOF (v1) THEN
        RETURN (ctmv(v1\complex_number_literal.imag_part));
      END_IF;
    ef_negate_c :
      IF cnlit IN TYPEOF (v1) THEN  parts(v1,p,q);  RETURN (makec(-p,-q));  END_IF;
    ef_reciprocal_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := p*p + q*q;  RETURN (makec(p/t,-q/t));
      END_IF;
    ef_add_c : BEGIN
      p := 0.0;  q := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF cnlit IN TYPEOF (vlist[i]) THEN
          parts(vlist[i],r,s);  p := p + r;  q := q + s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (makec(p,q));  END_IF;
      IF p*p+q*q <> 0.0 THEN  INSERT (vlist, makec(p,q), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (makec(p-r,q-s));
      END_IF;
    ef_multiply_c : BEGIN
      p := 1.0;  q := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF cnlit IN TYPEOF (vlist[i]) THEN
          parts(vlist[i],r,s);  p := p*r-q*s;  q := p*s+q*r;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (makec(p,q));  END_IF;
      IF (p <> 1.0) OR (q <> 0.0) THEN  INSERT (vlist, makec(p,q), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  t := r*r+s*s;
        RETURN (makec((p*r+q*s)/t,(q*r-p*s)/t));
      END_IF;
    ef_exponentiate_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  t := 0.5*LOG(p*p+q*q);  u := atan2(q,p);
        p := r*t-s*u;  q := r*u+s*t;  r := EXP(p);
        RETURN (makec(r*COS(q),r*SIN(q)));
      END_IF;
    ef_exponentiate_ci :
      IF (cnlit IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        parts(v1,p,q);  k := v2;  r := 1.0;  s := 0.0;
        REPEAT i := 1 TO ABS(k);  r := p*r-q*s;  s := p*s+q*r;  END_REPEAT;
        IF k < 0 THEN  t := r*r+s*s;  r := r/t;  s := -s/t;  END_IF;
        RETURN (makec(r,s));
      END_IF;
    ef_eq_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (ctmv((p = r) AND (q = s)));
      END_IF;
    ef_ne_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (ctmv((p <> r) OR (q <> s)));
      END_IF;
    ef_conjugate_c :
      IF cnlit IN TYPEOF (v1) THEN  parts(v1,p,q);  RETURN (makec(p,-q));  END_IF;
    ef_abs_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (ctmv(SQRT(p*p+q*q)));
      END_IF;
    ef_arg_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (ctmv(atan2(q,p)));
      END_IF;
    ef_cos_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := 0.5*EXP(-q);  u := 0.5*EXP(q);
        RETURN (makec((t+u)*COS(p),(t-u)*SIN(p)));
      END_IF;
    ef_exp_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (makec(EXP(p)*COS(q),EXP(p)*SIN(q)));
      END_IF;
    ef_ln_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (makec(0.5*LOG(p*p+q*q),atan2(q,p)));
      END_IF;
    ef_sin_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := 0.5*EXP(-q);  u := 0.5*EXP(q);
        RETURN (makec((t+u)*SIN(p),(u-t)*COS(p)));
      END_IF;
    ef_sqrt_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := SQRT(SQRT(p*p+q*q));  u := 0.5*atan2(q,p);
        RETURN (makec(t*COS(u),t*SIN(u)));
      END_IF;
    ef_tan_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := EXP(2.0*q) + EXP(-2.0*q) + 2.0*COS(2.0*p);
        RETURN (makec(2.0*SIN(2.0*p)/t,(EXP(-2.0*q)-EXP(2.0*q))/t));
      END_IF;
    -- ef_if_c : combined with ef_if
    ef_subscript_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        str := v1;  k := v2;  RETURN (ctmv(str[k]));
      END_IF;
    ef_eq_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str = st2));
      END_IF;
    ef_ne_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str <> st2));
      END_IF;
    ef_gt_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str > st2));
      END_IF;
    ef_lt_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str < st2));
      END_IF;
    ef_ge_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str >= st2));
      END_IF;
    ef_le_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str <= st2));
      END_IF;
    ef_subsequence_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) AND
        ('INTEGER' IN TYPEOF (v3)) THEN
        str := v1;  j := v2;  k := v3;  RETURN (ctmv(str[j:k]));
      END_IF;
    ef_concat_s : BEGIN
      str := '';
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'STRING' IN TYPEOF (vlist[i]) THEN
          st2 := vlist[i];  str := str + st2;
          REMOVE (vlist, i);
        ELSE IF str <> '' THEN
          INSERT (vlist, ctmv(str), i);
          str := '';
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(str));  END_IF;
      IF str <> '' THEN  INSERT (vlist, ctmv(str), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_s :
      IF 'STRING' IN TYPEOF (v1) THEN  str:=v1;  RETURN (ctmv(LENGTH(str)));  END_IF;
    ef_format :
      IF ('NUMBER' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        RETURN (ctmv(FORMAT(v1,v2)));
      END_IF;
    ef_value :
      IF 'STRING' IN TYPEOF (v1) THEN  str:=v1;  RETURN (ctmv(VALUE(str)));  END_IF;
    ef_like :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        RETURN (ctmv(v1 LIKE v2));
      END_IF;
    -- ef_if_s : combined with ef_if
    ef_subscript_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        bin := v1;  k := v2;  RETURN (ctmv(bin[k]));
      END_IF;
    ef_eq_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin = bi2));
      END_IF;
    ef_ne_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin <> bi2));
      END_IF;
    ef_gt_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin > bi2));
      END_IF;
    ef_lt_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin < bi2));
      END_IF;
    ef_ge_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin >= bi2));
      END_IF;
    ef_le_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin <= bi2));
      END_IF;
    ef_subsequence_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) AND
        ('INTEGER' IN TYPEOF (v3)) THEN
        bin := v1;  j := v2;  k := v3;  RETURN (ctmv(bin[j:k]));
      END_IF;
    ef_concat_b : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'BINARY' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  bi2 := vlist[i];  bin := bin + bi2;
          ELSE         bin := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        ELSE IF boo THEN
          INSERT (vlist, ctmv(bin), i);
          boo := FALSE;
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(bin));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(bin), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_b :
      IF 'BINARY' IN TYPEOF (v1) THEN  bin:=v1;  RETURN (ctmv(BLENGTH(bin)));  END_IF;
    -- ef_if_b : combined with ef_if
    ef_subscript_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        tpl := v1;  k := v2;  RETURN (ctmv(tpl[k]));
      END_IF;
    ef_eq_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('LIST' IN TYPEOF (v2)) THEN
        lgc := equal_maths_values(v1,v2);
        IF lgc <> UNKNOWN THEN  RETURN (ctmv(lgc));  END_IF;
      END_IF;
    ef_ne_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('LIST' IN TYPEOF (v2)) THEN
        lgc := equal_maths_values(v1,v2);
        IF lgc <> UNKNOWN THEN  RETURN (ctmv(NOT lgc));  END_IF;
      END_IF;
    ef_concat_t : BEGIN
      tpl := [];
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'STRING' IN TYPEOF (vlist[i]) THEN
          tp2 := vlist[i];  tpl := tpl + tp2;
          REMOVE (vlist, i);
        ELSE IF SIZEOF (tpl) <> 0 THEN
          INSERT (vlist, ctmv(tpl), i);
          tpl := [];
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF SIZEOF (tpl) <> 0 THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_t :
      IF 'LIST' IN TYPEOF (v1) THEN  tpl:=v1;  RETURN (ctmv(SIZEOF(tpl)));  END_IF;
    ef_entuple :
      RETURN (ctmv(vlist));
    ef_detuple :  -- This can have multiple outputs, but the expression only
                  -- denotes the first.
      IF 'LIST' IN TYPEOF (v1) THEN  tpl:=v1;  RETURN (ctmv(tpl[1]));  END_IF;
    ef_insert :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v3)) THEN
        tpl := v1;  k := v3;  INSERT (tpl, v2, k);  RETURN (ctmv(tpl));
      END_IF;
    ef_remove :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        tpl := v1;  k := v2;  REMOVE (tpl, k);  RETURN (ctmv(tpl));
      END_IF;
    -- ef_if_t : combined with ef_if
    ef_sum_it :
      IF good_t(v1,'INTEGER') THEN
        tpl := v1;  j := 0;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j + tpl[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_product_it :
      IF good_t(v1,'INTEGER') THEN
        tpl := v1;  j := 1;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j * tpl[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_add_it : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],'INTEGER') THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);  tpl[j] := tpl[j] + tp2[j];  END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_it :
      IF good_t(v1,'INTEGER') AND good_t(v2,'INTEGER') THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := tpl[i] - tp2[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_it :
      IF ('INTEGER' IN TYPEOF (v1)) AND good_t(v2,'INTEGER') THEN
        j := v1;  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := j * tpl[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_it :
      IF good_t(v1,'INTEGER') AND good_t(v2,'INTEGER') THEN
        tpl := v1;  tp2 := v2;  j := 0;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j + tpl[i] * tp2[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_sum_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_product_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 1.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r * tpl[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_add_rt : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],'REAL') THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);  tpl[j] := tpl[j] + tp2[j];  END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_rt :
      IF good_t(v1,'REAL') AND good_t(v2,'REAL') THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := tpl[i] - tp2[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_rt :
      IF ('REAL' IN TYPEOF (v1)) AND good_t(v2,'REAL') THEN
        r := v1;  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := r * tpl[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_rt :
      IF good_t(v1,'REAL') AND good_t(v2,'REAL') THEN
        tpl := v1;  tp2 := v2;  r := 0;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i] * tp2[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_norm_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i]*tpl[i];  END_REPEAT;
        RETURN (ctmv(SQRT(r)));
      END_IF;
    ef_sum_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  p := 0.0;  q := 0.0;
        REPEAT i:=1 TO SIZEOF (tpl);  parts(tpl[i],r,s);  p:=p+r;  q:=q+s;  END_REPEAT;
        RETURN (makec(p,q));
      END_IF;
    ef_product_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  p := 1.0;  q := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],r,s);  p := p*r-q*s;  q := p*s+q*r;
        END_REPEAT;
        RETURN (makec(p,q));
      END_IF;
    ef_add_ct : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],cnlit) THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);
              parts(tpl[j],p,q); parts(tp2[j],r,s);  tpl[j] := makec(p+r,q+s);
            END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_ct :
      IF good_t(v1,cnlit) AND good_t(v2,cnlit) THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],p,q);  parts(tp2[i],r,s);  tpl[i] := makec(p-r,q-s);
        END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_ct :
      IF (cnlit IN TYPEOF (v1)) AND good_t(v2,cnlit) THEN
        parts(v1,p,q);  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],r,s);  tpl[i] := makec(p*r-q*s,p*s+q*r);
        END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_ct :
      IF good_t(v1,cnlit) AND good_t(v2,cnlit) THEN
        tpl := v1;  tp2 := v2;  t := 0.0;  u := 0.0;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],p,q);  parts(tp2[i],r,s);  t := t + p*r+q*s;  u := u + q*r-p*s;
        END_REPEAT;
        RETURN (makec(t,u));
      END_IF;
    ef_norm_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  parts(tpl[i],p,q);  r:=r+p*p+q*q;  END_REPEAT;
        RETURN (ctmv(SQRT(r)));
      END_IF;
    ef_if, ef_if_i, ef_if_r, ef_if_c, ef_if_s, ef_if_b, ef_if_t :
      IF 'LOGICAL' IN TYPEOF (v1) THEN
        lgc := v1;  IF lgc THEN  RETURN (v2);  ELSE  RETURN (v3);  END_IF;
      END_IF;
    ef_ensemble :   -- (mem + vlist) effectively converts list to set
      RETURN (make_finite_space(mem + vlist));
    ef_member_of :
      IF (schema_prefix + 'MATHS_SPACE') IN TYPEOF (v2) THEN
        lgc := member_of(v1,v2);
        IF lgc <> UNKNOWN THEN  RETURN (ctmv(lgc));  END_IF;
      END_IF;
    END_CASE;
    RETURN (make_function_application(expr.func,vlist));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN types THEN
    gexpr := substitute(expr.func\abstracted_expression_function.expr,
      expr.func\quantifier_expression.variables,vlist);
    RETURN (simplify_generic_expression(gexpr));
  END_IF;
  IF 'FINITE_FUNCTION' IN types THEN
    pairs := expr.func\finite_function.pairs;
    REPEAT i := 1 TO SIZEOF (pairs);
      IF equal_maths_values(vlist[1],pairs[i][1]) THEN
        RETURN (simplify_maths_value(pairs[i][2]));
      END_IF;
    END_REPEAT;
    RETURN (make_function_application(expr.func,vlist));
  END_IF;
  RETURN (expr);
END_FUNCTION;  -- simplify_function_application
FUNCTION simplify_generic_expression(expr : generic_expression) : maths_value;
  FUNCTION restore_unary(expr : unary_generic_expression;
                         opnd : generic_expression) : generic_expression;
    expr.operand := opnd;
    RETURN (expr);
  END_FUNCTION;  -- restore_unary
  FUNCTION restore_binary(expr       : binary_generic_expression;
                          opd1, opd2 : generic_expression) : generic_expression;
    expr.operands[1] := opd1;
    expr.operands[2] := opd2;
    RETURN (expr);
  END_FUNCTION;  -- restore_binary
  FUNCTION restore_mulary(expr : multiple_arity_generic_expression;
                          ops  : LIST OF generic_expression) : generic_expression;
    expr.operands := ops;
    RETURN (expr);
  END_FUNCTION;  -- restore_mulary
  FUNCTION make_number_literal(nmb : NUMBER) : generic_literal;
    IF 'INTEGER' IN TYPEOF (nmb) THEN  RETURN (make_int_literal(nmb));  END_IF;
    RETURN (make_real_literal(nmb));
  END_FUNCTION;  -- make_number_literal;
  LOCAL
    types : SET OF STRING := stripped_typeof (expr);
    v1, v2 : maths_value;
    vlist : LIST OF maths_value := [];
    op1, op2 : generic_expression;
    oplist : LIST OF generic_expression := [];
    opnds : LIST [2:?] OF generic_expression;
    n, m : INTEGER;
    finfun : maths_function_select;
    boo : BOOLEAN;
    str : STRING;
    nmb : NUMBER;
  END_LOCAL;
  -- Unwrap the elementary kinds of literals
  IF 'INT_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\int_literal.the_value));
  END_IF;
  IF 'REAL_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\real_literal.the_value));
  END_IF;
  IF 'BOOLEAN_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\boolean_literal.the_value));
  END_IF;
  IF 'STRING_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\string_literal.the_value));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN types THEN
    RETURN (expr);  -- No simpler expression available
  END_IF;
  IF 'LOGICAL_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\logical_literal.lit_value));
  END_IF;
  IF 'BINARY_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\binary_literal.lit_value));
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN types THEN
    RETURN (expr\maths_enum_literal.lit_value);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\real_tuple_literal.lit_value));
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\integer_tuple_literal.lit_value));
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN types THEN
    RETURN (expr\atom_based_literal.lit_value);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\maths_tuple_literal.lit_value));
  END_IF;
  -- Simplify one special class of literals
  IF 'MATHS_SPACE' IN types THEN
    RETURN (simplify_maths_space(expr));
  END_IF;
  -- Simplify one special kind of expression
  IF 'FUNCTION_APPLICATION' IN types THEN
    RETURN (simplify_function_application(expr));
  END_IF;
  -- Separate and simplify the operands
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    v1 := simplify_generic_expression(expr\unary_generic_expression.operand);
    op1 := convert_to_operand(v1);
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    v1 := simplify_generic_expression(expr\binary_generic_expression.operands[1]);
    op1 := convert_to_operand(v1);
    v2 := simplify_generic_expression(expr\binary_generic_expression.operands[2]);
    op2 := convert_to_operand(v2);
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      v1 := simplify_generic_expression(opnds[i]);
      INSERT (vlist, v1, i-1);
      INSERT (oplist, convert_to_operand(v1), i-1);
    END_REPEAT;
  END_IF;
  -- Simplify the one kind of maths_function which derives its operands.
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types THEN
    v1 := vlist[1];
    n := SIZEOF (vlist);
    finfun := vlist[n];
    REMOVE (vlist, n);
    REMOVE (vlist, 1);
    RETURN (make_parallel_composed_function(v1,vlist,finfun));
  END_IF;
  -- Simplify individual kinds of expressions.  It is not necessary to cover all cases.
  IF ('ABS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ABS(v1)));
  END_IF;
  IF ('ACOS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ACOS(v1)));
  END_IF;
  IF 'AND_EXPRESSION' IN types THEN
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF (vlist[i]) THEN
        boo := vlist[i];
        IF NOT boo THEN  RETURN (convert_to_maths_value(FALSE));  END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(TRUE));  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('ASIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ASIN(v1)));
  END_IF;
  IF ('ATAN_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (ATAN(v1,v2)));
  END_IF;
  IF ('COMPARISON_EXPRESSION' IN types) AND (
    (('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2))) OR
    (('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2))) OR
    (('BOOLEAN' IN TYPEOF (v1)) AND ('BOOLEAN' IN TYPEOF (v2))) ) THEN
    IF      'COMPARISON_EQUAL'         IN types THEN  boo := bool(v1 = v2);
    ELSE IF 'COMPARISON_GREATER'       IN types THEN  boo := bool(v1 > v2);
    ELSE IF 'COMPARISON_GREATER_EQUAL' IN types THEN  boo := bool(v1 >= v2);
    ELSE IF 'COMPARISON_LESS'          IN types THEN  boo := bool(v1 < v2);
    ELSE IF 'COMPARISON_LESS_EQUAL'    IN types THEN  boo := bool(v1 <= v2);
    ELSE IF 'COMPARISON_NOT_EQUAL'     IN types THEN  boo := bool(v1 <> v2);
    ELSE IF 'LIKE_EXPRESSION'          IN types THEN  boo := bool(v1 LIKE v2);
    ELSE  RETURN (?);  -- Unreachable
    END_IF;  END_IF;  END_IF;  END_IF;  END_IF;  END_IF;  END_IF;
    RETURN (convert_to_maths_value (boo));
  END_IF;
  IF 'CONCAT_EXPRESSION' IN types THEN
    str := '';
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'STRING' IN TYPEOF (vlist[i]) THEN
        str := vlist[i] + str;
        REMOVE (oplist, i);
      ELSE IF LENGTH(str) > 0 THEN
        INSERT (oplist, make_string_literal(str), i);
        str := '';
      END_IF;  END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(str));  END_IF;
    IF LENGTH(str) > 0 THEN  INSERT (oplist, make_string_literal(str), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('COS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (COS(v1)));
  END_IF;
  IF ('DIV_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 DIV v2));
  END_IF;
  IF 'EQUALS_EXPRESSION' IN types THEN
    opnds := expr\binary_generic_expression.operands;
    RETURN (convert_to_maths_value (opnds[1] :=: opnds[2]));
  END_IF;
  IF ('EXP_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (EXP(v1)));
  END_IF;
  IF ('FORMAT_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (FORMAT(v1,v2)));
  END_IF;
  IF ('INDEX_EXPRESSION' IN types) AND
    ('STRING' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    str := v1;  n := v2;
    RETURN (convert_to_maths_value (str[n]));
  END_IF;
  IF ('INT_VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (VALUE(v1)));
  END_IF;
  IF 'INTERVAL_EXPRESSION' IN types THEN
    str := '';
    IF 'NUMBER'  IN TYPEOF (vlist[1]) THEN str := 'NUMBER';   END_IF;
    IF 'STRING'  IN TYPEOF (vlist[1]) THEN str := 'STRING';   END_IF;
    IF 'BOOLEAN' IN TYPEOF (vlist[1]) THEN str := 'BOOLEAN';  END_IF;
    IF (LENGTH (str) > 0) AND (str IN TYPEOF (vlist[2])) AND
      (str IN TYPEOF (vlist[3])) THEN
      RETURN (convert_to_maths_value ({vlist[1] <= vlist[2] <= vlist[3]}));
    END_IF;
  END_IF;
  IF ('LENGTH_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LENGTH(v1)));
  END_IF;
  IF ('LOG_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG(v1)));
  END_IF;
  IF ('LOG10_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG10(v1)));
  END_IF;
  IF ('LOG2_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG2(v1)));
  END_IF;
  IF 'MAXIMUM_EXPRESSION' IN types THEN
    boo := FALSE;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        IF boo THEN
          IF nmb < vlist[i] THEN  nmb := vlist[i];  END_IF;
        ELSE
          nmb := vlist[i];  boo := TRUE;
        END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF boo THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
  END_IF;
  IF 'MINIMUM_EXPRESSION' IN types THEN
    boo := FALSE;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        IF boo THEN
          IF nmb > vlist[i] THEN  nmb := vlist[i];  END_IF;
        ELSE
          nmb := vlist[i];  boo := TRUE;
        END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF boo THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
  END_IF;
  IF ('MINUS_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 - v2));
  END_IF;
  IF ('MOD_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 MOD v2));
  END_IF;
  IF 'MULT_EXPRESSION' IN types THEN
    nmb := 1;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        nmb := nmb * vlist[i];
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF nmb <> 1 THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('NOT_EXPRESSION' IN types) AND ('BOOLEAN' IN TYPEOF (v1)) THEN
    boo := v1;
    RETURN (convert_to_maths_value (NOT(boo)));
  END_IF;
  IF ('ODD_EXPRESSION' IN types) AND ('INTEGER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ODD(v1)));
  END_IF;
  IF 'OR_EXPRESSION' IN types THEN
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF (vlist[i]) THEN
        boo := vlist[i];
        IF boo THEN  RETURN (convert_to_maths_value(TRUE));  END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(FALSE));  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF 'PLUS_EXPRESSION' IN types THEN
    nmb := 0;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        nmb := nmb + vlist[i];
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF nmb <> 0 THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('POWER_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 ** v2));
  END_IF;
  IF ('SIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (SIN(v1)));
  END_IF;
  IF ('SLASH_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 / v2));
  END_IF;
  IF ('SQUARE_ROOT_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (SQRT(v1)));
  END_IF;
  IF ('SUBSTRING_EXPRESSION' IN types) AND
    ('STRING' IN TYPEOF (vlist[1])) AND ('NUMBER' IN TYPEOF (vlist[2])) AND
    ('NUMBER' IN TYPEOF (vlist[3])) THEN
    str := vlist[1];  n := vlist[2];  m := vlist[3];
    RETURN (convert_to_maths_value (str[n:m]));
  END_IF;
  IF ('TAN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (TAN(v1)));
  END_IF;
  IF ('UNARY_MINUS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    nmb := v1;
    RETURN (convert_to_maths_value (-nmb));
  END_IF;
  IF ('VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (VALUE(v1)));
  END_IF;
  IF ('XOR_EXPRESSION' IN types) AND
    ('BOOLEAN' IN TYPEOF (v1)) AND ('BOOLEAN' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 XOR v2));
  END_IF;
  -- No special simplification defined, return same with simplified operands.
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_unary(expr,op1));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_binary(expr,op1,op2));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_mulary(expr,oplist));
  END_IF;
  -- Should be unreachable, but for safety, return unsimplified expression.
  RETURN (expr);
END_FUNCTION;  -- simplify_generic_expression
FUNCTION simplify_maths_space(spc : maths_space) : maths_space;
  LOCAL
    stypes : SET OF STRING := stripped_typeof (spc);
    sset : SET OF maths_value;
    zset : SET OF maths_value := [];
    zval : maths_value;
    zspc : maths_space;
    zallint : BOOLEAN := TRUE;
    zint, zmin, zmax : INTEGER;
    factors : LIST OF maths_space;
    zfactors : LIST OF maths_space := [];
    rspc : maths_space;
  END_LOCAL;
  IF 'FINITE_SPACE' IN stypes THEN
    sset := spc\finite_space.members;
    REPEAT i := 1 TO SIZEOF (sset);
      zval := simplify_maths_value(sset[i]);
      zset := zset + [zval];
      IF zallint AND ('INTEGER' IN TYPEOF (zval)) THEN
        zint := zval;
        IF i = 1 THEN
          zmin := zint;
          zmax := zint;
        ELSE
          IF zint < zmin THEN
            zmin := zint;
          END_IF;
          IF zint > zmax THEN
            zmax := zint;
          END_IF;
        END_IF;
      ELSE
        zallint := FALSE;
      END_IF;
    END_REPEAT;
    IF zallint AND (SIZEOF(zset) = zmax-zmin+1) THEN
      RETURN (make_finite_integer_interval(zmin,zmax));
    END_IF;
    RETURN (make_finite_space(zset));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\uniform_product_space.base);
    RETURN (make_uniform_product_space(zspc,spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF (factors);
      INSERT (zfactors, simplify_maths_space(factors[i]), i-1);
    END_REPEAT;
    RETURN (make_listed_product_space(zfactors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\extended_tuple_space.base);
    rspc := simplify_maths_space(spc\extended_tuple_space.extender);
    RETURN (make_extended_tuple_space(zspc,rspc));
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\function_space.domain_argument);
    rspc := simplify_maths_space(spc\function_space.range_argument);
    RETURN (make_function_space(spc\function_space.domain_constraint,zspc,
      spc\function_space.range_constraint,rspc));
  END_IF;
  RETURN (spc);
END_FUNCTION;  -- simplify_maths_space
FUNCTION simplify_maths_value(val : maths_value) : maths_value;
  LOCAL
    vtypes : SET OF STRING := stripped_typeof(val);
    vlist : LIST OF maths_value;
    nlist : LIST OF maths_value := [];
  END_LOCAL;
  IF 'GENERIC_EXPRESSION' IN vtypes THEN
    RETURN (simplify_generic_expression(val));
  END_IF;
  IF 'LIST' IN vtypes THEN
    vlist := val;
    REPEAT i := 1 TO SIZEOF (vlist);
      INSERT (nlist, simplify_maths_value(vlist[i]), i-1);
    END_REPEAT;
    RETURN (convert_to_maths_value(nlist));
  END_IF;
  RETURN (val);
END_FUNCTION;  -- simplify_maths_value
FUNCTION singleton_member_of(spc : maths_space) : maths_value;
  LOCAL
    types : SET OF STRING := stripped_typeof (spc);
  END_LOCAL;
  IF 'FINITE_SPACE' IN types THEN
    IF SIZEOF (spc\finite_space.members) = 1 THEN
      RETURN (spc\finite_space.members[1]);
    END_IF;
    RETURN (?);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types THEN
    IF spc\finite_integer_interval.size = 1 THEN
      RETURN (spc\finite_integer_interval.min);
    END_IF;
    RETURN (?);
  END_IF;
  RETURN (?);
END_FUNCTION;  -- singleton_member_of
FUNCTION space_dimension(tspace : tuple_space) : nonnegative_integer;
  LOCAL
    types : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types THEN
    RETURN (tspace\uniform_product_space.exponent);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types THEN
    RETURN (SIZEOF (tspace\listed_product_space.factors));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    -- In the case of an extended_tuple_space, the minimum dimension is returned.
    RETURN (space_dimension (tspace\extended_tuple_space.base));
  END_IF;
  -- Should be unreachable
  RETURN (?);
END_FUNCTION;  -- space_dimension
FUNCTION space_is_continuum(space : maths_space) : BOOLEAN;
  LOCAL
    typenames : SET OF STRING := TYPEOF (space);
    factors : LIST OF maths_space;
  END_LOCAL;
  IF NOT EXISTS (space) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(space,es_reals) OR subspace_of_es(space,es_complex_numbers) THEN
    RETURN (TRUE);
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    RETURN (space_is_continuum(space\uniform_product_space.base));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    factors := space\listed_product_space.factors;
    IF SIZEOF(factors) = 0 THEN
      RETURN (FALSE);
    END_IF;
    REPEAT i := 1 TO SIZEOF (factors);
      IF NOT space_is_continuum(factors[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- space_is_continuum
FUNCTION space_is_singleton(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := stripped_typeof (spc);
  END_LOCAL;
  IF 'FINITE_SPACE' IN types THEN
    RETURN (bool(SIZEOF (spc\finite_space.members) = 1));
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types THEN
    RETURN (bool(spc\finite_integer_interval.size = 1));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- space_is_singleton
FUNCTION stripped_typeof(arg : GENERIC:G) : SET OF STRING;
  LOCAL
    types : SET OF STRING := TYPEOF (arg);
    stypes : SET OF STRING := [];
    n : INTEGER := LENGTH (schema_prefix);
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (types);
    IF types[i][1:n] = schema_prefix THEN
       stypes := stypes + types[i][n+1:LENGTH(types[i])];
    ELSE
       stypes := stypes + types[i];
    END_IF;
  END_REPEAT;
  RETURN (stypes);
END_FUNCTION;  -- stripped_typeof
FUNCTION subspace_of(space1, space2 : maths_space) : LOGICAL;
  LOCAL
    spc1 : maths_space := simplify_maths_space(space1);
    spc2 : maths_space := simplify_maths_space(space2);
    types1 : SET OF STRING := stripped_typeof (spc1);
    types2 : SET OF STRING := stripped_typeof (spc2);
    lgcl, cum : LOGICAL;
    es_val : elementary_space_enumerators;
    bnd1, bnd2 : REAL;
    n : INTEGER;
    sp1, sp2 : maths_space;
    prgn1, prgn2 : polar_complex_number_region;
    aitv : finite_real_interval;
  END_LOCAL;
  IF NOT EXISTS (spc1) OR NOT EXISTS (spc2) THEN
    RETURN (FALSE);
  END_IF;
  IF spc2 = the_generics THEN
    RETURN (TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1 THEN
    IF NOT ('ELEMENTARY_SPACE' IN types2) THEN
      RETURN (FALSE);
    END_IF;
    es_val := spc2\elementary_space.space_id;
    IF spc1\elementary_space.space_id = es_val THEN
      RETURN (TRUE);
    END_IF;
    -- Note that the cases (spc2=the_generics) and (spc1=spc2) have been handled.
    CASE spc1\elementary_space.space_id OF
    es_numbers :  RETURN (FALSE);
    es_complex_numbers :  RETURN (es_val = es_numbers);
    es_reals :  RETURN (es_val = es_numbers);
    es_integers :  RETURN (es_val = es_numbers);
    es_logicals :  RETURN (FALSE);
    es_booleans :  RETURN (es_val = es_logicals);
    es_strings :  RETURN (FALSE);
    es_binarys :  RETURN (FALSE);
    es_maths_spaces :  RETURN (FALSE);
    es_maths_functions :  RETURN (FALSE);
    es_generics :  RETURN (FALSE);
    END_CASE;
    -- Should be unreachable.
    RETURN (UNKNOWN);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types1 THEN
    cum := TRUE;
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      cum := cum AND member_of (i, spc2);
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_FROM_MIN' IN types2 THEN
      RETURN (spc1\integer_interval_from_min.min>=spc2\integer_interval_from_min.min);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_TO_MAX' IN types2 THEN
      RETURN (spc1\integer_interval_to_max.max <= spc2\integer_interval_to_max.max);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR
      ('REAL_INTERVAL_FROM_MIN' IN types2) OR
      ('REAL_INTERVAL_TO_MAX' IN types2) THEN
      IF min_exists (spc2) THEN
        bnd1 := spc1\finite_real_interval.min;
        bnd2 := real_min (spc2);
        IF (bnd1 < bnd2) OR ((bnd1 = bnd2) AND min_included (spc1) AND NOT
          min_included (spc2)) THEN
          RETURN (FALSE);
        END_IF;
      END_IF;
      IF max_exists (spc2) THEN
        bnd1 := spc1\finite_real_interval.max;
        bnd2 := real_max (spc2);
        IF (bnd1 > bnd2) OR ((bnd1 = bnd2) AND max_included (spc1) AND NOT
          max_included (spc2)) THEN
          RETURN (FALSE);
        END_IF;
      END_IF;
      RETURN (TRUE);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_FROM_MIN' IN types2 THEN
      bnd1 := spc1\real_interval_from_min.min;
      bnd2 := spc2\real_interval_from_min.min;
      RETURN ((bnd2 < bnd1) OR ((bnd2 = bnd1) AND (min_included (spc2) OR
        NOT min_included (spc1))));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_TO_MAX' IN types2 THEN
      bnd1 := spc1\real_interval_to_max.max;
      bnd2 := spc2\real_interval_to_max.max;
      RETURN ((bnd2 > bnd1) OR ((bnd2 = bnd1) AND (max_included (spc2) OR
        NOT max_included (spc1))));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(spc1\cartesian_complex_number_region.real_constraint,
        spc2\cartesian_complex_number_region.real_constraint) AND
        subspace_of(spc1\cartesian_complex_number_region.imag_constraint,
        spc2\cartesian_complex_number_region.imag_constraint));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(enclose_cregion_in_pregion(spc1,
        spc2\polar_complex_number_region.centre),spc2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(enclose_pregion_in_cregion(spc1),spc2));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
      prgn1 := spc1;
      prgn2 := spc2;
      IF prgn1.centre = prgn2.centre THEN
        IF prgn2.direction_constraint.max > PI THEN
          aitv := make_finite_real_interval(-PI,open,prgn2.direction_constraint.max
            -2.0*PI,prgn2.direction_constraint.max_closure);
          RETURN (subspace_of(prgn1.distance_constraint,prgn2.distance_constraint)
            AND (subspace_of(prgn1.direction_constraint,prgn2.direction_constraint)
              OR subspace_of(prgn1.direction_constraint,aitv)));
        ELSE
          RETURN (subspace_of(prgn1.distance_constraint,prgn2.distance_constraint)
            AND subspace_of(prgn1.direction_constraint,prgn2.direction_constraint));
        END_IF;
      END_IF;
      RETURN (subspace_of(enclose_pregion_in_pregion(prgn1,prgn2.centre),prgn2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types1 THEN
    cum := TRUE;
    REPEAT i := 1 TO SIZEOF (spc1\finite_space.members);
      cum := cum AND member_of (spc1\finite_space.members[i], spc2);
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'PRODUCT_SPACE' IN types1 THEN
    IF 'PRODUCT_SPACE' IN types2 THEN
      IF space_dimension (spc1) = space_dimension (spc2) THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension (spc1);
          cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      IF space_dimension (spc1) >= space_dimension (spc2) THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension (spc1);
          cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      n := space_dimension (spc1);
      IF n < space_dimension (spc2) THEN
        n := space_dimension (spc2);
      END_IF;
      cum := TRUE;
      REPEAT i := 1 TO n+1;
        cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
        IF cum = FALSE THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      RETURN (spc2\elementary_space.space_id = es_maths_functions);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      cum := TRUE;
      sp1 := spc1\function_space.domain_argument;
      sp2 := spc2\function_space.domain_argument;
      CASE spc1\function_space.domain_constraint OF
      sc_equal : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND equal_maths_spaces (sp1, sp2);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : cum := cum AND member_of (sp1, sp2);
        END_CASE;
        END;
      sc_subspace : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : RETURN (FALSE);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : BEGIN
          IF NOT member_of (sp1, sp2) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        END_CASE;
        END;
      sc_member : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND space_is_singleton(sp1) AND
          equal_maths_spaces(singleton_member_of(sp1),sp2);
        sc_subspace : BEGIN
          IF NOT member_of (sp2, sp1) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        sc_member : cum := cum AND (subspace_of (sp1, sp2));
        END_CASE;
        END;
      END_CASE;
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
      sp1 := spc1\function_space.range_argument;
      sp2 := spc2\function_space.range_argument;
      CASE spc1\function_space.range_constraint OF
      sc_equal : BEGIN
        CASE spc2\function_space.range_constraint OF
        sc_equal : cum := cum AND equal_maths_spaces (sp1, sp2);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : cum := cum AND member_of (sp1, sp2);
        END_CASE;
        END;
      sc_subspace : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : RETURN (FALSE);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : BEGIN
          IF NOT member_of (sp1, sp2) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        END_CASE;
        END;
      sc_member : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND space_is_singleton(sp1) AND
          equal_maths_spaces(singleton_member_of(sp1),sp2);
        sc_subspace : BEGIN
          IF NOT member_of (sp2, sp1) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        sc_member : cum := cum AND subspace_of (sp1, sp2);
        END_CASE;
        END;
      END_CASE;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Should be unreachable
  RETURN (UNKNOWN);
END_FUNCTION;  -- subspace_of
FUNCTION subspace_of_es(spc : maths_space;
                        es  : elementary_space_enumerators) : LOGICAL;
  LOCAL
    types : SET OF STRING := stripped_typeof(spc);
  END_LOCAL;
  IF NOT EXISTS (spc) OR NOT EXISTS (es) THEN  RETURN (FALSE);  END_IF;
  IF 'ELEMENTARY_SPACE' IN types THEN
    RETURN (es_subspace_of_es(spc\elementary_space.space_id,es));
  END_IF;
  IF 'FINITE_SPACE' IN types THEN
    RETURN (all_members_of_es(spc\finite_space.members,es));
  END_IF;
  CASE es OF
  es_numbers : RETURN (
    ('FINITE_INTEGER_INTERVAL' IN types) OR
    ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
    ('INTEGER_INTERVAL_TO_MAX' IN types) OR
    ('FINITE_REAL_INTERVAL' IN types) OR
    ('REAL_INTERVAL_FROM_MIN' IN types) OR
    ('REAL_INTERVAL_TO_MAX' IN types) OR
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR
    ('POLAR_COMPLEX_NUMBER_REGION' IN types) );
  es_complex_numbers : RETURN (
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR
    ('POLAR_COMPLEX_NUMBER_REGION' IN types) );
  es_reals : RETURN (
    ('FINITE_REAL_INTERVAL' IN types) OR
    ('REAL_INTERVAL_FROM_MIN' IN types) OR
    ('REAL_INTERVAL_TO_MAX' IN types) );
  es_integers : RETURN (
    ('FINITE_INTEGER_INTERVAL' IN types) OR
    ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
    ('INTEGER_INTERVAL_TO_MAX' IN types) );
  es_logicals : RETURN (FALSE);
  es_booleans : RETURN (FALSE);
  es_strings : RETURN (FALSE);
  es_binarys : RETURN (FALSE);
  es_maths_spaces : RETURN (FALSE);
  es_maths_functions : RETURN ('FUNCTION_SPACE' IN types);
  es_generics : RETURN (TRUE);
  END_CASE;
  RETURN (UNKNOWN);
END_FUNCTION;  -- subspace_of_es
FUNCTION substitute(expr : generic_expression;
                    vars : LIST [1:?] OF generic_variable;
                    vals : LIST [1:?] OF maths_value) : generic_expression;
  LOCAL
    types : SET OF STRING := stripped_typeof(expr);
    opnds : LIST OF generic_expression;
    op1, op2 : generic_expression;
    qvars : LIST OF generic_variable;
    srcdom : maths_space_or_function;
    prpfun : LIST [1:?] OF maths_function;
    finfun : maths_function_select;
  END_LOCAL;
  IF SIZEOF (vars) <> SIZEOF (vals) THEN  RETURN (?);  END_IF;
  IF 'GENERIC_LITERAL' IN types THEN  RETURN (expr);  END_IF;
  IF 'GENERIC_VARIABLE' IN types THEN
    REPEAT i := 1 TO SIZEOF (vars);
      IF expr :=: vars[i] THEN  RETURN (vals[i]);  END_IF;
    END_REPEAT;
    RETURN (expr);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN types THEN
    qvars := expr\quantifier_expression.variables;
    -- Variables subject to a quantifier do not participate in this kind of
    -- substitution process.
    REPEAT i := SIZEOF (vars) TO 1 BY -1;
      IF vars[i] IN qvars THEN
        REMOVE (vars, i);
        REMOVE (vals, i);
      END_IF;
    END_REPEAT;
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      IF NOT (opnds[i] IN qvars) THEN
        expr\multiple_arity_generic_expression.operands[i] :=
          substitute(opnds[i],vars,vals);
        -- This technique will not work on subtypes of quantifier_expression
        -- which derive their operands from other attributes!
      END_IF;
    END_REPEAT;
    RETURN (expr);  -- operands modified!
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    op1 := expr\unary_generic_expression.operand;
    expr\unary_generic_expression.operand := substitute(op1, vars, vals);
    -- This technique will not work on subtypes of unary_generic_expression
    -- which derive their operands from other attributes!
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    op1 := expr\binary_generic_expression.operands[1];
    expr\binary_generic_expression.operands[1] := substitute(op1, vars, vals);
    op2 := expr\binary_generic_expression.operands[2];
    expr\binary_generic_expression.operands[2] := substitute(op2, vars, vals);
    -- This technique will not work on subtypes of binary_generic_expression
    -- which derive their operands from other attributes!
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types THEN
    -- Subtype of multiple_arity_generic_expression which derives its operands.
    srcdom := expr\parallel_composed_function.source_of_domain;
    prpfun := expr\parallel_composed_function.prep_functions;
    finfun := expr\parallel_composed_function.final_function;
    srcdom := substitute(srcdom,vars,vals);
    REPEAT i := 1 TO SIZEOF (prpfun);
      prpfun[i] := substitute(prpfun[i],vars,vals);
    END_REPEAT;
    IF 'MATHS_FUNCTION' IN stripped_typeof(finfun) THEN
      finfun := substitute(finfun,vars,vals);
    END_IF;
    RETURN (make_parallel_composed_function(srcdom,prpfun,finfun));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      expr\multiple_arity_generic_expression.operands[i] :=
        substitute(opnds[i],vars,vals);
        -- This technique will not work on subtypes of multiple_arity_generic_
        -- expression which derive their operands from other attributes!
    END_REPEAT;
  END_IF;
  RETURN (expr);
END_FUNCTION;  -- substitute
FUNCTION values_space_of(expr : generic_expression) : maths_space;
  LOCAL
    e_prefix : STRING := 'ISO13584_EXPRESSIONS_SCHEMA.';
    typenames : SET OF STRING := TYPEOF (expr);
  END_LOCAL;
  IF (schema_prefix + 'MATHS_VARIABLE') IN typenames THEN
    RETURN (expr\maths_variable.values_space);
  END_IF;
  IF (e_prefix + 'EXPRESSION') IN typenames THEN
    IF (e_prefix + 'NUMERIC_EXPRESSION') IN typenames THEN
      IF expr\numeric_expression.is_int THEN
        IF (e_prefix + 'INT_LITERAL') IN typenames THEN
          RETURN (make_finite_space ([expr\int_literal.the_value]));
        ELSE
          RETURN (the_integers);
        END_IF;
      ELSE
        IF (e_prefix + 'REAL_LITERAL') IN typenames THEN
          RETURN (make_finite_space ([expr\real_literal.the_value]));
        ELSE
          RETURN (the_reals);
        END_IF;
      END_IF;
    END_IF;
    IF (e_prefix + 'BOOLEAN_EXPRESSION') IN typenames THEN
      IF (e_prefix + 'BOOLEAN_LITERAL') IN typenames THEN
        RETURN (make_finite_space ([expr\boolean_literal.the_value]));
      ELSE
        RETURN (the_booleans);
      END_IF;
    END_IF;
    IF (e_prefix + 'STRING_EXPRESSION') IN typenames THEN
      IF (e_prefix + 'STRING_LITERAL') IN typenames THEN
        RETURN (make_finite_space ([expr\string_literal.the_value]));
      ELSE
        RETURN (the_strings);
      END_IF;
    END_IF;
    RETURN (?);  -- unknown subtype of expression
  END_IF;
  IF (schema_prefix + 'MATHS_FUNCTION') IN typenames THEN
    IF expression_is_constant (expr) THEN
      RETURN (make_finite_space ([expr]));
    ELSE
      RETURN (make_function_space (sc_equal, expr\maths_function.domain,
        sc_equal, expr\maths_function.range));
    END_IF;
  END_IF;
  IF (schema_prefix + 'FUNCTION_APPLICATION') IN typenames THEN
    RETURN (expr\function_application.func.range);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames THEN
    IF expression_is_constant (expr) THEN
      RETURN (make_finite_space ([expr]));
    ELSE
      -- This case cannot occur in this version of the schema.
      -- When it becomes possible, the subtypes should be analysed and
      -- more finely defined spaces returned.
      RETURN (make_elementary_space (es_maths_spaces));
    END_IF;
  END_IF;
  IF (schema_prefix + 'DEPENDENT_VARIABLE_DEFINITION') IN typenames THEN
    RETURN (values_space_of (expr\unary_generic_expression.operand));
  END_IF;
  IF (schema_prefix + 'COMPLEX_NUMBER_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr]));
  END_IF;
  IF (schema_prefix + 'LOGICAL_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\logical_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'BINARY_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\binary_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_ENUM_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\maths_enum_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'REAL_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\real_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'INTEGER_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\integer_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'ATOM_BASED_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\atom_based_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\maths_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'PARTIAL_DERIVATIVE_EXPRESSION') IN typenames THEN
    RETURN (drop_numeric_constraints (values_space_of (
      expr\partial_derivative_expression.derivand)));
  END_IF;
  IF (schema_prefix + 'DEFINITE_INTEGRAL_EXPRESSION') IN typenames THEN
    RETURN (drop_numeric_constraints (values_space_of (
      expr\definite_integral_expression.integrand)));
  END_IF;
  RETURN (?);  -- not recognized as a mathematical expression
END_FUNCTION;  -- values_space_of
END_SCHEMA;  -- mathematical_functions_schema


--
-- MATHS_VALUE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/maths_value/mim.exp)
--
(*
 $Id: mim.exp,v 1.11 2019/06/26 17:41:33 kevin Exp 
 ISO TC184/SC4/WG12 N10492 - ISO/TS 10303-1092 Maths value - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2802
*)

SCHEMA Maths_value_mim;

USE FROM Generic_expression_mim; -- ISO/TS 10303-1341
USE FROM iso13584_expressions_schema;-- ISO 13584-20
USE FROM iso13584_generic_expressions_schema;-- ISO 13584-20
USE FROM mathematical_functions_schema;    -- ISO 10303-50
USE FROM Numeric_expression_mim; -- ISO/TS 10303-1526

END_SCHEMA;



--
-- MEASURE_REPRESENTATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/measure_representation/mim.exp)
--
(*
 $Id: mim.exp,v 1.5 2017/04/28 15:09:08 verodub Exp 
 ISO TC184/SC4/WG12 N1217 - ISO/TS 10303-1118 Measure representation - EXPRESS MIM
*)

SCHEMA Measure_representation_mim;

USE FROM Foundation_representation_mim;   -- ISO/TS 10303-1006

USE FROM qualified_measure_schema   -- ISO 10303-45
(measure_representation_item);

USE FROM representation_schema   -- ISO 10303-43
(value_representation_item);

USE FROM Value_with_unit_mim;   -- ISO/TS 10303-1054

END_SCHEMA;



--
-- MEASURE_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/measure_schema/measure_schema.exp)
--
(*
Id: measure_schema.exp,v 1.34 2017/10/09 12:26:21 verodub Exp 
ISO 10303 TC184/SC4/WG12 N9715

EXPRESS Source:
ISO 10303-41 ed5 Fundamentals of product description and support - Measure schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2017  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed5 Fundamentals of product description and support - Measure schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA measure_schema '{iso standard 10303 part(41) version(8) object(1) measure_schema(15)}';

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (get_name_value,
   name_attribute,
   name_attribute_select); 
REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation_context); 

REFERENCE FROM support_resource_schema;    -- ISO 10303-41

  TYPE s_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    derived_unit);
  END_TYPE;

  TYPE absorbed_dose_measure = REAL;
  END_TYPE;

TYPE acceleration_measure = REAL;
  END_TYPE;

  TYPE radioactivity_measure = REAL;
  END_TYPE;

TYPE amount_of_substance_measure = REAL;
  END_TYPE;

  TYPE area_measure = REAL;
  END_TYPE;

  TYPE celsius_temperature_measure = REAL;
  END_TYPE;

  TYPE context_dependent_measure = REAL;
  END_TYPE;

  TYPE count_measure = NUMBER;
  END_TYPE;

  TYPE descriptive_measure = STRING;
  END_TYPE;
  
  TYPE capacitance_measure = REAL;
  END_TYPE;
  
  TYPE dose_equivalent_measure = REAL;
  END_TYPE;

  TYPE electric_charge_measure = REAL;
  END_TYPE;
  
  TYPE electric_current_measure = REAL;
  END_TYPE;

  TYPE conductance_measure = REAL;
  END_TYPE;

  TYPE electric_potential_measure = REAL;
  END_TYPE;
  
  TYPE energy_measure = REAL;
  END_TYPE;  
  
  TYPE force_measure = REAL;
  END_TYPE;  
  
  TYPE frequency_measure = REAL;
  END_TYPE; 
  
  TYPE magnetic_flux_density_measure = REAL;
  END_TYPE;

  TYPE illuminance_measure = REAL;
  END_TYPE;  

  TYPE inductance_measure = REAL;
  END_TYPE;
  
  TYPE length_measure = REAL;
  END_TYPE;

  TYPE luminous_intensity_measure = REAL;
  END_TYPE;

  TYPE luminous_flux_measure = REAL;
  END_TYPE;

  TYPE mass_measure = REAL;
  END_TYPE;

  TYPE measure_value = SELECT 
    (absorbed_dose_measure,
     dose_equivalent_measure,
     radioactivity_measure,
     acceleration_measure,
     amount_of_substance_measure, 
     area_measure, 
     celsius_temperature_measure, 
     context_dependent_measure, 
     count_measure, 
     descriptive_measure, 
     capacitance_measure,
     electric_charge_measure,
     conductance_measure,
     electric_current_measure, 
     electric_potential_measure,
     energy_measure,
     magnetic_flux_density_measure,
     force_measure,
     frequency_measure,
     illuminance_measure,
     inductance_measure,
     length_measure, 
     luminous_flux_measure,
     luminous_intensity_measure, 
     magnetic_flux_measure,
     mass_measure, 
     numeric_measure, 
     non_negative_length_measure,
     parameter_value, 
     plane_angle_measure, 
     positive_length_measure, 
     positive_plane_angle_measure, 
     positive_ratio_measure, 
     power_measure,
     pressure_measure,
     ratio_measure, 
     resistance_measure,
     solid_angle_measure, 
     thermodynamic_temperature_measure, 
     time_measure, 
     velocity_measure,
     volume_measure);
  END_TYPE;

  TYPE magnetic_flux_measure = REAL;
  END_TYPE;

  TYPE non_negative_length_measure = length_measure;
   WHERE
    WR1: SELF >= 0.0;
  END_TYPE;

  TYPE numeric_measure = NUMBER;
  END_TYPE;

  TYPE parameter_value = REAL;
  END_TYPE;

  TYPE plane_angle_measure = REAL;
  END_TYPE;

  TYPE positive_length_measure = non_negative_length_measure;
    WHERE
      WR1: SELF > 0.0;
  END_TYPE;

  TYPE positive_plane_angle_measure = plane_angle_measure;
    WHERE
      WR1: SELF > 0.0;
  END_TYPE;

  TYPE positive_ratio_measure = ratio_measure;
    WHERE
      WR1: SELF > 0.0;
  END_TYPE;

  TYPE power_measure = REAL;
  END_TYPE;

  TYPE pressure_measure = REAL;
  END_TYPE;

  TYPE ratio_measure = REAL;
  END_TYPE;

  TYPE resistance_measure = REAL;
  END_TYPE;

  TYPE si_prefix = ENUMERATION OF (exa, peta, tera, giga, mega, kilo, hecto, deca, deci, centi, milli, micro, nano, pico, femto, atto);
  END_TYPE;

  TYPE si_unit_name = ENUMERATION OF (metre, gram, second, ampere, kelvin, mole, candela, radian, steradian, hertz, newton, pascal, joule, watt, coulomb, volt, farad, ohm, siemens, weber, tesla, henry, degree_Celsius, lumen, lux, becquerel, gray, sievert);
  END_TYPE;

  TYPE solid_angle_measure = REAL;
  END_TYPE;

  TYPE thermodynamic_temperature_measure = REAL;
  END_TYPE;

  TYPE time_measure = REAL;
  END_TYPE;

  TYPE unit = SELECT (derived_unit, named_unit);
  END_TYPE;

  TYPE velocity_measure = REAL;
  END_TYPE;
  
  TYPE volume_measure = REAL;
  END_TYPE;

ENTITY absorbed_dose_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
    WR1: 'MEASURE_SCHEMA.ABSORBED_DOSE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY absorbed_dose_unit
 SUBTYPE OF (derived_unit);
WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.gray);  
END_ENTITY;

  ENTITY si_absorbed_dose_unit
     SUBTYPE OF (absorbed_dose_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.gray;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY acceleration_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ACCELERATION_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;
  
  ENTITY acceleration_unit
    SUBTYPE OF (derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = 
       dimensional_exponents ( 1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0 );
  END_ENTITY;

ENTITY radioactivity_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
    WR1: 'MEASURE_SCHEMA.RADIOACTIVITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY radioactivity_unit
 SUBTYPE OF (derived_unit);
WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.becquerel);  
END_ENTITY;

  ENTITY si_radioactivity_unit
     SUBTYPE OF (radioactivity_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.becquerel;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY amount_of_substance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY amount_of_substance_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY area_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.AREA_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY area_unit
   SUBTYPE OF (derived_unit);
  WHERE
  WR1: derive_dimensional_exponents(SELF) = 
      dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 );
  END_ENTITY;

  ENTITY celsius_temperature_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY context_dependent_unit
    SUBTYPE OF (named_unit);
    name : label;
  END_ENTITY;

  ENTITY conversion_based_unit
    SUBTYPE OF (named_unit);
     name : label;
     conversion_factor : measure_with_unit;
  WHERE
    WR1: SELF\named_unit.dimensions = derive_dimensional_exponents(conversion_factor\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY derived_unit
    SUPERTYPE OF (ONEOF(absorbed_dose_unit,
	acceleration_unit,
    radioactivity_unit,
	area_unit,
    capacitance_unit,
	dose_equivalent_unit,
    electric_charge_unit,
    conductance_unit,
    electric_potential_unit,
    energy_unit,
    magnetic_flux_density_unit,
    force_unit,
    frequency_unit,
    illuminance_unit,
    inductance_unit,
    magnetic_flux_unit,
    power_unit,
    pressure_unit,
    resistance_unit,
    velocity_unit,
    volume_unit));
    elements : SET [1:?] OF derived_unit_element;
  DERIVE
    name : label := get_name_value(SELF);
  WHERE
    WR1: (SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (elements[1].exponent <> 1.0));
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY derived_unit_element;
    unit : named_unit;
    exponent : REAL;
  END_ENTITY;

  ENTITY dimensional_exponents;
    length_exponent : REAL;
    mass_exponent : REAL;
    time_exponent : REAL;
    electric_current_exponent : REAL;
    thermodynamic_temperature_exponent : REAL;
    amount_of_substance_exponent : REAL;
    luminous_intensity_exponent : REAL;
  END_ENTITY;

  ENTITY capacitance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.farad);  
  END_ENTITY;

  ENTITY capacitance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.CAPACITANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_capacitance_unit
     SUBTYPE OF (capacitance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.farad;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

ENTITY dose_equivalent_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
    WR1: 'MEASURE_SCHEMA.DOSE_EQUIVALENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY dose_equivalent_unit
 SUBTYPE OF (derived_unit);
WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.sievert);  
END_ENTITY;

  ENTITY si_dose_equivalent_unit
     SUBTYPE OF (dose_equivalent_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.sievert;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY electric_charge_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.coulomb);  
  END_ENTITY;

  ENTITY electric_charge_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ELECTRIC_CHARGE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_electric_charge_unit
     SUBTYPE OF (electric_charge_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.coulomb;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
  
  ENTITY electric_current_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ELECTRIC_CURRENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY electric_current_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;
  
   ENTITY conductance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.siemens);  
  END_ENTITY;

  ENTITY conductance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.CONDUCTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_conductance_unit
     SUBTYPE OF (conductance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.siemens;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY electric_potential_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.volt);  
  END_ENTITY;

  ENTITY electric_potential_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ELECTRIC_POTENTIAL_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_electric_potential_unit
     SUBTYPE OF (electric_potential_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.volt;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY energy_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.joule);  
  END_ENTITY;

  ENTITY energy_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ENERGY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_energy_unit
     SUBTYPE OF (energy_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.joule;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY magnetic_flux_density_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.tesla);  
  END_ENTITY;

  ENTITY magnetic_flux_density_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.MAGNETIC_FLUX_DENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_magnetic_flux_density_unit
     SUBTYPE OF (magnetic_flux_density_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.tesla;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY force_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.newton);  
  END_ENTITY;

  ENTITY force_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.FORCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_force_unit
     SUBTYPE OF (force_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.newton;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY frequency_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.hertz);  
  END_ENTITY;

  ENTITY frequency_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.FREQUENCY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_frequency_unit
     SUBTYPE OF (frequency_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.hertz;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
 
  ENTITY global_unit_assigned_context
    SUBTYPE OF (representation_context);
    units : SET [1:?] OF unit;
  END_ENTITY;

  ENTITY illuminance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.lux);  
  END_ENTITY;

  ENTITY illuminance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ILLUMINANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_illuminance_unit
     SUBTYPE OF (illuminance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.lux;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY inductance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.henry);  
  END_ENTITY;

  ENTITY inductance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.INDUCTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_inductance_unit
     SUBTYPE OF (inductance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.henry;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
 
  ENTITY length_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.LENGTH_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY positive_length_measure_with_unit
    SUBTYPE OF (length_measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
  END_ENTITY;

  ENTITY length_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 1.0) AND 
    (SELF\named_unit.dimensions.mass_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.time_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY luminous_flux_unit
    SUBTYPE OF(named_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.lumen);  
  END_ENTITY;

  ENTITY luminous_flux_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.LUMINOUS_FLUX_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY luminous_intensity_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY luminous_intensity_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
  END_ENTITY;

  ENTITY magnetic_flux_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.weber);  
  END_ENTITY;

  ENTITY magnetic_flux_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.MAGNETIC_FLUX_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_magnetic_flux_unit
     SUBTYPE OF (magnetic_flux_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.weber;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY mass_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.MASS_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY mass_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY measure_with_unit
    SUPERTYPE OF (ONEOF(length_measure_with_unit, 
    mass_measure_with_unit, 
	time_measure_with_unit, 
    electric_current_measure_with_unit, 
	thermodynamic_temperature_measure_with_unit, 
    celsius_temperature_measure_with_unit, 
	amount_of_substance_measure_with_unit, 
    luminous_intensity_measure_with_unit, 
	plane_angle_measure_with_unit, 
    solid_angle_measure_with_unit, 
	area_measure_with_unit, 
	volume_measure_with_unit, 
    ratio_measure_with_unit, 
    acceleration_measure_with_unit,
    capacitance_measure_with_unit,
    electric_charge_measure_with_unit,
    conductance_measure_with_unit,
    electric_potential_measure_with_unit,
    energy_measure_with_unit,
    magnetic_flux_density_measure_with_unit,
    force_measure_with_unit,
    frequency_measure_with_unit,
    illuminance_measure_with_unit,
    inductance_measure_with_unit,
    luminous_flux_measure_with_unit,
    magnetic_flux_measure_with_unit,
    power_measure_with_unit,
    pressure_measure_with_unit,
    resistance_measure_with_unit,
    velocity_measure_with_unit,
	absorbed_dose_measure_with_unit,
    radioactivity_measure_with_unit,
    dose_equivalent_measure_with_unit));
    value_component : measure_value;
    unit_component : unit;
  WHERE
    WR1: valid_units(SELF);
  END_ENTITY;

  ENTITY named_unit
    SUPERTYPE OF (ONEOF(si_unit, conversion_based_unit, context_dependent_unit) ANDOR 
    ONEOF(length_unit, mass_unit, time_unit, electric_current_unit, thermodynamic_temperature_unit, 
    amount_of_substance_unit, luminous_flux_unit, luminous_intensity_unit, plane_angle_unit, 
    solid_angle_unit, ratio_unit));
    dimensions : dimensional_exponents;
  END_ENTITY;

  ENTITY plane_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY positive_plane_angle_measure_with_unit
    SUBTYPE OF (plane_angle_measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
  END_ENTITY;

  ENTITY plane_angle_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY power_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.watt);  
  END_ENTITY;

  ENTITY power_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.POWER_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_power_unit
     SUBTYPE OF (power_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.watt;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
 
  ENTITY pressure_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.pascal);  
  END_ENTITY;

  ENTITY pressure_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.PRESSURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_pressure_unit
     SUBTYPE OF (pressure_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.pascal;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY ratio_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.RATIO_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY ratio_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY resistance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.ohm);  
  END_ENTITY;

  ENTITY resistance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.RESISTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_resistance_unit
     SUBTYPE OF (resistance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.ohm;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  
  ENTITY si_unit
    SUBTYPE OF (named_unit);
    prefix : OPTIONAL si_prefix;
    name : si_unit_name;
  DERIVE
    SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit(name);
  WHERE
    WR1: NOT(('MEASURE_SCHEMA.MASS_UNIT' IN TYPEOF(SELF)) AND
             (SIZEOF(USEDIN(SELF,'MEASURE_SCHEMA.DERIVED_UNIT_ELEMENT.UNIT')) > 0)) OR
            (prefix = si_prefix.kilo); 
  END_ENTITY;

  ENTITY solid_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY solid_angle_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY thermodynamic_temperature_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY thermodynamic_temperature_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY time_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.TIME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY time_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 1.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY velocity_measure_with_unit
   SUBTYPE OF (measure_with_unit);
  WHERE
   WR1: 'MEASURE_SCHEMA.VELOCITY_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;
  
  ENTITY velocity_unit
  SUBTYPE OF (derived_unit);
  WHERE
  WR1: derive_dimensional_exponents(SELF) = 
       dimensional_exponents ( 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 );
  END_ENTITY;

  ENTITY volume_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.VOLUME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY volume_unit
    SUBTYPE OF (derived_unit);
   WHERE
     WR1: derive_dimensional_exponents(SELF) = 
          dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 );
  END_ENTITY;

  FUNCTION derive_dimensional_exponents (x : unit):dimensional_exponents;
    LOCAL
      result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    END_LOCAL;

    IF 'MEASURE_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN
      REPEAT i := LOINDEX(x\derived_unit.elements) TO HIINDEX(x\derived_unit.elements);
        result.length_exponent := result.length_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.time_exponent);
        result.electric_current_exponent := result.electric_current_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.amount_of_substance_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.luminous_intensity_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x\named_unit.dimensions;
    END_IF;
    RETURN (result);
  END_FUNCTION;

  FUNCTION dimensions_for_si_unit (n : si_unit_name):dimensional_exponents;
    CASE n OF 
      metre:
        RETURN (dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      gram:
        RETURN (dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      second:
        RETURN (dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
      ampere:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
      kelvin:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
      mole:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
      candela:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      radian:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      steradian:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      hertz:
        RETURN (dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
      newton:
        RETURN (dimensional_exponents(1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      pascal:
        RETURN (dimensional_exponents(-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      joule:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      watt:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
      coulomb:
        RETURN (dimensional_exponents(0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
      volt:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
      farad:
        RETURN (dimensional_exponents(-2.0, -1.0, 4.0, 2.0, 0.0, 0.0, 0.0));
      ohm:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
      siemens:
        RETURN (dimensional_exponents(-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
      weber:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
      tesla:
        RETURN (dimensional_exponents(0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
      henry:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
      degree_Celsius:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
      lumen:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      lux:
        RETURN (dimensional_exponents(-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      becquerel:
        RETURN (dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
      gray:
        RETURN (dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      sievert:
        RETURN (dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      OTHERWISE:
        RETURN (?);
    END_CASE;
  END_FUNCTION;

  FUNCTION valid_units (m : measure_with_unit):BOOLEAN;
    IF 'MEASURE_SCHEMA.LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.MASS_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.TIME_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.CELSIUS_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.AREA_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.VOLUME_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.RATIO_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.ACCELERATION_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'MEASURE_SCHEMA.CAPACITANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( -2.0, -1.0, 4.0, 2.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.ELECTRIC_CHARGE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
        IF 'MEASURE_SCHEMA.CONDUCTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
          IF derive_dimensional_exponents(m.unit_component) <> 
            dimensional_exponents( -2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0 ) THEN
            RETURN (FALSE);
          END_IF;
    END_IF;
        IF 'MEASURE_SCHEMA.ELECTRIC_POTENTIAL_MEASURE' IN TYPEOF(m.value_component) THEN
          IF derive_dimensional_exponents(m.unit_component) <> 
            dimensional_exponents( 2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0 ) THEN
            RETURN (FALSE);
          END_IF;
    END_IF;    
    IF 'MEASURE_SCHEMA.ENERGY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.FORCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.FREQUENCY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.ILLUMINANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( -2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'MEASURE_SCHEMA.INDUCTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.LUMINOUS_FLUX_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.MAGNETIC_FLUX_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'MEASURE_SCHEMA.MAGNETIC_FLUX_DENSITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.POWER_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.PRESSURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( -1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.RESISTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.VELOCITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.RADIOACTIVITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.ABSORBED_DOSE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.DOSE_EQUIVALENT_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    RETURN (TRUE);
  END_FUNCTION;
END_SCHEMA;


--
-- MESH_TOPOLOGY_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/mesh_topology_schema/mesh_topology_schema.exp)
--
(*
Id: mesh_topology_schema.exp,v 1.18 2019/05/07 13:05:18 kevin Exp 
ISO 10303 TC184/SC4/WG12 N10057

EXPRESS Source:
ISO 10303-52 ed2 Mesh-based topology - Mesh topology schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2019  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-52 ed2 Mesh-based topology - Mesh topology schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA mesh_topology_schema '{iso standard 10303 part(52) version(4) object(1) mesh_topology_schema(3)}';
  REFERENCE FROM mathematical_description_of_distribution_schema  -- ISO 10303-51
    (property_distribution_description);
  REFERENCE FROM mathematical_functions_schema                    -- ISO 10303-50
    (maths_space,
     tuple_space);
  REFERENCE FROM structural_response_representation_schema        -- ISO 10303-104
    (element_order,
     element_representation,
     fea_model);
  REFERENCE FROM support_resource_schema                          -- ISO 10303-41
    (identifier,
     label,
     text);
  REFERENCE FROM topology_schema                                  -- ISO 10303-42
    (topological_representation_item,
     vertex,  vertex_point);

TYPE cell_shape = EXTENSIBLE SELECT 
    (cell_shape_0D,
     cell_shape_1D,
     cell_shape_2D,
     cell_shape_3D);
END_TYPE;

TYPE cell_shape_0D = EXTENSIBLE ENUMERATION OF
    (single);
END_TYPE;

TYPE cell_shape_1D = EXTENSIBLE ENUMERATION OF
    (line);
END_TYPE;

TYPE cell_shape_2D = EXTENSIBLE ENUMERATION OF
    (quadrilateral,
     triangle);
END_TYPE;

TYPE cell_shape_3D = EXTENSIBLE ENUMERATION OF
    (hexahedron,
     wedge,
     tetrahedron,
     pyramid);
END_TYPE;

TYPE indices_group = SELECT
     (indices_list,
      indices_range);
END_TYPE;

TYPE mesh_location = EXTENSIBLE ENUMERATION OF
     (unspecified,
      application_defined,
      vertices,
      cell_centre,
      face_centre,
      iface_centre,
      jface_centre,
      kface_centre,
      edge_centre);
END_TYPE;

TYPE mesh_maths_space_type = EXTENSIBLE ENUMERATION OF
     (cells,
      vertices);
END_TYPE;

TYPE structured_mesh_type = EXTENSIBLE ENUMERATION OF
    (rectangular,
     pentahedral,
     pyramidal,
     tetrahedral);
END_TYPE;

TYPE mesh_tuple_space = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON tuple_space WITH
  (mesh_derived_maths_space);
END_TYPE;

ENTITY array_based_unstructured_mesh
  SUBTYPE OF (unstructured_mesh);
  cells        : ARRAY [1:SELF\unstructured_mesh.cell_count] OF vertex_defined_cell;
WHERE
  WR1 : SELF\mesh.index_count = 1;
END_ENTITY;

ENTITY array_based_unstructured_mesh_and_vertices
  SUBTYPE OF (array_based_unstructured_mesh);
  vertex_count : INTEGER;
  vertices     : ARRAY [1:vertex_count] OF UNIQUE vertex;
WHERE
  WR1 : all_mesh_vertices(SELF);
END_ENTITY;

ENTITY cell
  SUPERTYPE OF (ONEOF(cell_of_structured_mesh, vertex_defined_cell))
  SUBTYPE OF (topological_representation_item);
  description : text;
  dimension   : INTEGER;
END_ENTITY;

ENTITY cell_of_structured_mesh
  SUBTYPE OF (cell);
  the_mesh : structured_mesh;
  cell_identifier : ARRAY [1:index_count] OF INTEGER;
DERIVE
  index_count : INTEGER := the_mesh\mesh.index_count;
END_ENTITY;

ENTITY cell_with_explicit_boundary
  SUBTYPE OF (cell);
  boundary : SET [1:?] OF topological_representation_item;
END_ENTITY;

ENTITY explicit_unstructured_mesh
  SUBTYPE OF (unstructured_mesh);
  explicit_model : fea_model;
  cells          : ARRAY [1:cell_count] OF UNIQUE element_representation;
END_ENTITY;

ENTITY extraction_of_structured_submesh
SUBTYPE OF(extraction_of_submesh);
  lower_vertex : ARRAY [1:whole_indices] OF INTEGER;
  used_indices : ARRAY [1:part_indices] OF INTEGER;
  used_senses  : ARRAY [1:part_indices] OF BOOLEAN;
DERIVE
  whole_indices : INTEGER := whole\mesh.index_count;
  part_indices  : INTEGER := part\mesh.index_count;
WHERE
  WR1: ('MESH_TOPOLOGY_SCHEMA.STRUCTURED_MESH' IN  TYPEOF(
             SELF\extraction_of_submesh.whole));
  WR2: ('MESH_TOPOLOGY_SCHEMA.STRUCTURED_MESH' IN  TYPEOF(
             SELF\extraction_of_submesh.part));

END_ENTITY;

ENTITY extraction_of_submesh;
   whole:  mesh;
   part:   submesh;
END_ENTITY;
 
ENTITY extraction_of_submesh_by_cells
  SUBTYPE OF (extraction_of_submesh);
  cell_count: INTEGER;
  cells : ARRAY [1:cell_count] OF cell;
END_ENTITY;

ENTITY extraction_of_submesh_by_vertices
  SUBTYPE OF (extraction_of_submesh);
  vertex_count: INTEGER;
  vertices : ARRAY [1:vertex_count] OF vertex;
END_ENTITY;

ENTITY indices_list;
  nindices : INTEGER;
  indices  : LIST [1:?] OF ARRAY [1:nindices] OF INTEGER;
END_ENTITY;

ENTITY indices_range;
  nindices : INTEGER;
  start    : ARRAY [1:nindices] OF INTEGER;
  finish   : ARRAY [1:nindices] OF INTEGER;
END_ENTITY;

ENTITY mesh
  ABSTRACT SUPERTYPE OF (ONEOF(structured_mesh,
        unstructured_mesh) ANDOR submesh)
   SUBTYPE OF (topological_representation_item);
  description : text;
  index_count : INTEGER;
END_ENTITY;

ENTITY mesh_derived_maths_space
  SUBTYPE OF (maths_space);
  description : text;
  name        : label;
  id          : identifier;
  the_mesh    : mesh;
  kind        : mesh_maths_space_type;
END_ENTITY;

ENTITY product_of_mesh;
  operands : LIST [2:2] OF mesh;
  product  : mesh;
WHERE
  WR1 : ('MESH_TOPOLOGY_SCHEMA.STRUCTURED_MESH' IN TYPEOF(operands[1])) AND
        ('MESH_TOPOLOGY_SCHEMA.STRUCTURED_MESH' IN TYPEOF(operands[2])) AND
        ('MESH_TOPOLOGY_SCHEMA.STRUCTURED_MESH' IN TYPEOF(product));
  WR2 : operands[1].index_count = 1;
  WR3 : operands[1].index_count + operands[2].index_count
        = product.index_count;
END_ENTITY;

ENTITY rind;
  index_count : INTEGER;
  planes      : ARRAY [1:2*index_count] OF INTEGER;
END_ENTITY;

ENTITY structured_mesh
  SUBTYPE OF (mesh);
  vertex_counts : ARRAY [1:SELF\mesh.index_count] OF INTEGER;
  cell_counts   : ARRAY [1:SELF\mesh.index_count] OF INTEGER;
  kind          : structured_mesh_type;
END_ENTITY;

ENTITY structured_mesh_with_rind
  SUBTYPE OF (structured_mesh);
  rind_planes : rind;
END_ENTITY;

ENTITY submesh
  SUBTYPE OF (mesh);
END_ENTITY;

ENTITY unstructured_mesh
  ABSTRACT SUPERTYPE OF (ONEOF(array_based_unstructured_mesh, 
        explicit_unstructured_mesh))
  SUBTYPE OF (mesh);
  cell_count   : INTEGER;
END_ENTITY;



ENTITY vertex_defined_cell 
  SUBTYPE OF (cell); 
  shape       : cell_shape;
  order       : element_order;
  vertices    : ARRAY [1:vn_count] OF OPTIONAL vertex;
DERIVE
  bound_count       : INTEGER := cell_counts(SELF)[1];
  edge_node_count   : INTEGER := cell_counts(SELF)[2];
  opt_node_count    : INTEGER := cell_counts(SELF)[3];
  required_count    : INTEGER := bound_count + edge_node_count;
  vn_count          : INTEGER := required_count + opt_node_count;
  required_vertices : ARRAY [1:required_count] OF vertex
                        := shorten_array(vertices, vn_count, required_count);
END_ENTITY;

(*
ENTITY vertex_range_defined_patch
  SUBTYPE OF (patch);
  base_mesh : structured_mesh;
  range     : indices_range;
END_ENTITY;
*)

FUNCTION all_mesh_vertices(arg : array_based_unstructured_mesh_and_vertices)
         : BOOLEAN;
LOCAL
  vertex_set : SET OF vertex := [];
  cell : vertex_defined_cell;
END_LOCAL;
  REPEAT i := 1 TO arg.cell_count;
    cell := arg.cells[i];
    REPEAT j := 1 TO cell.vn_count;
      vertex_set := vertex_set + cell.vertices[j];
    END_REPEAT;
  END_REPEAT;
  IF (SIZEOF(vertex_set) <> arg.index_count) THEN
    RETURN(FALSE);
  END_IF;
  REPEAT i := 1 TO arg.index_count;
    IF (NOT (arg.vertices[i] IN vertex_set) ) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION cell_counts(arg : vertex_defined_cell) : ARRAY[1:3] OF INTEGER;
LOCAL
  om1    : INTEGER := 0;      -- (order - 1)
  om1sq  : INTEGER := om1**2; -- (order - 1) squared
  vts    : INTEGER;           -- number of bounding vertices
  eds    : INTEGER;           -- number of edges
  qf     : INTEGER := 0;      -- number of quadrilateral faces
  tf     : INTEGER := 0;      -- number of triangular faces
  result : ARRAY [1:3] OF INTEGER := [0,0,0];
END_LOCAL;
  CASE arg.order OF
    linear    : om1 := 0;
    quadratic : om1 := 1;
    cubic     : om1 := 2;
    OTHERWISE : RETURN(result);
  END_CASE;
  om1sq := om1**2;
  CASE arg.shape OF
    cell_shape_0D.single : 
        BEGIN
          vts := 1; eds := 0; qf := 0; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 0, 0
          result[3] := 0;                         -- 0, 0, 0
        END;
    cell_shape_1D.line :
        BEGIN
          vts := 2; eds := 1; qf := 0; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 1, 2
          result[3] := 0;                         -- 0, 0, 0
        END;
    cell_shape_2D.quadrilateral : 
        BEGIN
          vts := 4; eds := 4; qf := 1; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 4, 8
          result[3] := om1sq*qf;                  -- 0, 1, 4
        END;
    cell_shape_2D.triangle : 
        BEGIN
          vts := 3; eds := 3; qf := 0; tf := 1;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 3, 6
          result[3] := (om1-1)*tf;                --    0, 1
          CASE arg.order OF
            linear : result[3] := 0;              -- 0
          END_CASE;
        END;
    cell_shape_3D.hexahedron :
        BEGIN
          vts := 8; eds := 12; qf := 6; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 12, 24
          result[3] := om1sq*(qf+om1);            -- 0, 7, 32
        END;
    cell_shape_3D.wedge :
        BEGIN
          vts := 6; eds := 9; qf := 3; tf := 2;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 9,  18
          result[3] := om1sq*qf + om1*tf;         -- 0, 3, 16
        END;
    cell_shape_3D.tetrahedron : 
        BEGIN
          vts := 4; eds := 6; qf := 0; tf := 4;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 6, 12
          result[3] := (om1-1)*tf;                --    0, 4
          CASE arg.order OF
            linear : result[3] := 0;              -- 0
          END_CASE;
        END;
    cell_shape_3D.pyramid : 
        BEGIN
          vts := 5; eds := 8; qf := 1; tf := 4;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 8, 16
          result[3] := om1sq*qf + (om1-1)*tf;     --    1, 9
          CASE arg.order OF
            linear : result[3] := 0;              -- 0
          END_CASE;
        END;
  END_CASE;
RETURN(result);
END_FUNCTION;


FUNCTION shorten_array(longa : ARRAY OF GENERIC : T;
                      oldl, newl : INTEGER) : ARRAY OF GENERIC : T;
   LOCAL
     shorta : ARRAY [1:newl] OF GENERIC : T;
   END_LOCAL;

   IF (newl > oldl) THEN
     RETURN(?);
   ELSE
     REPEAT i := 1 TO newl;
       shorta[i] := longa[i];
     END_REPEAT;
     RETURN(shorta);
   END_IF;
END_FUNCTION;

END_SCHEMA;  -- end of mesh_topology_schema


--
-- MESSAGE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/message/mim.exp)
--
(*
Id: mim.exp,v 1.25 2009/08/11 07:53:53 robbod Exp 
ISO TC184/SC4/WG12 N6046 - ISO/TS 10303-1270 Message - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N3083
*) 


SCHEMA Message_mim;

USE FROM Approval_mim;    -- ISO/CD-TS 10303-1012

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Group_mim;    -- ISO/TS 10303-1113

USE FROM group_schema   -- ISO 10303-41
  (group); 

USE FROM management_resources_schema   -- ISO 10303-41
  (group_assignment); 

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_category,
   product_related_product_category,
   product_relationship); 

USE FROM qualified_measure_schema   -- ISO 10303-45
  (descriptive_representation_item); 

USE FROM representation_schema   -- ISO 10303-43
  (representation,
   representation_context,
   representation_item); 

USE FROM Security_classification_mim;    -- ISO/TS 10303-1015

USE FROM State_observed_mim;    -- ISO/TS 10303-1256


TYPE message_approval = SELECT BASED_ON approval_item WITH 
   (structured_message);
END_TYPE; 

TYPE message_date = SELECT BASED_ON date_item WITH 
   (structured_message);
END_TYPE; 

TYPE message_date_time = SELECT BASED_ON date_and_time_item WITH 
   (structured_message);
END_TYPE; 

TYPE message_organization = SELECT BASED_ON organization_item WITH 
   (structured_message);
END_TYPE; 

TYPE message_person_and_organization = SELECT BASED_ON person_and_organization_item WITH 
   (structured_message);
END_TYPE; 

TYPE message_security_classification = SELECT BASED_ON security_classification_item WITH 
   (structured_message);
END_TYPE; 

TYPE message_state = SELECT BASED_ON state_observed_of_item WITH 
   (structured_message);
END_TYPE; 

ENTITY containing_message
  SUBTYPE OF (group_assignment);
  items : SET[1:1] OF structured_message;
  SELF\group_assignment.assigned_group RENAMED message_contents_group : message_contents_group;
END_ENTITY;

ENTITY message_contents_assignment
  SUBTYPE OF (group_assignment);
  items : SET[1:?] OF representation;
  SELF\group_assignment.assigned_group RENAMED message_contents_group : message_contents_group;
END_ENTITY;

ENTITY message_contents_group
  SUBTYPE OF (group);
END_ENTITY;

ENTITY message_relationship
  SUBTYPE OF (product_relationship);
  SELF\product_relationship.relating_product RENAMED relating_message : structured_message;
  SELF\product_relationship.related_product RENAMED related_message : structured_message;
END_ENTITY;

ENTITY structured_message
  SUBTYPE OF (product);
END_ENTITY;

END_SCHEMA;  -- Message_mim


--
-- METHOD_DEFINITION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/method_definition_schema/method_definition_schema.exp)
--
(*
Id: method_definition_schema.exp,v 1.4 2015/06/29 19:31:31 dgnedwards Exp 
ISO 10303 TC184/SC4/WG12 N8546

EXPRESS Source:
ISO 10303-49 ed1 Process structure and properties - Method definition schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-49 ed1 Process structure and properties - Method definition schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA method_definition_schema '{iso standard 10303 part(49) version(1) object(1) method_definition_schema(1)}';

REFERENCE FROM action_schema
    (action_method, 
     action_method_relationship, 
     action_relationship);

REFERENCE FROM document_schema
    (document, 
     document_usage_constraint);

REFERENCE FROM effectivity_schema
    (effectivity);

REFERENCE FROM measure_schema
    (count_measure);

REFERENCE FROM support_resource_schema
    (label, 
     text);

REFERENCE FROM process_property_schema
    (product_definition_process,
     property_process);

TYPE relationship_with_condition = SELECT
  (action_method_relationship,
   action_relationship,
   context_dependent_action_method_relationship,
   context_dependent_action_relationship);
END_TYPE;

TYPE process_or_process_relationship = SELECT
  (product_definition_process,
   property_process,
   relationship_with_condition);
END_TYPE;

ENTITY action_method_with_associated_documents
  SUBTYPE OF (action_method);
  documents : SET [1:?] of document;
END_ENTITY;

ENTITY action_method_with_associated_documents_constrained
  SUBTYPE OF (action_method_with_associated_documents);
  usage_constraints : SET [1:?] OF document_usage_constraint;
WHERE
  WR1: SIZEOF (QUERY (item <* usage_constraints | 
       NOT (item.source 
       IN SELF\action_method_with_associated_documents.documents))) = 0;
END_ENTITY;

ENTITY action_method_to_select_from
  SUBTYPE OF (action_method);
  number_of_elements : count_measure;
WHERE
  WR1: number_of_elements >=1;
  WR2: SIZEOF (USEDIN (SELF, 
       'ACTION_SCHEMA.ACTION_METHOD_RELATIONSHIP.RELATING_METHOD')) >= 
       number_of_elements;
END_ENTITY;

ENTITY process_or_process_relationship_effectivity
  SUBTYPE OF (effectivity);
  effective_process_or_process_relationship : process_or_process_relationship;
END_ENTITY;

ENTITY serial_action_method
  SUBTYPE OF (action_method_relationship);
END_ENTITY;

ENTITY sequential_method
  SUBTYPE OF (serial_action_method);
  sequence_position : count_measure;
END_ENTITY;

ENTITY concurrent_action_method
  SUBTYPE OF (action_method_relationship);
END_ENTITY;

ENTITY context_dependent_action_method_relationship;
  name                  : label;
  relating_relationship : action_method_relationship;
  related_relationship  : action_method_relationship;
UNIQUE
  UR1: relating_relationship, related_relationship;
WHERE
  WR1: relating_relationship.relating_method :=:
       related_relationship.relating_method;
END_ENTITY;

ENTITY context_dependent_action_relationship;
  name                  : label;
  relating_relationship : action_relationship;
  related_relationship  : action_relationship;
UNIQUE
  UR1: relating_relationship, related_relationship;
WHERE
  WR1: relating_relationship.relating_action :=:
       related_relationship.relating_action;
END_ENTITY;

ENTITY relationship_condition;
  name                     : label;
  applicable_relationships : SET [1:?] OF relationship_with_condition;
  condition_description    : text;
END_ENTITY;

END_SCHEMA;  -- method_definition_schema


--
-- MULTI_LINGUISM_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/multi_linguism/mim.exp)
--
(*
 $Id: mim.exp,v 1.12 2019/01/23 18:21:55 brandon Exp 
 ISO TC184/SC4/WG12 N10271 - ISO/TS 10303-1105 Multi linguism - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N3243
*) 


SCHEMA Multi_linguism_mim;

USE FROM language_schema (language); -- ISO 10404-41
USE FROM management_resources_schema   -- ISO 10303-41
  (attribute_classification_assignment,
   attribute_value_assignment); 



TYPE attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (multi_language_attribute_assignment, 
    attribute_value_assignment);
END_TYPE; 


TYPE multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE;


ENTITY attribute_language_assignment 
SUBTYPE OF (attribute_classification_assignment); 
  SELF\attribute_classification_assignment.assigned_class: language;
  items : SET [1:?] OF attribute_language_item; 
WHERE 
WR1: SELF\attribute_classification_assignment.role.name IN ['primary', 'translated']; 
WR2: SELF\attribute_classification_assignment.attribute_name<> '';
END_ENTITY; 

ENTITY multi_language_attribute_assignment 
SUBTYPE OF (attribute_value_assignment); 
  items : SET [1:?] OF multi_language_attribute_item;

DERIVE
  translation_language : language := language_indication[1]\attribute_classification_assignment.assigned_class;

INVERSE
  language_indication: SET[1:1] OF attribute_language_assignment FOR items;

WHERE 
WR1: (SELF\attribute_value_assignment.role.name = 'alternate language');
WR2: SIZEOF( QUERY( ala <* language_indication |  
   (ala\attribute_classification_assignment.attribute_name = 'attribute_value') AND 
   (ala\attribute_classification_assignment.role.name='translated') )) = 1 ; 
WR3: SELF\attribute_value_assignment.attribute_name <> '' ;
WR4: SIZEOF(QUERY(ci <* items |
SIZEOF(QUERY(ata <* USEDIN(ci, 'MULTI_LINGUISM_MIM.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS') |
(ata\attribute_value_assignment.attribute_name = SELF\attribute_value_assignment.attribute_name) AND 
(ata.translation_language :=: translation_language) ))>1 )) =0;
WR5: SIZEOF(QUERY(ci <* items |
SIZEOF(QUERY(ata <* USEDIN(ci, 'MULTI_LINGUISM_MIM.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS') |
 (ata\attribute_classification_assignment.role.name='primary') AND
 (ata\attribute_classification_assignment.attribute_name= SELF\attribute_value_assignment.attribute_name) AND 
 (ata\attribute_classification_assignment.assigned_class :=: translation_language) ))>0 )) =0;
END_ENTITY; 


RULE restrict_language_assignment_per_attribute FOR (attribute_language_assignment);
WHERE
WR1: SIZEOF ( QUERY ( ala1 <* attribute_language_assignment |
	SIZEOF(QUERY( it <* ala1.items |
	   SIZEOF ( QUERY ( ala2 <* USEDIN ( it ,'MULTI_LINGUISM_MIM.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS' ) | 
		( ala1\attribute_classification_assignment.attribute_name = ala2\attribute_classification_assignment.attribute_name ) AND 
		( ala1\attribute_classification_assignment.assigned_class :=: ala2\attribute_classification_assignment.assigned_class )
		 )) >1 
	   )) >0 
	)) =0;
END_RULE;

END_SCHEMA;


--
-- NAME_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/name_assignment/mim.exp)
--
(*
 $Id: mim.exp,v 1.6 2004/11/19 21:37:37 robbod Exp 
 ISO TC184/SC4/WG12 N3086 - ISO/TS 10303-1340 Name assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2283
*) 


SCHEMA Name_assignment_mim;

USE FROM management_resources_schema   -- ISO 10303-41
  (name_assignment); 


TYPE name_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_name_assignment
  SUBTYPE OF (name_assignment);
  item : name_item;
END_ENTITY;

END_SCHEMA;  -- Name_assignment_mim






--
-- NUMERIC_EXPRESSION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/numeric_expression/mim.exp)
--
(*
   $Id: mim.exp,v 1.5 2017/10/26 15:52:18 verodub Exp 
   ISO TC184/SC4/WG12 N7868 - ISO/TS 10303-1526 Numeric expression - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N7221
*)

SCHEMA Numeric_expression_mim;

USE FROM Expression_mim;   -- ISO/TS 10303-1342
USE FROM Generic_expression_mim;   -- ISO/TS 10303-1341
USE FROM iso13584_expressions_schema(   -- ISO 13584-20
	and_expression,
	binary_boolean_expression,
	binary_function_call,
	binary_numeric_expression,
	boolean_defined_function,
	boolean_expression,
	boolean_literal,
	boolean_variable,
	comparison_equal,
	comparison_expression,
	comparison_greater,
	comparison_greater_equal,
	comparison_less,
	comparison_less_equal,
	comparison_not_equal,
	defined_function,
	div_expression,
	equals_expression,
	expression,
	int_literal,
	int_numeric_variable,
	literal_number,
	minus_expression,
	mod_expression,
	mult_expression,
	multiple_arity_boolean_expression,
	multiple_arity_function_call,
	multiple_arity_numeric_expression,
	not_expression,
	numeric_expression,
	numeric_variable,
	or_expression,
	plus_expression,
	power_expression,
	real_literal,
	real_numeric_variable,
	simple_boolean_expression,
	simple_numeric_expression,
	slash_expression,
	unary_boolean_expression,
	unary_numeric_expression,
	xor_expression
	);
USE FROM Numeric_function_mim;   -- ISO/TS 10303-1346
	
END_SCHEMA;


--
-- NUMERIC_FUNCTION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/numeric_function/mim.exp)
--
(*
 $Id: mim.exp,v 1.22 2017/10/26 15:52:18 verodub Exp 
 ISO TC184/SC4/WG12 N7871 - ISO/TS 10303-1346 Numeric function - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N7227 
*)

SCHEMA Numeric_function_mim;

USE FROM Elementary_function_mim;   -- ISO/TS 10303-1527

USE FROM Expression_mim;   -- ISO/TS 10303-1342

USE FROM iso13584_expressions_schema(   -- ISO 13584-20
	int_value_function,
	length_function,	
	odd_function,	
	value_function);
	
END_SCHEMA;


--
-- OBSERVATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/observation/mim.exp)
--
(*
Id: mim.exp,v 1.18 2010/11/12 16:31:52 mikeward Exp 
ISO TC184/SC4/WG12 N7277 - ISO/TS 10303-1258 Observation - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6049
*) 


SCHEMA Observation_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_directive,
   action_relationship); 

USE FROM Activity_as_realized_mim;    -- ISO/TS 10303-1259

USE FROM Activity_mim;    -- ISO/TS 10303-1047

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Description_assignment_mim;    -- ISO/TS 10303-1473

USE FROM Management_resource_information_mim;    -- ISO/TS 10303-1288

USE FROM Name_assignment_mim;    -- ISO/TS 10303-1340

USE FROM Product_as_individual_mim;    -- ISO/TS 10303-1164

USE FROM qualified_measure_schema   -- ISO 10303-45
  (descriptive_representation_item); 

USE FROM representation_schema   -- ISO 10303-43
  (representation_context,
   representation_item); 

USE FROM Work_order_mim;    -- ISO/TS 10303-1043

USE FROM Work_request_mim;    -- ISO/TS 10303-1042


TYPE observation_approval = SELECT BASED_ON mri_approval_item WITH 
   (observation);
END_TYPE; 

TYPE observation_classification = SELECT BASED_ON classification_item WITH 
   (observation, 
    observation_relationship);
END_TYPE; 

TYPE observation_consequence_name_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON name_item WITH 
   (observation_consequence);
END_TYPE; 

TYPE observation_consequence_role = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON description_item WITH 
   (observation_consequence);
END_TYPE; 

TYPE observation_date = SELECT
   (observation);
END_TYPE; 

TYPE observation_date_and_time = SELECT BASED_ON mri_date_and_time_item WITH 
   (observation);
END_TYPE; 

TYPE observation_identification_item = SELECT BASED_ON mri_identification_item WITH 
   (observation, 
    observation_consequence);
END_TYPE; 

TYPE observation_organization = SELECT BASED_ON mri_organization_item WITH 
   (observation);
END_TYPE; 

TYPE observation_person_and_organization = SELECT BASED_ON mri_person_and_organization_item WITH 
   (observation);
END_TYPE; 

TYPE observation_recorder_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH 
   (product_definition_formation);
END_TYPE; 

TYPE observed_context_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items;
END_TYPE; 

ENTITY observation
  SUBTYPE OF (action_actual);
END_ENTITY;

ENTITY observation_consequence
  SUBTYPE OF (applied_action_assignment);
END_ENTITY;

ENTITY observation_relationship
  SUBTYPE OF (action_relationship);
END_ENTITY;

END_SCHEMA;  -- Observation_mim


--
-- ORGANIZATION_TYPE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/organization_type/mim.exp)
--
(*
 $Id: mim.exp,v 1.8 2004/11/19 21:37:38 robbod Exp 
 ISO TC184/SC4/WG12 N3092 - ISO/TS 10303-1240 Organization type - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2400
*) 


SCHEMA Organization_type_mim;

USE FROM management_resources_schema   -- ISO 10303-41
  (organization_type_assignment); 

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011

USE FROM person_organization_schema   -- ISO 10303-41
  (organization,
   organization_type); 


TYPE organization_type_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (organization);
END_TYPE; 

ENTITY applied_organization_type_assignment
  SUBTYPE OF (organization_type_assignment);
  items : SET[1:?] OF organization_type_item;
END_ENTITY;

END_SCHEMA;  -- Organization_type_mim




--
-- PART_AND_VERSION_IDENTIFICATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/part_and_version_identification/mim.exp)
--
(*
 $Id: mim.exp,v 1.10 2012/10/06 20:09:56 liutkuviene Exp 
ISO TC184/SC4/WG12 N7703 - ISO/TS 10303-1022 Part and version identification - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6581
*) 


SCHEMA Part_and_version_identification_mim;

USE FROM product_definition_schema   -- ISO 10303-41
  (product_category,
   product_related_product_category); 

USE FROM Product_identification_mim;    -- ISO/CD-TS 10303-1017

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

END_SCHEMA;  -- Part_and_version_identification_mim



--
-- PART_COLLECTION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/part_collection/mim.exp)
--
(*
 $Id: mim.exp,v 1.23 2012/10/08 00:47:24 thomasrthurman Exp 
 ISO TC184/SC4/WG12 N7745 - ISO/TS 10303-1115 Part collection - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N6915
*)

SCHEMA Part_collection_mim;

USE FROM Product_occurrence_mim;

REFERENCE FROM product_definition_schema
	(categories_of_product);


  RULE restrict_collection_category FOR (product_definition);
    LOCAL
      collection_definitions: SET OF product_definition := [];
    END_LOCAL;
      collection_definitions :=  QUERY( pd <* product_definition | 
        SIZEOF( QUERY( pdca <* USEDIN( pd, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') |
        pdca.frame_of_reference.name= 'collection definition')) > 0 );
    WHERE
      WR1: SIZEOF( QUERY( pd <* collection_definitions | 
	    NOT ('collection' IN categories_of_product(pd.formation.of_product)) ))= 0;
  END_RULE;

  RULE restrict_product_definitions_for_collection FOR
      (product_definition_relationship);
    WHERE
      WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
       ( pdr. name = 'collection membership' ) AND 
       ( ( pdr.relating_product_definition.frame_of_reference.name<>'part definition' ) OR 
       ( pdr.related_product_definition.frame_of_reference.name<>'part occurrence' ) OR 
       ( SIZEOF ( QUERY ( pdca <* USEDIN (pdr.relating_product_definition ,
       'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') | 
       ( pdca.role.name = 'part definition type' ) AND 
       ( pdca.frame_of_reference.name = 'collection definition' ) )) =0 ) ) ) ) =0;
  END_RULE;
  
END_SCHEMA;


--
-- PART_DEFINITION_RELATIONSHIP_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/part_definition_relationship/mim.exp)
--
(*
 $Id: mim.exp,v 1.7 2017/10/26 10:55:02 verodub Exp 
 ISO TC184/SC4/WG12 N9873 - ISO/TS 10303-1055 Part definition relationship - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N1327
*)
   
SCHEMA Part_definition_relationship_mim;

USE FROM Part_view_definition_mim;   -- ISO/TS 10303-1023
USE FROM product_structure_schema   -- ISO 10303-44
	(make_from_usage_option);
USE FROM Product_view_definition_relationship_mim;   -- ISO/TS 10303-1041
USE FROM Value_with_unit_mim; -- ISO/TS 10303-1054

ENTITY definitional_product_definition_usage
  SUBTYPE OF (product_definition_usage);
UNIQUE
  UR1 : relating_product_definition, related_product_definition;
END_ENTITY;

END_SCHEMA;


--
-- PART_SHAPE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/part_shape/mim.exp)
--
(*
   $Id: mim.exp,v 1.6 2019/01/23 18:22:58 brandon Exp 
   ISO TC184/SC4/WG12 N9693 - ISO/TS 10303-1807 General part feature - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N7332
*)

SCHEMA Part_shape_mim;

USE FROM Part_view_definition_mim;    --  ISO/TS 10303-1023 
USE FROM product_property_definition_schema(shape_aspect_occurrence);  -- ISO/TS 10303-41
USE FROM Shape_feature_mim; -- ISO/TS 10303-1764
USE FROM Shape_property_assignment_mim; -- ISO/TS 10303-1032


END_SCHEMA;


--
-- PART_VIEW_DEFINITION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/part_view_definition/mim.exp)
--
(*
 $Id: mim.exp,v 1.12 2012/10/11 05:49:25 liutkuviene Exp 
 ISO TC184/SC4/WG12 N8039 - ISO/TS 10303-1023 Part view definition - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N7455
*)


SCHEMA Part_view_definition_mim;

USE FROM Part_and_version_identification_mim;    -- ISO/TS 10303-1022

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019


END_SCHEMA;  -- Part_view_definition_mim


--
-- PERSON_ORGANIZATION_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/person_organization_assignment/mim.exp)
--
(*
Id: mim.exp,v 1.8 2010/06/09 21:51:47 philsp Exp 
ISO TC184/SC4/WG12 N7123 - ISO/TS 10303-1013 Person organization assignment - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1091
*)
      
SCHEMA Person_organization_assignment_mim;

USE FROM management_resources_schema   -- ISO 10303-41
  (organization_assignment,
   person_and_organization_assignment); 

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011

USE FROM person_organization_schema   -- ISO 10303-41
  (organization_role,
   person_and_organization_role); 


TYPE organization_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

TYPE person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_organization_assignment
  SUBTYPE OF (organization_assignment);
  items : SET[1:?] OF organization_item;
END_ENTITY;

ENTITY applied_person_and_organization_assignment
  SUBTYPE OF (person_and_organization_assignment);
  items : SET[1:?] OF person_and_organization_item;
END_ENTITY;

END_SCHEMA;  -- Person_organization_assignment_mim


--
-- PERSON_ORGANIZATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/person_organization/mim.exp)
--
(*
 $Id: mim.exp,v 1.11 2004/10/29 16:20:10 thendrix Exp 
ISO TC184/SC4/WG12 N2922 - ISO/TS 10303-1011 Person organization - EXPRESS MIM
*) 


SCHEMA Person_organization_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute,
   id_attribute_select,
   name_attribute,
   name_attribute_select); 

USE FROM person_organization_schema   -- ISO 10303-41
  (address,
   organization,
   organization_relationship,
   organizational_address,
   person,
   person_and_organization,
   personal_address); 


ENTITY person_and_organization_address
  SUBTYPE OF (organizational_address, personal_address);
  SELF\organizational_address.organizations : SET[1:1] OF organization;
  SELF\personal_address.people : SET[1:1] OF person;
WHERE
  WR1: SIZEOF(QUERY(pao <* USEDIN (SELF\personal_address.people[1], 'PERSON_ORGANIZATION_SCHEMA.PERSON_AND_ORGANIZATION.THE_PERSON') | pao.the_organization :=: SELF\organizational_address.organizations[1])) = 1;
END_ENTITY;

END_SCHEMA;  -- Person_organization_mim


--
-- PERSON_ORGANIZATION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/person_organization_schema/person_organization_schema.exp)
--
(*
Id: person_organization_schema.exp,v 1.32 2017/10/09 12:26:21 verodub Exp 
ISO 10303 TC184/SC4/WG12 N9834

EXPRESS Source:
ISO 10303-41 ed5 Fundamentals of product description and support - Person organization schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2017  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed5 Fundamentals of product description and support - Person organization schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA person_organization_schema '{iso standard 10303 part(41) version(8) object(1) person_organization_schema(16)}';

  REFERENCE FROM basic_attribute_schema (   -- ISO 10303-41
    description_attribute, 
    description_attribute_select,
    generic_attribute,
    generic_attribute_assignment,
    generic_attribute_list_assignment,
    generic_attribute_list_select,
    generic_attribute_select,
    get_description_value, 
    get_id_value, 
    get_name_value, 
    get_role, 
    id_attribute, 
    id_attribute_select,
    name_attribute, 
    name_attribute_select,
    object_role, 
    role_association);

  REFERENCE FROM support_resource_schema (   -- ISO 10303-41
    bag_to_set, 
    identifier, 
    label, 
    text);

  TYPE person_organization_select = SELECT (
    person, 
    organization, 
    person_and_organization);
  END_TYPE;

  TYPE pos_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    person_and_organization_role,
    person_and_organization,
    person_role,
    organization_role,
    organizational_project);
  END_TYPE;
  
  TYPE pos_generic_attribute_select = SELECT BASED_ON generic_attribute_select WITH (
    address);
  END_TYPE; 

  TYPE pos_generic_attribute_list_select = SELECT BASED_ON generic_attribute_list_select WITH (
    address,
    person);
  END_TYPE; 

  TYPE pos_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    address,
    organizational_project);
  END_TYPE;

  TYPE pos_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    address,
    person_and_organization);
  END_TYPE;

  ENTITY address;
    internal_location : OPTIONAL label;
    street_number : OPTIONAL label;
    street : OPTIONAL label;
    postal_box : OPTIONAL label;
    town : OPTIONAL label;
    region : OPTIONAL label;
    postal_code : OPTIONAL label;
    country : OPTIONAL label;
    facsimile_number : OPTIONAL label;
    telephone_number : OPTIONAL label;
    electronic_mail_address : OPTIONAL label;
    telex_number : OPTIONAL label;
  DERIVE
    name : label := get_name_value(SELF);
    url : identifier := get_id_value(SELF);
  WHERE
    WR1: EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number);
  END_ENTITY;

  ENTITY organization;
    id : OPTIONAL identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY organization_relationship;
    name : label;
    description : OPTIONAL text;
    relating_organization : organization;
    related_organization : organization;
  END_ENTITY;

  ENTITY organization_role;
    name : label;
  DERIVE
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY organization_type;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY organization_type_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_organization_type : organization_type;
    related_organization_type : organization_type;
  END_ENTITY;

  ENTITY organizational_address
    SUBTYPE OF (address);
    organizations : SET [1:?] OF organization;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY organizational_project;
    name : label;
    description : OPTIONAL text;
    responsible_organizations : SET [1:?] OF organization;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY organizational_project_relationship;
    name : label;
    description : OPTIONAL text;
    relating_organizational_project : organizational_project;
    related_organizational_project : organizational_project;
  END_ENTITY;

  ENTITY person;
    id : identifier;
    last_name : OPTIONAL label;
    first_name : OPTIONAL label;
    middle_names : OPTIONAL LIST [1:?] OF label;
    prefix_titles : OPTIONAL LIST [1:?] OF label;
    suffix_titles : OPTIONAL LIST [1:?] OF label;
  WHERE
    WR1: EXISTS(last_name) OR EXISTS(first_name);
  END_ENTITY;

  ENTITY person_and_organization;
    the_person : person;
    the_organization : organization;
  DERIVE
    name : label := get_name_value(SELF);
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY person_and_organization_role;
    name : label;
  DERIVE
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY person_role;
    name : label;
  DERIVE
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY person_type;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY person_type_definition;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    formation : person_type_definition_formation;
  END_ENTITY;

  ENTITY person_type_definition_formation;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    of_person_type : person_type;
  END_ENTITY;

  ENTITY person_type_definition_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_person_type_definition : person_type_definition;
    related_person_type_definition : person_type_definition;
  END_ENTITY;

  ENTITY personal_address
    SUBTYPE OF (address);
    people : SET [1:?] OF person;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY position_in_organization;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY position_in_organization_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_position_in_organization : position_in_organization;
    related_position_in_organization : position_in_organization;
  END_ENTITY;

  ENTITY position_in_organization_type;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  FUNCTION acyclic_organization_relationship (relation : organization_relationship; relatives : SET [1:?] OF organization; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF organization_relationship;
    END_LOCAL;

    IF relation.relating_organization IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(org <* bag_to_set(USEDIN(relation.relating_organization, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATION_RELATIONSHIP.' + 'RELATED_ORGANIZATION')) | specific_relation IN TYPEOF(org));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organization_relationship(x[i], relatives + relation.relating_organization, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_organization_type_relationship (relation : organization_type_relationship; relatives : SET OF organization_type; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF organization_type_relationship;
    END_LOCAL;

    IF relation.relating_organization_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(orgtyp <* bag_to_set(USEDIN(relation.relating_organization_type, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATION_TYPE_RELATIONSHIP.' + 'RELATED_ORGANIZATION_TYPE')) | specific_relation IN TYPEOF(orgtyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organization_type_relationship(x[i], relatives + relation.relating_organization_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_organizational_project_relationship (relation : organizational_project_relationship; relatives : SET [1:?] OF organizational_project; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF organizational_project_relationship;
    END_LOCAL;

    IF relation.relating_organizational_project IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(op <* bag_to_set(USEDIN(relation.relating_organizational_project, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATIONAL_PROJECT_RELATIONSHIP.' + 'RELATED_ORGANIZATIONAL_PROJECT')) | specific_relation IN TYPEOF(op));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organizational_project_relationship(x[i], relatives + relation.relating_organizational_project, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_person_type_definition_relationship (relation : person_type_definition_relationship; relatives : SET OF person_type_definition; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF person_type_definition_relationship;
    END_LOCAL;

    IF relation.relating_person_type_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ptdef <* bag_to_set(USEDIN(relation.relating_person_type_definition, 'PERSON_ORGANIZATION_SCHEMA.' + 'PERSON_TYPE_DEFINITION_RELATIONSHIP.' + 'RELATED_PERSON_TYPE_DEFINITION')) | specific_relation IN TYPEOF(ptdef));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_person_type_definition_relationship(x[i], relatives + relation.relating_person_type_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_position_in_organization_relationship (relation : position_in_organization_relationship; relatives : SET OF position_in_organization; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF position_in_organization_relationship;
    END_LOCAL;

    IF relation.relating_position_in_organization IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(piorg <* bag_to_set(USEDIN(relation.relating_position_in_organization, 'PERSON_ORGANIZATION_SCHEMA.' + 'POSITION_IN_ORGANIZATION_RELATIONSHIP.' + 'RELATED_POSITION_IN_ORGANIZATION')) | specific_relation IN TYPEOF(piorg));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_position_in_organization_relationship(x[i], relatives + relation.relating_position_in_organization, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;


--
-- PHYSICAL_BREAKDOWN_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/physical_breakdown/mim.exp)
--
(*
 $Id: mim.exp,v 1.12 2008/09/13 12:26:54 liutkuviene Exp 
 ISO TC184/SC4/WG12 N5450 - ISO/TS 10303-1215 Physical breakdown - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4947
*) 

SCHEMA Physical_breakdown_mim;

USE FROM Product_breakdown_mim;    -- ISO/TS 10303-1248


  ENTITY physical_breakdown_context
    SUBTYPE OF (breakdown_context);
  END_ENTITY;

  ENTITY physical_element_usage
    SUBTYPE OF (breakdown_element_usage);
  END_ENTITY;

END_SCHEMA;  


--
-- PLIB_CLASS_REFERENCE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/plib_class_reference/mim.exp)
--
(*
 $Id: mim.exp,v 1.11 2008/09/13 12:26:56 liutkuviene Exp 
 ISO TC184/SC4/WG12 N5456 - ISO/TS 10303-1291 Plib class reference - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4841
*) 


SCHEMA Plib_class_reference_mim;

USE FROM External_class_mim;    -- ISO/TS 10303-1275

USE FROM External_item_identification_assignment_mim;    -- ISO/TS 10303-1128

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM external_reference_schema   -- ISO 10303-41
  (external_source,
   pre_defined_item); 

  TYPE plib_class_identification_item = SELECT BASED_ON external_identification_item WITH 
    (externally_defined_class);
  END_TYPE; 

  TYPE plib_class_organization_item = SELECT BASED_ON organization_item WITH 
    (class);
  END_TYPE; 

  ENTITY known_source
    SUBTYPE OF (external_source, pre_defined_item);
  END_ENTITY;

END_SCHEMA;



--
-- POSITION_IN_ORGANIZATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/position_in_organization/mim.exp)
--
(*
 $Id: mim.exp,v 1.9 2004/11/19 21:37:38 robbod Exp 
 ISO TC184/SC4/WG12 N3098 - ISO/TS 10303-1242 Position in organization - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2403
*) 


SCHEMA Position_in_organization_mim;

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM group_schema;    -- ISO 10303-41

USE FROM management_resources_schema   -- ISO 10303-41
  (group_assignment,
   name_assignment,
   position_in_organization_assignment,
   position_in_organization_type_assignment); 

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011

USE FROM person_organization_schema   -- ISO 10303-41
  (address,
   organization,
   organizational_project,
   person,
   person_type,
   position_in_organization,
   position_in_organization_relationship,
   position_in_organization_type); 

USE FROM Project_mim;    -- ISO/TS 10303-1061

USE FROM Type_of_person_mim;    -- ISO/TS 10303-1245


TYPE position_in_organization_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (applied_position_in_organization_assignment, 
    applied_position_in_organization_type_assignment, 
    group, 
    position_in_organization, 
    position_in_organization_relationship, 
    position_in_organization_type);
END_TYPE; 

TYPE position_in_organization_group_assignment_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (position_in_organization_assignment);
END_TYPE; 

TYPE position_in_organization_group_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

TYPE position_in_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (address, 
    organization, 
    organizational_project, 
    person);
END_TYPE; 

TYPE position_in_organization_type_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (person_type, 
    position_in_organization);
END_TYPE; 

TYPE project_group_name_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (applied_position_in_organization_group_assignment);
END_TYPE; 

ENTITY applied_position_in_organization_assignment
  SUBTYPE OF (position_in_organization_assignment);
  items : SET[1:?] OF position_in_organization_item;
END_ENTITY;

ENTITY applied_position_in_organization_assignment_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET[1:?] OF position_in_organization_group_assignment_item;
END_ENTITY;

ENTITY applied_position_in_organization_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET[1:?] OF position_in_organization_group_item;
END_ENTITY;

ENTITY applied_position_in_organization_type_assignment
  SUBTYPE OF (position_in_organization_type_assignment);
  items : SET[1:?] OF position_in_organization_type_item;
END_ENTITY;

ENTITY applied_project_group_name_assignment
  SUBTYPE OF (name_assignment);
  items : SET[1:?] OF project_group_name_item;
END_ENTITY;

END_SCHEMA;  -- Position_in_organization_mim


--
-- PROBABILITY_DISTRIBUTION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/probability_distribution/mim.exp)
--
(*
   ISO TC184/SC4/WG12 N11085 - ISO/TS 10303-1274 Probability distribution - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5894
*) 

SCHEMA Probability_distribution_mim;

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Probability_mim;    -- ISO/TS 10303-1252

TYPE probability_distribution_item = SELECT BASED_ON classification_item WITH 
   (measure_representation_item);
END_TYPE; 

END_SCHEMA;  -- Probability_distribution_mim


--
-- PROBABILITY_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/probability/mim.exp)
--
(*
   ISO TC184/SC4/WG12 N11082 - ISO/TS 10303-1252 Probability - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5891
*) 

SCHEMA Probability_mim;

USE FROM External_representation_item_mim;    -- ISO/TS 10303-1779

USE FROM Measure_representation_mim;    -- ISO/TS 10303-1118

END_SCHEMA;  -- Probability_mim



--
-- PROCESS_PROPERTY_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/process_property_assignment/mim.exp)
--
(*
 $Id: mim.exp,v 1.17 2008/09/13 12:26:54 liutkuviene Exp 
 ISO TC184/SC4/WG12 N5471 - ISO/TS 10303-1040 Process property assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4953
*)

SCHEMA Process_property_assignment_mim; 

USE FROM Activity_mim;    -- ISO/TS 10303-1047

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Independent_property_mim;    -- ISO/TS 10303-1036

USE FROM process_property_representation_schema   -- ISO 10303-49
  (action_property_representation); 

USE FROM process_property_schema   -- ISO 10303-49
  (action_property,
   characterized_action_definition); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (derived_property_select,
   general_property_association); 


END_SCHEMA; 


--
-- PROCESS_PROPERTY_REPRESENTATION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/process_property_representation_schema/process_property_representation_schema.exp)
--
(*
Id: process_property_representation_schema.exp,v 1.4 2015/06/29 19:32:11 dgnedwards Exp 
ISO 10303 TC184/SC4/WG12 N8547

EXPRESS Source:
ISO 10303-49 ed1 Process structure and properties - Process property representation schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-49 ed1 Process structure and properties - Process property representation schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA process_property_representation_schema '{iso standard 10303 part(49) version(1) object(1) process_property_representation_schema(2)}';

REFERENCE FROM support_resource_schema
    (label, 
     text);

REFERENCE FROM representation_schema
    (representation);

REFERENCE FROM process_property_schema
    (action_property, 
     resource_property);

ENTITY action_property_representation;
  name           : label;
  description    : text;
  property       : action_property;
  representation : representation;
END_ENTITY;

ENTITY resource_property_representation;
  name           : label;
  description    : text;
  property       : resource_property;
  representation : representation;
END_ENTITY;

END_SCHEMA; -- process_property_representation_schema


--
-- PROCESS_PROPERTY_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/process_property_schema/process_property_schema.exp)
--
(*
Id: process_property_schema.exp,v 1.4 2015/06/29 19:32:44 dgnedwards Exp 
ISO 10303 TC184/SC4/WG12 N8548

EXPRESS Source:
ISO 10303-49 ed1 Process structure and properties - Process property schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-49 ed1 Process structure and properties - Process property schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA process_property_schema '{iso standard 10303 part(49) version(1) object(1) process_property_schema(3)}';

REFERENCE FROM action_schema
    (action, 
     action_method,
     action_method_relationship,
     action_relationship,
     action_resource,
     action_resource_relationship,
     acyclic_action_relationship);

REFERENCE FROM product_property_definition_schema
    (characterized_product_definition,
     property_definition, 
     shape_definition);

REFERENCE FROM support_resource_schema
    (identifier,
     label,
     text);

TYPE characterized_action_definition = SELECT
   (action,
   action_method,
   action_method_relationship,
   action_relationship);
END_TYPE;

TYPE characterized_resource_definition = SELECT
  (action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship);
END_TYPE;

TYPE property_or_shape_select = SELECT
     (property_definition,
      shape_definition);
END_TYPE;

ENTITY action_property;
  name        : label;
  description : text;
  definition  : characterized_action_definition;
END_ENTITY;

ENTITY product_definition_process
  SUBTYPE OF (action);
  identification : identifier;
INVERSE 
  product_definitions : SET [1:?] OF process_product_association FOR process;
END_ENTITY;

ENTITY process_product_association;
  name            : label;
  description     : text;
  defined_product : characterized_product_definition;
  process         : product_definition_process;
END_ENTITY;

ENTITY property_process
  SUBTYPE OF (action);
  identification : identifier;
INVERSE
  properties : SET [1:?] OF process_property_association FOR process;
END_ENTITY;

ENTITY process_property_association;
  name              : label;
  description       : text;
  process           : property_process;
  property_or_shape : property_or_shape_select;
END_ENTITY;

ENTITY replacement_relationship
  SUBTYPE OF (action_relationship);
WHERE
  WR1: acyclic_action_relationship (SELF,
       [SELF\action_relationship.related_action],
       'PROCESS_PROPERTY_SCHEMA.REPLACEMENT_RELATIONSHIP');
END_ENTITY;

ENTITY resource_property;
  name        : label;
  description : text;
  resource    : characterized_resource_definition;
END_ENTITY;

ENTITY action_resource_requirement;
  name        : label;
  description : text;
  kind        : resource_requirement_type;
  operations  : SET [1:?] OF characterized_action_definition;
END_ENTITY;

ENTITY action_property_relationship;
  name                     : label;
  description              : text;
  relating_action_property : action_property;
  related_action_property  : action_property;
WHERE
  WR1: relating_action_property :<>: related_action_property;
END_ENTITY;

ENTITY requirement_for_action_resource
  SUBTYPE OF (action_resource_requirement);
  resources : SET [1:?] OF action_resource;
END_ENTITY;

ENTITY resource_property_relationship;
  name                       : label;
  description                : text;
  relating_resource_property : resource_property;
  related_resource_property  : resource_property;
WHERE
  WR1: relating_resource_property :<>: related_resource_property;
END_ENTITY;

ENTITY action_resource_requirement_relationship;
  name                                 : label;
  description                          : text;
  relating_action_resource_requirement : action_resource_requirement;
  related_action_resource_requirement  : action_resource_requirement;
WHERE
  WR1: relating_action_resource_requirement :<>: 
       related_action_resource_requirement;
END_ENTITY;

ENTITY resource_requirement_type;
  name        : label;
  description : text;
END_ENTITY;

ENTITY resource_requirement_type_relationship;
  name                      : label;
  description               : text;
  relating_requirement_type : resource_requirement_type;
  related_requirement_type  : resource_requirement_type;
WHERE
  WR1: relating_requirement_type :<>: related_requirement_type;
END_ENTITY;

END_SCHEMA; -- process_property_schema


--
-- PRODUCT_ANALYSIS_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/product_analysis_schema/product_analysis_schema.exp)
--
(*
Id: product_analysis_schema.exp,v 1.11 2014/03/04 00:30:39 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N6003

EXPRESS Source:
ISO 10303-53 ed1 Numerical analysis - Product analysis schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-53 ed1 Numerical analysis - Product analysis schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA product_analysis_schema '{iso standard 10303 part(53) version(1) object(1) product_analysis_schema(2)}';
  REFERENCE FROM analysis_product_relationships_schema  -- ISO 10303-53
    (idealisation_relationship);
  REFERENCE FROM product_property_definition_schema     -- ISO 10303-41
    (general_property);
  REFERENCE FROM support_resource_schema                -- ISO 10303-41
    (bag_to_set,
     identifier,
     label,
     text);

ENTITY behavioural_decomposition_of_temporal_spatial_domain;
  parts : SET [2 : ?] OF temporal_spatial_domain;
  whole : temporal_spatial_domain;
END_ENTITY;

ENTITY domain_property;
  domain : temporal_spatial_domain;
  property_type : general_property;
END_ENTITY;

ENTITY physical_action_domain
SUBTYPE OF (temporal_spatial_domain);
  initial : physical_state_domain;
  final : physical_state_domain;
END_ENTITY;

ENTITY physical_product_domain
SUBTYPE OF (temporal_spatial_domain);
  temporal_parts : SET [0 : ?] OF physical_action_domain;
END_ENTITY;

ENTITY physical_state_domain
SUBTYPE OF (temporal_spatial_domain);
END_ENTITY;

ENTITY spatial_decomposition_of_temporal_spatial_domain;
  parts : SET [2 : ?] OF temporal_spatial_domain;
  whole : temporal_spatial_domain;
END_ENTITY;

ENTITY temporal_decomposition_of_action_domain;
  whole : physical_action_domain;
  parts : LIST [2 : ?] OF physical_action_domain;
END_ENTITY;

ENTITY temporal_spatial_domain;
  id : identifier;
  name : label;
  description : text;
WHERE
    wr1: definition_for_temporal_spatial_domain(SELF);
END_ENTITY;

SUBTYPE_CONSTRAINT sc1_temporal_spatial_domain FOR temporal_spatial_domain;
  ABSTRACT SUPERTYPE;
END_SUBTYPE_CONSTRAINT;

  FUNCTION definition_for_temporal_spatial_domain (domain : temporal_spatial_domain): BOOLEAN;
    LOCAL
      spatial_set : SET OF spatial_decomposition_of_temporal_spatial_domain;
      behavioural_set : SET OF behavioural_decomposition_of_temporal_spatial_domain;
      domains : SET OF temporal_spatial_domain := [];
      idealising : BAG OF idealisation_relationship;
      spatial_bag : BAG OF spatial_decomposition_of_temporal_spatial_domain;
      behavioural_bag : BAG OF behavioural_decomposition_of_temporal_spatial_domain;
    END_LOCAL;

    idealising := USEDIN(domain, 'ANALYSIS_PRODUCT_RELATIONSHIPS_SCHEMA.IDEALISATION_RELATIONSHIP.IDEALISATION');
    IF SIZEOF(idealising) > 0 THEN
      RETURN (TRUE);
    END_IF;
    spatial_bag := USEDIN(domain, 'PRODUCT_ANALYSIS_SCHEMA.SPATIAL_DECOMPOSITION_OF_TEMPORAL_SPATIAL_DOMAIN.PARTS');
    IF SIZEOF(spatial_bag) > 0 THEN
      spatial_set := bag_to_set(spatial_bag);
      REPEAT i := 1 TO HIINDEX(spatial_set);
        domains := domains + spatial_set[i].whole;
      END_REPEAT;
    END_IF;
    behavioural_bag := USEDIN(domain, 'PRODUCT_ANALYSIS_SCHEMA.BEHAVIOURAL_DECOMPOSITION_OF_TEMPORAL_SPATIAL_DOMAIN.PARTS');
    IF SIZEOF(behavioural_bag) > 0 THEN
      behavioural_set := bag_to_set(behavioural_bag);
      REPEAT i := 1 TO HIINDEX(behavioural_set);
        domains := domains + behavioural_set[i].whole;
      END_REPEAT;
    END_IF;
    IF SIZEOF(domains) > 0 THEN
      REPEAT i := 1 TO HIINDEX(domains);
        IF definition_for_temporal_spatial_domain(domains[i]) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (FALSE);
  END_FUNCTION;



END_SCHEMA;



--
-- PRODUCT_AS_INDIVIDUAL_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_as_individual/mim.exp)
--
(*
ISO TC184/SC4/WG12 N11079 - ISO/TS 10303-1164 Product as individual - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N7269
*) 


SCHEMA Product_as_individual_mim;

USE FROM Configuration_item_mim; -- ISO/TS 10303-1056

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_related_product_category,
   product_relationship);

USE FROM Product_occurrence_mim;    -- ISO/TS 10303-1063

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019

TYPE product_as_individual_identification_item = SELECT BASED_ON identification_item WITH
  (product,
   product_definition_formation);
END_TYPE;

ENTITY product_as_planned
SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY product_design_to_individual
SUBTYPE OF (product_relationship);
  SELF\product_relationship.related_product RENAMED individual_product : product;
  SELF\product_relationship.relating_product RENAMED product_design : product;
END_ENTITY;

ENTITY product_design_version_to_individual
SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.related_product_definition_formation RENAMED individual_product : product_definition_formation;
  SELF\product_definition_formation_relationship.relating_product_definition_formation RENAMED product_design_version : product_definition_formation;
END_ENTITY;

ENTITY product_planned_to_realized
SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation RENAMED planned_product : product_as_planned;
  SELF\product_definition_formation_relationship.related_product_definition_formation RENAMED realized_product : product_definition_formation;
END_ENTITY;

END_SCHEMA;



--
-- PRODUCT_BREAKDOWN_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_breakdown/mim.exp)
--
(*
 $Id: mim.exp,v 1.21 2012/10/06 20:09:56 liutkuviene Exp 
 ISO TC184/SC4/WG12 N7775 - ISO/TS 10303-1248 Product breakdown - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N5474
*) 


SCHEMA Product_breakdown_mim;

USE FROM group_schema(group);    -- ISO 10303-41

USE FROM management_resources_schema   -- ISO 10303-41
  (group_assignment); 

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition,
   product_definition_relationship); 

USE FROM product_property_definition_schema(characterized_object);    -- ISO 10303-41

USE FROM product_structure_schema   -- ISO 10303-44
  (product_definition_usage); 

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030


  TYPE product_definition_or_breakdown_element_usage = EXTENSIBLE GENERIC_ENTITY SELECT
    (product_definition_usage, 
     product_definition);
  END_TYPE; 

  TYPE product_definition_or_product_definition_relationship = EXTENSIBLE GENERIC_ENTITY SELECT
    (product_definition, 
     product_definition_usage);
  END_TYPE; 

  ENTITY breakdown_context
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY;

  ENTITY breakdown_element_group_assignment
    SUBTYPE OF (group_assignment);
      SELF\group_assignment.assigned_group : product_definition_element_relationship;
      items : SET[1:1] OF product_definition_or_breakdown_element_usage;
  END_ENTITY;

  ENTITY breakdown_element_realization
    SUBTYPE OF (characterized_object, product_definition_element_relationship);
  END_ENTITY;

  ENTITY breakdown_element_usage
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY;

  ENTITY breakdown_of
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY;

  ENTITY product_definition_element_relationship
    SUBTYPE OF (group);
  END_ENTITY;

  ENTITY product_definition_group_assignment
    SUBTYPE OF (group_assignment);
    SELF\group_assignment.assigned_group : product_definition_element_relationship;
    items : SET[1:1] OF product_definition_or_product_definition_relationship;
  END_ENTITY;

END_SCHEMA; 






--
-- PRODUCT_CLASS_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_class/mim.exp)
--
(*
 $Id: mim.exp,v 1.38 2019/06/20 16:13:45 kevin Exp 
 ISO TC184/SC4/WG12 N10404 - ISO/TS 10303-1103 Product class - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N9578
*)

SCHEMA Product_class_mim;

USE FROM Classification_assignment_mim;   -- ISO/TS 10303-1114
USE FROM Group_mim;   -- ISO/TS 10303-1113
USE FROM Identification_assignment_mim;   -- ISO/TS 10303-1021
USE FROM Product_concept_identification_mim;   -- ISO/TS 10303-1060
USE FROM Property_assignment_mim;   -- ISO/TS 10303-1030

USE FROM basic_attribute_schema (   -- ISO 10303-41
  object_role);

USE FROM product_concept_schema(   -- ISO 10303-44
  conditional_concept_feature,
  product_concept_relationship,
  product_concept_feature,
  product_concept_feature_association,
  concept_feature_operator);

USE FROM product_property_definition_schema(   -- ISO 10303-41
  characterized_object);

TYPE category_usage_item = SELECT (product_class);
END_TYPE;

TYPE id_for_class = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH (
  product_class, 
  product_concept_feature);
END_TYPE;

TYPE specification_for_category = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH (
  package_product_concept_feature,
  product_concept_feature);
END_TYPE;

ENTITY characterized_product_concept_feature
  SUBTYPE OF (product_concept_feature, characterized_object);
END_ENTITY;
  
ENTITY characterized_product_concept_feature_category
  SUBTYPE OF (product_concept_feature_category, characterized_object);
END_ENTITY;
  
ENTITY exclusive_product_concept_feature_category
  SUBTYPE OF (product_concept_feature_category);
END_ENTITY;

ENTITY inclusion_product_concept_feature
	SUBTYPE OF (conditional_concept_feature);
	WHERE
		WR1: NOT ( 'PRODUCT_CLASS_MIM.' + 'PACKAGE_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( SELF ) ) ;
		WR2: SIZEOF (QUERY( cfr <* USEDIN( SELF ,'PRODUCT_CONCEPT_SCHEMA.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATING_PRODUCT_CONCEPT_FEATURE' ) | 
						'PRODUCT_CONCEPT_SCHEMA.'+ 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF( cfr ) 
			 )) + 
			 SIZEOF(QUERY( cfr <* USEDIN(SELF , 'PRODUCT_CONCEPT_SCHEMA.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATED_PRODUCT_CONCEPT_FEATURE' ) | 
						'PRODUCT_CONCEPT_SCHEMA.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF(cfr)
			)) = 0;
		WR3: SELF.condition.conditional_operator.name = 'implication';
END_ENTITY;

ENTITY package_product_concept_feature
	SUBTYPE OF (product_concept_feature);
WHERE
	WR1: NOT ( 'PRODUCT_CONCEPT_SCHEMA.' + 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF ( SELF ) ) ;
	WR2: SIZEOF ( QUERY ( cfr <* USEDIN ( SELF , 'PRODUCT_CONCEPT_SCHEMA.' + 'CONCEPT_FEATURE_RELATIONSHIP.' +'RELATING_PRODUCT_CONCEPT_FEATURE' ) | 
		        ('PRODUCT_CONCEPT_SCHEMA.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF (cfr ) ) AND 
			    (SIZEOF ( QUERY (ipcf <* USEDIN ( cfr , 'PRODUCT_CONCEPT_SCHEMA.' + 'CONDITIONAL_CONCEPT_FEATURE.' + 'CONDITION' ) | 
				 'PRODUCT_CLASS_MIM.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( ipcf ) 
			     )) = 1)
		)) > 0;
END_ENTITY;
					
ENTITY product_class
  SUBTYPE OF (product_concept,characterized_object);
END_ENTITY;

ENTITY product_concept_feature_category
  SUBTYPE OF (group);
WHERE
	WR1 : SIZEOF(QUERY(aga <* USEDIN( SELF, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP' ) |
           ('GROUP_MIM.'+ 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(aga)) AND
           (( aga\group_assignment.role\object_role.name <> 'specification category member' ) OR 
            ( SIZEOF(QUERY (i <* aga\applied_group_assignment.items | ('PRODUCT_CONCEPT_SCHEMA.'+ 'PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( i ) ) AND 
             NOT ('PRODUCT_CONCEPT_SCHEMA.'+ 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF (i)))) <> SIZEOF (aga\applied_group_assignment.items)
              ))
          )) =0;
END_ENTITY;

ENTITY product_concept_feature_category_usage
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_concept_feature_category;
  items : SET [1:?] OF category_usage_item;
WHERE
WR1 : SELF.role.name IN [ 'mandatory category usage', 'optional category usage' ];
END_ENTITY;

RULE restrict_concept_feature_operator FOR (concept_feature_operator);
WHERE
	WR1: SIZEOF ( QUERY ( cfo <* concept_feature_operator | NOT
		( cfo.name IN ['and' , 'or' , 'oneof' , 'not' , 'implication'] ) ) ) = 0;
	WR2: SIZEOF ( QUERY ( cfo <* concept_feature_operator | (cfo.name = 'implication' ) AND
	 ( SIZEOF ( QUERY (cfrwc <* USEDIN ( cfo , 'PRODUCT_CONCEPT_SCHEMA.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.' +
	'CONDITIONAL_OPERATOR' ) | 
		SIZEOF ( QUERY ( ccf <* USEDIN( cfrwc , 'PRODUCT_CONCEPT_SCHEMA.' + 'CONDITIONAL_CONCEPT_FEATURE.CONDITION' ) | 
		NOT ('PRODUCT_CLASS_MIM.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( ccf )))) >0 )) >0 ))) = 0;
	WR3: SIZEOF( QUERY (cfo <* concept_feature_operator | (cfo.name = 'not')
	AND (SIZEOF(QUERY(cfrwc <* USEDIN(cfo, 'PRODUCT_CONCEPT_SCHEMA.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.CONDITIONAL_OPERATOR') | 
		cfrwc.related_product_concept_feature :<>: cfrwc.relating_product_concept_feature)) >0 ))) = 0;
END_RULE;	

RULE restrict_group_relationship_for_specification_category FOR (group_relationship); 
WHERE 
WR1 : SIZEOF( QUERY( gr <* group_relationship | 
  (gr.name = 'specification category hierarchy') AND 
  (NOT('PRODUCT_CLASS_MIM.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(gr.related_group)) 
  OR NOT('PRODUCT_CLASS_MIM.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(gr.relating_group))) )) = 0; 
END_RULE; 

RULE product_concept_feature_requires_category FOR (product_concept_feature);
WHERE
WR1: SIZEOF ( QUERY ( pcf <* product_concept_feature |
(SIZEOF(['PRODUCT_CLASS_MIM.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE',
'PRODUCT_CONCEPT_SCHEMA.' + 'CONDITIONAL_CONCEPT_FEATURE'] * TYPEOF(pcf)) = 0) AND 
(SIZEOF ( QUERY ( aga <* USEDIN ( pcf , 'GROUP_MIM.' + 'APPLIED_GROUP_ASSIGNMENT.' + 'ITEMS' ) | 
(aga\group_assignment.role\object_role.name = 'specification category member' ) AND 
('PRODUCT_CLASS_MIM.' + 'PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF ( aga.assigned_group )))) <>1 ) ) ) = 0;
END_RULE;

END_SCHEMA;


--
-- PRODUCT_CONCEPT_IDENTIFICATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_concept_identification/mim.exp)
--
(*
 $Id: mim.exp,v 1.6 2004/10/22 14:44:26 darla Exp 
 ISO TC184/SC4/WG12 N1178 - ISO/TS 10303-1060 Product concept identification - EXPRESS MIM
*)
   
SCHEMA Product_concept_identification_mim;

USE FROM product_concept_schema -- ISO 10303-44
  (product_concept);
USE FROM application_context_schema -- ISO 10303-41
  (product_concept_context);

   
END_SCHEMA;



--
-- PRODUCT_CONCEPT_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/product_concept_schema/product_concept_schema.exp)
--
(*
Id: product_concept_schema.exp,v 1.5 2014/03/04 00:30:39 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N8371

EXPRESS Source:
ISO 10303-44 ed3 Product structure configuration - Product concept schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-44 ed3 Product structure configuration - Product concept schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA product_concept_schema '{iso standard 10303 part(44) version(2) object(1) product_concept_schema(2)}';

  REFERENCE FROM support_resource_schema
    (text, label, identifier);

  REFERENCE FROM application_context_schema
    (product_concept_context);

ENTITY concept_feature_operator;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY concept_feature_relationship;
  name                              : label;
  description                       : OPTIONAL text;
  relating_product_concept_feature  : product_concept_feature;
  related_product_concept_feature   : product_concept_feature;
END_ENTITY;

ENTITY concept_feature_relationship_with_condition
  SUBTYPE OF (concept_feature_relationship);
  conditional_operator : concept_feature_operator;
END_ENTITY;

ENTITY conditional_concept_feature
  SUBTYPE OF (product_concept_feature);
  condition : concept_feature_relationship_with_condition;
END_ENTITY;

ENTITY product_concept;
  id                  : identifier;
  name                : label;
  description         : OPTIONAL text;
  market_context      : product_concept_context;
UNIQUE
  UR1: id;
END_ENTITY;

ENTITY product_concept_feature;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY product_concept_feature_association;
  name        : label;
  description : OPTIONAL text;
  concept     : product_concept;
  feature     : product_concept_feature;
END_ENTITY;

ENTITY product_concept_relationship;
  name                     : label;
  description              : OPTIONAL text;
  relating_product_concept : product_concept;
  related_product_concept  : product_concept;
END_ENTITY;

END_SCHEMA; -- product_concept_schema


--
-- PRODUCT_DEFINITION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/product_definition_schema/product_definition_schema.exp)
--
(*
Id: product_definition_schema.exp,v 1.33 2021/05/06 16:23:00 kevin Exp 
ISO 10303 TC184/SC4/WG12 N10887

EXPRESS Source:
ISO 10303-41 ed7 Fundamentals of product description and support - Product definition schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2021  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed7 Fundamentals of product description and support - Product definition schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA product_definition_schema '{iso standard 10303 part(41) version(10) object(1) product_definition_schema(18)}';

  REFERENCE FROM application_context_schema (   -- ISO 10303-41
    product_context, 
    product_definition_context);
  REFERENCE FROM basic_attribute_schema (   -- ISO 10303-41
    get_id_value, 
    get_name_value, 
    id_attribute,
    id_attribute_select,
    name_attribute,
    name_attribute_select);
  REFERENCE FROM document_schema (   -- ISO 10303-41
    document);
  REFERENCE FROM effectivity_schema (   -- ISO 10303-41
    effectivity);
  REFERENCE FROM external_reference_schema (   -- ISO 10303-41
    external_source);
  REFERENCE FROM product_property_definition_schema (   -- ISO 10303-41
    characterized_object);
  REFERENCE FROM support_resource_schema (   -- ISO 10303-41
    bag_to_set, 
    identifier, 
    label, 
    text);

    
  TYPE product_definition_or_reference = EXTENSIBLE GENERIC_ENTITY SELECT (
    product_definition, 
    generic_product_definition_reference);
  END_TYPE;
    
  TYPE pds_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    product_category);
  END_TYPE;
  TYPE pds_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    product_definition,
    product_definition_substitute);
  END_TYPE;
  
  TYPE source = ENUMERATION OF (made, bought, not_known);
  END_TYPE;

  ENTITY alternative_solution_relationship
  	SUBTYPE of (product_definition_formation_relationship);
  	relation_type	: STRING;									
  WHERE
	WR1: acyclic_alternative_solution_relationship(SELF, [SELF\product_definition_formation_relationship.related_product_definition_formation], 'PRODUCT_DEFINITION_SCHEMA.ALTERNATIVE_SOLUTION_RELATIONSHIP');
  END_ENTITY;

  ENTITY characterized_product
    SUBTYPE OF (characterized_object, product);
  END_ENTITY;

  ENTITY generic_product_definition_reference
    ABSTRACT SUPERTYPE OF ( ONEOF ( product_definition_reference, product_definition_reference_with_local_representation) );
    source : external_source;
  END_ENTITY;
 
  ENTITY product;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    frame_of_reference : SET [1:?] OF product_context;
  END_ENTITY;

  ENTITY product_category;
    name : label;
    description : OPTIONAL text;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY product_category_relationship;
    name : label;
    description : OPTIONAL text;
    category : product_category;
    sub_category : product_category;
  WHERE
    WR1: acyclic_product_category_relationship(SELF, [SELF.sub_category]);
  END_ENTITY;

  ENTITY product_definition;
    id : identifier;
    description : OPTIONAL text;
    formation : product_definition_formation;
    frame_of_reference : product_definition_context;
  DERIVE
    name : label := get_name_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY product_definition_context_association;
    definition : product_definition;
    frame_of_reference : product_definition_context;
    role : product_definition_context_role;
  END_ENTITY;

  ENTITY product_definition_context_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY product_definition_effectivity
    SUBTYPE OF (effectivity);
    usage : product_definition_relationship;
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0;
  END_ENTITY;

  ENTITY product_definition_formation;
    id : identifier;
    description : OPTIONAL text;
    of_product : product;
  UNIQUE
    UR1: id, of_product;
  END_ENTITY;
  
ENTITY final_solution
	SUBTYPE OF (product_definition_formation);
	status			: STRING;
 INVERSE
	specification 	: SET [1:?] OF product_definition FOR formation;
END_ENTITY;

  ENTITY product_definition_formation_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_product_definition_formation : product_definition_formation;
    related_product_definition_formation : product_definition_formation;
  END_ENTITY;

  ENTITY product_definition_formation_with_specified_source
    SUBTYPE OF (product_definition_formation);
    make_or_buy : source;
  END_ENTITY;

  ENTITY product_definition_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_product_definition : product_definition_or_reference;
    related_product_definition : product_definition_or_reference;
  END_ENTITY;

  ENTITY product_definition_relationship_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating : product_definition_relationship;
    related : product_definition_relationship;
  END_ENTITY;
  
  ENTITY product_definition_reference
    SUBTYPE OF (generic_product_definition_reference);
    product_id : identifier;
    product_definition_formation_id : identifier;
    product_definition_id : identifier;
    id_owning_organization_name : OPTIONAL label;
  END_ENTITY;
 
  ENTITY product_definition_reference_with_local_representation
    SUBTYPE OF (generic_product_definition_reference, product_definition);
  END_ENTITY;
  
  ENTITY product_definition_substitute;
    description : OPTIONAL text;
    context_relationship : product_definition_relationship;
    substitute_definition : product_definition;
  DERIVE
    name : label := get_name_value(SELF);
  WHERE
    WR1: context_relationship.related_product_definition :<>: substitute_definition;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY product_definition_with_associated_documents
    SUBTYPE OF (product_definition);
    documentation_ids : SET [1:?] OF document;
  END_ENTITY;

  ENTITY product_related_product_category
    SUBTYPE OF (product_category);
    products : SET [1:?] OF product;
  END_ENTITY;

  ENTITY product_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_product : product;
    related_product : product;
  END_ENTITY;

FUNCTION acyclic_alternative_solution_relationship (relation : alternative_solution_relationship; relatives : SET [1:?] OF product_definition_formation; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF alternative_solution_relationship;
    END_LOCAL;

    IF relation.relating_product_definition_formation IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(asr <* bag_to_set(USEDIN(relation.relating_product_definition_formation, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION_FORMATION')) | specific_relation IN TYPEOF(asr));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_alternative_solution_relationship(x[i], relatives + relation.relating_product_definition_formation, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_product_category_relationship (relation : product_category_relationship; children : SET OF product_category):BOOLEAN;
    LOCAL
      x : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX(children);
      IF relation.category :=: children[i] THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_product_definition_formation_relationship (relation : product_definition_formation_relationship; relatives : SET [1:?] OF product_definition_formation; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF product_definition_formation_relationship;
    END_LOCAL;

    IF relation.relating_product_definition_formation IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pdf <* bag_to_set(USEDIN(relation.relating_product_definition_formation, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION_FORMATION')) | specific_relation IN TYPEOF(pdf));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_formation_relationship(x[i], relatives + relation.relating_product_definition_formation, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_product_definition_relationship (relation : product_definition_relationship; relatives : SET [1:?] OF product_definition_or_reference; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;

    IF relation.relating_product_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_product_definition, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')) | specific_relation IN TYPEOF(pd));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_product_relationship (relation : product_relationship; relatives : SET [1:?] OF product; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF product_relationship;
    END_LOCAL;

    IF relation.relating_product IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(prod <* bag_to_set(USEDIN(relation.relating_product, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATIONSHIP.' + 'RELATED_PRODUCT')) | specific_relation IN TYPEOF(prod));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_relationship(x[i], relatives + relation.relating_product, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION categories_of_product
   (obj : product) : SET OF STRING; 
  LOCAL
    category_assignments: BAG OF product_category;
    categories: SET OF STRING:=[];
  END_LOCAL;
    category_assignments := USEDIN(obj, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
    REPEAT i := LOINDEX(category_assignments) TO HIINDEX(category_assignments) BY 1;
      categories := categories + category_assignments[i].name;
    END_REPEAT;
    RETURN(categories);
  END_FUNCTION; 

  FUNCTION get_product_definitions (c_def_instance : product):SET OF product_definition;
    LOCAL
      pd_set : SET OF product_definition_formation := [];
      pdr_set : SET OF product_definition := [];
    END_LOCAL;

    pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION.FORMATION'));
    END_REPEAT;
    RETURN (pdr_set);
  END_FUNCTION;

END_SCHEMA;


--
-- PRODUCT_ENVIRONMENT_DEFINITION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_environment_definition/mim.exp)
--
(*
ISO TC184/SC4/WG12 N11173 - ISO/TS 10303-1400 Product environment definition - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6816
*) 


SCHEMA Product_environment_definition_mim;

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM group_schema   -- ISO 10303-41
  (group); 

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_definition,
   product_definition_formation,
   product_definition_relationship); 

USE FROM Product_group_mim;    -- ISO/TS 10303-1278

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041


TYPE env_dfn_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (environment_assignment, 
    environment_definition, 
    environment_definition_version, 
    environment_view_definition_relationship);
END_TYPE; 

TYPE env_dfn_identification_assignment = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (environment_assignment, 
    environment_definition, 
    environment_definition_version, 
    environment_view_definition_relationship);
END_TYPE; 

ENTITY environment_assignment
  SUBTYPE OF (group);
END_ENTITY;

ENTITY environment_definition
  SUBTYPE OF (product);
END_ENTITY;

ENTITY environment_definition_version
  SUBTYPE OF (product_definition_formation);
  SELF\product_definition_formation.of_product RENAMED of_environment : environment_definition;
END_ENTITY;

ENTITY environment_definition_view
  SUBTYPE OF (product_definition);
  SELF\product_definition.formation RENAMED defined_environment_version : environment_definition_version;
END_ENTITY;

ENTITY environment_view_definition_relationship
  SUBTYPE OF (product_definition_relationship);
  SELF\product_definition_relationship.relating_product_definition RENAMED relating_environment : environment_definition_view;
  SELF\product_definition_relationship.related_product_definition RENAMED related_environment : environment_definition_view;
END_ENTITY;

END_SCHEMA;  -- Product_environment_definition_mim


--
-- PRODUCT_ENVIRONMENT_OBSERVED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_environment_observed/mim.exp)
--
(*
ISO TC184/SC4/WG12 N11175 - ISO/TS 10303-1401 Product environment observed - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6819
*) 


SCHEMA Product_environment_observed_mim;

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition_formation_relationship,
   product_relationship); 

USE FROM Product_environment_definition_mim;    -- ISO/TS 10303-1400


TYPE env_obs_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (observed_environment, 
    observed_environment_assignment, 
    observed_environment_version, 
    observed_environment_view_definition_relationship);
END_TYPE; 

TYPE env_obs_identification_assignment = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (observed_environment, 
    observed_environment_assignment, 
    observed_environment_version, 
    observed_environment_view_definition_relationship);
END_TYPE; 

ENTITY observed_environment
  SUBTYPE OF (product);
END_ENTITY;

ENTITY observed_environment_assignment
  SUBTYPE OF (group);
END_ENTITY;

ENTITY observed_environment_to_definition
  SUBTYPE OF (product_relationship);
  SELF\product_relationship.relating_product RENAMED defined_environment : environment_definition;
  SELF\product_relationship.related_product RENAMED observed_environment : observed_environment;
END_ENTITY;

ENTITY observed_environment_to_definition_version
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation RENAMED defined_environment_version : environment_definition_version;
  SELF\product_definition_formation_relationship.related_product_definition_formation RENAMED observed_environment_version : observed_environment_version;
END_ENTITY;

ENTITY observed_environment_to_definition_view
  SUBTYPE OF (product_definition_relationship);
  SELF\product_definition_relationship.relating_product_definition RENAMED defined_environment_view : observed_environment_view;
  SELF\product_definition_relationship.related_product_definition RENAMED observed_environment_view : environment_definition_view;
END_ENTITY;

ENTITY observed_environment_version
  SUBTYPE OF (product_definition_formation);
  SELF\product_definition_formation.of_product RENAMED of_environment : observed_environment;
END_ENTITY;

ENTITY observed_environment_view
  SUBTYPE OF (product_definition);
  SELF\product_definition.formation RENAMED observed_environment_version : observed_environment_version;
END_ENTITY;

ENTITY observed_environment_view_definition_relationship
  SUBTYPE OF (product_definition_relationship);
  SELF\product_definition_relationship.relating_product_definition RENAMED relating_environment : observed_environment_view;
  SELF\product_definition_relationship.related_product_definition RENAMED related_environment : observed_environment_view;
END_ENTITY;

END_SCHEMA;  -- Product_environment_observed_mim


--
-- PRODUCT_GROUP_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_group/mim.exp)
--
(*
 $Id: mim.exp,v 1.13 2010/11/12 16:29:10 mikeward Exp 
 ISO TC184/SC4/WG12 N7275 - ISO/TS 10303-1278 Product group - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N3113
*) 


SCHEMA Product_group_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute); 

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Effectivity_application_mim;    -- ISO/TS 10303-1059

USE FROM group_schema   -- ISO 10303-41
  (group,
   group_relationship); 

USE FROM management_resources_schema   -- ISO 10303-41
  (group_assignment); 

USE FROM Product_as_individual_mim;    -- ISO/TS 10303-1164

USE FROM Product_concept_identification_mim;    -- ISO/TS 10303-1060

USE FROM product_concept_schema   -- ISO 10303-44
  (product_concept); 

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_definition_formation); 

USE FROM Product_identification_mim;    -- ISO/TS 10303-1017

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object); 

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

USE FROM qualified_measure_schema   -- ISO 10303-45
  (descriptive_representation_item); 


TYPE attribute_select = SELECT
   (product_group_context, 
    product_group_purpose);
END_TYPE; 

TYPE product_group_classification_item = SELECT BASED_ON classification_item WITH 
   (product_group, 
    product_group_relationship);
END_TYPE; 

TYPE product_group_effectivity_item = SELECT BASED_ON effectivity_item WITH 
   (product_group, 
    product_group_membership, 
    product_group_relationship);
END_TYPE; 

TYPE product_select = EXTENSIBLE GENERIC_ENTITY SELECT
   (product, 
    product_concept, 
    product_definition_formation, 
    product_group);
END_TYPE; 

ENTITY product_group
  SUBTYPE OF (group);
END_ENTITY;

ENTITY product_group_attribute_assignment
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_group_attributes;
  attributes : SET[1:1] OF attribute_select;
END_ENTITY;

ENTITY product_group_attribute_set
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_group;
  product_group_attributes : SET[1:1] OF product_group_attributes;
END_ENTITY;

ENTITY product_group_attributes
  SUBTYPE OF (group);
END_ENTITY;

ENTITY product_group_context
  SUBTYPE OF (descriptive_representation_item);
END_ENTITY;

ENTITY product_group_membership
  SUBTYPE OF (characterized_object, group_assignment);
  member : product_select;
END_ENTITY;

ENTITY product_group_membership_rules
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_group;
  product_group_rules : SET[1:1] OF product_group_rules;
END_ENTITY;

ENTITY product_group_purpose
  SUBTYPE OF (descriptive_representation_item);
END_ENTITY;

ENTITY product_group_relationship
  SUBTYPE OF (group_relationship);
END_ENTITY;

ENTITY product_group_rule
  SUBTYPE OF (descriptive_representation_item);
END_ENTITY;

ENTITY product_group_rule_assignment
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_group_rules;
  product_group_rules : SET[1:?] OF product_group_rule;
END_ENTITY;

ENTITY product_group_rules
  SUBTYPE OF (group);
END_ENTITY;

END_SCHEMA;  -- Product_group_mim


--
-- PRODUCT_IDENTIFICATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_identification/mim.exp)
--
(*
Id: mim.exp,v 1.13 2009/08/11 07:57:32 robbod Exp 
ISO TC184/SC4/WG12 N6066 - ISO/TS 10303-1017 Product identification - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N2926
*) 


SCHEMA Product_identification_mim;

USE FROM product_definition_schema   -- ISO 10303-41
  (product); 


END_SCHEMA;  -- Product_identification_mim


--
-- PRODUCT_OCCURRENCE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_occurrence/mim.exp)
--
(*
 ISO TC184/SC4/WG12 N10737 - ISO/TS 10303-1063 Product occurrence - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N9690
*)

SCHEMA Product_occurrence_mim;

  USE FROM Assembly_structure_mim;	-- ISO/TS 10303-1026
  USE FROM Product_view_definition_relationship_mim;	-- ISO/TS 10303-1041
  USE FROM Extended_measure_representation_mim;	-- ISO/TS 10303-1106	
  USE FROM Specified_product_mim;	-- ISO/TS 10303-1104	
  USE FROM Part_view_definition_mim;	-- ISO/TS 10303-1023
  USE FROM product_structure_schema(   -- ISO 10303-44
  	product_definition_occurrence_relationship,
  	product_definition_specified_occurrence, 
  	product_definition_occurrence_reference, 
  	product_definition_occurrence_reference_with_local_representation);   

USE FROM product_definition_schema(   -- ISO 10303-41
  product_definition_relationship);

USE FROM product_property_definition_schema(   -- ISO 10303-41
	characterized_product_definition,
	property_definition);

USE FROM product_property_representation_schema(   -- ISO 10303-41
	property_definition_representation);
	
REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set);

  TYPE product_definition_or_assembly_relationship = SELECT (assembly_component_usage, product_definition);
  END_TYPE;
	
  RULE restrict_part_occurrence FOR (product_definition);
    LOCAL
      part_occurrences: SET OF product_definition := QUERY(pd <* product_definition | 
	    ( pd.frame_of_reference.name = 'part occurrence' ));
    END_LOCAL;
    WHERE
      WR1: SIZEOF ( QUERY ( pd <* part_occurrences | 
	    ( NOT( pd.name IN 
        ['single instance' , 'selected instance' ,'quantified instance' , 'specified instance' ] ) ) ) ) = 0;
      WR2: SIZEOF ( QUERY ( pd <* part_occurrences | 
 	    (SIZEOF ( QUERY ( pdr <* USEDIN ( pd ,
        'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | 
	    pdr.name = 'definition usage' ) ) <>1 ) AND 
        ( SIZEOF ( QUERY ( cd <* USEDIN ( pd , 'CONFIGURATION_MANAGEMENT_SCHEMA.' + 'CONFIGURATION_DESIGN.DESIGN' ) | 
        ( cd.name = 'occurrence usage definition' ) AND 
        ( NOT ('SPECIFIED_PRODUCT_MIM.' + 'PRODUCT_IDENTIFICATION' IN TYPEOF( cd.configuration ) ) ) ) ) <>1 ) ) ) = 0;
      WR3: SIZEOF ( QUERY ( pd <* part_occurrences |  
        (SIZEOF ( QUERY ( cd <* USEDIN ( pd , 'PRODUCT_DEFINITION_SCHEMA.'+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) |
        ( 'PRODUCT_STRUCTURE_SCHEMA.' +'PRODUCT_DEFINITION_USAGE' IN TYPEOF ( cd ) ) ) ) = 0 )AND
        ( SIZEOF ( USEDIN ( pd , 'PRODUCT_STRUCTURE_SCHEMA.' + 'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE' ) ) = 0 ) ) ) = 0;
      WR4: SIZEOF ( QUERY ( pd <* part_occurrences | 
        ( pd.name = 'selected instance' ) AND 
        NOT valid_selected_instance_representation(pd) ))=0;
      WR5: SIZEOF ( QUERY ( pd <* part_occurrences | 
        ( pd.name = 'quantified instance' ) AND 
        ( SIZEOF ( QUERY (ppd <* USEDIN ( pd , 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' +'PROPERTY_DEFINITION.DEFINITION' ) |
        ( ppd.name ='occurrence quantity' ) AND 
        ( SIZEOF ( QUERY ( pdr <*USEDIN ( ppd , 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION' ) | (
        pdr.used_representation.name = 'quantity' ) AND 
        (SIZEOF ( pdr.used_representation.items ) = 1 ) AND 
        (SIZEOF ( QUERY ( i <* pdr.used_representation.items | 
        ('QUALIFIED_MEASURE_SCHEMA.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND
        ( i.name = 'quantity measure' ) ) ) = 1)))= 1 )))= 0 )))= 0;
      WR6: SIZEOF ( QUERY ( pd <* part_occurrences | 
        ( pd.name = 'specified instance' ) AND 
        ( SIZEOF ( QUERY (
        pdor <* USEDIN ( pd , 'PRODUCT_STRUCTURE_SCHEMA.' +'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE' ) | 
        'PRODUCT_STRUCTURE_SCHEMA.' +'SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN TYPEOF ( pdor.occurrence_usage ) ) ) = 0 ) ) ) = 0;
  END_RULE;
	
  RULE restrict_part_occurrence_category FOR (product_definition);
    LOCAL
      part_occurrences: SET OF product_definition := QUERY( pd <* product_definition |(
        pd.frame_of_reference.name = 'part occurrence'));
    END_LOCAL;
    WHERE
      WR1: SIZEOF( QUERY( pd <* part_occurrences | 
        (SIZEOF( QUERY( prpc <* USEDIN(pd.formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
        prpc.name IN ['part','raw material','tool'] )) = 0 ) )) = 0;
  END_RULE;
		
  RULE selected_instance_usage_requires_representation FOR (assembly_component_usage);
    LOCAL
      selected_instance_usages: SET OF assembly_component_usage := QUERY( acr <* assembly_component_usage|
        (acr.name = 'selected instance usage'));
    END_LOCAL;
    WHERE
      WR1: SIZEOF ( QUERY ( acr <* selected_instance_usages | 
        NOT valid_selected_instance_representation(acr) ))=0;
  END_RULE;
	
  RULE restrict_product_definitions_for_definition_usage FOR (product_definition_relationship);
    WHERE
      WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
        ( pdr.name = 'definition usage' ) AND 
        ( ( pdr.relating_product_definition.frame_of_reference.name<> 'part definition' ) OR 
        ( pdr.related_product_definition.frame_of_reference.name<>'part occurrence' )))) =0;
  END_RULE;
	
  FUNCTION valid_selected_instance_representation (pd: product_definition_or_assembly_relationship): LOGICAL;
    LOCAL
      properties: SET OF property_definition := bag_to_set(QUERY( prd<* USEDIN ( pd ,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION' ) | 
        (prd.name = 'occurrence selection' )));
      property_definition_representations: SET OF property_definition_representation := bag_to_set(QUERY ( pdr <* USEDIN ( properties[1] , 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
	    ( pdr.used_representation.name = 'selection criteria' )));
      selected_representation: representation;
    END_LOCAL;
    IF (SIZEOF( properties)<>1) THEN
	  RETURN(FALSE);
    END_IF;
    IF (SIZEOF(property_definition_representations)<>1) THEN
	  RETURN(FALSE);
    END_IF;
    selected_representation := property_definition_representations[1]\property_definition_representation.used_representation;
    IF (SIZEOF(selected_representation\representation.items) <1) OR (SIZEOF(selected_representation\representation.items) >2) THEN
	  RETURN(FALSE);
    END_IF;
    IF (SIZEOF ( QUERY ( i <* selected_representation\representation.items |
	  ( SIZEOF (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' ,
      'EXTENDED_MEASURE_REPRESENTATION_MIM.VALUE_RANGE']* TYPEOF ( i ) ) = 1) AND
      ( i.name = 'selection quantity' ))) <> 1 ) THEN
      RETURN(FALSE);
    END_IF;
    IF (SIZEOF ( QUERY ( i <* selected_representation\representation.items |
	  ( 'QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND
 	  ( i.name = 'selection control' )))> 1) THEN
	  RETURN(FALSE);
    END_IF; --the selection control is not specified then the quantity shall be a qualified_representation_item or a value_range
    IF (SIZEOF ( QUERY ( i <* selected_representation\representation.items |
      ( 'QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF( i ) ) AND
      ( i.name = 'selection control' ) ))= 0) AND 
      (SIZEOF ( QUERY ( i <* selected_representation\representation.items |
      ( i.name = 'selection quantity' ) AND  
      ( SIZEOF(['QUALIFIED_MEASURE_SCHEMA.QUALIFIED_REPRESENTATION_ITEM' ,
      'EXTENDED_MEASURE_REPRESENTATION_MIM.VALUE_RANGE']* TYPEOF ( i ) ) =0 ))) > 0 ) THEN
	  RETURN(FALSE);
    END_IF;
    RETURN(TRUE);
  END_FUNCTION;

END_SCHEMA;




--
-- PRODUCT_PLACEMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_placement/mim.exp)
--
(*
 $Id: mim.exp,v 1.9 2012/10/30 08:46:20 lothartklein Exp 
 ISO TC184/SC4/WG12 N8248 - ISO/TS 10303-1343 Product placement - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N7093
*)

SCHEMA Product_placement_mim;

USE FROM Contextual_shape_positioning_mim;
USE FROM Physical_breakdown_mim;
USE FROM Product_occurrence_mim;


END_SCHEMA;


--
-- PRODUCT_PROPERTY_DEFINITION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/product_property_definition_schema/product_property_definition_schema.exp)
--
(*
Id: product_property_definition_schema.exp,v 1.35 2021/05/06 16:23:00 kevin Exp 
ISO 10303 TC184/SC4/WG12 N10886

EXPRESS Source:
ISO 10303-41 ed7 Fundamentals of product description and support - Product property definition schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2021  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed7 Fundamentals of product description and support - Product property definition schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA product_property_definition_schema '{iso standard 10303 part(41) version(10) object(1) product_property_definition_schema(19)}';

  REFERENCE FROM basic_attribute_schema (   -- ISO 10303-41
    get_id_value, 
    id_attribute,
    id_attribute_select);
  REFERENCE FROM process_property_schema (   -- ISO 10303-49
    action_property, 
    resource_property);
  REFERENCE FROM product_definition_schema (   -- ISO 10303-41
    product_definition, 
    product_definition_relationship,
    product_definition_relationship_relationship);
  REFERENCE FROM product_property_representation_schema (   -- ISO 10303-41
    item_identified_representation_usage);
  REFERENCE FROM product_structure_schema (   -- ISO 10303-44
    assembly_component_usage,
    multi_level_reference_designator,
    next_assembly_usage_occurrence,
    product_definition_occurrence);
      REFERENCE FROM shape_dimension_schema (   -- ISO 10303-47
    dimensional_location,
    dimensional_size);
  REFERENCE FROM shape_tolerance_schema (   -- ISO 10303-47
    geometric_tolerance);
  REFERENCE FROM support_resource_schema (   -- ISO 10303-41
    bag_to_set, 
    identifier, 
    label, 
    text);
    
  TYPE characterized_definition = SELECT (
    characterized_item,
    characterized_object, 
    characterized_product_definition, 
    shape_definition);
  END_TYPE;

  TYPE characterized_item = SELECT (
    item_identified_representation_usage,
     dimensional_size,
     geometric_tolerance);
  END_TYPE;

  TYPE ppds_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    property_definition,
    shape_aspect, 
    shape_aspect_relationship);
  END_TYPE;
  
  TYPE characterized_product_definition = SELECT (
    product_definition, 
    product_definition_occurrence, 
    product_definition_relationship,
    product_definition_relationship_relationship);
  END_TYPE;

  TYPE derived_property_select = SELECT (
  	property_definition, 
  	action_property, 
  	resource_property,
  	dimensional_location,
  	dimensional_size,
  	geometric_tolerance);
  END_TYPE;

  TYPE shape_aspect_or_characterized_object = SELECT (shape_aspect, characterized_object);
  END_TYPE;
  
  TYPE shape_definition = SELECT (product_definition_shape, shape_aspect, shape_aspect_relationship);
  END_TYPE;

  TYPE internal_or_reflected_shape_aspect = SELECT (
    shape_aspect,
    identifier);
  END_TYPE;

  TYPE multi_or_next_assembly_usage_occurrence = SELECT (
    multi_level_reference_designator,
    next_assembly_usage_occurrence);
  END_TYPE;

  ENTITY characterized_object;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY characterized_object_relationship;
    name : label;
    description : OPTIONAL text;
    relating_object : characterized_object;
    related_object : characterized_object;
  END_ENTITY;

  ENTITY component_path_shape_aspect
    SUBTYPE OF (shape_aspect);
    location : multi_or_next_assembly_usage_occurrence;
    component_shape_aspect : internal_or_reflected_shape_aspect;
  UNIQUE
    UR1 : location, component_shape_aspect;
  END_ENTITY;

  ENTITY constituent_shape_aspect
    SUBTYPE OF (shape_aspect);
    parent : shape_aspect;
  DERIVE
   SELF\shape_aspect.of_shape : product_definition_shape := get_product_definition_shape(SELF);
  END_ENTITY;
  
  ENTITY general_property;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY general_property_association;
    name : label;
    description : OPTIONAL text;
    base_definition : general_property;
    derived_definition : derived_property_select;
  WHERE
    WR1: (SIZEOF(['SHAPE_DIMENSION_SCHEMA.DIMENSIONAL_LOCATION', 'SHAPE_DIMENSION_SCHEMA.DIMENSIONAL_SIZE', 'SHAPE_TOLERANCE_SCHEMA.GEOMETRIC_TOLERANCE'] *
                TYPEOF(derived_definition)) > 0)
         OR (SIZEOF(USEDIN(derived_definition, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION')) = 1);
    WR2: (SIZEOF(['SHAPE_DIMENSION_SCHEMA.DIMENSIONAL_LOCATION', 'SHAPE_DIMENSION_SCHEMA.DIMENSIONAL_SIZE', 'SHAPE_TOLERANCE_SCHEMA.GEOMETRIC_TOLERANCE'] *
                TYPEOF(derived_definition)) > 0)
          OR (derived_definition.name = base_definition.name);
  END_ENTITY;

  ENTITY general_property_relationship;
    name : label;
    description : OPTIONAL text;
    relating_property : general_property;
    related_property : general_property;
  END_ENTITY;

  ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
  UNIQUE
    UR1: SELF\property_definition.definition;
  WHERE
    WR1: SIZEOF(['PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_PRODUCT_DEFINITION', 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT'] * TYPEOF(SELF\property_definition.definition)) > 0;
  END_ENTITY;

  ENTITY property_definition;
    name : label;
    description : OPTIONAL text;
    definition : characterized_definition;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY shape_aspect
    SUPERTYPE OF (ONEOF (shape_aspect_occurrence, component_path_shape_aspect)
                  ANDOR constituent_shape_aspect);
    name : label;
    description : OPTIONAL text;
    of_shape : product_definition_shape;
    product_definitional : LOGICAL;
  DERIVE
    id : identifier := get_id_value(SELF);
  UNIQUE
    UR1: id, of_shape;    
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY shape_aspect_occurrence
    SUBTYPE OF (shape_aspect);
    definition : shape_aspect_or_characterized_object;
  WHERE
    WR1: acyclic_shape_aspect_occurrence(SELF,definition);
  END_ENTITY;

  ENTITY shape_aspect_relationship;
    name : label;
    description : OPTIONAL text;
    relating_shape_aspect : shape_aspect;
    related_shape_aspect : shape_aspect;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  FUNCTION acyclic_characterized_object_relationship (relation : characterized_object_relationship; relatives : SET [1:?] OF characterized_object; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF characterized_object_relationship;
    END_LOCAL;

    IF relation.relating_object IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ca <* bag_to_set(USEDIN(relation.relating_object, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'CHARACTERIZED_OBJECT_RELATIONSHIP.' + 'RELATED_OBJECT')) | specific_relation IN TYPEOF(ca));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_characterized_object_relationship(x[i], relatives + relation.relating_object, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_general_property_relationship (relation : general_property_relationship; relatives : SET [1:?] OF general_property; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF general_property_relationship;
    END_LOCAL;

    IF relation.relating_property IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(genp <* bag_to_set(USEDIN(relation.relating_property, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'GENERAL_PROPERTY_RELATIONSHIP.' + 'RELATED_PROPERTY')) | specific_relation IN TYPEOF(genp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_general_property_relationship(x[i], relatives + relation.relating_property, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_shape_aspect_occurrence
          (sao : shape_aspect_occurrence; definition : shape_aspect_or_characterized_object) : BOOLEAN;
    IF NOT  (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_OCCURRENCE') IN TYPEOF(definition)) THEN
      RETURN  (TRUE);
    END_IF;
    IF  (definition :=: sao) THEN
      RETURN  (FALSE);
    ELSE RETURN(acyclic_shape_aspect_occurrence(sao, definition\shape_aspect_occurrence.definition));
    END_IF;
  END_FUNCTION; 

  FUNCTION acyclic_shape_aspect_relationship (relation : shape_aspect_relationship; relatives : SET [1:?] OF shape_aspect; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF shape_aspect_relationship;
    END_LOCAL;

    IF relation.relating_shape_aspect IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(sa <* bag_to_set(USEDIN(relation.relating_shape_aspect, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'SHAPE_ASPECT_RELATIONSHIP.' + 'RELATED_SHAPE_ASPECT')) | specific_relation IN TYPEOF(sa));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_shape_aspect_relationship(x[i], relatives + relation.relating_shape_aspect, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION get_product_definition_shape(current: constituent_shape_aspect) : product_definition_shape ;
    REPEAT
      WHILE ('PRODUCT_DEFINITION_SCHEMA.CONSTITUENT_SHAPE_ASPECT' IN TYPEOF(current.parent));
  	  current := current.parent;
    END_REPEAT;
    RETURN (current.parent\shape_aspect.of_shape);
  END_FUNCTION;
  
  FUNCTION get_shape_aspects (c_def_instance : characterized_definition):SET OF shape_aspect;
    LOCAL
      pd_set : SET OF product_definition_shape := [];
      pdr_set : SET OF shape_aspect := [];
    END_LOCAL;

    pd_set := bag_to_set(QUERY(pd <* USEDIN(c_def_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    END_REPEAT;
    RETURN (pdr_set);
  END_FUNCTION;

END_SCHEMA;


--
-- PRODUCT_PROPERTY_REPRESENTATION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/product_property_representation_schema/product_property_representation_schema.exp)
--
(*
Id: product_property_representation_schema.exp,v 1.65 2021/05/06 16:23:00 kevin Exp 
ISO 10303 TC184/SC4/WG12 N10355

EXPRESS Source:
ISO 10303-41 ed7 Fundamentals of product description and support - Product property representation schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2021  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed7 Fundamentals of product description and support - Product property representation schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA product_property_representation_schema '{iso standard 10303 part(41) version(10) object(1) product_property_representation_schema(20)}';

  REFERENCE FROM basic_attribute_schema (   -- ISO 10303-41
    description_attribute, 
    description_attribute_select,
    get_description_value, 
    get_name_value, 
    name_attribute,
    name_attribute_select);
  REFERENCE FROM material_property_definition_schema (   -- ISO 10303-45
    property_definition_relationship);
  REFERENCE FROM product_definition_schema (   -- ISO 10303-41
    product_definition, 
    product_definition_relationship);
  REFERENCE FROM product_property_definition_schema (   -- ISO 10303-41
    characterized_object, 
    characterized_definition, 
    general_property, 
    product_definition_shape, 
    property_definition, 
    shape_aspect, 
    shape_aspect_relationship);
  REFERENCE FROM product_structure_schema (  -- ISO 10303-44
    product_definition_specified_occurrence);
  REFERENCE FROM representation_schema (   -- ISO 10303-43
    representation, 
    representation_item,
    representation_relationship, 
    representation_reference,
    using_representations, 
    mapped_item, 
    representation_context, 
    representation_map,
    list_representation_item,
    set_representation_item,
    get_representations_for_items);
  REFERENCE FROM support_resource_schema (   -- ISO 10303-41
    bag_to_set, 
    label, 
    text);

  TYPE pprs_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    context_dependent_shape_representation,
    property_definition_representation);
  END_TYPE;
  
  TYPE pprs_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    context_dependent_shape_representation,
    property_definition_representation);
  END_TYPE;

  TYPE chained_representation_link = SELECT (mapped_item, representation_context, representation_relationship);
  END_TYPE;

  TYPE represented_definition = SELECT (
    general_property, 
    property_definition, 
    property_definition_relationship, 
    shape_aspect, 
    shape_aspect_relationship);
  END_TYPE;

  TYPE item_identified_representation_usage_definition = EXTENSIBLE GENERIC_ENTITY SELECT (
    represented_definition);
  END_TYPE;
  
  TYPE item_identified_representation_usage_select = SELECT (
    representation_item,
    list_representation_item,
    set_representation_item);
  END_TYPE;  

  ENTITY chain_based_item_identified_representation_usage
    SUBTYPE OF (item_identified_representation_usage);
    nodes : LIST [2:?] OF UNIQUE representation;
    undirected_link : LIST [1:?] OF chained_representation_link;
  DERIVE
    root : representation := nodes[1];
    SELF\item_identified_representation_usage.used_representation RENAMED leaf : representation := nodes[HIINDEX(nodes)];
    directed_link : LIST [1:?] OF representation_relationship := get_directed_link(nodes, undirected_link);
  WHERE
    WR1 : EXISTS(directed_link);
  END_ENTITY;
 
  ENTITY characterized_chain_based_item_within_representation 
    SUBTYPE OF (characterized_item_within_representation);
    nodes : LIST[2:?] OF UNIQUE representation;
    undirected_link : LIST[1:?] OF chained_representation_link;
  DERIVE
    root : representation := nodes[1];
    SELF\characterized_item_within_representation.rep RENAMED leaf : representation := nodes[HIINDEX(nodes)];
    directed_link : LIST[1:?] OF representation_relationship := get_directed_link(nodes, undirected_link);
  WHERE
    WR1 : EXISTS(directed_link);
  END_ENTITY;
 
  ENTITY characterized_item_within_representation
    SUBTYPE OF (characterized_object);
    item : representation_item;
    rep : representation;
  UNIQUE
    UR1: item, rep;
  WHERE
    WR1: rep IN using_representations(item);
  END_ENTITY;

  ENTITY context_dependent_shape_representation;
    representation_relation : shape_representation_relationship;
    represented_product_relation : product_definition_shape;
  DERIVE
    description : text := get_description_value(SELF);
    name : label := get_name_value(SELF);
  WHERE
    WR1: 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(represented_product_relation\property_definition.definition);
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
    WR3: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY item_identified_representation_usage;
    name : label;
    description : OPTIONAL text;
    definition : item_identified_representation_usage_definition;
    used_representation : representation;
    identified_item : item_identified_representation_usage_select;
  UNIQUE
    UR1: used_representation, identified_item;
    UR2: used_representation, definition;
  WHERE
    WR1: valid_identified_item_in_representation(identified_item, used_representation);
  END_ENTITY;

  ENTITY property_definition_representation;
    definition : represented_definition;
    used_representation : representation;
  DERIVE
    description : text := get_description_value(SELF);
    name : label := get_name_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY shape_definition_representation
    SUBTYPE OF (property_definition_representation);
    SELF\property_definition_representation.definition : property_definition;
    SELF\property_definition_representation.used_representation : shape_representation;
  WHERE
    WR1: ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(definition)) OR
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_DEFINITION' IN TYPEOF(definition\property_definition.definition));   
  END_ENTITY;

  ENTITY shape_representation
    SUBTYPE OF (representation);
  END_ENTITY;

ENTITY shape_representation_reference
  SUBTYPE OF (representation_reference);
END_ENTITY;

  ENTITY shape_representation_relationship
    SUBTYPE OF (representation_relationship);
  WHERE
    WR1: SIZEOF(['PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION',
                 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION_REFERENCE'] * 
               (TYPEOF( SELF\representation_relationship.rep_1 ) + 
                TYPEOF( SELF\representation_relationship.rep_2 ) ) )
               >= 1;
  END_ENTITY;

  ENTITY specified_occurrence_context_dependent_shape_representation
    SUBTYPE OF (context_dependent_shape_representation);
    sub_element : product_definition_specified_occurrence;
  WHERE
    WR1: 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_OCCURRENCE' IN TYPEOF(SELF.represented_product_relation.definition.related_product_definition);
    WR2: sub_element IN represented_product_relation.definition.related_product_definition.descendant_occurrences;
  END_ENTITY;

  FUNCTION get_directed_link ( nodes : LIST OF representation;
                            undirected_link  : LIST OF chained_representation_link) : LIST OF representation_relationship;
  LOCAL
   directed_link : LIST OF representation_relationship := [];
  END_LOCAL;

  IF (SIZEOF(nodes) <> SIZEOF(undirected_link) + 1) OR
     (value_unique(nodes) = FALSE)
  THEN
   RETURN(?);
  END_IF;
  
  REPEAT i := 1 to SIZEOF(undirected_link);
   CASE TRUE OF
    ('REPRESENTATION_SCHEMA.REPRESENTATION_CONTEXT' IN TYPEOF(undirected_link[i])) :
    BEGIN
     IF ((nodes[i]\representation.context_of_items   :=: undirected_link[i]) AND 
         (nodes[i+1]\representation.context_of_items :=: undirected_link[i])) THEN
       INSERT(directed_link, representation_relationship('','',nodes[i+1],nodes[i]), (i - 1));
     ELSE
       RETURN(?); 
     END_IF;
    END;

    ('REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP' IN TYPEOF(undirected_link[i])) :
    BEGIN
     IF (((nodes[i]   :=: undirected_link[i]\representation_relationship.rep_1) AND
          (nodes[i+1] :=: undirected_link[i]\representation_relationship.rep_2)) OR
         ((nodes[i]   :=: undirected_link[i]\representation_relationship.rep_2) AND
          (nodes[i+1] :=: undirected_link[i]\representation_relationship.rep_1))) THEN
       INSERT(directed_link, representation_relationship('','',nodes[i+1],nodes[i]), (i - 1));
     ELSE
       RETURN(?); 
     END_IF;
    END;

    ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF(undirected_link[i])) :
    BEGIN
     IF ((nodes[i] IN using_representations(undirected_link[i])) AND 
         (nodes[i+1] :=: undirected_link[i]\mapped_item.mapping_source\representation_map.mapped_representation)) THEN
       INSERT(directed_link, representation_relationship('','',nodes[i+1],nodes[i]), (i - 1));
     ELSE
       RETURN(?); 
     END_IF;
    END;

    OTHERWISE : RETURN(?);
   END_CASE;
  END_REPEAT;
  
  IF (value_unique(directed_link) = FALSE)
  THEN
   RETURN(?);
  END_IF;
  
  RETURN(directed_link);
  END_FUNCTION;

  FUNCTION relatives_of_product_definitions (definition_set : SET OF product_definition; relation_subtype : STRING):SET OF product_definition;
    FUNCTION local_relatives_of_product_definitions (definition_set : SET OF product_definition; total_definitions : SET OF product_definition; relation_subtype : STRING):SET OF product_definition;
      LOCAL
        local_def : SET OF product_definition := [];
        local_pdr : SET OF product_definition_relationship := [];
        local_total : SET OF product_definition := [];
      END_LOCAL;

      REPEAT i := 1 TO HIINDEX(definition_set);
        local_pdr := local_pdr + bag_to_set(USEDIN(definition_set[i], relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(local_pdr);
        local_def := local_def + local_pdr[i].related_product_definition;
      END_REPEAT;
      IF (SIZEOF(local_def) - SIZEOF(total_definitions)) = 0 THEN
        RETURN (local_def);
      ELSE
        local_total := total_definitions + local_def;
        RETURN (local_def + (local_relatives_of_product_definitions(local_def - total_definitions, local_total, relation_subtype)));
      END_IF;
    END_FUNCTION;

    RETURN (local_relatives_of_product_definitions(definition_set, definition_set, relation_subtype));
  END_FUNCTION;

  FUNCTION relatives_of_shape_representations (shape_representation_set : SET OF shape_representation):SET OF shape_representation;
    FUNCTION local_relatives_of_shape_representations (shape_representation_set : SET OF shape_representation; total_reps : SET OF shape_representation):SET OF shape_representation;
      LOCAL
        local_shape_rep : SET OF shape_representation := [];
        local_srr : SET OF shape_representation_relationship := [];
        local_total : SET OF shape_representation := [];
      END_LOCAL;

      REPEAT i := 1 TO HIINDEX(shape_representation_set);
        local_srr := local_srr + QUERY(rr <* bag_to_set(USEDIN(shape_representation_set[i], 'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_1')) | 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(rr));
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(local_srr);
        IF 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' + 'SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(local_srr[i]) THEN
          local_shape_rep := local_shape_rep + local_srr[i].rep_2;
        END_IF;
      END_REPEAT;
      IF SIZEOF(local_shape_rep - total_reps) = 0 THEN
        RETURN (shape_representation_set);
      ELSE
        local_total := total_reps + local_shape_rep;
        RETURN (local_shape_rep + (local_relatives_of_shape_representations(local_shape_rep - total_reps, local_total)));
      END_IF;
    END_FUNCTION;

    RETURN (local_relatives_of_shape_representations(shape_representation_set, shape_representation_set));
  END_FUNCTION;

  FUNCTION get_property_definition_representations (c_def_instance : characterized_definition):SET OF property_definition_representation;
    LOCAL
      pd_set : SET OF property_definition := [];
      pdr_set : SET OF property_definition_representation := [];
    END_LOCAL;

    pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    END_REPEAT;
    RETURN (pdr_set);
  END_FUNCTION;

  FUNCTION valid_identified_item_in_representation (identified_item : item_identified_representation_usage_select; used_representation : representation) : BOOLEAN;
    LOCAL
      i : INTEGER := 1;
    END_LOCAL;
    IF 'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(identified_item)
    THEN
      RETURN(used_representation IN using_representations(identified_item));
    END_IF;
    IF ('REPRESENTATION_SCHEMA.LIST_REPRESENTATION_ITEM' IN TYPEOF(identified_item)) OR
       ('REPRESENTATION_SCHEMA.SET_REPRESENTATION_ITEM' IN TYPEOF(identified_item))
    THEN
      REPEAT WHILE (EXISTS(identified_item[i]));
        IF NOT (used_representation IN using_representations(identified_item[i]))
        THEN 
          RETURN(FALSE);
        END_IF;
        i := i + 1;
      END_REPEAT;
      RETURN(TRUE);
    END_IF;
    RETURN(?);
  END_FUNCTION; 

END_SCHEMA;


--
-- PRODUCT_RELATIONSHIP_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_relationship/mim.exp)
--
(*
 $Id: mim.exp,v 1.5 2004/10/22 14:59:58 darla Exp 
 ISO TC184/SC4/WG12 N1133 - ISO/TS 10303-1024 Product relationship - EXPRESS MIM
*)
  
SCHEMA Product_relationship_mim;
USE FROM Product_identification_mim; -- ISO 10303-1017
USE FROM product_definition_schema -- ISO 10303-41
  (product_relationship);
END_SCHEMA;






--
-- PRODUCT_REPLACEMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_replacement/mim.exp)
--
(*
 $Id: mim.exp,v 1.6 2006/03/24 18:58:39 thendrix Exp 
 ISO TC184/SC4/WG12 N4361 - ISO/TS 10303-1046 Product replacement - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1145
*)
    
SCHEMA Product_replacement_mim;

USE FROM Assembly_structure_mim; -- ISO 10303-1026
USE FROM Product_identification_mim; -- ISO 10303-1017

USE FROM product_structure_schema -- ISO 10303-44
  (alternate_product_relationship,
   assembly_component_usage_substitute);
END_SCHEMA;






--
-- PRODUCT_STRUCTURE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_structure/mim.exp)
--
(*
ISO TC184/SC4/WG12 N2547 - ISO/TS 10303-1134 Product structure - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1671
*) 


SCHEMA Product_structure_mim;

USE FROM Assembly_structure_mim;    -- ISO/TS 10303-1026

USE FROM Contextual_shape_positioning_mim;    -- ISO/TS 10303-1027

USE FROM Part_and_version_identification_mim;    -- ISO/TS 10303-1022

USE FROM Part_definition_relationship_mim;    -- ISO/TS 10303-1055

USE FROM Product_replacement_mim;    -- ISO/TS 10303-1046

USE FROM Product_version_relationship_mim;    -- ISO/TS 10303-1020

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

USE FROM Single_part_representation_mim;    -- ISO/TS 10303-1133

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set); 


END_SCHEMA;  -- Product_structure_mim


--
-- PRODUCT_STRUCTURE_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/product_structure_schema/product_structure_schema.exp)
--
(*
Id: product_structure_schema.exp,v 1.41 2021/08/04 15:59:44 kevin Exp 
ISO 10303 TC184/SC4/WG12 N10967

EXPRESS Source:
ISO 10303-44 ed6 Product structure configuration - Product structure schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
and derivations of the Schema:

Copyright ISO 2021  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-44 ed6 Product structure configuration - Product structure schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA product_structure_schema '{iso standard 10303 part(44) version(6) object(1) product_structure_schema(1)}';

  REFERENCE FROM measure_schema   -- ISO 10303-41
     (measure_with_unit);

  REFERENCE FROM product_definition_schema   -- ISO 10303-41
    (acyclic_product_definition_relationship,
     generic_product_definition_reference,
     product,
     product_definition,
     product_definition_formation,
     product_definition_or_reference,
     product_definition_reference,
     product_definition_relationship,
     product_definition_relationship_relationship);

  REFERENCE FROM support_resource_schema   -- ISO 10303-41
     (identifier, label, text);

TYPE product_definition_occurrence_or_reference = SELECT (
  product_definition_occurrence,
  product_definition_occurrence_reference);
END_TYPE;

TYPE product_definition_or_reference_or_occurrence = SELECT BASED_ON product_definition_or_reference WITH (
  product_definition_occurrence);
END_TYPE;

ENTITY alternate_product_relationship;
  name        : label;
  definition  : OPTIONAL text;
  alternate   : product;
  base        : product;
  basis       : text;
UNIQUE
  UR1: alternate, base;
WHERE
  WR1: alternate :<>: base;
END_ENTITY;

ENTITY assembly_component_usage
  SUPERTYPE OF (quantified_assembly_component_usage ANDOR
                ONEOF (multi_level_reference_designator,
  					   next_assembly_usage_occurrence,
  					   promissory_usage_occurrence,
                       specified_higher_usage_occurrence))
  SUBTYPE OF (product_definition_usage);
  reference_designator : OPTIONAL identifier;
END_ENTITY;

ENTITY assembly_component_usage_substitute;
  name              : label;
  definition        : OPTIONAL text;
  base              : assembly_component_usage;
  substitute        : assembly_component_usage;
UNIQUE
  UR1: base,substitute;
WHERE
  WR1: base.relating_product_definition :=:
       substitute.relating_product_definition;
  WR2: base :<>: substitute;
END_ENTITY;

ENTITY assembly_component_usage_substitute_with_ranking
  SUBTYPE OF (assembly_component_usage_substitute);
  ranking           : INTEGER;
  ranking_rationale : text;
END_ENTITY;

ENTITY make_from_usage_option
  SUBTYPE OF (product_definition_usage);
  ranking           : INTEGER;
  ranking_rationale : text;
  quantity          : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;

ENTITY make_from_usage_option_group;
  members : SET [2:?] OF make_from_usage_option;
WHERE
  WR1: SIZEOF (QUERY (example <* members |
       example.related_product_definition
       :=: members[1].related_product_definition)) =SIZEOF(members);
END_ENTITY;

ENTITY multi_level_reference_designator
  SUBTYPE OF (assembly_component_usage);
  location : LIST[1:?] OF UNIQUE next_assembly_usage_occurrence;
DERIVE
  SELF\product_definition_relationship.relating_product_definition RENAMED root : product_definition := location[1]\product_definition_relationship.relating_product_definition;
  SELF\product_definition_relationship.related_product_definition  RENAMED leaf : product_definition_or_reference := location[HIINDEX(location)]\product_definition_relationship.related_product_definition;
UNIQUE
  UR1: location;
WHERE
  WR1: unambiguously_specified_multi_level_reference_designator(location);
  WR2: SIZEOF(QUERY(cp <* location | NOT (
         EXISTS(cp\assembly_component_usage.reference_designator)))) = 0;
END_ENTITY;

ENTITY next_assembly_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
DERIVE
  product_definition_occurrence_id : identifier := SELF\product_definition_relationship.related_product_definition\product_definition_occurrence.id;
-- replicates the id of a product_definition_occurrence that is referenced by related_product_definition.
UNIQUE
  UR1 : SELF\assembly_component_usage.reference_designator, SELF\product_definition_relationship.relating_product_definition;
  UR2 : product_definition_occurrence_id, SELF\product_definition_relationship.relating_product_definition;
--  The id of a product_definition_occurrence shall be unique among all product_definition_or_occurrence_or_reference that are used within an assembly of the occurrance_usages
END_ENTITY;

ENTITY product_definition_occurrence
  SUPERTYPE OF (product_definition_specified_occurrence ANDOR product_definition_occurrence_reference_with_local_representation);
  id : identifier;
  name : OPTIONAL label;
  description : OPTIONAL text;
  definition : OPTIONAL product_definition_or_reference_or_occurrence;
  quantity : OPTIONAL measure_with_unit;
DERIVE
  descendant_occurrences : SET[0:?] OF product_definition_specified_occurrence := get_descendant_occurrences(SELF);
INVERSE
  assembly_usages : SET[0:?] OF assembly_component_usage FOR related_product_definition;
  child_occurrences : SET[0:?] OF product_definition_specified_occurrence FOR occurrence_usage;
WHERE
  WR1 : NOT (('PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_OCCURRENCE' IN TYPEOF(definition)) OR 
             ('PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_OCCURRENCE_REFERENCE' IN TYPEOF(definition)))
      OR
           ('PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_SPECIFIED_OCCURRENCE' IN TYPEOF(SELF));
  WR2: EXISTS(definition) OR
       (SIZEOF(USEDIN(SELF, 'CONFIGURATION_MANAGEMENT_SCHEMA.CONFIGURATION_DESIGN.DESIGN')) > 0);
  WR3: NOT ('NUMBER' IN TYPEOF(quantity\measure_with_unit.value_component)) OR 
            (quantity\measure_with_unit.value_component > 0);
END_ENTITY;

ENTITY product_definition_occurrence_reference
  SUBTYPE OF (product_definition_reference);
  product_occurrence_id : identifier;
END_ENTITY;

ENTITY product_definition_occurrence_reference_with_local_representation
  SUBTYPE OF (product_definition_occurrence, generic_product_definition_reference);
END_ENTITY;

ENTITY product_definition_occurrence_relationship;
  name             : label;
  description      : OPTIONAL text;
  occurrence       : product_definition;
  occurrence_usage : assembly_component_usage;
WHERE
  WR1: occurrence_usage.relating_product_definition :<>:
       occurrence;
  WR2: occurrence_usage.related_product_definition :<>:
       occurrence;
  WR3: occurrence.formation :=:
       occurrence_usage.related_product_definition.formation;
END_ENTITY;

ENTITY product_definition_specified_occurrence
  SUBTYPE OF (product_definition_occurrence);
	SELF\product_definition_occurrence.definition : product_definition_occurrence_or_reference;
	occurrence_usage : product_definition_occurrence_or_reference;
UNIQUE
	UR1 : occurrence_usage, id;
WHERE
	WR1: SIZEOF(assembly_usages) = 0;
	WR2: acyclic_product_definition_specified_occurrence(SELF, SELF\product_definition_occurrence.definition);
END_ENTITY;

ENTITY product_definition_usage
  SUPERTYPE OF (ONEOF (make_from_usage_option,
                       assembly_component_usage))
  SUBTYPE OF (product_definition_relationship);
UNIQUE
  UR1: SELF\product_definition_relationship.id,
       SELF\product_definition_relationship.relating_product_definition,
       SELF\product_definition_relationship.related_product_definition;
WHERE
  WR1:  acyclic_product_definition_relationship
         (SELF,
         [SELF\product_definition_relationship.related_product_definition],
         'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE');
END_ENTITY;

ENTITY product_definition_usage_relationship
  SUBTYPE OF (product_definition_relationship_relationship);
  SELF\product_definition_relationship_relationship.relating : product_definition_usage;
  SELF\product_definition_relationship_relationship.related : product_definition_usage;
WHERE
  WR1: relating.relating_product_definition :=: related.relating_product_definition;
END_ENTITY;

ENTITY promissory_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;

ENTITY quantified_assembly_component_usage
  SUBTYPE OF (assembly_component_usage);
  quantity   : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;

ENTITY specified_higher_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
  upper_usage   : assembly_component_usage;
  next_usage    : next_assembly_usage_occurrence;
UNIQUE
  UR1: upper_usage, next_usage;
WHERE
  WR1: SELF :<>: upper_usage;
  WR2: SELF\product_definition_relationship.relating_product_definition
       :=: upper_usage.relating_product_definition;
  WR3: SELF\product_definition_relationship.related_product_definition
       :=: next_usage.related_product_definition;
  WR4: (upper_usage.related_product_definition :=:
       next_usage.relating_product_definition) OR
       (SIZEOF (QUERY (pdr <* USEDIN (upper_usage.related_product_definition,
       'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
        pdr.relating_product_definition :=:
        next_usage.relating_product_definition)) = 1);
  WR5: SIZEOF (['PRODUCT_STRUCTURE_SCHEMA.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
       'PRODUCT_STRUCTURE_SCHEMA.SPECIFIED_HIGHER_USAGE_OCCURRENCE']
       * TYPEOF(upper_usage)) = 1;
END_ENTITY;

FUNCTION acyclic_product_definition_specified_occurrence
          (pdso : product_definition_specified_occurrence; definition : product_definition_occurrence) : BOOLEAN;
    IF NOT (('PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_SPECIFIED_OCCURRENCE') IN TYPEOF(definition)) THEN
      RETURN   (TRUE);
    END_IF;
    IF  (definition :=: pdso) THEN
      RETURN  (FALSE);
    ELSE RETURN(acyclic_product_definition_specified_occurrence(pdso, definition\product_definition_occurrence.definition));
    END_IF;
END_FUNCTION;

FUNCTION get_descendant_occurrences(input : product_definition_occurrence) : SET [0:?] OF product_definition_specified_occurrence;
    LOCAL
        result : SET  OF  product_definition_specified_occurrence := input.child_occurrences;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(input.child_occurrences) BY 1;
        result := result + get_descendant_occurrences(input.child_occurrences[i]);
    END_REPEAT;
    RETURN (result);
END_FUNCTION;

FUNCTION unambiguously_specified_multi_level_reference_designator (links : LIST[1:?] OF next_assembly_usage_occurrence) : BOOLEAN;
REPEAT i := 1 to SIZEOF(links) - 1;
--case 1 all in one file; had to disambiguate link[i].relating instance type to distinguish case 1 from case 3.
   CASE TRUE OF
      ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(links[i]\product_definition_relationship.relating_product_definition))
       AND
      ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(links[i]\product_definition_relationship.related_product_definition))
       AND
      ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(links[i+1]\product_definition_relationship.relating_product_definition)) :
     BEGIN
        IF NOT (
                (links[i]\product_definition_relationship.related_product_definition :=:
                 links[i+1]\product_definition_relationship.relating_product_definition)
                 OR
                ((SIZEOF (QUERY (pdr <* USEDIN(links[i]\product_definition_relationship.related_product_definition,
                          'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION') |
                          pdr\product_definition_relationship.relating_product_definition :=:
                          links[i+1]\product_definition_relationship.relating_product_definition)) = 1)
                  AND
                   (links[i]\product_definition_relationship.related_product_definition\product_definition.formation\product_definition_formation.of_product
                    :=:
                    links[i+1]\product_definition_relationship.relating_product_definition\product_definition.formation\product_definition_formation.of_product)))
         THEN
          RETURN(FALSE);
        END_IF;
     END;

--case 2 ; intermediate node reference from main to external file or both node references in external file. links[i].relating instance can be either pd or pdref.
     ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_REFERENCE' IN TYPEOF(links[i]\product_definition_relationship.related_product_definition))
       AND
     ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_REFERENCE' IN TYPEOF(links[i+1]\product_definition_relationship.relating_product_definition)) :
       BEGIN
         IF NOT (
                (links[i]\product_definition_relationship.related_product_definition :=:
                 links[i+1]\product_definition_relationship.relating_product_definition)
                 OR
                ((SIZEOF (QUERY (pdr <* USEDIN(links[i]\product_definition_relationship.related_product_definition,
                          'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION') |
                          pdr\product_definition_relationship.relating_product_definition :=:
                          links[i+1]\product_definition_relationship.relating_product_definition)) = 1)
                  AND
                   (links[i]\product_definition_relationship.related_product_definition\product_definition_reference.product_id
                    =
                    links[i+1]\product_definition_relationship.relating_product_definition\product_definition_reference.product_id)
                  AND
                   (links[i]\product_definition_relationship.related_product_definition\product_definition_reference.id_owning_organization_name
                    =
                    links[i+1]\product_definition_relationship.relating_product_definition\product_definition_reference.id_owning_organization_name)
                  AND
                   (links[i]\product_definition_relationship.related_product_definition\product_definition_reference.product_definition_id
                   <>
                    links[i+1]\product_definition_relationship.relating_product_definition\product_definition_reference.product_definition_id)))
         THEN
          RETURN(FALSE);
        END_IF;
     END;

--case 3 should never see -- link in external file referencing a node in main assembly file. Note link is just links[i].
     ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_REFERENCE' IN TYPEOF(links[i]\product_definition_relationship.relating_product_definition))
       AND
     ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(links[i]\product_definition_relationship.related_product_definition)) :
     RETURN(FALSE);

     OTHERWISE : RETURN(FALSE);
   END_CASE;

END_REPEAT;
RETURN(TRUE);
END_FUNCTION;

END_SCHEMA; -- product_structure


--
-- PRODUCT_VERSION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_version/mim.exp)
--
(* 
 $Id: mim.exp,v 1.6 2004/01/13 10:15:26 robbod Exp 
 ISO TC184/SC4/WG12 N2528 - ISO/TS 10303-1018 Product version - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1106
*) 


SCHEMA Product_version_mim; 

USE FROM Product_identification_mim;    -- ISO/TS 10303-1017

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition_formation); 


END_SCHEMA;  -- Product_version_mim



--
-- PRODUCT_VERSION_RELATIONSHIP_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_version_relationship/mim.exp)
--
(*
 $Id: mim.exp,v 1.6 2006/03/24 19:02:40 thendrix Exp 
 ISO TC184/SC4/WG12 N4355 - ISO/TS 10303-1020 Product version relationship - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1130
*)
   
SCHEMA Product_version_relationship_mim;

USE FROM Product_version_mim; 	--ISO 10303-1018

USE FROM product_definition_schema 	-- ISO 10303-41
  (product_definition_formation_relationship);
   
END_SCHEMA;




--
-- PRODUCT_VIEW_DEFINITION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_view_definition/mim.exp)
--
(*
 ISO TC184/SC4/WG12 N11095 - ISO/TS 10303-1019 Product view definition - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N9273
*) 

SCHEMA Product_view_definition_mim;

USE FROM application_context_schema   -- ISO 10303-41
  (dependent_product_definition_exchange_context,
   product_definition_context);

USE FROM basic_attribute_schema   -- ISO 10303-41
  (name_attribute,
   name_attribute_select);

USE FROM Identification_assignment_mim; -- ISO/TS 10303-1021

USE FROM Multi_linguism_mim; -- ISO/TS 10303-1105

USE FROM Person_organization_mim; -- ISO/TS 10303-1011

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition,
   product_definition_context_association);

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

USE FROM Shape_property_assignment_mim; -- ISO/TS 10303-1032

USE FROM Value_with_unit_mim; -- ISO/TS 10303-1054

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set);

END_SCHEMA;  -- Product_view_definition_mim



--
-- PRODUCT_VIEW_DEFINITION_PROPERTIES_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_view_definition_properties/mim.exp)
--
(*
 $Id: mim.exp,v 1.14 2012/11/09 21:40:59 thomasrthurman Exp 
ISO TC184/SC4/WG12 N8290 - ISO/TS 10303-1034 Product view definition properties - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N3228
*) 


SCHEMA Product_view_definition_properties_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute,
   id_attribute_select); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_product_definition); 

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030


END_SCHEMA;  -- Product_view_definition_properties_mim


--
-- PRODUCT_VIEW_DEFINITION_REFERENCE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_view_definition_reference/mim.exp)
--
(*
   $Id: mim.exp,v 1.3 2017/04/28 15:09:08 verodub Exp 
   ISO TC184/SC4/WG12 N7769 - ISO/TS 10303-1823 Product view definition reference - EXPRESS MIM*)

SCHEMA Product_view_definition_reference_mim;

	USE FROM Support_resource_mim; -- ISO/TS 10303-1800
	USE FROM External_item_identification_assignment_mim;	-- ISO/TS 10303-1128
	USE FROM Product_view_definition_mim;	-- ISO/TS 10303-1019
	USE FROM External_reference_schema   -- ISO 10303-41
		(externally_defined_item,
		external_source);
	USE FROM product_definition_schema (   -- ISO 10303-41
		generic_product_definition_reference,
		product_definition_reference,
		product_definition_reference_with_local_representation);
	
TYPE pie_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
     (generic_product_definition_reference);
END_TYPE; 

END_SCHEMA;


--
-- PRODUCT_VIEW_DEFINITION_RELATIONSHIP_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/product_view_definition_relationship/mim.exp)
--
(*
 $Id: mim.exp,v 1.6 2012/09/22 18:15:05 thomasrthurman Exp 
 ISO TC184/SC4/WG12 N1142 - ISO/TS 10303-1041 Product view definition relationship - EXPRESS MIM
*)

SCHEMA Product_view_definition_relationship_mim;

USE FROM Product_view_definition_mim; -- ISO 10303-1019
USE FROM Product_view_definition_reference_mim; -- ISO/TS 10303-1738

USE FROM product_definition_schema -- ISO 10303-41
  (product_definition_relationship);

USE FROM product_structure_schema -- ISO 10303-44
  (product_definition_usage);
END_SCHEMA;


--
-- PROJECT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/project/mim.exp)
--
(*
 $Id: mim.exp,v 1.13 2012/11/09 21:40:59 thomasrthurman Exp 
 ISO TC184/SC4/WG12 N8293 - ISO/TS 10303-1061 Project - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4264
*) 


SCHEMA Project_mim; 

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Date_time_mim;    -- ISO/TS 10303-1010

USE FROM Event_assignment_mim;    -- ISO/TS 10303-1364

USE FROM Event_mim;    -- ISO/TS 10303-1064

USE FROM management_resources_schema   -- ISO 10303-41
  (organizational_project_assignment,
   organizational_project_role); 

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011

USE FROM person_organization_schema   -- ISO 10303-41
  (organizational_project,
   organizational_project_relationship); 


TYPE project_as_date_and_time_item = SELECT BASED_ON date_and_time_item WITH 
   (organizational_project);
END_TYPE; 

TYPE project_as_date_item = SELECT BASED_ON date_item WITH 
   (organizational_project);
END_TYPE; 

TYPE project_event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON event_occurrence_item WITH 
   (organizational_project);
END_TYPE; 

TYPE project_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_organizational_project_assignment
  SUBTYPE OF (organizational_project_assignment);
  items : SET[1:?] OF project_item;
END_ENTITY;

END_SCHEMA;  -- Project_mim


--
-- PROPERTY_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/property_assignment/mim.exp)
--
(*
 $Id: mim.exp,v 1.21 2019/06/06 17:24:06 kevin Exp 
 ISO TC184/SC4/WG12 N10266 - ISO/TS 10303-1030 Property assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N8042
*) 


SCHEMA Property_assignment_mim;

USE FROM Activity_mim;      -- ISO/TS 10303-1047

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute,
   id_attribute_select); 

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Independent_property_mim;    -- ISO/TS 10303-1036

USE FROM material_property_definition_schema  -- ISO 10303-45
  (property_definition_relationship);

USE FROM product_property_definition_schema   -- ISO 10303-41
  (general_property_association,
   property_definition); 

USE FROM product_property_representation_schema   -- ISO 10303-41
  (property_definition_representation); 

TYPE pa_action_items = SELECT BASED_ON action_items WITH
  (property_definition_relationship);
END_TYPE;

END_SCHEMA;  -- Property_assignment_mim


--
-- PROPERTY_AS_DEFINITION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/property_as_definition/mim.exp)
--
(*
Id: mim.exp,v 1.9 2017/01/23 13:58:18 kevletu Exp 
ISO TC184/SC4/WG12 N9344 - ISO/TS 10303-1399 Property as definition - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6583
*) 


SCHEMA Property_as_definition_mim;

USE FROM Product_view_definition_properties_mim;    -- ISO/TS 10303-1034

ENTITY single_property_is_definition
  SUBTYPE OF (property_definition);
  SELF\property_definition.definition : product_definition;
UNIQUE
  UR1: definition;
END_ENTITY;

END_SCHEMA;  -- Property_as_definition_mim




--
-- QUALIFICATIONS_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/qualifications/mim.exp)
--
(*
 $Id: mim.exp,v 1.6 2004/11/19 21:37:38 robbod Exp 
 ISO TC184/SC4/WG12 N3116 - ISO/TS 10303-1244 Qualifications - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2412
*) 


SCHEMA Qualifications_mim;

USE FROM Certification_mim;    -- ISO/TS 10303-1044

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM management_resources_schema   -- ISO 10303-41
  (qualification_type_assignment); 

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011

USE FROM person_organization_schema   -- ISO 10303-41
  (person); 

USE FROM qualifications_schema   -- ISO 10303-41
  (qualification_type,
   qualification_type_relationship); 


TYPE person_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (person);
END_TYPE; 

TYPE qualification_type_certification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON certification_item WITH 
   (applied_qualification_type_assignment);
END_TYPE; 

TYPE qualification_type_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (qualification_type);
END_TYPE; 

TYPE qualification_type_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (applied_qualification_type_assignment);
END_TYPE; 

TYPE qualification_type_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (applied_qualification_type_assignment);
END_TYPE; 

TYPE qualification_type_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (applied_qualification_type_assignment, 
    qualification_type);
END_TYPE; 

ENTITY applied_qualification_type_assignment
  SUBTYPE OF (qualification_type_assignment);
  items : SET[1:?] OF person_organization_item;
END_ENTITY;

END_SCHEMA;  -- Qualifications_mim



--
-- QUALIFICATIONS_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/qualifications_schema/qualifications_schema.exp)
--
(*
Id: qualifications_schema.exp,v 1.16 2014/03/04 00:30:40 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Qualifications schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Qualifications schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA qualifications_schema '{iso standard 10303 part(41) version(6) object(1) qualifications_schema(20)}';
  REFERENCE FROM support_resource_schema (identifier, label, text, bag_to_set);
  ENTITY qualification;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY qualification_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_qualification : qualification;
    related_qualification : qualification;
  END_ENTITY;

  ENTITY qualification_type;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY qualification_type_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_qualification_type : qualification_type;
    related_qualification_type : qualification_type;
  END_ENTITY;

  FUNCTION acyclic_qualification_relationship (relation : qualification_relationship; relatives : SET OF qualification; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF qualification_relationship;
    END_LOCAL;

    IF relation.relating_qualification IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(qual <* bag_to_set(USEDIN(relation.relating_qualification, 'QUALIFICATIONS_SCHEMA.' + 'QUALIFICATION_RELATIONSHIP.' + 'RELATED_QUALIFICATION')) | specific_relation IN TYPEOF(qual));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_qualification_relationship(x[i], relatives + relation.relating_qualification, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_qualification_type_relationship (relation : qualification_type_relationship; relatives : SET OF qualification_type; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF qualification_type_relationship;
    END_LOCAL;

    IF relation.relating_qualification_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(qultyp <* bag_to_set(USEDIN(relation.relating_qualification_type, 'QUALIFICATIONS_SCHEMA.' + 'QUALIFICATION_TYPE_RELATIONSHIP.' + 'RELATED_QUALIFICATION_TYPE')) | specific_relation IN TYPEOF(qultyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_qualification_type_relationship(x[i], relatives + relation.relating_qualification_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;


--
-- QUALIFIED_MEASURE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/qualified_measure/mim.exp)
--
(*
   $Id: mim.exp,v 1.16 2019/06/10 20:32:29 kevin Exp 
   ISO TC184/SC4/WG12 N10520 - ISO/TS 10303-1782 Qualified measure - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N10428
*)

SCHEMA Qualified_measure_mim;

USE FROM Maths_value_mim; -- ISO/TS 10303-1092

USE FROM Measure_representation_mim; -- ISO/TS 10303-1118

USE FROM qualified_measure_schema   -- ISO 10303-45
  (expanded_uncertainty,
  maths_value_precision_qualifier,
  measure_qualification,
  measure_representation_item,
  qualified_representation_item,
  qualitative_uncertainty,
  precision_qualifier,
  standard_uncertainty,
  type_qualifier,
  uncertainty_qualifier,
  value_format_type_qualifier);

USE FROM representation_schema   -- ISO 10303-43
  (uncertainty_assigned_representation);


RULE consistent_uncertainty 
      FOR (global_uncertainty_assigned_context,
           qualified_representation_item,
           uncertainty_assigned_representation);
WHERE
WR1: SIZEOF ( QUERY ( guac <* global_uncertainty_assigned_context | 
    SIZEOF ( QUERY ( u1 <* guac.uncertainty | 
	SIZEOF ( QUERY ( u2 <* guac.uncertainty | u2.name =  u1.name ) ) >1 ) ) >0 ) ) =  0 ;
WR2: SIZEOF ( QUERY ( uar <* uncertainty_assigned_representation | 
	SIZEOF ( QUERY ( u1<* uar.uncertainty | 
	SIZEOF ( QUERY ( u2 <* uar.uncertainty | u2.name =  u1.name ) ) >1 ) ) >0 ) ) =  0;
WR3: SIZEOF ( QUERY ( qri <* qualified_representation_item |
     SIZEOF ( QUERY ( u1 <* qri.qualifiers |
     ('QUALIFIED_MEASURE_SCHEMA.' + 'UNCERTAINTY_QUALIFIER' IN TYPEOF ( u1 ) ) AND 
	( SIZEOF ( QUERY ( u2 <* qri.qualifiers |
     ( 'QUALIFIED_MEASURE_SCHEMA.' + 'UNCERTAINTY_QUALIFIER' IN TYPEOF ( u2 ) ) AND 
	( u2\uncertainty_qualifier.measure_name =  u1\uncertainty_qualifier.measure_name ) )
     ) >1 ) ) ) >0 ) ) =  0;
END_RULE; 

END_SCHEMA;


--
-- QUALIFIED_MEASURE_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/qualified_measure_schema/qualified_measure_schema.exp)
--
(*
Id: qualified_measure_schema.exp,v 1.13 2019/04/18 13:10:02 verodub Exp 
ISO 10303 TC184/SC4/WG12 N10471

EXPRESS Source:
ISO 10303-45 ed5 Material and other engineering properties - Qualified measure schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2019  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-45 ed5 Material and other engineering properties - Qualified measure schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA qualified_measure_schema '{iso standard 10303 part(45) version(4) object(1) qualified_measure_schema(3)}';

REFERENCE FROM mathematical_functions_schema   -- ISO 10303-50
     (maths_value);

REFERENCE FROM measure_schema   -- ISO 10303-41
     (measure_with_unit,
unit);

REFERENCE FROM representation_schema   -- ISO 10303-43
     (representation_item);

REFERENCE FROM support_resource_schema   -- ISO 10303-41
     (identifier,
      label,
      text,
      bag_to_set);

TYPE value_format_type = identifier;
WHERE
      WR1: LENGTH(SELF) <= 80; 
END_TYPE; -- value_format_type
  
TYPE value_qualifier = SELECT
  (maths_value_precision_qualifier,
   precision_qualifier,
   type_qualifier,
   uncertainty_qualifier,
   value_format_type_qualifier);
END_TYPE;

ENTITY descriptive_representation_item
  SUBTYPE OF (representation_item);
  description : text;
END_ENTITY;

ENTITY expanded_uncertainty
  SUBTYPE OF (standard_uncertainty);
  coverage_factor : REAL;
END_ENTITY;

ENTITY maths_value_qualification;
  name 			: label;
  description 		: text;
  qualified_maths_value : maths_value_with_unit;
  qualifiers 		: SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             ('QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER'
             IN TYPEOF(temp)) OR
	     ('QUALIFIED_MEASURE_SCHEMA.MATHS_VALUE_PRECISION_QUALIFIER'
	     IN TYPEOF(temp)))) < 2;
  WR2: NOT ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM'
           IN TYPEOF(SELF\maths_value_qualification.qualified_maths_value));
END_ENTITY;

ENTITY maths_value_representation_item
  SUBTYPE OF (representation_item, maths_value_with_unit);
END_ENTITY;

ENTITY maths_value_with_unit;
  value_component 	: maths_value;
  unit_component 		: unit;
END_ENTITY;

ENTITY measure_qualification;
  name 			: label;
  description 		: text;
  qualified_measure 	: measure_with_unit;
  qualifiers 		: SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             ('QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER'
             IN TYPEOF(temp)) OR
	     ('QUALIFIED_MEASURE_SCHEMA.MATHS_VALUE_PRECISION_QUALIFIER'
	     IN TYPEOF(temp)))) < 2;
  WR2: NOT ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM'
           IN TYPEOF(SELF\measure_qualification.qualified_measure));
END_ENTITY;

ENTITY measure_representation_item
  SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY;

ENTITY maths_value_precision_qualifier;
  precision_value : maths_value;
END_ENTITY;

ENTITY precision_qualifier;
  precision_value : INTEGER;
END_ENTITY;

ENTITY qualified_representation_item
  SUBTYPE OF (representation_item);
  qualifiers 	: SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             ('QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER'
              IN TYPEOF(temp)) OR
             ('QUALIFIED_MEASURE_SCHEMA.MATHS_VALUE_PRECISION_QUALIFIER'
	      IN TYPEOF(temp)))) < 2;
END_ENTITY;

ENTITY qualitative_uncertainty
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : text;
END_ENTITY;

ENTITY standard_uncertainty
  SUPERTYPE OF (expanded_uncertainty)
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : REAL;
END_ENTITY;

ENTITY type_qualifier;
  name : label;
END_ENTITY;

ENTITY uncertainty_qualifier
 SUPERTYPE OF (ONEOF (standard_uncertainty,
                     qualitative_uncertainty));
  measure_name : label;
  description  : text;
END_ENTITY;

ENTITY value_format_type_qualifier;
  format_type : value_format_type;
END_ENTITY;


END_SCHEMA;  -- qualified_measure_schema



--
-- REPRESENTATION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/representation_schema/representation_schema.exp)
--
(*
Id: representation_schema.exp,v 1.42 2021/05/06 16:22:59 kevin Exp 
ISO 10303 TC184/SC4/WG12 N10587

EXPRESS Source:
ISO 10303-43 ed5 Representation structures - Representation schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2021  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-43 ed5 Representation structures - Representation schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA representation_schema '{iso standard 10303 part(43) version(7) object(1) representation_schema(1)}';

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   description_attribute_select,
   get_description_value,
   get_id_value,
   id_attribute,
   id_attribute_select);

REFERENCE FROM measure_schema   -- ISO 10303-41
  (measure_value,
   measure_with_unit);

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);
   
  TYPE rs_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    representation);
  END_TYPE;
  
  TYPE rs_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    representation);
  END_TYPE;

  TYPE compound_item_definition = SELECT
    (list_representation_item,
     set_representation_item);
  END_TYPE;

  TYPE founded_item_select = SELECT
    (founded_item,
     representation_item);
  END_TYPE;

  TYPE representation_or_representation_reference = SELECT (
             representation,
             representation_reference);
  END_TYPE;

  TYPE list_representation_item = LIST [1:?] OF representation_item;
  END_TYPE;

  TYPE set_representation_item = SET [1:?] OF representation_item;
  END_TYPE;

  TYPE set_item_defined_transformation = 
    SET[1:?] OF item_defined_transformation;
  END_TYPE; 
  
  TYPE transformation = SELECT
    (item_defined_transformation,
     functionally_defined_transformation,
     set_item_defined_transformation);
  END_TYPE;


  ENTITY binary_representation_item 
    SUBTYPE OF (representation_item); 
      binary_value : BINARY; 
  END_ENTITY; 

  ENTITY bytes_representation_item 
    SUBTYPE OF (binary_representation_item); 
    DERIVE 
      no_of_bytes : INTEGER := BLENGTH(SELF\binary_representation_item.binary_value) DIV 8; 
    WHERE 
      WR1: BLENGTH(SELF\binary_representation_item.binary_value) MOD 8 = 0; 
  END_ENTITY; 

  ENTITY compound_representation_item
    SUBTYPE OF (representation_item);
      item_element : compound_item_definition;
  END_ENTITY;

  ENTITY definitional_representation
    SUBTYPE OF (representation);
    WHERE
      WR1: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' IN
          TYPEOF (SELF\representation.context_of_items );
  END_ENTITY;

  ENTITY definitional_representation_relationship
    SUBTYPE OF (representation_relationship);
     WHERE
       WR1: acyclic_representation_relationship(SELF,
         [SELF\representation_relationship.rep_2],
         'REPRESENTATION_SCHEMA.'+'REPRESENTATION');
  END_ENTITY;  

  ENTITY definitional_representation_relationship_with_same_context
    SUBTYPE OF (definitional_representation_relationship);
     WHERE
       WR1: SELF\representation_relationship.rep_1.context_of_items :=: 
            SELF\representation_relationship.rep_2.context_of_items;
  END_ENTITY;  

  ENTITY founded_item;
    DERIVE
      users : SET[0:?] OF founded_item_select := using_items(SELF,[]);
    WHERE
      WR1: SIZEOF(users) > 0;
      WR2: NOT(SELF IN users);  
  END_ENTITY;

  ENTITY functionally_defined_transformation;
    name        : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY global_uncertainty_assigned_context
    SUBTYPE OF (representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY;

  ENTITY item_defined_transformation;
    name             : label;
    description      : OPTIONAL text;
    transform_item_1 : representation_item;
    transform_item_2 : representation_item;
  END_ENTITY;

  ENTITY mapped_item
    SUBTYPE OF (representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
    WHERE
      WR1: acyclic_mapped_representation(SELF);
  END_ENTITY;

  ENTITY parametric_representation_context
    SUBTYPE OF (representation_context);
  END_ENTITY;

  ENTITY representation;
      name             : label;
      items            : SET[1:?] OF representation_item;
      context_of_items : representation_context;
    DERIVE
      id               : identifier := get_id_value (SELF);
      description      : text := get_description_value (SELF);
    WHERE
      WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                                 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))
         <= 1;
      WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                                 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))
         <= 1;
  END_ENTITY;

  ENTITY representation_context;
      context_identifier : identifier;
      context_type       : text;
    INVERSE
      representations_in_context : SET [1:?] OF representation FOR context_of_items;
  END_ENTITY;

  ENTITY representation_context_reference;
      context_identifier : identifier;
   INVERSE
      representations_in_context : SET [1:?] OF representation_reference FOR context_of_items;
  END_ENTITY;

  ENTITY representation_item
    SUPERTYPE OF(ONEOF(binary_representation_item,
      compound_representation_item, 
      mapped_item, 
      value_representation_item));
      name : label;
    WHERE
      WR1: SIZEOF(using_representations(SELF)) > 0;
  END_ENTITY;

  ENTITY representation_item_relationship;
    name : label;
    description : OPTIONAL text;
    relating_representation_item : representation_item;
    related_representation_item : representation_item;
  END_ENTITY;

  ENTITY representation_map;
      mapping_origin        : representation_item;
      mapped_representation : representation;
    INVERSE
      map_usage : SET[1:?] OF mapped_item FOR mapping_source;
    WHERE
      WR1: item_in_context(mapping_origin, mapped_representation\representation.context_of_items);
  END_ENTITY;

  ENTITY representation_reference;
    id                                : identifier;
    context_of_items                  : representation_context_reference;
  END_ENTITY;

  ENTITY representation_relationship;
      name        : label;
      description : OPTIONAL text;
      rep_1        : representation_or_representation_reference;
      rep_2        : representation_or_representation_reference;
  END_ENTITY;

  ENTITY representation_relationship_with_transformation
    SUBTYPE OF (representation_relationship);
      transformation_operator : transformation;
    WHERE
      WR1: SELF\representation_relationship.rep_1.context_of_items
           :<>: SELF\representation_relationship.rep_2.context_of_items;
      WR2: NOT('REPRESENTATION_SCHEMA.ITEM_DEFINED_TRANSFORMATION' IN TYPEOF(transformation_operator)) OR
              (SELF\representation_relationship.rep_1 IN
               using_representations(transformation_operator\item_defined_transformation.transform_item_1)) AND
              (SELF\representation_relationship.rep_2 IN
               using_representations(transformation_operator\item_defined_transformation.transform_item_2));
  END_ENTITY;

  ENTITY uncertainty_assigned_representation
    SUBTYPE OF (representation);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY;

  ENTITY uncertainty_measure_with_unit
    SUBTYPE OF (measure_with_unit);
      name        : label;
      description : OPTIONAL text;
    WHERE
      WR1: valid_measure_value (SELF\measure_with_unit.value_component);
  END_ENTITY;

  ENTITY value_representation_item
    SUBTYPE OF (representation_item);
      value_component : measure_value;
    WHERE
      WR1: SIZEOF (QUERY (rep <* using_representations (SELF) |
        NOT ('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'
        IN TYPEOF (rep.context_of_items)
        ))) = 0;
  END_ENTITY;

  FUNCTION acyclic_mapped_representation
    (mi : mapped_item) : BOOLEAN;
    LOCAL
      rms : SET OF representation_map;
      mis : SET OF mapped_item;
      rs1, rs2 : SET OF representation;
    END_LOCAL;
 
    rs1 := using_representations(mi);
    rs2 := [];
    -- loop as long as there are elements in rs1
    REPEAT WHILE SIZEOF(rs1) > 0; 
      REPEAT i := 1 TO HIINDEX(rs1);
        -- Determine the set of representation_map that reference the parent_set
        rms := bag_to_set(USEDIN(rs1[i], 'REPRESENTATION_SCHEMA.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
        IF SIZEOF(rms) > 0 THEN
          REPEAT j := 1 TO HIINDEX(rms);
            mis := bag_to_set(USEDIN(rms[i], 'REPRESENTATION_SCHEMA.MAPPED_ITEM.MAPPING_SOURCE'));
            IF SIZEOF(mis) > 0 THEN
              REPEAT j := 1 TO HIINDEX(mis);
                -- check mis members for instance equal with mi. If so then there is a cycle
                IF mis[i] :=: mi THEN
                  RETURN (FALSE);
                END_IF;
                rs2 := rs2 + using_representations(mis[i]);
              END_REPEAT;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
      rs1 := rs2;
      rs2 := [];
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;  
  
  FUNCTION acyclic_representation_relationship
    (relation : representation_relationship; relatives : SET[1:?] OF representation; specific_relation : STRING) : BOOLEAN; 
    LOCAL
      x : SET OF representation_relationship;
    END_LOCAL;

    IF relation.rep_1 IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(r <* bag_to_set(USEDIN(relation.rep_1, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.' + 'REP_2')) | specific_relation IN TYPEOF(r));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_representation_relationship(x[i], relatives + relation.rep_1, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION; 

  FUNCTION get_representations_for_items(input : SET OF founded_item_select) : SET OF representation;
    LOCAL
      r_set : SET OF representation := [];
    END_LOCAL;
    REPEAT i := LOINDEX(input) TO HIINDEX(input);
        r_set := r_set + using_representations(input[i]);
    END_REPEAT;
    RETURN (r_set);
  END_FUNCTION;
  
  FUNCTION item_in_context
    (item  : representation_item;
     cntxt : representation_context) : BOOLEAN;
    LOCAL
      y : BAG OF representation_item;
    END_LOCAL;
    -- If there is one or more representation using both the item
    -- and cntxt return true.
    IF SIZEOF(USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS')
      * cntxt.representations_in_context) > 0 THEN
      RETURN (TRUE);
      -- Determine the bag of representation_items that reference
      -- item
      ELSE y := QUERY(z <* USEDIN (item , '') |
             'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
        -- Ensure that the bag is not empty
        IF SIZEOF(y) > 0 THEN
        -- For each element in the bag
        REPEAT i := 1 TO HIINDEX(y);
          -- Check to see it is an item in the input cntxt.
          IF item_in_context(y[i], cntxt) THEN
            RETURN (TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    -- Return false when all possible branches have been checked
    -- with no success.
    RETURN (FALSE);
  END_FUNCTION;

  FUNCTION using_items (item : founded_item_select;
                        checked_items: SET OF founded_item_select)
                      : SET OF founded_item_select;
    LOCAL
      new_check_items    : SET OF founded_item_select;
      result_items       : SET OF founded_item_select;
      next_items         : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    -- Find the set of representation_items or founded_items
    -- in which item is used directly.
    next_items := QUERY(z <* bag_to_set( USEDIN(item , '')) |
      ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
      ('REPRESENTATION_SCHEMA.FOUNDED_ITEM'        IN TYPEOF(z)));
    -- If the set of next_items is not empty;
    IF SIZEOF(next_items) > 0 THEN
      -- For each element in the set, find the using_items recursively
      REPEAT i := 1 TO HIINDEX(next_items);
        -- Check for loop in data model, i.e. one of the next_items
        -- occurred earlier in the set of check_items;
        IF NOT(next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] +
                          using_items(next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    -- return the set of representation_items or founded_items
    -- in which the input item is used directly and indirectly.
    RETURN (result_items);
  END_FUNCTION;

  FUNCTION using_representations (item : founded_item_select)
    : SET OF representation;
    LOCAL
      results            : SET OF representation;
      result_bag         : BAG OF representation;
      intermediate_items : SET OF founded_item_select;
    END_LOCAL;
    -- Find the representations in which the item is used and add to the
    -- results set.
    results := [];
    result_bag := USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag);
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    -- Find all representation_items or founded_items
    -- by which item is referenced directly or indirectly.
    intermediate_items := using_items(item,[]);
    -- If the set of intermediate items is not empty;
    IF SIZEOF(intermediate_items) > 0 THEN
      -- For each element in the set, add the
      -- representations of that element.
      REPEAT i := 1 TO HIINDEX(intermediate_items);
        result_bag := USEDIN(intermediate_items[i],
                      'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) > 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag);
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    -- Return the set of representation in which the input item is
    -- used directly and indirectly (through intervening
    -- representation_items or founded items).
    RETURN (results);
  END_FUNCTION;

  FUNCTION valid_measure_value
    (m : measure_value) : BOOLEAN;
    IF ('REAL' IN TYPEOF (m)) THEN
    RETURN (m > 0.0);
    ELSE
     IF ('INTEGER' IN TYPEOF (m)) THEN
      RETURN (m > 0);
      ELSE
        RETURN (TRUE);
      END_IF;
    END_IF;
  END_FUNCTION;

END_SCHEMA;


--
-- REQUIRED_RESOURCE_CHARACTERIZED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/required_resource_characterized/mim.exp)
--
(*
Id: mim.exp,v 1.15 2009/08/11 07:59:16 robbod Exp 
ISO TC184/SC4/WG12 N3122 - ISO/TS 10303-1280 Required resource characterized - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N2418
*) 


SCHEMA Required_resource_characterized_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method); 

USE FROM Approval_mim;    -- ISO/CD-TS 10303-1012

USE FROM Attribute_classification_mim;    -- ISO/TS 10303-1246

USE FROM Condition_mim;    -- ISO/TS 10303-1253

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM Justification_mim;    -- ISO/CD-TS 10303-1263

USE FROM Multi_linguism_mim;    -- ISO/TS 10303-1105

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Process_property_assignment_mim;    -- ISO/TS 10303-1040

USE FROM process_property_schema   -- ISO 10303-49
  (action_resource_requirement,
   action_resource_requirement_relationship); 

USE FROM Required_resource_mim;    -- ISO/CD-TS 10303-1267

USE FROM Requirement_assignment_mim;    -- ISO/CD-TS 10303-1233

USE FROM Resource_item_characterized_mim;    -- ISO/TS 10303-1281

USE FROM Resource_property_assignment_mim;    -- ISO/TS 10303-1273


TYPE required_resource_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (action_resource_requirement, 
    action_resource_requirement_relationship);
END_TYPE; 

TYPE required_resource_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_classification_item WITH 
   (action_resource_requirement, 
    action_resource_requirement_relationship);
END_TYPE; 

TYPE required_resource_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (action_resource_requirement, 
    action_resource_requirement_relationship);
END_TYPE; 

TYPE required_resource_condition_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON condition_action_method_items WITH 
   (action_method, 
    action_resource_requirement, 
    action_resource_requirement_relationship);
END_TYPE; 

TYPE required_resource_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (action_resource_requirement);
END_TYPE; 

TYPE required_resource_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (action_resource_requirement);
END_TYPE; 

TYPE required_resource_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (action_resource_requirement, 
    action_resource_requirement_relationship);
END_TYPE; 

TYPE required_resource_justification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON justification_item WITH 
   (action_method, 
    action_resource_requirement, 
    action_resource_requirement_relationship);
END_TYPE; 

TYPE required_resource_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (action_resource_requirement, 
    action_resource_requirement_relationship);
END_TYPE; 

TYPE required_resource_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (action_resource_requirement);
END_TYPE; 

TYPE required_resource_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (action_resource_requirement);
END_TYPE; 

TYPE required_resource_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
   (action_resource_requirement);
END_TYPE; 

END_SCHEMA;  -- Required_resource_characterized_mim



--
-- REQUIRED_RESOURCE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/required_resource/mim.exp)
--
(*
Id: mim.exp,v 1.18 2009/12/18 14:52:14 robbod Exp 
ISO TC184/SC4/WG12 N6069 - ISO/TS 10303-1267 Required resource - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N3119
*) 


SCHEMA Required_resource_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method); 

USE FROM Activity_method_assignment_mim;    -- ISO/TS 10303-1249

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM management_resources_schema   -- ISO 10303-41
  (action_method_assignment,
   action_method_role); 

USE FROM process_property_schema   -- ISO 10303-49
  (action_resource_requirement,
   action_resource_requirement_relationship,
   characterized_action_definition,
   characterized_resource_definition,
   requirement_for_action_resource,
   resource_property,
   resource_requirement_type); 

USE FROM Requirement_identification_and_version_mim;    -- ISO/TS 10303-1140

USE FROM Resource_item_mim;    -- ISO/TS 10303-1268

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


TYPE required_resource_classification_item = SELECT BASED_ON classification_item WITH 
   (action_method, 
    action_resource_requirement, 
    action_resource_requirement_relationship);
END_TYPE; 

END_SCHEMA;  -- Required_resource_mim


--
-- REQUIREMENT_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/requirement_assignment/mim.exp)
--
(*
Id: mim.exp,v 1.19 2009/08/11 07:59:44 robbod Exp 
ISO TC184/SC4/WG12 N6130 - ISO/TS 10303-1233 Requirement assignment - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N5486
*) 


SCHEMA Requirement_assignment_mim;

USE FROM group_schema   -- ISO 10303-41
  (group,
   group_relationship); 

USE FROM management_resources_schema   -- ISO 10303-41
  (group_assignment); 

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object); 

USE FROM Requirement_view_definition_mim;    -- ISO/TS 10303-1141


TYPE requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

TYPE requirement_satisfaction_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (requirement_assigned_item);
END_TYPE; 

TYPE requirement_source_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY assigned_requirement
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_assignment;
  items : SET[1:1] OF product_definition;
END_ENTITY;

ENTITY requirement_assigned_object
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_assignment;
  items : SET[1:1] OF requirement_assigned_item;
END_ENTITY;

ENTITY requirement_assignment
  SUBTYPE OF (characterized_object, group);
END_ENTITY;

ENTITY requirement_source
  SUBTYPE OF (group);
END_ENTITY;

ENTITY satisfied_requirement
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : satisfies_requirement;
  items : SET[1:1] OF product_definition;
END_ENTITY;

ENTITY satisfies_requirement
  SUBTYPE OF (group);
END_ENTITY;

ENTITY satisfying_item
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : satisfies_requirement;
  items : SET[1:1] OF requirement_satisfaction_item;
END_ENTITY;

ENTITY source_for_requirement
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_source;
  items : SET[1:1] OF requirement_source_item;
END_ENTITY;

ENTITY sourced_requirement
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_source;
  items : SET[1:1] OF product_definition;
END_ENTITY;

END_SCHEMA;  -- Requirement_assignment_mim




--
-- REQUIREMENT_IDENTIFICATION_AND_VERSION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/requirement_identification_and_version/mim.exp)
--
(*
Id: mim.exp,v 1.24 2009/04/28 20:57:20 mikeward Exp 
ISO TC184/SC4/WG12 N6585 - ISO/TS 10303-1140 Requirement identification and version - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N5945
*) 


SCHEMA Requirement_identification_and_version_mim;

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_category,
   product_definition_formation,
   product_related_product_category); 

USE FROM Product_version_relationship_mim;    -- ISO/TS 10303-1020


TYPE requirement_identification_and_version_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (product, 
    product_definition_formation);
END_TYPE; 

END_SCHEMA;  -- Requirement_identification_and_version_mim



--
-- REQUIREMENT_MANAGEMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/requirement_management/mim.exp)
--
(*
ISO TC184/SC4/WG3 N10782 - ISO/TS 10303-1348 Requirement management - EXPRESS MIM
Supersedes ISO TC184/SC4/WG3 N10352
*) 


SCHEMA Requirement_management_mim;

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Collection_identification_and_version_mim;    -- ISO/TS 10303-1396

USE FROM date_time_schema   -- ISO 10303-41
  (local_time); 

USE FROM Document_assignment_mim;    -- ISO/TS 10303-1122

USE FROM Document_properties_mim;    -- ISO/TS 10303-1126

USE FROM Effectivity_application_mim;    -- ISO/TS 10303-1059

USE FROM Identification_relationship_mim;    -- ISO/TS 10303-1398

USE FROM Information_rights_mim;    -- ISO/TS 10303-1241

USE FROM Property_as_definition_mim;    -- ISO/TS 10303-1399

USE FROM Requirement_assignment_mim;    -- ISO/TS 10303-1233

USE FROM Requirement_view_definition_relationship_mim;    -- ISO/TS 10303-1142

USE FROM systems_engineering_representation_schema   -- ISO 10303-61
  (representation_proxy_item,
   representation_proxy_select); 

TYPE requirement_approval_scope_item = SELECT BASED_ON approval_scope_item WITH
  (executed_action);
END_TYPE;

TYPE requirement_certification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON certification_item WITH 
   (product, 
    product_definition_formation);
END_TYPE; 

TYPE requirement_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (address, 
    applied_approval_assignment, 
    applied_certification_assignment, 
    applied_contract_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_effectivity_assignment, 
    applied_event_occurrence_assignment, 
    applied_external_identification_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_organizational_project_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    applied_usage_right, 
    approval, 
    approval_person_organization, 
    approval_relationship, 
    approval_status, 
    attribute_language_assignment, 
    calendar_date, 
    certification, 
    class, 
    contract, 
    contract_relationship, 
    date_and_time, 
    date_and_time_assignment, 
    date_assignment, 
    derived_unit, 
    document_file, 
    effectivity, 
    effectivity_relationship, 
    event_occurrence, 
    event_occurrence_relationship, 
    general_property, 
    general_property_relationship, 
    information_right, 
    information_usage_right, 
    language, 
    local_time, 
    measure_with_unit, 
    multi_language_attribute_assignment, 
    named_unit, 
    organization, 
    organization_relationship, 
    organizational_project, 
    organizational_project_relationship, 
    person, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    representation_context, 
    representation_item, 
    requirement_assignment, 
    requirement_source, 
    security_classification, 
    time_interval_relationship, 
    usage_association);
END_TYPE; 

TYPE requirement_collection_assignment_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON collection_assignment_groupable_item WITH 
   (contract, 
    organization, 
    organizational_project, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE requirement_collection_membership_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON collection_membership_groupable_item WITH 
   (address, 
    applied_approval_assignment, 
    applied_certification_assignment, 
    applied_classification_assignment, 
    applied_contract_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_effectivity_assignment, 
    applied_event_occurrence_assignment, 
    applied_external_identification_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_organizational_project_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    applied_usage_right, 
    approval, 
    approval_person_organization, 
    approval_relationship, 
    approval_status, 
    attribute_language_assignment, 
    calendar_date, 
    certification, 
    class, 
    collection_assignment, 
    collection_membership, 
    contract, 
    contract_relationship, 
    coordinated_universal_time_offset, 
    date_and_time, 
    date_and_time_assignment, 
    date_assignment, 
    derived_unit, 
    derived_unit_element, 
    document_file, 
    effectivity, 
    effectivity_relationship, 
    event_occurrence, 
    event_occurrence_relationship, 
    external_source, 
    general_property, 
    general_property_relationship, 
    identification_assignment_relationship, 
    information_right, 
    information_usage_right, 
    language, 
    local_time, 
    measure_with_unit, 
    multi_language_attribute_assignment, 
    named_unit, 
    organization, 
    organization_relationship, 
    organizational_project, 
    organizational_project_relationship, 
    person, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    product_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    representation_context, 
    representation_item, 
    representation_relationship, 
    requirement_assignment, 
    requirement_source,
    satisfies_requirement, 
    security_classification, 
    time_interval, 
    time_interval_relationship, 
    usage_association);
END_TYPE; 

TYPE requirement_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH 
   (organizational_project, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    requirement_assignment, 
    requirement_source, 
    security_classification);
END_TYPE; 

TYPE requirement_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (applied_approval_assignment, 
    applied_certification_assignment, 
    applied_contract_assignment, 
    applied_effectivity_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    approval, 
    certification, 
    contract, 
    contract_relationship, 
    effectivity, 
    general_property, 
    general_property_relationship, 
    information_right, 
    information_usage_right, 
    organization, 
    organizational_project, 
    person, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    representation_item, 
    requirement_assignment, 
    requirement_source, 
    security_classification);
END_TYPE; 

TYPE requirement_effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON effectivity_item WITH 
   (applied_approval_assignment, 
    applied_certification_assignment, 
    applied_contract_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_effectivity_assignment, 
    applied_external_identification_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_organizational_project_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    applied_usage_right, 
    date_and_time_assignment, 
    date_assignment, 
    document_file, 
    multi_language_attribute_assignment, 
    organization_relationship, 
    organizational_address, 
    person_and_organization, 
    person_and_organization_address,
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    requirement_assignment, 
    requirement_source);
END_TYPE; 

TYPE requirement_event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON event_occurrence_item WITH 
   (certification, 
    organizational_project);
END_TYPE; 

TYPE requirement_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
   (address, 
    applied_external_identification_assignment, 
    approval, 
    approval_status, 
    attribute_language_assignment, 
    calendar_date, 
    certification, 
    contract, 
    coordinated_universal_time_offset, 
    date_and_time, 
    derived_unit, 
    derived_unit_element, 
    event_occurrence, 
    external_source, 
    general_property, 
    information_right, 
    information_usage_right, 
    language, 
    local_time, 
    measure_with_unit, 
    named_unit, 
    organization, 
    person, 
    product_definition_context, 
    representation_context, 
    requirement_source, 
    security_classification, 
    time_interval, 
    usage_association);
END_TYPE; 

TYPE requirement_ir_usage_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH 
   (applied_certification_assignment, 
    applied_security_classification_assignment, 
    applied_usage_right, 
    certification, 
    document_file, 
    product, 
    product_definition, 
    product_definition_formation, 
    requirement_assignment, 
    security_classification);
END_TYPE; 

TYPE requirement_mri_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_approval_item WITH 
   (applied_certification_assignment, 
    applied_classification_assignment, 
    applied_contract_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_effectivity_assignment, 
    applied_event_occurrence_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_organizational_project_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    date_and_time_assignment, 
    date_assignment, 
    organization_relationship, 
    organizational_address, 
    organizational_project, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    requirement_assignment, 
    requirement_source, 
    security_classification);
END_TYPE; 

TYPE requirement_mri_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_attribute_language_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    event_occurrence, 
    general_property, 
    general_property_relationship, 
    information_right, 
    information_usage_right, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    representation_item, 
    requirement_assignment, 
    requirement_source);
END_TYPE; 

TYPE requirement_mri_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_and_time_item WITH 
   (applied_certification_assignment, 
    applied_classification_assignment, 
    applied_contract_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_effectivity_assignment, 
    applied_event_occurrence_assignment, 
    applied_identification_assignment, 
    applied_organizational_project_assignment, 
    applied_usage_right, 
    approval, 
    date_and_time_assignment, 
    date_assignment, 
    document_file, 
    effectivity, 
    general_property, 
    general_property_relationship, 
    organization_relationship, 
    organizational_address, 
    organizational_project, 
    person, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    requirement_assignment, 
    requirement_source);
END_TYPE; 

TYPE requirement_mri_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_item WITH 
   (applied_certification_assignment, 
    applied_classification_assignment, 
    applied_contract_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_effectivity_assignment, 
    applied_event_occurrence_assignment, 
    applied_identification_assignment, 
    applied_organizational_project_assignment, 
    applied_usage_right, 
    approval, 
    date_and_time_assignment, 
    date_assignment, 
    document_file, 
    effectivity, 
    general_property, 
    general_property_relationship, 
    organization_relationship, 
    organizational_address, 
    organizational_project, 
    person, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    requirement_assignment, 
    requirement_source);
END_TYPE; 

TYPE requirement_mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_identification_item WITH 
   (address, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    approval, 
    certification, 
    document_file, 
    effectivity, 
    event_occurrence, 
    general_property, 
    general_property_relationship, 
    information_right, 
    information_usage_right, 
    organizational_project, 
    person, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    requirement_assignment, 
    requirement_source);
END_TYPE; 

TYPE requirement_mri_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_multi_language_attribute_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    event_occurrence, 
    general_property, 
    general_property_relationship, 
    information_right, 
    information_usage_right, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    representation_item, 
    requirement_assignment, 
    requirement_source);
END_TYPE; 

TYPE requirement_mri_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_organization_item WITH 
   (applied_certification_assignment, 
    applied_classification_assignment, 
    applied_contract_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_effectivity_assignment, 
    applied_event_occurrence_assignment, 
    applied_organization_assignment, 
    applied_organizational_project_assignment, 
    applied_person_and_organization_assignment, 
    approval, 
    certification, 
    date_and_time_assignment, 
    date_assignment, 
    document_file, 
    effectivity, 
    event_occurrence, 
    general_property, 
    general_property_relationship, 
    organizational_address, 
    organizational_project, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    requirement_assignment, 
    requirement_source, 
    security_classification);
END_TYPE; 

TYPE requirement_mri_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_person_and_organization_item WITH 
   (applied_certification_assignment, 
    applied_classification_assignment, 
    applied_contract_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_effectivity_assignment, 
    applied_event_occurrence_assignment, 
    applied_organization_assignment, 
    applied_organizational_project_assignment, 
    applied_person_and_organization_assignment, 
    approval, 
    certification, 
    date_and_time_assignment, 
    date_assignment, 
    document_file, 
    effectivity, 
    event_occurrence, 
    general_property, 
    general_property_relationship, 
    organizational_address, 
    organizational_project, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    requirement_assignment, 
    requirement_source, 
    security_classification);
END_TYPE; 

TYPE requirement_project_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON project_item WITH 
   (product, 
    product_definition_formation);
END_TYPE; 

TYPE requirement_representation_proxy_select = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON representation_proxy_select WITH 
   (product_definition_formation);
END_TYPE; 

TYPE requirement_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    document_file, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    requirement_assignment, 
    requirement_source);
END_TYPE; 

TYPE rm_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
   (product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE rm_requirement_source_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_source_item WITH 
   (product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

END_SCHEMA;  -- Requirement_management_mim


--
-- REQUIREMENT_VIEW_DEFINITION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/requirement_view_definition/mim.exp)
--
(*
Id: mim.exp,v 1.15 2012/11/09 21:40:58 thomasrthurman Exp 
ISO TC184/SC4/WG12 N8296 - ISO/TS 10303-1141 Requirement view definition - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6843
*) 


SCHEMA Requirement_view_definition_mim;

USE FROM Property_as_definition_mim; -- ISO/TS 10303-1399
USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019

USE FROM Requirement_identification_and_version_mim;    -- ISO/TS 10303-1140


END_SCHEMA;  -- Requirement_view_definition_mim


--
-- REQUIREMENT_VIEW_DEFINITION_RELATIONSHIP_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/requirement_view_definition_relationship/mim.exp)
--
(*
 $Id: mim.exp,v 1.16 2014/02/13 15:32:01 thomasrthurman Exp 
 ISO TC184/SC4/WG12 N8446 - ISO/TS 10303-1142 Requirement view definition relationship - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N6133
*)


SCHEMA Requirement_view_definition_relationship_mim;

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041
USE FROM Requirement_view_definition_mim;    -- ISO/TS 10303-1141

  ENTITY requirement_view_definition_relationship
    SUBTYPE OF ( product_definition_relationship );
  END_ENTITY;

END_SCHEMA;  -- Requirement_view_definition_relationship_mim



--
-- RESOURCE_AS_REALIZED_CHARACTERIZED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/resource_as_realized_characterized/mim.exp)
--
(*
Id: mim.exp,v 1.19 2009/12/18 14:52:16 robbod Exp 
ISO TC184/SC4/WG12 N5903 - ISO/TS 10303-1283 Resource as realized characterized - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N4898
*) 


SCHEMA Resource_as_realized_characterized_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method,
   action_resource,
   action_resource_relationship); 

USE FROM Approval_mim;    -- ISO/TS 10303-1012

USE FROM Attribute_classification_mim;    -- ISO/TS 10303-1246

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM Justification_mim;    -- ISO/TS 10303-1263

USE FROM Multi_linguism_mim;    -- ISO/TS 10303-1105

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Process_property_assignment_mim;    -- ISO/TS 10303-1040

USE FROM Resource_as_realized_mim;    -- ISO/TS 10303-1269

USE FROM Resource_management_characterized_mim;    -- ISO/TS 10303-1282

USE FROM Resource_property_assignment_mim;    -- ISO/TS 10303-1273

USE FROM State_definition_mim;    -- ISO/TS 10303-1255

USE FROM State_observed_mim;    -- ISO/TS 10303-1256


TYPE resource_as_realized_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (action_resource);
END_TYPE; 

TYPE resource_as_realized_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_classification_item WITH 
   (action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_as_realized_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_as_realized_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (action_resource);
END_TYPE; 

TYPE resource_as_realized_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (action_resource);
END_TYPE; 

TYPE resource_as_realized_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (action_resource);
END_TYPE; 

TYPE resource_as_realized_justification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON justification_item WITH 
   (action_resource);
END_TYPE; 

TYPE resource_as_realized_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_as_realized_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (action_resource);
END_TYPE; 

TYPE resource_as_realized_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (action_resource);
END_TYPE; 

TYPE resource_as_realized_state_observed_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_observed_of_item WITH 
   (action_method, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_as_realized_state_type_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_type_of_item WITH 
   (action_method, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

END_SCHEMA;  -- Resource_as_realized_characterized_mim



--
-- RESOURCE_AS_REALIZED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/resource_as_realized/mim.exp)
--
(*
Id: mim.exp,v 1.12 2009/03/02 18:20:08 mikeward Exp
ISO TC184/SC4/WG12 N6074 - ISO/TS 10303-1269 Resource as realized - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N3140
*) 


SCHEMA Resource_as_realized_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method,
   action_resource,
   action_resource_relationship,
   supported_item); 

USE FROM Activity_method_assignment_mim;    -- ISO/TS 10303-1249

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Required_resource_mim;    -- ISO/CD-TS 10303-1267

USE FROM Resource_item_mim;    -- ISO/CD-TS 10303-1268

USE FROM Resource_management_mim;    -- ISO/CD-TS 10303-1266

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


TYPE resource_as_realized_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (action_method, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

END_SCHEMA;  -- Resource_as_realized_mim


--
-- RESOURCE_ITEM_CHARACTERIZED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/resource_item_characterized/mim.exp)
--
(*
Id: mim.exp,v 1.19 2009/12/18 14:52:16 robbod Exp 
ISO TC184/SC4/WG12 N6991 - ISO/TS 10303-1281 Resource item characterized - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N5906
*) 


SCHEMA Resource_item_characterized_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method,
   action_resource,
   action_resource_relationship); 

USE FROM Ap239_properties_mim;    -- ISO/TS 10303-1295

USE FROM Approval_mim;    -- ISO/TS 10303-1012

USE FROM Attribute_classification_mim;    -- ISO/TS 10303-1246

USE FROM Certification_mim;    -- ISO/TS 10303-1044

USE FROM Condition_mim;    -- ISO/TS 10303-1253

USE FROM Contract_mim;    -- ISO/TS 10303-1062

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Document_assignment_mim;    -- ISO/TS 10303-1122

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM Justification_mim;    -- ISO/TS 10303-1263

USE FROM Multi_linguism_mim;    -- ISO/TS 10303-1105

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Process_property_assignment_mim;    -- ISO/TS 10303-1040

USE FROM Resource_item_mim;    -- ISO/TS 10303-1268

USE FROM Resource_property_assignment_mim;    -- ISO/TS 10303-1273

USE FROM Security_classification_mim;    -- ISO/TS 10303-1015

USE FROM State_definition_mim;    -- ISO/TS 10303-1255

USE FROM State_observed_mim;    -- ISO/TS 10303-1256

REFERENCE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014


TYPE resource_item_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (action_method, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_item_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_classification_item WITH 
   (action_method, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_item_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (action_method, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_item_certification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON certification_item WITH 
   (action_resource);
END_TYPE; 

TYPE resource_item_condition_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON condition_action_method_items WITH 
   (action_method, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_item_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH 
   (action_resource);
END_TYPE; 

TYPE resource_item_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (action_method, 
    action_resource);
END_TYPE; 

TYPE resource_item_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (action_method, 
    action_resource);
END_TYPE; 

TYPE resource_item_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (action_resource);
END_TYPE; 

TYPE resource_item_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (action_resource);
END_TYPE; 

TYPE resource_item_justification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON justification_item WITH 
   (action_method, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_item_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (action_method, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_item_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (action_method, 
    action_resource);
END_TYPE; 

TYPE resource_item_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (action_method, 
    action_resource);
END_TYPE; 

TYPE resource_item_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH 
   (action_resource);
END_TYPE; 

TYPE resource_item_state_observed_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_observed_of_item WITH 
   (action_method, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_item_state_type_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_type_of_item WITH 
   (action_method, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

END_SCHEMA;  -- Resource_item_characterized_mim


--
-- RESOURCE_ITEM_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/resource_item/mim.exp)
--
(*
Id: mim.exp,v 1.15 2009/08/11 08:00:57 robbod Exp 
ISO TC184/SC4/WG12 N6079 - ISO/TS 10303-1268 Resource item - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N3146
*) 


SCHEMA Resource_item_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method,
   action_resource,
   action_resource_relationship,
   action_resource_type,
   supported_item); 

USE FROM Activity_method_assignment_mim;    -- ISO/TS 10303-1249

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM management_resources_schema   -- ISO 10303-41
  (action_method_assignment,
   action_method_role); 

USE FROM process_property_representation_schema   -- ISO 10303-49
  (resource_property_representation); 

USE FROM process_property_schema   -- ISO 10303-49
  (characterized_resource_definition,
   resource_property); 

USE FROM representation_schema   -- ISO 10303-43
  (representation,
   representation_context,
   representation_item,
   value_representation_item); 

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


TYPE resource_item_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (action_method, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

END_SCHEMA;  -- Resource_item_mim


--
-- RESOURCE_MANAGEMENT_CHARACTERIZED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/resource_management_characterized/mim.exp)
--
(*
Id: mim.exp,v 1.20 2009/04/29 08:45:27 mikeward Exp 
ISO TC184/SC4/WG12 N6594 - ISO/TS 10303-1282 Resource management characterized - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N5909
*) 


SCHEMA Resource_management_characterized_mim;

USE FROM action_schema   -- ISO 10303-41
  (action,
   action_relationship,
   action_resource,
   action_resource_relationship); 

USE FROM Approval_mim;    -- ISO/CD-TS 10303-1012

USE FROM Attribute_classification_mim;    -- ISO/TS 10303-1246

USE FROM Condition_mim;    -- ISO/TS 10303-1253

USE FROM Contract_mim;    -- ISO/CD-TS 10303-1062

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Document_assignment_mim;    -- ISO/TS 10303-1122

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM Justification_mim;    -- ISO/CD-TS 10303-1263

USE FROM Multi_linguism_mim;    -- ISO/TS 10303-1105

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Process_property_assignment_mim;    -- ISO/TS 10303-1040

USE FROM process_property_schema   -- ISO 10303-49
  (action_property); 

USE FROM Required_resource_characterized_mim;    -- ISO/CD-TS 10303-1280

USE FROM Resource_management_mim;    -- ISO/CD-TS 10303-1266

USE FROM Resource_property_assignment_mim;    -- ISO/TS 10303-1273

USE FROM State_definition_mim;    -- ISO/TS 10303-1255

USE FROM State_observed_mim;    -- ISO/TS 10303-1256


TYPE resource_management_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (action, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_management_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_classification_item WITH 
   (action, 
    action_property, 
    action_relationship, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_management_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (action, 
    action_property, 
    action_relationship, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_management_characterized_state_observed_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_observed_of_item WITH 
   (action, 
    action_property, 
    action_relationship);
END_TYPE; 

TYPE resource_management_characterized_state_type_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_type_of_item WITH 
   (action, 
    action_property, 
    action_relationship);
END_TYPE; 

TYPE resource_management_condition_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON condition_action_method_items WITH 
   (action, 
    action_relationship, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_management_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH 
   (action, 
    action_resource);
END_TYPE; 

TYPE resource_management_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (action, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_management_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (action, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_management_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (action);
END_TYPE; 

TYPE resource_management_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (action, 
    action_resource);
END_TYPE; 

TYPE resource_management_justification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON justification_item WITH 
   (action, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_management_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (action, 
    action_property, 
    action_relationship, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_management_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (action, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_management_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (action, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

END_SCHEMA;  -- Resource_management_characterized_mim



--
-- RESOURCE_MANAGEMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/resource_management/mim.exp)
--
(*
Id: mim.exp,v 1.14 2009/08/11 08:01:29 robbod Exp 
ISO TC184/SC4/WG12 N6082 - ISO/TS 10303-1266 Resource management - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N3152
*) 


SCHEMA Resource_management_mim;

USE FROM action_schema   -- ISO 10303-41
  (action,
   action_method,
   action_relationship,
   action_resource,
   action_resource_relationship,
   supported_item); 

USE FROM Activity_method_assignment_mim;    -- ISO/TS 10303-1249

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Location_assignment_mim;    -- ISO/TS 10303-1277

USE FROM process_property_representation_schema   -- ISO 10303-49
  (action_property_representation); 

USE FROM process_property_schema   -- ISO 10303-49
  (action_property,
   characterized_action_definition); 

USE FROM Required_resource_mim;    -- ISO/CD-TS 10303-1267

USE FROM Resource_item_mim;    -- ISO/CD-TS 10303-1268

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


TYPE resource_management_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (action, 
    action_property, 
    action_relationship, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

TYPE resource_management_location_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON location_item WITH 
   (action_resource);
END_TYPE; 

END_SCHEMA;  -- Resource_management_mim


--
-- RESOURCE_PROPERTY_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/resource_property_assignment/mim.exp)
--
(*
 $Id: mim.exp,v 1.3 2004/11/19 21:37:41 robbod Exp 
 ISO TC184/SC4/WG12 N3158 - ISO/TS 10303-1273 Resource property assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2439
*) 


SCHEMA Resource_property_assignment_mim;

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Independent_property_mim;    -- ISO/TS 10303-1036

USE FROM process_property_representation_schema   -- ISO 10303-49
  (resource_property_representation); 

USE FROM process_property_schema   -- ISO 10303-49
  (characterized_resource_definition,
   resource_property); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (derived_property_select,
   general_property_association); 


END_SCHEMA;  -- Resource_property_assignment_mim


--
-- RETENTION_PERIOD_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/retention_period/mim.exp)
--
(*
   ISO TC184/SC4/WG12 N10805 - ISO/TS 10303-1852 Retention period - EXPRESS MIM
*)
SCHEMA Retention_period_mim;

USE FROM Activity_mim;    -- ISO/TS 10303-1047

USE FROM Event_assignment_mim;    -- ISO/TS 10303-1364

USE FROM Time_interval_assignment_mim;    -- ISO/TS 10303-1065

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054

ENTITY retention
SUBTYPE OF (action);
WHERE
  WR1:  SIZEOF( QUERY( aa <* USEDIN(SELF,'MANAGEMENT_RESOURCES_SCHEMA.' +
           'ACTION_ASSIGNMENT.ASSIGNED_ACTION') |
               ('ACTIVITY_MIM.APPLIED_ACTION_ASSIGNMENT' IN
                TYPEOF(aa)) AND
               (aa.role.name = 'retention')
              )) >= 1;
  WR2:  (SIZEOF( QUERY( atia <* USEDIN(SELF,'TIME_INTERVAL_ASSIGNMENT_MIM.' +
     'APPLIED_TIME_INTERVAL_ASSIGNMENT.ITEMS') |
                        (atia.role.name = 'minimum retention period')
                       )) = 1) AND
                     (SIZEOF( QUERY( atia <* USEDIN(SELF,'TIME_INTERVAL_ASSIGNMENT_MIM.' +
     'APPLIED_TIME_INTERVAL_ASSIGNMENT.ITEMS') |
                        (atia.role.name = 'maximum retention period')
                       )) = 1) AND
                     (SIZEOF( QUERY( atia1 <* USEDIN(SELF,'TIME_INTERVAL_ASSIGNMENT_MIM.' +
     'APPLIED_TIME_INTERVAL_ASSIGNMENT.ITEMS') |
                       (atia1.role.name = 'minimum retention period') AND
                       ('DATE_TIME_SCHEMA.TIME_INTERVAL_WITH_BOUNDS' IN
                        TYPEOF(atia1.assigned_time_interval)) AND
                       (EXISTS(atia1.assigned_time_interval\time_interval_with_bounds.secondary_bound) OR
                        EXISTS(atia1.assigned_time_interval\time_interval_with_bounds.duration)) AND
                       (SIZEOF( QUERY( atia2 <* USEDIN(SELF,'TIME_INTERVAL_ASSIGNMENT_MIM.' +
       'APPLIED_TIME_INTERVAL_ASSIGNMENT.ITEMS') |
 (atia2.role.name = 'maximum retention period') AND
 ('DATE_TIME_SCHEMA.TIME_INTERVAL_WITH_BOUNDS' IN
  TYPEOF(atia2.assigned_time_interval)) AND
 (EXISTS(atia2.assigned_time_interval\time_interval_with_bounds.secondary_bound) OR
  EXISTS(atia2.assigned_time_interval\time_interval_with_bounds.duration)) AND
 (atia1.assigned_time_interval\time_interval_with_bounds.primary_bound :=:
  atia2.assigned_time_interval\time_interval_with_bounds.primary_bound)
)) = 1)
                       )) = 1);

  WR3:  SIZEOF( USEDIN(SELF,'ACTION_SCHEMA.' +
                      'ACTION_RELATIONSHIP.RELATING_ACTION')) +
              SIZEOF( USEDIN(SELF,'ACTION_SCHEMA.' +
                      'ACTION_RELATIONSHIP.RELATED_ACTION')) = 0;
END_ENTITY;

END_SCHEMA; -- Retention_period_mim



--
-- RISK_DEFINITION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/risk_definition/mim.exp)
--
(*
ISO TC184/SC4/WG12 N7134 - ISO/TS 10303-1786 Risk definition - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6837
*) 


SCHEMA Risk_definition_mim;

USE FROM Activity_method_assignment_mim;    -- ISO/TS 10303-1249

USE FROM Probability_distribution_mim;    -- ISO/TS 10303-1274

USE FROM Process_property_assignment_mim;    -- ISO/TS 10303-1040

USE FROM Product_relationship_mim;    -- ISO/TS 10303-1024

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

USE FROM risk_schema;    -- ISO 10303-58


TYPE risk_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH 
   (risk_perception);
END_TYPE; 

ENTITY risk_event
  SUBTYPE OF (applied_action_method_assignment);
  SELF\applied_action_method_assignment.items : SET[1:1] OF risk_perception;
WHERE
  WR1: SELF\action_method_assignment.role.name = 'risk of event';
END_ENTITY;

END_SCHEMA;  -- Risk_definition_mim


--
-- RISK_MANAGEMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/risk_management/mim.exp)
--
(*
ISO TC184/SC4/WG3 N10790 - ISO/TS 10303-1467 Risk management - EXPRESS MIM
Supersedes ISO TC184/SC4/WG3 N2756
*) 


SCHEMA Risk_management_mim;

USE FROM Approval_mim;    -- ISO/TS 10303-1012

USE FROM Collection_identification_and_version_mim;    -- ISO/TS 10303-1396

USE FROM Condition_mim;    -- ISO/TS 10303-1253

USE FROM date_time_schema   -- ISO 10303-41
  (local_time); 

USE FROM Document_assignment_mim;    -- ISO/TS 10303-1122

USE FROM Identification_relationship_mim;    -- ISO/TS 10303-1398

USE FROM Justification_mim;    -- ISO/TS 10303-1263

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Resource_item_mim;    -- ISO/TS 10303-1268

USE FROM Risk_definition_mim;    -- ISO/TS 10303-1786

USE FROM state_type_schema   -- ISO 10303-56
  (state_type_role); 


TYPE rm_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH 
   (action_method, 
    action_resource, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    approval, 
    ascribable_state, 
    document_file, 
    executed_action, 
    general_property, 
    organization, 
    person, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    risk_impact_assignment, 
    risk_perception_source_assignment, 
    state_observed, 
    state_observed_assignment, 
    state_observed_relationship);
END_TYPE; 

TYPE rm_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH 
   (action_method, 
    action_resource, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    applied_approval_assignment, 
    date_and_time_assignment, 
    date_assignment, 
    document_file, 
    executed_action, 
    organization, 
    person, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    risk_impact_assignment, 
    risk_perception_source_assignment, 
    state_observed_relationship, 
    state_type);
END_TYPE; 

TYPE rm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (action_method, 
    action_method_relationship, 
    action_resource, 
    action_resource_relationship, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    applied_classification_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    ascribable_state, 
    assumption, 
    date_and_time_assignment, 
    date_assignment, 
    executed_action, 
    general_property, 
    general_property_relationship, 
    identification_assignment_relationship, 
    justification_assignment, 
    justification_group_assignment, 
    justification_item_group_assignment, 
    justification_support_assignment, 
    justification_support_item_group_assignment, 
    organization_relationship, 
    organizational_address, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    product_relationship, 
    property_definition, 
    risk_impact_assignment, 
    risk_perception_source_assignment, 
    state_observed_assignment, 
    state_observed_relationship, 
    state_type, 
    state_type_assignment, 
    state_type_relationship);
END_TYPE; 

TYPE rm_approval_scope_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_scope_item WITH 
   (executed_action);
END_TYPE; 

TYPE rm_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (action_method, 
    action_method_relationship, 
    action_relationship, 
    action_resource, 
    action_resource_relationship, 
    applied_action_assignment,
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_identification_assignment, 
    approval, 
    approval_relationship, 
    approval_status, 
    ascribable_state, 
    assumption, 
    date_and_time_assignment, 
    date_assignment, 
    executed_action, 
    general_property, 
    general_property_relationship, 
    justification_assignment, 
    justification_group_assignment, 
    justification_item_group_assignment, 
    justification_support_assignment, 
    justification_support_item_group_assignment, 
    organization_relationship, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_relationship, 
    property_definition, 
    risk_impact_assignment, 
    risk_perception_source_assignment, 
    state_observed, 
    state_observed_relationship, 
    state_type,
    state_type_relationship);
END_TYPE;

TYPE rm_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (action_method, 
    action_method_relationship, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    document_file, 
    executed_action, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_relationship, 
    property_definition, 
    risk_impact_assignment, 
    risk_perception_relationship, 
    risk_perception_source_assignment);
END_TYPE; 

TYPE rm_collection_assignment_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON collection_assignment_groupable_item WITH 
   (action_method, 
    executed_action, 
    organization, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE rm_collection_membership_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON collection_membership_groupable_item WITH 
   (action_method, 
    action_method_relationship, 
    action_relationship, 
    action_resource, 
    action_resource_relationship, 
    action_status, 
    address, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    applied_approval_assignment, 
    applied_classification_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval, 
    approval_person_organization, 
    approval_relationship, 
    approval_status, 
    ascribable_state, 
    ascribable_state_relationship, 
    calendar_date, 
    class, 
    collection_assignment, 
    collection_membership, 
    coordinated_universal_time_offset, 
    date_and_time, 
    date_and_time_assignment, 
    date_assignment, 
    derived_unit, 
    derived_unit_element, 
    document_file, 
    executed_action, 
    external_source, 
    general_property, 
    general_property_relationship, 
    identification_assignment_relationship, 
    justification_assignment, 
    justification_group_assignment, 
    justification_item_group_assignment, 
    justification_support_assignment, 
    justification_support_item_group_assignment, 
    local_time, 
    measure_with_unit, 
    named_unit, 
    organization, 
    organization_relationship, 
    person, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    product_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    representation_context, 
    representation_item, 
    representation_relationship, 
    risk_impact_assignment, 
    risk_perception_source_assignment, 
    state_observed, 
    state_observed_assignment, 
    state_observed_relationship, 
    state_observed_role, 
    state_type, 
    state_type_assignment, 
    state_type_relationship, 
    state_type_role);
END_TYPE; 

TYPE rm_condition_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON condition_action_method_items WITH 
   (action_method, 
    action_resource, 
    action_resource_relationship, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    applied_approval_assignment, 
    applied_classification_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval, 
    ascribable_state, 
    calendar_date, 
    date_and_time, 
    date_and_time_assignment, 
    date_assignment, 
    executed_action, 
    general_property, 
    justification_assignment, 
    justification_group_assignment, 
    justification_item_group_assignment, 
    organization, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    state_observed, 
    state_type, 
    state_type_relationship);
END_TYPE; 

TYPE rm_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (action_method, 
    action_method_relationship, 
    action_relationship, 
    action_resource, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    applied_classification_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval, 
    approval_person_organization, 
    ascribable_state, 
    date_and_time_assignment, 
    date_assignment, 
    document_file, 
    executed_action, 
    general_property, 
    general_property_relationship, 
    identification_assignment_relationship, 
    justification_assignment, 
    justification_group_assignment, 
    justification_item_group_assignment, 
    justification_support_assignment, 
    justification_support_item_group_assignment, 
    organization_relationship, 
    organizational_address, 
    person, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    risk_impact_assignment, 
    risk_perception_relationship, 
    risk_perception_source_assignment, 
    state_observed, 
    state_observed_assignment, 
    state_observed_relationship, 
    state_type, 
    state_type_assignment, 
    state_type_relationship);
END_TYPE; 

TYPE rm_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (action_method, 
    action_method_relationship, 
    action_relationship, 
    action_resource, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    applied_classification_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval, 
    approval_person_organization, 
    ascribable_state, 
    date_and_time_assignment, 
    date_assignment, 
    document_file, 
    executed_action, 
    general_property, 
    general_property_relationship, 
    identification_assignment_relationship, 
    justification_assignment, 
    justification_group_assignment, 
    justification_item_group_assignment, 
    justification_support_assignment, 
    justification_support_item_group_assignment, 
    organization_relationship, 
    organizational_address, 
    person, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    risk_impact_assignment, 
    risk_perception_relationship, 
    risk_perception_source_assignment, 
    state_observed, 
    state_observed_assignment, 
    state_observed_relationship, 
    state_type, 
    state_type_assignment, 
    state_type_relationship);
END_TYPE; 

TYPE rm_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (action_method, 
    action_method_relationship, 
    action_relationship, 
    action_resource, 
    action_resource_relationship, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    applied_approval_assignment, 
    applied_classification_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval, 
    ascribable_state, 
    assumption_assignment, 
    assumption_relationship, 
    class, 
    executed_action, 
    general_property, 
    general_property_relationship, 
    item_assumed, 
    justification_assignment, 
    justification_group_assignment, 
    justification_item_group_assignment, 
    justification_support_assignment, 
    justification_support_item_group_assignment, 
    organization, 
    organization_relationship, 
    organizational_address, 
    person, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    product_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    representation_item, 
    risk_impact_assignment, 
    risk_perception_source_assignment, 
    state_observed, 
    state_type, 
    state_type_relationship);
END_TYPE; 

TYPE rm_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
   (action_method, 
    action_resource, 
    action_status, 
    address, 
    applied_action_method_assignment, 
    applied_external_identification_assignment, 
    approval, 
    approval_status, 
    ascribable_state, 
    calendar_date, 
    coordinated_universal_time_offset, 
    date_and_time, 
    derived_unit, 
    derived_unit_element, 
    executed_action, 
    external_source, 
    general_property, 
    item_assumed, 
    local_time, 
    measure_with_unit, 
    named_unit, 
    organization, 
    person, 
    product, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    representation_context, 
    state_observed, 
    state_observed_role, 
    state_type, 
    state_type_role);
END_TYPE; 

TYPE rm_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (action_method, 
    action_method_relationship, 
    action_relationship, 
    action_resource, 
    address, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval, 
    approval_status, 
    ascribable_state, 
    ascribable_state_relationship, 
    class, 
    document_file, 
    executed_action, 
    general_property, 
    general_property_relationship, 
    identification_assignment_relationship, 
    justification_assignment, 
    justification_group_assignment, 
    justification_item_group_assignment, 
    justification_support_assignment, 
    justification_support_item_group_assignment, 
    organization, 
    person, 
    person_and_organization, 
    product, 
    product_definition_formation, 
    product_definition_relationship, 
    product_relationship, 
    property_definition, 
    risk_impact_assignment, 
    risk_perception_source_assignment, 
    state_observed, 
    state_observed_assignment, 
    state_observed_relationship, 
    state_type_assignment, 
    state_type_relationship);
END_TYPE; 

TYPE rm_justification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON justification_item WITH 
   (action_method, 
    action_method_relationship, 
    action_resource, 
    action_resource_relationship, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    applied_approval_assignment, 
    applied_classification_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    approval, 
    ascribable_state, 
    executed_action, 
    general_property, 
    general_property_relationship, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    representation, 
    state_observed_assignment, 
    state_type_assignment);
END_TYPE; 

TYPE rm_justification_support_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON justification_support_item WITH 
   (action_method, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval, 
    executed_action, 
    general_property, 
    general_property_relationship, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    risk_impact_assignment, 
    state_observed, 
    state_observed_assignment, 
    state_observed_relationship, 
    state_type, 
    state_type_assignment, 
    state_type_relationship);
END_TYPE; 

TYPE rm_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (action_method, 
    action_method_relationship, 
    action_relationship, 
    action_resource, 
    action_resource_relationship, 
    applied_action_assignment,
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_identification_assignment, 
    approval, 
    approval_relationship, 
    approval_status, 
    ascribable_state, 
    assumption, 
    date_and_time_assignment, 
    date_assignment, 
    executed_action, 
    general_property, 
    general_property_relationship, 
    justification_assignment, 
    justification_group_assignment, 
    justification_item_group_assignment, 
    justification_support_assignment, 
    justification_support_item_group_assignment, 
    organization_relationship, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_relationship, 
    property_definition, 
    risk_impact_assignment, 
    risk_perception_source_assignment, 
    state_observed, 
    state_observed_relationship, 
    state_type,
    state_type_relationship);
END_TYPE;

TYPE rm_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (action_method, 
    action_method_relationship, 
    action_relationship, 
    action_resource, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    applied_classification_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval, 
    approval_status, 
    ascribable_state, 
    class, 
    date_and_time_assignment, 
    date_assignment, 
    document_file, 
    executed_action, 
    general_property, 
    general_property_relationship, 
    identification_assignment_relationship, 
    justification_assignment, 
    justification_group_assignment, 
    justification_item_group_assignment, 
    justification_support_assignment, 
    justification_support_item_group_assignment, 
    organization, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    risk_impact_assignment, 
    risk_perception_source_assignment, 
    state_observed, 
    state_observed_assignment, 
    state_observed_relationship, 
    state_type, 
    state_type_assignment, 
    state_type_relationship);
END_TYPE; 

TYPE rm_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (action_method, 
    action_method_relationship, 
    action_relationship, 
    action_resource, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    applied_classification_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval, 
    approval_status, 
    ascribable_state, 
    class, 
    date_and_time_assignment, 
    date_assignment, 
    document_file, 
    executed_action, 
    general_property, 
    general_property_relationship, 
    identification_assignment_relationship, 
    justification_assignment, 
    justification_group_assignment, 
    justification_item_group_assignment, 
    justification_support_assignment, 
    justification_support_item_group_assignment, 
    organization, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    risk_impact_assignment, 
    risk_perception_source_assignment, 
    state_observed, 
    state_observed_assignment, 
    state_observed_relationship, 
    state_type, 
    state_type_assignment, 
    state_type_relationship);
END_TYPE; 

TYPE rm_risk_impact_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON risk_impact_item WITH 
   (action_method, 
    action_relationship, 
    action_resource, 
    action_resource_relationship, 
    applied_action_assignment, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval, 
    ascribable_state, 
    ascribable_state_relationship, 
    executed_action, 
    general_property, 
    general_property_relationship, 
    organization, 
    person, 
    person_and_organization, 
    product_definition, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    representation, 
    representation_item, 
    state_observed, 
    state_observed_assignment, 
    state_observed_relationship, 
    state_type_relationship);
END_TYPE; 

TYPE rm_risk_perception_source_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON risk_perception_source_item WITH 
   (action_relationship, 
    action_resource, 
    action_resource_relationship, 
    applied_action_method_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval, 
    approval_person_organization, 
    ascribable_state, 
    ascribable_state_relationship, 
    document_file, 
    general_property, 
    general_property_relationship, 
    justification_assignment, 
    justification_group_assignment, 
    justification_item_group_assignment, 
    justification_support_assignment, 
    justification_support_item_group_assignment, 
    organization, 
    person, 
    person_and_organization, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    product_relationship, 
    property_definition, 
    representation, 
    representation_item, 
    state_observed, 
    state_observed_assignment, 
    state_observed_relationship, 
    state_type, 
    state_type_relationship);
END_TYPE; 

TYPE rm_state_observed_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_observed_of_item WITH 
   (action_method, 
    action_resource, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    applied_approval_assignment, 
    approval, 
    executed_action, 
    product, 
    product_definition_formation, 
    product_definition_relationship, 
    property_definition, 
    risk_impact_assignment, 
    state_observed_assignment);
END_TYPE; 

TYPE rm_state_type_of_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON state_type_of_item WITH 
   (action_method, 
    action_resource, 
    action_resource_relationship, 
    applied_action_assignment, 
    applied_action_method_assignment, 
    applied_external_identification_assignment, 
    approval, 
    document_file, 
    executed_action, 
    organization, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship, 
    risk_attitude, 
    risk_impact_assignment);
END_TYPE; 

ENTITY rm_characterizable_address
  SUBTYPE OF (address, characterized_object);
END_ENTITY;

ENTITY rm_characterizable_applied_action_assignment
  SUBTYPE OF (applied_action_assignment, characterized_object);
END_ENTITY;

ENTITY rm_characterizable_applied_action_method_assignment
  SUBTYPE OF (applied_action_method_assignment, characterized_object);
END_ENTITY;

ENTITY rm_characterizable_applied_document_reference
  SUBTYPE OF (applied_document_reference, characterized_object);
END_ENTITY;

ENTITY rm_characterizable_applied_document_usage_constraint_assignment
  SUBTYPE OF (applied_document_usage_constraint_assignment, characterized_object);
END_ENTITY;

ENTITY rm_characterizable_applied_organization_assignment
  SUBTYPE OF (applied_organization_assignment, characterized_object);
END_ENTITY;

ENTITY rm_characterizable_applied_person_and_organization_assignment
  SUBTYPE OF (applied_person_and_organization_assignment, characterized_object);
END_ENTITY;

ENTITY rm_characterizable_person
  SUBTYPE OF (characterized_object, person);
END_ENTITY;

ENTITY rm_characterizable_person_and_organization
  SUBTYPE OF (characterized_object, person_and_organization);
END_ENTITY;

ENTITY rm_characterizable_risk_impact_assignment
  SUBTYPE OF (characterized_object, risk_impact_assignment);
END_ENTITY;

ENTITY rm_characterizable_state_observed
  SUBTYPE OF (characterized_object, state_observed);
END_ENTITY;

ENTITY rm_characterizable_state_observed_assignment
  SUBTYPE OF (characterized_object, state_observed_assignment);
END_ENTITY;

ENTITY rm_characterizable_state_observed_relationship
  SUBTYPE OF (characterized_object, state_observed_relationship);
END_ENTITY;

ENTITY rm_characterizable_state_type
  SUBTYPE OF (characterized_object, state_type);
END_ENTITY;

ENTITY rm_characterizable_state_type_assignment
  SUBTYPE OF (characterized_object, state_type_assignment);
END_ENTITY;

ENTITY rm_characterizable_state_type_relationship
  SUBTYPE OF (characterized_object, state_type_relationship);
END_ENTITY;

END_SCHEMA;  -- Risk_management_mim


--
-- RISK_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/risk_schema/risk_schema.exp)
--
(*
Id: risk_schema.exp,v 1.36 2014/03/04 00:30:41 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N6846

EXPRESS Source:
ISO 10303-58 ed1 Risk - Risk schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-58 ed1 Risk - Risk schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA risk_schema '{iso standard 10303 part(58) version(1) object(1) risk_schema(1)}';

REFERENCE FROM action_schema   -- ISO 10303-41
  (action,
   action_method,
   action_relationship); 

REFERENCE FROM application_context_schema   -- ISO 10303-41
  (product_definition_context); 

REFERENCE FROM date_time_schema   -- ISO 10303-41
  (event_occurrence); 

REFERENCE FROM management_resources_schema   -- ISO 10303-41
  (event_occurrence_assignment); 

REFERENCE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_definition,
   product_definition_formation,
   product_definition_relationship,
   product_relationship); 

REFERENCE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object,
   property_definition); 

REFERENCE FROM product_property_representation_schema   -- ISO 10303-41
  (property_definition_representation); 

REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation); 


TYPE risk_action = SELECT
   (risk_acceptance, 
    risk_analysis, 
    risk_assessment, 
    risk_communication, 
    risk_control, 
    risk_estimation, 
    risk_evaluation, 
    risk_identification, 
    risk_treatment);
END_TYPE; 

TYPE risk_impact_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (product, 
    product_definition_formation);
END_TYPE; 

TYPE risk_perception_source_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (action, 
    action_method, 
    product);
END_TYPE; 

ENTITY causal_consequence
  SUBTYPE OF (product_definition_relationship);
  SELF\product_definition_relationship.relating_product_definition : risk_consequence;
  SELF\product_definition_relationship.related_product_definition : risk_consequence;
END_ENTITY;

ENTITY contained_acceptance
  SUBTYPE OF (risk_activity_structure);
  SELF\risk_activity_structure.parent : risk_control;
  SELF\risk_activity_structure.child : risk_acceptance;
END_ENTITY;

ENTITY contained_analysis
  SUBTYPE OF (risk_activity_structure);
  SELF\risk_activity_structure.parent : risk_assessment;
  SELF\risk_activity_structure.child : risk_analysis;
END_ENTITY;

ENTITY contained_communication
  SUBTYPE OF (risk_activity_structure);
  SELF\risk_activity_structure.parent : risk_control;
  SELF\risk_activity_structure.child : risk_communication;
END_ENTITY;

ENTITY contained_estimation
  SUBTYPE OF (risk_activity_structure);
  SELF\risk_activity_structure.parent : risk_analysis;
  SELF\risk_activity_structure.child : risk_estimation;
END_ENTITY;

ENTITY contained_evaluation
  SUBTYPE OF (risk_activity_structure);
  SELF\risk_activity_structure.parent : risk_assessment;
  SELF\risk_activity_structure.child : risk_evaluation;
END_ENTITY;

ENTITY contained_identification
  SUBTYPE OF (risk_activity_structure);
  SELF\risk_activity_structure.parent : risk_analysis;
  SELF\risk_activity_structure.child : risk_identification;
END_ENTITY;

ENTITY contained_treatments
  SUBTYPE OF (risk_activity_structure);
  SELF\risk_activity_structure.parent : risk_control;
  SELF\risk_activity_structure.child : risk_treatment;
END_ENTITY;

ENTITY event_occurrence_characterized_object
  SUBTYPE OF (characterized_object, event_occurrence);
END_ENTITY;

ENTITY event_probability
  SUBTYPE OF (property_definition);
  SELF\property_definition.definition : event_occurrence_characterized_object;
END_ENTITY;

ENTITY monitor
  SUBTYPE OF (risk_activity_structure);
  SELF\risk_activity_structure.parent : risk_control;
  SELF\risk_activity_structure.child : risk_assessment;
END_ENTITY;

ENTITY probability_representation
  SUBTYPE OF (property_definition_representation);
  SELF\property_definition_representation.definition : event_probability;
END_ENTITY;

ENTITY related_consequence
  SUBTYPE OF (product_definition_relationship);
  SELF\product_definition_relationship.relating_product_definition : risk_perception;
  SELF\product_definition_relationship.related_product_definition : risk_consequence;
END_ENTITY;

ENTITY risk
  SUBTYPE OF (product);
END_ENTITY;

ENTITY risk_acceptance
  SUBTYPE OF (action);
END_ENTITY;

ENTITY risk_activity_structure
  SUBTYPE OF (action_relationship);
  SELF\action_relationship.relating_action RENAMED parent : risk_action;
  SELF\action_relationship.related_action RENAMED child : risk_action;
END_ENTITY;

ENTITY risk_analysis
  SUBTYPE OF (action);
END_ENTITY;

ENTITY risk_assessment
  SUBTYPE OF (action);
END_ENTITY;

ENTITY risk_attitude
  SUBTYPE OF (property_definition_representation);
  SELF\property_definition_representation.definition : risk_level;
  SELF\property_definition_representation.used_representation RENAMED criticality_factor : representation;
END_ENTITY;

ENTITY risk_communication
  SUBTYPE OF (action);
END_ENTITY;

ENTITY risk_consequence
  SUBTYPE OF (product_definition);
  SELF\product_definition.formation : risk_perception_formation;
END_ENTITY;

ENTITY risk_control
  SUBTYPE OF (action);
END_ENTITY;

ENTITY risk_estimation
  SUBTYPE OF (action);
END_ENTITY;

ENTITY risk_evaluation
  SUBTYPE OF (action);
END_ENTITY;

ENTITY risk_identification
  SUBTYPE OF (action);
END_ENTITY;

ENTITY risk_impact_assignment;
  assigned_risk_consequence : risk_consequence;
  items : SET[1:?] OF risk_impact_item;
END_ENTITY;

ENTITY risk_level
  SUBTYPE OF (property_definition);
  SELF\property_definition.definition : risk_perception_characterized_object;
END_ENTITY;

ENTITY risk_measure
  SUBTYPE OF (action_method);
END_ENTITY;

ENTITY risk_perception
  SUBTYPE OF (product_definition);
  SELF\product_definition.formation : risk_perception_formation;
  SELF\product_definition.frame_of_reference RENAMED risk_perception_context : risk_perception_context;
END_ENTITY;

ENTITY risk_perception_characterized_object
  SUBTYPE OF (characterized_object, risk_perception);
END_ENTITY;

ENTITY risk_perception_context
  SUBTYPE OF (product_definition_context);
END_ENTITY;

ENTITY risk_perception_formation
  SUBTYPE OF (product_definition_formation);
  SELF\product_definition_formation.of_product RENAMED of_risk : risk;
END_ENTITY;

ENTITY risk_perception_relationship
  SUBTYPE OF (product_definition_relationship);
  SELF\product_definition_relationship.relating_product_definition : risk_perception;
  SELF\product_definition_relationship.related_product_definition : risk_perception;
END_ENTITY;

ENTITY risk_perception_source_assignment;
  assigned_risk : risk_perception;
  items : SET[1:?] OF risk_perception_source_item;
END_ENTITY;

ENTITY risk_relationship
  SUBTYPE OF (product_relationship);
  SELF\product_relationship.relating_product RENAMED relating_risk : risk;
  SELF\product_relationship.related_product RENAMED related_risk : risk;
END_ENTITY;

ENTITY risk_treatment
  SUBTYPE OF (action);
  SELF\action.chosen_method : risk_measure;
END_ENTITY;

END_SCHEMA;  -- risk_schema


--
-- SCAN_DATA_3D_SHAPE_MODEL_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/scan_data_3d_shape_model_schema/scan_data_3d_shape_model_schema.exp)
--
(*
   $Id: scan_data_3d_shape_model_schema.exp,v 1.12 2021/05/06 16:22:59 kevin Exp 
ISO 10303 TC184/SC4/WG12 N10694

EXPRESS Source:
ISO 10303-42 ed7 Geometric and topological representation - Scan data 3d shape model schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2021  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-42 ed7 Geometric and topological representation - Scan data 3d shape model schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA scan_data_3d_shape_model_schema '{iso standard 10303 part(42) version(2) object(1) scan_data_3d_shape_model_schema(4)}';
REFERENCE FROM measure_schema(global_unit_assigned_context, positive_length_measure); -- ISO 10303-41
REFERENCE FROM representation_schema(representation, 
                            representation_item,
                            using_representations);  -- ISO 10303-43
REFERENCE FROM product_property_representation_schema(shape_representation); -- ISO 10303-41
REFERENCE FROM support_resource_schema(label); -- ISO 10303-41
REFERENCE FROM geometry_schema(axis2_placement_3d,
                               geometric_representation_item,
                               geometric_representation_context);

TYPE point_cloud_set_or_superset = SELECT
   (point_cloud_dataset,
    point_cloud_superdataset);
END_TYPE;


ENTITY scan_data_shape_representation
SUBTYPE OF(shape_representation);
  SELF\representation.items : SET[1:?] OF scanned_data_item;
WHERE
  WR1: 'REPRESENTATION_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN TYPEOF(SELF\representation.context_of_items);
END_ENTITY;

ENTITY scanned_data_item
   SUPERTYPE OF (ONEOF(point_cloud_dataset, point_cloud_superdataset, triangulated_point_cloud_dataset,scan_3d_model))
   SUBTYPE OF(geometric_representation_item);
WHERE
  WR1: SIZEOF (QUERY (using_rep <* using_representations (SELF) | NOT ('SCAN_DATA_3D_SHAPE_MODEL_SCHEMA.SCAN_DATA_SHAPE_REPRESENTATION' IN TYPEOF(using_rep)))) = 0;
END_ENTITY;

ENTITY point_cloud_dataset
    SUBTYPE OF(scanned_data_item);
   point_coordinates : LIST [1: ?] OF LIST[3:3] OF REAL;
END_ENTITY;

ENTITY point_cloud_dataset_with_normals
    SUBTYPE OF(point_cloud_dataset);
   normals : LIST [1: ?] OF LIST[3:3] OF REAL;
 WHERE
   WR1: SIZEOF(normals) =       SIZEOF(SELF\point_cloud_dataset.point_coordinates); 
END_ENTITY;

ENTITY point_cloud_dataset_with_colours
    SUBTYPE OF(point_cloud_dataset);
   colour_indices : LIST [1: ?] OF LIST[3:3] OF INTEGER;
 WHERE
   WR1: SIZEOF(colour_indices) =   SIZEOF(SELF\point_cloud_dataset.point_coordinates); 
END_ENTITY;

ENTITY point_cloud_dataset_with_intensities
    SUBTYPE OF(point_cloud_dataset);
    intensities : LIST [1: ?] OF REAL;
 WHERE
   WR1: SIZEOF(intensities) =   SIZEOF(SELF\point_cloud_dataset.point_coordinates); 
END_ENTITY;

ENTITY point_cloud_superdataset
    SUBTYPE OF(scanned_data_item);
    pts_per_sublist : INTEGER; 
    sublists : LIST [2 : ?] OF point_cloud_dataset;
  WHERE
    WR1 : consistent_sizes(SELF.pts_per_sublist, SELF.sublists);
END_ENTITY;

ENTITY triangulated_point_cloud_dataset
    SUBTYPE OF(scanned_data_item);
     points : point_cloud_set_or_superset;
    triangles : LIST [1: ?] OF LIST[3:3] OF INTEGER;
END_ENTITY;


ENTITY scan_3d_model
SUBTYPE OF(scanned_data_item);
  scanner_info : SET [1 : ?] OF scanner_property;
  scanned_points : SET [1: ?] OF scanned_data_item;
WHERE
     WR1: SIZEOF(QUERY(tmp <* scanned_points | 'SCAN_DATA_3D_SHAPE_MODEL_SCHEMA.SCAN_3D_MODEL' IN TYPEOF(tmp))) = 0;
END_ENTITY; 

ENTITY scanner_property
    ABSTRACT SUPERTYPE
    SUBTYPE OF(representation_item);
END_ENTITY;


ENTITY scanner_basic_properties
   SUBTYPE OF(scanner_property);
   scanner_identification: label;
   scanner_location: axis2_placement_3d;
   scanner_uncertainty: OPTIONAL positive_length_measure;
END_ENTITY;   


FUNCTION consistent_sizes (max : INTEGER; point_lists : LIST OF point_cloud_dataset) : BOOLEAN;
   LOCAL
     ndatasets : INTEGER := SIZEOF(point_lists);
     RESULT: BOOLEAN := TRUE;
     
       END_LOCAL;
  REPEAT i := 1 TO (ndatasets - 1);
     IF (SIZEOF(point_lists[i].point_coordinates) <> max)  THEN
      result := FALSE;
      RETURN(result);
    END_IF; 
  END_REPEAT;
   IF (SIZEOF(point_lists[ndatasets].point_coordinates) > max)  THEN
     result := FALSE;
     RETURN(result);
   END_IF;
  RETURN(result);
END_FUNCTION;

END_SCHEMA; -- scan_data_3d_shape_model_schema


--
-- SCHEME_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/scheme/mim.exp)
--
(*
Id: mim.exp,v 1.11 2010/06/10 20:46:49 philsp Exp 
ISO TC184/SC4/WG12 N7148 - ISO/TS 10303-1260 Scheme - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N3161
*) 


SCHEMA Scheme_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method,
   action_method_relationship); 

USE FROM Activity_method_assignment_mim;    -- ISO/TS 10303-1249

USE FROM Activity_method_mim;    -- ISO/TS 10303-1049

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Identification_assignment_mim   -- ISO/TS 10303-1021
  (applied_identification_assignment,
   identification_item); 

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Time_interval_assignment_mim;    -- ISO/TS 10303-1365

USE FROM Time_interval_mim;    -- ISO/TS 10303-1065


TYPE scheme_date_and_time_item = EXTENSIBLE SELECT BASED_ON date_and_time_item WITH 
   (action_method);
END_TYPE; 

TYPE scheme_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (action_method);
END_TYPE; 

TYPE scheme_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (action_method);
END_TYPE; 

TYPE scheme_time_interval_item = EXTENSIBLE SELECT BASED_ON time_interval_item WITH 
   (action_method_relationship);
END_TYPE; 

END_SCHEMA;  -- Scheme_mim


--
-- SECURITY_CLASSIFICATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/security_classification/mim.exp)
--
(*
 $Id: mim.exp,v 1.9 2004/10/22 15:22:41 darla Exp 
 ISO TC184/SC4/WG12 N1097 - ISO/TS 10303-1015 Security classification - EXPRESS MIM
*)

SCHEMA Security_classification_mim;

USE FROM security_classification_schema -- ISO 10303-41
  (security_classification,
   security_classification_level);
USE FROM management_resources_schema -- ISO 10303-41
  (security_classification_assignment);
  
TYPE security_classification_item = EXTENSIBLE SELECT; 
END_TYPE;

ENTITY applied_security_classification_assignment
  SUBTYPE OF (security_classification_assignment);
  items : SET [1:?] OF security_classification_item;
END_ENTITY;

END_SCHEMA;








--
-- SECURITY_CLASSIFICATION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/security_classification_schema/security_classification_schema.exp)
--
(*
Id: security_classification_schema.exp,v 1.11 2014/03/04 00:30:41 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Security classification schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Security classification schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA security_classification_schema '{iso standard 10303 part(41) version(3) object(1) security_classification_schema(21)}';
  REFERENCE FROM support_resource_schema (label, text);
  ENTITY security_classification;
    name : label;
    purpose : text;
    security_level : security_classification_level;
  END_ENTITY;

  ENTITY security_classification_level;
    name : label;
  END_ENTITY;

END_SCHEMA;


--
-- SELECTED_ITEM_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/selected_item/mim.exp)
--
(*
 ISO TC184/SC4/WG12 N10785 - ISO/TS 10303-1357 Selected item - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N3164
*) 

SCHEMA Selected_item_mim;

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM management_resources_schema    -- ISO 10303-41
  (group_assignment);

TYPE selected_item_context_items = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

TYPE selected_item_select = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item;
END_TYPE;

ENTITY selected_item
SUBTYPE OF (class);
END_ENTITY;

ENTITY selected_item_assignment
SUBTYPE OF (applied_classification_assignment);
  SELF\classification_assignment.assigned_class : selected_item;
  SELF\applied_classification_assignment.items RENAMED item : SET [1 : 1] OF selected_item_select;
END_ENTITY;

ENTITY selected_items_assignment_in_context_group
SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : selected_items_context_group;
  selected_item_assignment : SET [1 : 1] OF selected_item_assignment;
END_ENTITY;

ENTITY selected_items_context_group
SUBTYPE OF (group);
END_ENTITY;

ENTITY selected_items_context_group_to_context
SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : selected_items_context_group;
  item_context : SET[1:?] OF selected_item_context_items;
END_ENTITY;

END_SCHEMA;  -- Selected_item_mim


--
-- SHAPE_ASPECT_DEFINITION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/shape_aspect_definition_schema/shape_aspect_definition_schema.exp)
--
(*
ISO 10303 TC184/SC4/WG12 N11257
Supersedes N10695

EXPRESS Source:
ISO 10303-47 ed6 Shape variation tolerances - Shape aspect definition schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
and derivations of the Schema:

Copyright ISO 2024 All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-47 ed6 Shape variation tolerances - Shape aspect definition schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA shape_aspect_definition_schema '{iso standard 10303 part(47) version(6) object(1) shape_aspect_definition_schema(1)}';

REFERENCE FROM geometry_schema   -- ISO 10303-42
  (axis2_placement,
   cartesian_point,
   direction,
   geometric_representation_context,
   line,
   placement,
   plane);

REFERENCE FROM measure_schema   -- ISO 10303-41
  (length_measure_with_unit,
   measure_with_unit);

REFERENCE FROM product_definition_schema -- ISO 10303-41
  (product_definition);
  
REFERENCE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object,
   product_definition_shape,
   property_definition,
   shape_aspect,
   shape_aspect_occurrence,
   shape_aspect_relationship);

REFERENCE FROM product_property_representation_schema   -- ISO 10303-41
  (shape_representation);

REFERENCE FROM qualified_measure_schema   -- ISO 10303-45
  (descriptive_representation_item,
   measure_representation_item);

REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation,
   using_representations);

REFERENCE FROM shape_dimension_schema   -- ISO 10303-47
  (dimensional_location,
   dimensional_size);

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   label,
   identifier);

TYPE common_datum_list = LIST[2:?] OF datum_reference_element;
WHERE
  WR1: SIZEOF( QUERY(dre <* SELF | dre\shape_aspect.of_shape <> SELF[1]\shape_aspect.of_shape)) = 0;
END_TYPE;

TYPE datum_or_common_datum = SELECT
   (common_datum_list,
    datum);
END_TYPE;

TYPE datum_reference_modifier = EXTENSIBLE SELECT
   (datum_reference_modifier_with_value,
    simple_datum_reference_modifier);
END_TYPE;

TYPE datum_reference_modifier_type = EXTENSIBLE ENUMERATION OF
   (circular_or_cylindrical,
    spherical,
    distance,
    projected);
END_TYPE;

TYPE limit_condition = ENUMERATION OF
   (maximum_material_condition,
    least_material_condition,
    regardless_of_feature_size);
END_TYPE;

TYPE shape_aspect_or_feature_definition = SELECT
   (feature_definition,
    shape_aspect);
END_TYPE;

TYPE shape_representation_with_parameters_items = EXTENSIBLE GENERIC_ENTITY SELECT
   (descriptive_representation_item,
    direction,
    measure_representation_item,
    placement);
END_TYPE;

TYPE simple_datum_reference_modifier = EXTENSIBLE ENUMERATION OF
   (free_state,
    basic,
    translation,
    least_material_requirement,
    maximum_material_requirement,
    point,
    line,
    plane,
    orientation,
    any_cross_section,
    any_longitudinal_section,
    contacting_feature,
    distance_variable,
    degree_of_freedom_constraint_x,
    degree_of_freedom_constraint_y,
    degree_of_freedom_constraint_z,
    degree_of_freedom_constraint_u,
    degree_of_freedom_constraint_v,
    degree_of_freedom_constraint_w,
    minor_diameter,
    major_diameter,
    pitch_diameter);
END_TYPE;

ENTITY all_around_shape_aspect
  SUBTYPE OF (continuous_shape_aspect);
END_ENTITY;

ENTITY apex
  SUBTYPE OF (derived_shape_aspect);
END_ENTITY;

ENTITY between_shape_aspect
  SUBTYPE OF (continuous_shape_aspect);
 WHERE
  WR1: SIZEOF(query(sar <* SELF\composite_shape_aspect.component_relationships |
               sar\shape_aspect_relationship.name = 'start feature')) = 1;
  WR2: SIZEOF(query(sar <* SELF\composite_shape_aspect.component_relationships |
               sar\shape_aspect_relationship.name = 'end feature')) = 1;
END_ENTITY;

ENTITY centre_of_symmetry
  SUBTYPE OF (derived_shape_aspect);
END_ENTITY;

ENTITY common_datum
  SUBTYPE OF (composite_shape_aspect, datum);
WHERE
  WR1: SIZEOF (SELF\composite_shape_aspect.component_relationships) = 2;
  WR2: SIZEOF (QUERY ( sar <* SELF\composite_shape_aspect.component_relationships| NOT (('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN TYPEOF (sar.related_shape_aspect)) AND NOT ('SHAPE_ASPECT_DEFINITION_SCHEMA.COMMON_DATUM' IN TYPEOF (sar.related_shape_aspect))) )) = 0;
END_ENTITY;

ENTITY composite_group_shape_aspect
  SUBTYPE OF (composite_shape_aspect);
END_ENTITY;

ENTITY composite_shape_aspect
  SUPERTYPE OF (ONEOF (continuous_shape_aspect,
                       common_datum,
                       composite_group_shape_aspect))
  SUBTYPE OF (shape_aspect);
INVERSE
  component_relationships : SET[2:?] OF shape_aspect_relationship FOR relating_shape_aspect;
END_ENTITY;

ENTITY contacting_feature
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\shape_aspect.product_definitional = FALSE;
END_ENTITY;

ENTITY continuous_shape_aspect
  SUPERTYPE OF ( ONEOF (between_shape_aspect, all_around_shape_aspect) )
  SUBTYPE OF (composite_shape_aspect);
END_ENTITY;

ENTITY datum
  SUBTYPE OF (shape_aspect);
  identification : identifier;
INVERSE
  established_by_relationships : SET[1:?] OF shape_aspect_relationship FOR related_shape_aspect;
UNIQUE
  UR1: identification,SELF\shape_aspect.of_shape;
WHERE
  WR1: ('SHAPE_ASPECT_DEFINITION_SCHEMA.COMMON_DATUM' IN TYPEOF(SELF))
   XOR ((SIZEOF(QUERY(x <* SELF\datum.established_by_relationships |
          SIZEOF(['SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM_FEATURE',
             'SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM_TARGET'] *
           TYPEOF(x\shape_aspect_relationship.relating_shape_aspect)) = 1)) >= 1));
  WR2: SIZEOF(QUERY(x <* SELF\datum.established_by_relationships |
          ('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM_FEATURE' IN TYPEOF(x\shape_aspect_relationship.relating_shape_aspect)))) <= 1;
  WR3: SELF\shape_aspect.product_definitional = FALSE;
  WR4: SELF\shape_aspect.name = '';
END_ENTITY;

ENTITY datum_feature
  SUPERTYPE OF (ONEOF (dimensional_location_with_datum_feature, dimensional_size_with_datum_feature))
  SUBTYPE OF (shape_aspect);
INVERSE
  feature_basis_relationship : SET[1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
WHERE
  WR1: SIZEOF(QUERY(sar <* SELF\datum_feature.feature_basis_relationship | ('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN TYPEOF (sar\shape_aspect_relationship.related_shape_aspect)))) = 1;
  WR2: SELF\shape_aspect.product_definitional = TRUE;
END_ENTITY;

ENTITY datum_reference;
  precedence : INTEGER;
  referenced_datum : datum;
WHERE
  WR1: precedence > 0;
END_ENTITY;

ENTITY datum_reference_compartment
  SUBTYPE OF (general_datum_reference);
INVERSE
  owner : datum_system FOR constituents;
END_ENTITY;

ENTITY datum_reference_element
  SUBTYPE OF (general_datum_reference);
DERIVE
  owner : general_datum_reference := sts_get_general_datum_reference(SELF);
WHERE
  WR1: SELF <> owner;
  WR2: EXISTS(owner);
  WR3: SELF\shape_aspect.of_shape = owner\shape_aspect.of_shape;
END_ENTITY;

ENTITY datum_reference_modifier_with_value;
  modifier_type : datum_reference_modifier_type;
  modifier_value : length_measure_with_unit;
WHERE
  WR1: modifier_value\measure_with_unit.value_component > 0.0;
END_ENTITY;

ENTITY datum_system
  SUBTYPE OF (shape_aspect);
  constituents : LIST[1:3] OF UNIQUE datum_reference_compartment;
UNIQUE
  UR1: SELF\shape_aspect.of_shape,SELF\shape_aspect.name;
WHERE
  WR1: SELF\shape_aspect.product_definitional = FALSE;
END_ENTITY;

ENTITY datum_target
  SUBTYPE OF (shape_aspect);
  target_id : identifier;
DERIVE
  the_datum : SET [1:?] OF datum := QUERY(sar <* SELF\datum_target.target_basis_relationship | ('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN TYPEOF (sar\shape_aspect_relationship.related_shape_aspect)));
  combined_datum_target_string : string := the_datum[1]\datum.identification + target_id;
INVERSE
  target_basis_relationship : SET[1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
UNIQUE
  UR1: combined_datum_target_string, self\shape_aspect.of_shape;
WHERE
  WR1: SIZEOF(the_datum) = 1;
  WR2: SELF\shape_aspect.product_definitional = TRUE;
  WR3: 0 < value(target_id);
  WR4: SELF\shape_aspect.name = '';
  WR5: NOT EXISTS(SELF\shape_aspect.description);
END_ENTITY;

ENTITY derived_shape_aspect
  SUPERTYPE OF (ONEOF (apex,
                       centre_of_symmetry,
                       geometric_alignment,
                       geometric_contact,
                       geometric_intersection,
                       parallel_offset,
                       perpendicular_to,
                       extension,
                       tangent))
  SUBTYPE OF (shape_aspect);
INVERSE
  deriving_relationships : SET[1:?] OF shape_aspect_deriving_relationship FOR relating_shape_aspect;
END_ENTITY;

ENTITY dimensional_location_with_datum_feature
  SUBTYPE OF (datum_feature, dimensional_location);
END_ENTITY;

ENTITY dimensional_size_with_datum_feature
  SUBTYPE OF (datum_feature, dimensional_size);
  WHERE
   WR1: SELF\dimensional_size.applies_to :=: SELF;
END_ENTITY;

ENTITY extension
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

ENTITY face_surface_shape_aspect
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF (SELF\shape_aspect.of_shape\property_definition.definition);
  WR2: SELF\shape_aspect.product_definitional;
--IP1 : A face_surface_shape_aspect shall be the identification of a face_surface in a geometric model of the product.
--IP2 : A face_surface_shape_aspect shall not be in a complex instance with any other subtype of shape_aspect.  
END_ENTITY;

ENTITY feature_definition
  SUBTYPE OF (characterized_object);
END_ENTITY;

ENTITY general_datum_reference
  ABSTRACT SUPERTYPE OF (ONEOF (datum_reference_compartment,
                                datum_reference_element))
  SUBTYPE OF (shape_aspect);
  base : datum_or_common_datum;
  modifiers : OPTIONAL SET[1:?] OF datum_reference_modifier;
WHERE
  WR1: SELF\shape_aspect.name = '';
  WR2: NOT EXISTS(SELF\shape_aspect.description);
  WR3: NOT EXISTS(SELF\shape_aspect.id);
  WR4: SELF\shape_aspect.product_definitional = FALSE;
  WR5: NOT('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN TYPEOF(base)) OR (SELF\shape_aspect.of_shape = base\shape_aspect.of_shape);
  WR6: NOT('SHAPE_ASPECT_DEFINITION_SCHEMA.COMMON_DATUM_LIST' IN TYPEOF(base)) OR (SELF\shape_aspect.of_shape = base[1]\shape_aspect.of_shape);
END_ENTITY;

ENTITY geometric_alignment
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)> 1;
END_ENTITY;

ENTITY geometric_contact
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 2;
END_ENTITY;

ENTITY geometric_intersection
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)> 1;
END_ENTITY;

ENTITY instanced_feature
  SUBTYPE OF (feature_definition, shape_aspect);
WHERE
  WR1: 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF (SELF.of_shape.definition);
  WR2: SELF.product_definitional;
END_ENTITY;

ENTITY parallel_offset
  SUBTYPE OF (derived_shape_aspect);
  offset : measure_with_unit;
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

ENTITY perpendicular_to
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

ENTITY referenced_modified_datum
  SUBTYPE OF (datum_reference);
  modifier : limit_condition;
END_ENTITY;

ENTITY shape_aspect_deriving_relationship
  SUBTYPE OF (shape_aspect_relationship);
  SELF\shape_aspect_relationship.relating_shape_aspect : derived_shape_aspect;
END_ENTITY;

ENTITY shape_representation_with_parameters
  SUBTYPE OF (shape_representation);
  SELF\representation.items : SET[1:?] OF shape_representation_with_parameters_items;
END_ENTITY;

ENTITY symmetric_shape_aspect
  SUBTYPE OF (shape_aspect);
INVERSE
  basis_relationships : SET[1:?] OF shape_aspect_deriving_relationship FOR related_shape_aspect;
END_ENTITY;

ENTITY surface_shape_aspect
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF (SELF\shape_aspect.of_shape\property_definition.definition);
  WR2: SELF\shape_aspect.product_definitional;
--IP1 : A surface_shape_aspect shall be the identification of a surface in a geometric model of the product.
--IP2 : A surface_shape_aspect shall not be in a complex instance with any other subtype of shape_aspect.  
END_ENTITY;

ENTITY tangent
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

SUBTYPE_CONSTRAINT sads_shape_aspect_subtypes FOR shape_aspect;
  ONEOF (contacting_feature,
         datum,
         datum_feature,
         datum_target,
         datum_system,
         general_datum_reference);
END_SUBTYPE_CONSTRAINT;

RULE unique_datum_system for (
                                          product_definition_shape,
                                          datum_system);
LOCAL
 ds   : SET OF datum_system := []; 
 sa  : SET OF shape_aspect := [];
 pass : BOOLEAN := TRUE;
END_LOCAL;

REPEAT ii := 1 TO SIZEOF (product_definition_shape) WHILE pass;
 sa := bag_to_set(USEDIN(product_definition_shape[ii], 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'SHAPE_ASPECT.' + 'OF_SHAPE'));
 REPEAT iii := 1 to SIZEOF (sa) WHILE pass;
  ds := QUERY(ds <* sa | 'SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM_SYSTEM' IN TYPEOF(ds));

  REPEAT i := 1 TO SIZEOF(ds);
   REPEAT j := 1 TO SIZEOF(ds);
    IF (i <> j) THEN
     IF ds[i]\datum_system.constituents =
        ds[j]\datum_system.constituents  THEN
      pass := FALSE;
     END_IF;
    END_IF;
   END_REPEAT;
  END_REPEAT;

 END_REPEAT;
END_REPEAT;

WHERE
  WR1: pass;
END_RULE;

FUNCTION sts_get_general_datum_reference
 (input : datum_reference_element) : general_datum_reference;
LOCAL
      general_datum_reference_bag : BAG OF general_datum_reference :=
(USEDIN(input,
      'SHAPE_ASPECT_DEFINITION_SCHEMA.' + 'GENERAL_DATUM_REFERENCE.' + 'BASE'));
    END_LOCAL;

    IF SIZEOF(general_datum_reference_bag) = 1 THEN
      RETURN (general_datum_reference_bag[1]);
    ELSE
      RETURN (?);
    END_IF;END_FUNCTION;

END_SCHEMA;  -- shape_aspect_definition_schema


--
-- SHAPE_DIMENSION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/shape_dimension_schema/shape_dimension_schema.exp)
--
(*
ISO 10303 TC184/SC4/WG12 N11258
Supersedes N9666

EXPRESS Source:
ISO 10303-47 ed6 Shape variation tolerances - Shape dimension schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2024 All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-47 ed6 Shape variation tolerances - Shape dimension schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA shape_dimension_schema '{iso standard 10303 part(47) version(4) object(1) shape_dimension_schema(2)}';

REFERENCE FROM basic_attribute_schema -- ISO 10303-41
  (get_id_value, 
  id_attribute,
  id_attribute_select);

REFERENCE FROM geometry_schema (  -- ISO 10303-42
       cartesian_point,
       geometric_representation_item,
       line,
       placement);  

REFERENCE FROM measure_schema   -- ISO 10303-41
  (measure_with_unit); 

REFERENCE FROM product_property_definition_schema   -- ISO 10303-41
  (shape_aspect,
   shape_aspect_relationship); 
   
REFERENCE FROM product_property_representation_schema   -- ISO 10303-41
  (item_identified_representation_usage_definition,
   shape_representation); 
   
REFERENCE FROM qualified_measure_schema   -- ISO 10303-45
  (descriptive_representation_item,
   measure_representation_item,
   qualified_representation_item); 
   
REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation,
   compound_representation_item,
   using_representations); 

REFERENCE FROM shape_aspect_definition_schema  -- ISO 10303-47
  (face_surface_shape_aspect,
   surface_shape_aspect);
  
REFERENCE FROM shape_tolerance_schema  -- ISO 10303-47
  (geometric_tolerance);
  
REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (identifier,
   label,
   text); 
   
REFERENCE FROM topology_schema  -- ISO 10303-42
   (edge_curve,
   vertex_point);
   
TYPE sd_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    dimensional_size);
END_TYPE;

TYPE angle_relator = ENUMERATION OF 
   (equal,
    large,
    small);
END_TYPE; 

TYPE dimensional_characteristic = SELECT
   (dimensional_location, 
    dimensional_size);
END_TYPE; 

TYPE dimensional_location_with_normal_constraint_type = ENUMERATION OF
   (uniform_thickness_cone_cone, --coaxial having same apex angle having different apexes and different material senses.
    uniform_thickness_cylinder_cylinder, --coaxial features having different diameters and different material senses.
    uniform_thickness_face_surface_face_surface, -- face_surfaces on opposing surfaces of a body.
    uniform_thickness_plane_plane, -- planes on opposing surfaces of a body.
    uniform_thickness_revolute_revolute, -- coaxial features having same circle diameter delta in any cross section and different material senses.
    uniform_thickness_sphere_sphere, --concentric features having different diameters and different material senses.
    uniform_thickness_surface_surface, -- generic opposing surfaces of a body.
    uniform_thickness_torus_torus); -- coaxial and concentric features having same small diameter and different material senses.
END_TYPE;

TYPE sds_item_identified_representation_usage_definition = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON item_identified_representation_usage_definition WITH 
   (dimensional_size);
END_TYPE; 

TYPE shape_dimension_representation_item = SELECT
   (compound_representation_item, 
    descriptive_representation_item, 
    measure_representation_item,
    placement);
END_TYPE; 

TYPE surface_or_face_surface_shape_aspect = SELECT
    (face_surface_shape_aspect,
     surface_shape_aspect);
END_TYPE;

ENTITY angular_location
  SUBTYPE OF (dimensional_location);
  angle_selection : angle_relator;
END_ENTITY;

ENTITY angular_size
  SUBTYPE OF (dimensional_size);
  angle_selection : angle_relator;
END_ENTITY;

ENTITY dimensional_characteristic_representation;
  dimension : dimensional_characteristic;
  representation : shape_dimension_representation;
END_ENTITY;

ENTITY dimensional_location
  SUPERTYPE OF (ONEOF (angular_location,
                       dimensional_location_with_path))
  SUBTYPE OF (shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
  WR2: SELF\shape_aspect_relationship.relating_shape_aspect.of_shape :=: SELF\shape_aspect_relationship.related_shape_aspect.of_shape;
  WR3: (SELF\shape_aspect_relationship.relating_shape_aspect\shape_aspect.product_definitional <> UNKNOWN)
        AND 
       (SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.product_definitional <> UNKNOWN);
END_ENTITY;

ENTITY dimensional_location_with_path
  SUBTYPE OF (dimensional_location);
  path : shape_aspect;
END_ENTITY;

ENTITY dimensional_location_with_normal_constraint
  SUBTYPE OF (directed_dimensional_location);
  classification : dimensional_location_with_normal_constraint_type;
  SELF\shape_aspect_relationship.relating_shape_aspect RENAMED surface1 : surface_or_face_surface_shape_aspect;
  SELF\shape_aspect_relationship.related_shape_aspect RENAMED surface2 : surface_or_face_surface_shape_aspect;
INVERSE
 associated_geometric_tolerance : SET [0:0] OF geometric_tolerance FOR toleranced_shape_aspect;
WHERE
 WR1 : TYPEOF(surface1) = TYPEOF(surface2);
 WR2 : surface1 :<>: surface2;
END_ENTITY;
--IP1 : The measurement shall be anti-parallel to the geometry of the normal to surface1 at the measurement location;
--IP2 : The measurement geometry shall be a straight line starting at surface1 and terminating on surface2;
--IP3 : surface1 and surface2 are on opposing faces of the solid.
--IP4 : The surface1 normal geometry shall be a straight line that is normal to the exterior surface of the solid.
--IP5 : When the solid is revolute, the surface1 shall be the identification of a face_surface or connected_face_subset whose elements are all in the domain of the outer surface of the solid.
--IP6 : When the solid is revolute, the surface2 shall be the identification of a face_surface or connected_face_subset whose elements are all in the domain of the inner surface of the solid.
--IP7 : The type of surface1 and of surface_2 shall be consistent with the type specified in classification.
--IP8 : The dimensional_location_with_normal_constraint shall not be any other subtype of dimensional_location.

ENTITY dimensional_size
  SUPERTYPE OF (ONEOF (angular_size,
                       dimensional_size_with_path));
  applies_to : shape_aspect;
  name : label;
 DERIVE
  id : identifier := get_id_value(SELF);
UNIQUE
  UR1: id, applies_to;    
WHERE
  WR1: applies_to.product_definitional = TRUE;
  WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY dimensional_size_with_path
  SUBTYPE OF (dimensional_size);
  path : shape_aspect;
END_ENTITY;

ENTITY directed_dimensional_location
  SUBTYPE OF (dimensional_location);
END_ENTITY;

ENTITY shape_dimension_representation
  SUBTYPE OF (shape_representation);
  SELF\representation.items : SET[1:?] OF shape_dimension_representation_item;
END_ENTITY;

END_SCHEMA;  -- shape_dimension_schema


--
-- SHAPE_FEATURE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/shape_feature/mim.exp)
--
(*
   $Id: mim.exp,v 1.22 2019/01/23 20:59:43 rick Exp 
   ISO TC184/SC4/WG12 N10170 - ISO/TS 10303-1764 Shape feature - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N9876
*)

SCHEMA Shape_feature_mim;

USE FROM Characterizable_object_mim;  -- ISO/TS 10303-1765
USE FROM Contextual_shape_positioning_mim;  -- ISO/TS 10303-1027
USE FROM machining_feature_schema (feature_component_relationship, shape_defining_relationship);   -- ISO 10303-113
USE FROM product_property_definition_schema (
       characterized_object_relationship,
       constituent_shape_aspect ); -- ISO 10303-41
USE FROM Property_assignment_mim;  --  ISO/TS 10303-1030
USE FROM shape_aspect_definition_schema          -- ISO 10303-47
      (composite_shape_aspect,
       feature_definition,
       instanced_feature);
REFERENCE FROM product_property_definition_schema (  -- ISO 10303-41
 	           get_shape_aspects); 
REFERENCE FROM product_property_representation_schema ( -- ISO 10303-41
	           get_property_definition_representations);       
                            

ENTITY shape_feature_definition
  SUBTYPE OF (feature_definition);
END_ENTITY;

ENTITY placed_feature
  SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY general_feature
  SUBTYPE OF (shape_feature_definition);
WHERE
  WR1:  (SIZEOF(get_property_definition_representations(SELF)) <= 1) AND
             (SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)
             )) <= 1);   
  WR2:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               sa.description = 'course of travel occurrence')) =
             SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               (sa.description = 'course of travel occurrence') AND
               (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
                 ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' IN
                  TYPEOF(sar)) AND
                 (sar.name = 'course of travel')
                )) = 1 )));   
  WR3:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               sa.description = 'course of travel occurrence')) =
             SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               (sa.description = 'course of travel occurrence') AND
               (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
                 ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' IN
                  TYPEOF(sar)) AND
                 ('SHAPE_FEATURE_MIM.PATH_FEATURE_COMPONENT' IN
                  TYPEOF(sar.relating_shape_aspect))
                )) = 1 )));   
  WR4:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               sa.description = 'boundary occurrence')) =
             SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               (sa.description = 'boundary occurrence') AND
               (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
                 ('MACHINING_FEATURE_SCHEMA.SHAPE_DEFINING_RELATIONSHIP' IN
                  TYPEOF(sar)) AND
                 (sar.description = 'profile usage')
                )) = 1 )));   
  WR5:  (SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               ('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' IN
                  TYPEOF(sa))
              )) <= 1 ) AND
             (SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               ('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' IN
                  TYPEOF(sa)) AND
               (sa.name = 'general compound feature') AND
               (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
                 ('MACHINING_FEATURE_SCHEMA.FEATURE_COMPONENT_RELATIONSHIP' IN
                  TYPEOF(sar)) AND
                 ('SHAPE_ASPECT_DEFINITION_SCHEMA.INSTANCED_FEATURE' IN
                  TYPEOF(sar.related_shape_aspect))
                )) >= 2 )
              )) <= 1 );   
END_ENTITY;

ENTITY shape_feature_definition_relationship
  SUBTYPE OF (characterized_object_relationship, characterized_object);
  SELF\characterized_object_relationship.relating_object : shape_feature_definition;
  SELF\characterized_object_relationship.related_object : shape_feature_definition;
DERIVE
  SELF\characterized_object.name : label := SELF\characterized_object_relationship.name;
  SELF\characterized_object.description : text := SELF\characterized_object_relationship.description;
END_ENTITY;

ENTITY shape_feature_definition_element_relationship
  SUBTYPE OF (shape_aspect_relationship, characterized_object);
DERIVE
  SELF\characterized_object.name : label := SELF\shape_aspect_relationship.name;
  SELF\characterized_object.description : text := SELF\shape_aspect_relationship.description;
END_ENTITY;

END_SCHEMA;


--
-- SHAPE_PROPERTY_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/shape_property_assignment/mim.exp)
--
(*
	ISO TC184/SC4/WG12 N11252 - ISO/TS 10303-1032 Shape property assignment - EXPRESS MIM
	Supersedes ISO TC184/SC4/WG12 N10035
*)


SCHEMA Shape_property_assignment_mim;

(*REFERENCE FROM*) USE FROM Assembly_structure_mim; -- ISO/TS 10303-1026
(*REFERENCE FROM*) USE FROM External_model_mim; -- ISO/TS 10303-1033
USE FROM Geometric_model_relationship_mim; -- ISO/TS 10303-1403
USE FROM Property_assignment_mim; -- ISO/TS 10303-1030
USE FROM Product_view_definition_relationship_mim; -- ISO/TS 10303-1041

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute);

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_item,
   characterized_product_definition,
   product_definition_shape,
   shape_aspect,
   shape_aspect_relationship);

USE FROM product_property_representation_schema   -- ISO 10303-41
  (item_identified_representation_usage,
   chain_based_item_identified_representation_usage,
   shape_definition_representation);

USE FROM shape_dimension_schema (   -- ISO 10303-47
    dimensional_location,
    dimensional_size);

USE FROM shape_tolerance_schema (  -- ISO 10303-47
     chain_based_geometric_item_specific_usage,
     geometric_item_specific_usage_select,
     geometric_item_specific_usage,
     geometric_model_item,
     shape_model);
     

END_SCHEMA;


--
-- SHAPE_TOLERANCE_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/shape_tolerance_schema/shape_tolerance_schema.exp)
--
(*
ISO 10303 TC184/SC4/WG12 N11259
Supersedes N10696

EXPRESS Source:
ISO 10303-47 ed6 Shape variation tolerances - Shape tolerance schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
and derivations of the Schema:

Copyright ISO 2024 All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-47 ed6 Shape variation tolerances - Shape tolerance schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA shape_tolerance_schema '{iso standard 10303 part(47) version(7) object(1) shape_tolerance_schema(3)}';

REFERENCE FROM basic_attribute_schema --ISO 10303-41
 (get_id_value,
  id_attribute,
  id_attribute_select);

REFERENCE FROM geometry_schema --ISO 10303-42
 (axis2_placement_3d,
  geometric_representation_item); -- add for correct reference resolution.

REFERENCE FROM measure_schema   -- ISO 10303-41
  (derive_dimensional_exponents,
   dimensional_exponents,
   length_measure_with_unit,
   measure_with_unit,
   measure_value,
   plane_angle_measure_with_unit);

REFERENCE FROM product_property_definition_schema   -- ISO 10303-41
  (product_definition_shape,
   shape_aspect,
   shape_aspect_relationship);

REFERENCE FROM product_property_representation_schema   -- ISO 10303-41
  (chain_based_item_identified_representation_usage,  --add for correct reference resolution
  item_identified_representation_usage,  --add for correct reference resolution
  item_identified_representation_usage_definition,
  shape_representation); --add for correct reference resolution

REFERENCE FROM qualified_measure_schema   -- ISO 10303-45
  (measure_representation_item);

REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation);

REFERENCE FROM shape_aspect_definition_schema   -- ISO 10303-47
  (composite_group_shape_aspect,
   datum,
   datum_reference,
   datum_system,
   limit_condition,
   general_datum_reference);

REFERENCE FROM shape_dimension_schema   -- ISO 10303-47
  (dimensional_characteristic,
   dimensional_location,
   dimensional_size);

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text,
   type_check_function);

TYPE st_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    geometric_tolerance);
END_TYPE;

TYPE area_unit_type = EXTENSIBLE ENUMERATION OF
   (circular,
    square,
    rectangular,
    cylindrical,
    spherical );
END_TYPE;

TYPE datum_system_or_reference = SELECT
   (datum_reference,
    datum_system);
END_TYPE;

TYPE directed_tolerance_zone_type = ENUMERATION OF
  (angular,
   perpendicular, 
   parallel, 
   including,
   symmetrical_to
   );
END_TYPE;

TYPE direction_feature_application_type = ENUMERATION OF
  (perpendicular, 
   parallel, 
   inclined,
   runout);
END_TYPE;

TYPE geometric_tolerance_auxiliary_classification_enum = ENUMERATION OF
 (all_over,
 unless_otherwise_specified);
 END_TYPE;

TYPE geometric_tolerance_modifier = EXTENSIBLE ENUMERATION OF
   (circle_a,
    continuous_features,
    maximum_material_requirement,
    least_material_requirement,
    reciprocity_requirement,
    any_cross_section,
    free_state,
    common_zone,
    minor_diameter,
    major_diameter,
    pitch_diameter,
    line_element,
    not_convex,
    statistical_tolerance,
    tangent_plane,
    each_radial_element,
    separate_requirement,
    united_feature,
    associated_minmax_feature,
    associated_least_square_feature,
    associated_minimum_inscribed_feature,
    associated_tangent_feature,
    associated_maximum_inscribed_feature,
    reference_minimax_feature_without_constraint,
    reference_minimax_feature_with_external_material_constraint,
    reference_minimax_feature_with_internal_material_constraint,
    reference_least_square_feature_without_constraint,
    reference_least_square_feature_with_external_material_constraint,
    reference_least_square_feature_with_internal_material_constraint,
    reference_minimum_circumscribed_feature,
    reference_maximum_inscribed_feature,
    total_range_deviations,
    peak_height,
    valley_depth,
    standard_deviation,
    unspecified_linear_tolerance_zone_offset,
    unspecified_angular_tolerance_zone_offset
    );
END_TYPE;

TYPE geometric_tolerance_target = SELECT
   (dimensional_location,
    dimensional_size,
    product_definition_shape,
    shape_aspect);
END_TYPE;

TYPE length_or_plane_angle_measure_with_unit_select = SELECT (
  length_measure_with_unit,
  plane_angle_measure_with_unit);
END_TYPE;

TYPE oriented_tolerance_zone_type = ENUMERATION OF
  (perpendicular, parallel, angular);
END_TYPE;

TYPE shape_tolerance_select = SELECT
   (geometric_tolerance,
    plus_minus_tolerance);
END_TYPE;

TYPE sts_item_identified_representation_usage_definition = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON item_identified_representation_usage_definition WITH
   (geometric_tolerance);
END_TYPE;

TYPE tolerance_method_definition = SELECT
   (limits_and_fits,
    tolerance_value);
END_TYPE;

TYPE tolerance_zone_target = SELECT (
  dimensional_location,
  dimensional_size,
  geometric_tolerance,
  general_datum_reference);
END_TYPE;

ENTITY angularity_tolerance
  SUBTYPE OF (geometric_tolerance_with_datum_reference);
END_ENTITY;

ENTITY circular_runout_tolerance
  SUBTYPE OF (geometric_tolerance_with_datum_reference);
END_ENTITY;

ENTITY coaxiality_tolerance
  SUBTYPE OF (geometric_tolerance_with_datum_reference);
END_ENTITY;

ENTITY concentricity_tolerance
  SUBTYPE OF (geometric_tolerance_with_datum_reference);
END_ENTITY;

ENTITY cylindricity_tolerance
  SUBTYPE OF (geometric_tolerance);
WHERE
  WR1: NOT ('SHAPE_TOLERANCE_SCHEMA.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
END_ENTITY;

ENTITY dimension_related_tolerance_zone_element;
  related_dimension : dimensional_location;
  related_element : tolerance_zone_definition;
END_ENTITY;

ENTITY directed_tolerance_zone
  SUBTYPE OF (tolerance_zone_with_datum);
  direction : directed_tolerance_zone_type;
END_ENTITY;

ENTITY directed_tolerance_zone_with_angle
  SUBTYPE OF (directed_tolerance_zone);
  angle : plane_angle_measure_with_unit;
WHERE
  WR1: SELF\directed_tolerance_zone.direction = directed_tolerance_zone_type.angular;
END_ENTITY;

ENTITY direction_feature_tolerance_zone 
  SUBTYPE OF (tolerance_zone_with_datum);
  width_direction : direction_feature_application_type;
  angle : OPTIONAL plane_angle_measure_with_unit;
DERIVE
  indicated_datum : datum := SELF\tolerance_zone_with_datum.datum_reference\datum_system.constituents[1]\general_datum_reference.base;
WHERE
  WR1 : SIZEOF(SELF\tolerance_zone_with_datum.datum_reference\datum_system.constituents) = 1;
--The inherited attribute tolerance_zone_with_datum shall specify a datum_system that has exactly one member of datum_system.constituents
  WR2 : 'SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN TYPEOF(indicated_datum);
--The datum_system shall reference a datum.
 WR3: (width_direction <> direction_feature_application_type.inclined) XOR EXISTS(angle);
-- WR3: An angle value shall be specified if and only if the width_direction is of type inclined.
 WR4: SELF\tolerance_zone.form\tolerance_zone_form.name IN [
            'between two coaxial cylinders',
            'between two equidistant complex surfaces or two parallel planes',
            'between two non-equidistant complex surfaces or two non-parallel planes',
            'between two equidistant surfaces'];

-- The form of the tolerance zone shall be the following: 
--'between two coaxial cylinders'
--'between two equidistant complex surfaces or two parallel planes'
--'between two non-equidistant complex surfaces or two non-parallel planes'
--'between two equidistant surfaces'

--IP1 : If the geometric representation of the indicated_datum is a plane then the direction_feature_application_type value shall not be runout.
--IP2 : A direction_feature_tolerance_zone shall be represented by a plane, cylinder, or a cone.
--IP3 : The geometric representation for the indicated_datum shall be a plane or an axis.

END_ENTITY;

ENTITY flatness_tolerance
  SUBTYPE OF (geometric_tolerance);
WHERE
  WR1: NOT ('SHAPE_TOLERANCE_SCHEMA.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
END_ENTITY;

ENTITY geometric_tolerance
  ABSTRACT SUPERTYPE OF (geometric_tolerance_with_datum_reference
                         ANDOR geometric_tolerance_with_defined_unit
                        ANDOR ONEOF (geometric_tolerance_with_modifiers,
                             modified_geometric_tolerance)
                      ANDOR unequally_disposed_geometric_tolerance
                     ANDOR ONEOF (cylindricity_tolerance,
                          flatness_tolerance,
                          line_profile_tolerance,
                          position_tolerance,
                          roundness_tolerance,
                          straightness_tolerance,
                          surface_profile_tolerance));
  name : label;
  description : OPTIONAL text;
  magnitude : OPTIONAL length_measure_with_unit;
  toleranced_shape_aspect : geometric_tolerance_target;
DERIVE
  controlling_shape : product_definition_shape := sts_get_product_definition_shape(toleranced_shape_aspect);
    id : identifier := get_id_value(SELF);
INVERSE
	auxiliary_classification : SET [0:?] OF geometric_tolerance_auxiliary_classification FOR described_item;
	tolerance_relationship   : SET [0:?] OF geometric_tolerance_relationship for relating_geometric_tolerance;
UNIQUE
  UR1: id, controlling_shape;
WHERE
  WR1: magnitude\measure_with_unit.value_component >= 0.0;
  WR2: EXISTS(controlling_shape);
  WR3: NOT ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP' IN TYPEOF(toleranced_shape_aspect))
       OR (toleranced_shape_aspect\shape_aspect_relationship.relating_shape_aspect.of_shape :=:
            toleranced_shape_aspect\shape_aspect_relationship.related_shape_aspect.of_shape);
  WR4: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  WR5: SIZEOF(QUERY( tr <* tolerance_relationship | tr.name = 'composite tolerance')) <= 1;
--description a) A Geometric_tolerance shall be used at most once by geometric_tolerance_relationship.related with the name "composite tolerance"
END_ENTITY;

ENTITY geometric_tolerance_auxiliary_classification;
 attribute_value : geometric_tolerance_auxiliary_classification_enum;
 described_item : geometric_tolerance;
 END_ENTITY;

ENTITY geometric_tolerance_relationship;
  name : label;
  description : text;
  relating_geometric_tolerance : geometric_tolerance;
  related_geometric_tolerance : geometric_tolerance;
 WHERE
  WR1: NOT(name = 'composite tolerance') OR
       (('SHAPE_TOLERANCE_SCHEMA.POSITION_TOLERANCE' IN TYPEOF(relating_geometric_tolerance)) AND
        ('SHAPE_TOLERANCE_SCHEMA.POSITION_TOLERANCE' IN TYPEOF(related_geometric_tolerance))) OR
       (('SHAPE_TOLERANCE_SCHEMA.LINE_PROFILE_TOLERANCE' IN TYPEOF(relating_geometric_tolerance)) AND
        ('SHAPE_TOLERANCE_SCHEMA.LINE_PROFILE_TOLERANCE' IN TYPEOF(related_geometric_tolerance))) OR
       (('SHAPE_TOLERANCE_SCHEMA.SURFACE_PROFILE_TOLERANCE' IN TYPEOF(relating_geometric_tolerance)) AND
        ('SHAPE_TOLERANCE_SCHEMA.SURFACE_PROFILE_TOLERANCE' IN TYPEOF(related_geometric_tolerance)));
--description   b) For a geometric_tolerance_relationship with the name "composite tolerance"
--             the related and the relating subtype should be both either position_tolerance or line_profile_tolerance or surface_profile_tolerance

 WR2: NOT(name = 'composite tolerance') OR
  (relating_geometric_tolerance\geometric_tolerance.toleranced_shape_aspect :=:
  related_geometric_tolerance\geometric_tolerance.toleranced_shape_aspect);
--description c) For a geometric_tolerance_relationship with the name "composite tolerance"
--            the the related and relating geometric_tolerances shall refer to the same target.

 WR3: acyclic_geometric_tolerance_relationship(SELF, [related_geometric_tolerance],
       'SHAPE_TOLERANCE_SCHEMA.GEOMETRIC_TOLERANCE');
--The geometric_tolerance_relationship structure shall be acylic.
END_ENTITY;

ENTITY geometric_tolerance_with_datum_reference
  SUPERTYPE OF (ONEOF (angularity_tolerance,
                       circular_runout_tolerance,
                       coaxiality_tolerance,
                       concentricity_tolerance,
                       parallelism_tolerance,
                       perpendicularity_tolerance,
                       symmetry_tolerance,
                       total_runout_tolerance))
  SUBTYPE OF (geometric_tolerance);
  datum_system : SET[1:?] OF datum_system_or_reference;
WHERE
  WR1: (SIZEOF(QUERY(ds <* datum_system | 'SHAPE_TOLERANCE_SCHEMA.' + 'DATUM_SYSTEM' in TYPEOF(ds)))=0) OR (SIZEOF(datum_system)=1);
END_ENTITY;


ENTITY group_geometric_tolerance_with_datum_system_reference
SUBTYPE OF (geometric_tolerance);
  datum_system : SET[1:?] OF datum_system_for_composite_group_element;
  SELF\geometric_tolerance.toleranced_shape_aspect : composite_group_shape_aspect;
END_ENTITY;

ENTITY datum_system_for_composite_group_element
  SUBTYPE OF (datum_system);
  element : shape_aspect_relationship;
DERIVE
  associated_coordinate_system : axis2_placement_3d := coordinate_system_relation\geometric_item_specific_usage.identified_item;
INVERSE
  coordinate_system_relation : geometric_item_specific_usage FOR definition;
WHERE
  WR1: 'SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_GROUP_SHAPE_ASPECT' IN TYPEOF(element\shape_aspect_relationship.relating_shape_aspect);
  WR2: NOT('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_GROUP_SHAPE_ASPECT' IN TYPEOF(element\shape_aspect_relationship.related_shape_aspect));
-- desc: A composite_group_shape_aspect shall not be provided by the relating_shape_aspect.
END_ENTITY;

TYPE geometric_model_item = EXTENSIBLE GENERIC_ENTITY SELECT (
    geometric_representation_item);
END_TYPE;

TYPE geometric_item_specific_usage_select = SELECT
   (shape_aspect,
    shape_aspect_relationship);
END_TYPE;

TYPE shape_model = EXTENSIBLE GENERIC_ENTITY SELECT
   (shape_representation);
END_TYPE;

ENTITY geometric_item_specific_usage
  SUBTYPE OF(item_identified_representation_usage);
    SELF\item_identified_representation_usage.definition          : geometric_item_specific_usage_select;
    SELF\item_identified_representation_usage.used_representation : shape_model;
    SELF\item_identified_representation_usage.identified_item     : geometric_model_item;
END_ENTITY;

ENTITY chain_based_geometric_item_specific_usage
  SUBTYPE OF (geometric_item_specific_usage,
    chain_based_item_identified_representation_usage);
END_ENTITY;

ENTITY geometric_tolerance_with_defined_area_unit
  SUBTYPE OF (geometric_tolerance_with_defined_unit);
  area_type : area_unit_type;
  second_unit_size : OPTIONAL length_or_plane_angle_measure_with_unit_select;
WHERE
  WR1: NOT (EXISTS(second_unit_size) XOR (area_type IN [area_unit_type.rectangular, area_unit_type.cylindrical, area_unit_type.spherical]));
  WR2: NOT(area_type = area_unit_type.cylindrical)
	   OR  ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(unit_size))
	   AND ('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT' IN TYPEOF(second_unit_size));
  WR3: NOT (area_type =  area_unit_type.rectangular)
       OR ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(unit_size))
	   AND ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(second_unit_size));
  WR4: NOT(area_type = area_unit_type.spherical)
	   OR  ('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT' IN TYPEOF(unit_size))
	   AND ('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT' IN TYPEOF(second_unit_size));
  WR5: NOT(area_type =  area_unit_type.spherical)
	   OR  (SIZEOF(QUERY (tz <* USEDIN(SELF,'SHAPE_TOLERANCE_SCHEMA.TOLERANCE_ZONE.DEFINING_TOLERANCE') |
	       ('SHAPE_TOLERANCE_SCHEMA.ORIENTED_TOLERANCE_ZONE' IN TYPEOF(tz))
	       )) <> 0 );
END_ENTITY;

ENTITY geometric_tolerance_with_defined_unit
  SUBTYPE OF (geometric_tolerance);
  unit_size : length_or_plane_angle_measure_with_unit_select;
WHERE
  WR1: ('NUMBER' IN TYPEOF (unit_size\measure_with_unit.value_component)) AND (unit_size\measure_with_unit.value_component > 0.0);
END_ENTITY;

ENTITY geometric_tolerance_with_maximum_tolerance
  SUBTYPE OF (geometric_tolerance_with_modifiers);
  maximum_upper_tolerance : length_measure_with_unit;
WHERE
  WR1: (geometric_tolerance_modifier.maximum_material_requirement IN SELF\geometric_tolerance_with_modifiers.modifiers) OR (geometric_tolerance_modifier.least_material_requirement IN SELF\geometric_tolerance_with_modifiers.modifiers);
  WR2: (maximum_upper_tolerance\measure_with_unit.unit_component = SELF\geometric_tolerance.magnitude\measure_with_unit.unit_component) AND (maximum_upper_tolerance\measure_with_unit.value_component > SELF\geometric_tolerance.magnitude\measure_with_unit.value_component);
END_ENTITY;

ENTITY geometric_tolerance_with_modifiers
  SUBTYPE OF (geometric_tolerance);
  modifiers : SET[1:?] OF geometric_tolerance_modifier;
WHERE
  WR1: NOT (geometric_tolerance_modifier.circle_a IN modifiers) OR
           (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' IN
            TYPEOF(SELF\geometric_tolerance.toleranced_shape_aspect)) AND
           (SELF\geometric_tolerance.toleranced_shape_aspect\shape_aspect.product_definitional =
            TRUE) OR
            ('SHAPE_DIMENSION_SCHEMA.DIMENSIONAL_SIZE' IN
            TYPEOF(SELF\geometric_tolerance.toleranced_shape_aspect)));
END_ENTITY;
--wr1 description: If circle-A is provided, then the toleranced_shape_aspect shall be on the surface.

TYPE gps_filtration_specification_target = EXTENSIBLE GENERIC_ENTITY SELECT
    (geometric_tolerance);
END_TYPE;

TYPE gps_filtration_enumeration = ENUMERATION OF 
     (
     alternating_ball,
     alternating_disc,
     alternating_horizontal_segment,
     ball_radius,
     closing_ball,
     closing_disc,
     closing_horizontal_segment,
     complex_wavelet,
     cutoff_length,
     cutoff_upr,
     disc_radius,
     fourier,
     gaussian,
     hull,
     long_wave_pass_filter,
     opening_ball,
     opening_disc,
     opening_horizontal_segment,
     robust_gaussian,
     robust_spline,
     segment_length,
     short_wave_pass_filter,
     spline,
     spline_wavelet,
     urp_number,
     wavelength);
END_TYPE;

TYPE gps_filtration_type = EXTENSIBLE SELECT
    (geometric_tolerance_modifier,
     gps_filtration_enumeration);
END_TYPE;

 ENTITY gps_filtration_specification;
   base_target : gps_filtration_specification_target;
   filter_data : LIST [1:?] OF gps_filter;
-- WHERE
--  IP1 : The content of the data set is governed by ISO 1101 or other GPS standards.
 END_ENTITY;

ENTITY gps_filter;
   filter_type : gps_filtration_type;
   filter_data : LIST [1:?] OF measure_with_unit;
INVERSE
    owner : gps_filtration_specification FOR filter_data;
 WHERE
  WR1 :  NOT ('SHAPE_TOLERANCE_SCHEMA.GEOMETRIC_TOLERANCE_WITH_MODIFIERS' IN TYPEOF(owner\gps_filtration_specification.base_target)) 
         OR
         (SIZEOF([
            geometric_tolerance_modifier.reference_minimax_feature_without_constraint,
            geometric_tolerance_modifier.reference_minimax_feature_with_external_material_constraint,
            geometric_tolerance_modifier.reference_minimax_feature_with_internal_material_constraint,
            geometric_tolerance_modifier.reference_least_square_feature_without_constraint,
            geometric_tolerance_modifier.reference_least_square_feature_with_external_material_constraint,
            geometric_tolerance_modifier.reference_least_square_feature_with_internal_material_constraint,
            geometric_tolerance_modifier.reference_minimum_circumscribed_feature,
            geometric_tolerance_modifier.reference_maximum_inscribed_feature,
            geometric_tolerance_modifier.total_range_deviations,
            geometric_tolerance_modifier.peak_height,
            geometric_tolerance_modifier.valley_depth,
            geometric_tolerance_modifier.standard_deviation ] *
            owner\gps_filtration_specification.base_target\geometric_tolerance_with_modifiers.modifiers) <> 0 );
--  IP1 : The content of the data set is governed by ISO 1101 or other GPS standards.
 END_ENTITY;





ENTITY limits_and_fits;
  form_variance : label;
  zone_variance : label;
  grade : label;
  source : text;
END_ENTITY;

ENTITY line_profile_tolerance
  SUBTYPE OF (geometric_tolerance);
END_ENTITY;

ENTITY modified_geometric_tolerance
  SUBTYPE OF (geometric_tolerance);
  modifier : limit_condition;
END_ENTITY;

ENTITY non_uniform_zone_definition
  SUBTYPE OF (tolerance_zone_definition);
END_ENTITY;

ENTITY oriented_tolerance_zone
  SUBTYPE OF (tolerance_zone_with_datum);
  orientation : oriented_tolerance_zone_type;
  angle : OPTIONAL plane_angle_measure_with_unit;
WHERE
  WR1 : (orientation <> oriented_tolerance_zone_type.angular) XOR EXISTS(angle);
END_ENTITY;

ENTITY parallelism_tolerance
  SUBTYPE OF (geometric_tolerance_with_datum_reference);
END_ENTITY;

ENTITY perpendicularity_tolerance
  SUBTYPE OF (geometric_tolerance_with_datum_reference);
END_ENTITY;

ENTITY plus_minus_tolerance;
  range : tolerance_method_definition;
  toleranced_dimension : dimensional_characteristic;
UNIQUE
  UR1: toleranced_dimension;
END_ENTITY;

ENTITY position_tolerance
  SUBTYPE OF (geometric_tolerance);
END_ENTITY;

ENTITY projected_zone_definition
  SUBTYPE OF (tolerance_zone_definition);
  projection_end : shape_aspect;
  projected_length : length_measure_with_unit;
WHERE
  WR1: ('NUMBER' IN TYPEOF (projected_length\measure_with_unit.value_component)) AND (projected_length\measure_with_unit.value_component > 0.0);
  WR2: (derive_dimensional_exponents (projected_length\measure_with_unit.unit_component)= dimensional_exponents(1,0,0,0,0,0,0));
END_ENTITY;

ENTITY projected_zone_definition_with_offset
  SUBTYPE OF (projected_zone_definition);
  offset : length_measure_with_unit;
END_ENTITY;

ENTITY roundness_tolerance
  SUBTYPE OF (geometric_tolerance);
WHERE
  WR1: NOT ('SHAPE_TOLERANCE_SCHEMA.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
END_ENTITY;

ENTITY runout_zone_definition
  SUBTYPE OF (tolerance_zone_definition);
  orientation : runout_zone_orientation;
END_ENTITY;

ENTITY runout_zone_orientation;
  angle : plane_angle_measure_with_unit;
END_ENTITY;

ENTITY runout_zone_orientation_reference_direction
  SUBTYPE OF (runout_zone_orientation);
  orientation_defining_relationship : shape_aspect_relationship;
END_ENTITY;

ENTITY statistical_distribution_for_tolerance
  SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items | NOT ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (item)))) = 0;
END_ENTITY;

ENTITY straightness_tolerance
  SUBTYPE OF (geometric_tolerance);
WHERE
  WR1: NOT ('SHAPE_TOLERANCE_SCHEMA.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
END_ENTITY;

ENTITY surface_profile_tolerance
  SUBTYPE OF (geometric_tolerance);
END_ENTITY;

ENTITY symmetry_tolerance
  SUBTYPE OF (geometric_tolerance_with_datum_reference);
END_ENTITY;

ENTITY tolerance_value;
  lower_bound : measure_with_unit;
  upper_bound : measure_with_unit;
DERIVE
  ubvc : REAL := upper_bound\measure_with_unit.value_component;
  lbvc : REAL := lower_bound\measure_with_unit.value_component;
WHERE
  WR1: ubvc > lbvc;
  WR2: upper_bound\measure_with_unit.unit_component = lower_bound\measure_with_unit.unit_component;
END_ENTITY;

ENTITY tolerance_with_statistical_distribution;
  associated_tolerance : shape_tolerance_select;
  tolerance_allocation : statistical_distribution_for_tolerance;
END_ENTITY;

ENTITY tolerance_zone
  SUBTYPE OF (shape_aspect);
  defining_tolerance : SET[1:?] OF tolerance_zone_target;
  form : tolerance_zone_form;
END_ENTITY;

ENTITY tolerance_zone_definition
  SUPERTYPE OF (ONEOF (projected_zone_definition,
                       non_uniform_zone_definition,
                       runout_zone_definition));
  zone : tolerance_zone;
  boundaries : SET[0:?] OF shape_aspect;
END_ENTITY;

ENTITY tolerance_zone_form;
  name : label;
END_ENTITY;

ENTITY tolerance_zone_with_datum
  SUPERTYPE OF (ONEOF (directed_tolerance_zone, direction_feature_tolerance_zone, oriented_tolerance_zone))
  SUBTYPE OF (tolerance_zone);
  datum_reference : datum_system;
END_ENTITY;

ENTITY total_runout_tolerance
  SUBTYPE OF (geometric_tolerance_with_datum_reference);
END_ENTITY;

ENTITY unequally_disposed_geometric_tolerance
  SUBTYPE OF (geometric_tolerance);
  displacement : length_measure_with_unit;
WHERE
  WR1: 'NUMBER' IN TYPEOF(displacement\measure_with_unit.value_component);
END_ENTITY;

RULE subtype_exclusiveness_geometric_tolerance FOR
(geometric_tolerance);
WHERE
  WR1: SIZEOF(QUERY (gt <* geometric_tolerance | NOT (type_check_function(gt, ['SHAPE_TOLERANCE_SCHEMA.ANGULARITY_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.CIRCULAR_RUNOUT_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.COAXIALITY_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.CONCENTRICITY_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.CYLINDRICITY_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.FLATNESS_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.LINE_PROFILE_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.PARALLELISM_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.PERPENDICULARITY_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.POSITION_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.ROUNDNESS_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.STRAIGHTNESS_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.SURFACE_PROFILE_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.SYMMETRY_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.TOTAL_RUNOUT_TOLERANCE'] , 2 ) ))) = 0;
END_RULE;

FUNCTION acyclic_geometric_tolerance_relationship (relation : geometric_tolerance_relationship;
                                                  relatives : SET [1:?] OF geometric_tolerance;
                                                  specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF geometric_tolerance_relationship;
    END_LOCAL;

    IF relation.relating_geometric_tolerance IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(geotol <* bag_to_set(
              USEDIN(relation.relating_geometric_tolerance,
              'SHAPE_TOLERANCE_SCHEMA.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.' + 'RELATED_GEOMETRIC_TOLERANCE')) | specific_relation IN TYPEOF(geotol));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_geometric_tolerance_relationship(x[i], relatives + relation.relating_geometric_tolerance, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

FUNCTION sts_get_product_definition_shape
 (input : geometric_tolerance_target) : product_definition_shape;
CASE TRUE OF ('SHAPE_DIMENSION_SCHEMA.DIMENSIONAL_LOCATION' IN TYPEOF(input)) :
                 RETURN(input\shape_aspect_relationship.relating_shape_aspect\shape_aspect.of_shape);
               ('SHAPE_DIMENSION_SCHEMA.DIMENSIONAL_SIZE' IN TYPEOF(input)) :
                 RETURN(input\dimensional_size.applies_to\shape_aspect.of_shape);
               ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(input)) :
                 RETURN(input);
               ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' IN TYPEOF(input)) :
                 RETURN(input\shape_aspect.of_shape);
  OTHERWISE : RETURN(?);
  END_CASE;END_FUNCTION;

END_SCHEMA;  -- shape_tolerance_schema


--
-- SINGLE_PART_REPRESENTATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/single_part_representation/mim.exp)
--
(*
Id: mim.exp,v 1.19 2010/06/09 15:41:00 philsp Exp 
ISO TC184/SC4/WG12 N7140 - ISO/TS 10303-1133 Single part representation - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6088
*) 


SCHEMA Single_part_representation_mim;

USE FROM Document_assignment_mim;    -- ISO/TS 10303-1122

USE FROM Extended_measure_representation_mim;    -- ISO/TS 10303-1106

USE FROM Part_view_definition_mim;    -- ISO/TS 10303-1023

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

USE FROM Shape_property_assignment_mim;    -- ISO/TS 10303-1032


TYPE spr_document_reference_item = SELECT BASED_ON document_reference_item WITH 
   (product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE spr_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE spr_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

END_SCHEMA;  -- Single_part_representation_mim


--
-- SPECIFICATION_BASED_CONFIGURATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/specification_based_configuration/mim.exp)
--
(*
 $Id: mim.exp,v 1.17 2017/04/28 15:09:08 verodub Exp 
 ISO TC184/SC4/WG12 N9580 - ISO/TS 10303-1108 Specification based configuration - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N7706
*)

SCHEMA Specification_based_configuration_mim;

USE FROM Effectivity_application_mim;   -- ISO/TS 10303-1059

USE FROM Product_class_mim;   -- ISO/TS 10303-1103

USE FROM management_resources_schema(    -- ISO 10303-41
  effectivity_context_assignment);

USE FROM product_definition_schema(   -- ISO 10303-41
  product_definition);

TYPE sbc_effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON effectivity_item WITH (
  configured_effectivity_assignment);
END_TYPE;

TYPE configured_effectivity_context_item = SELECT (product_concept_feature_association);
END_TYPE;

TYPE configured_effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT (
  product_definition); 
END_TYPE; 

ENTITY configured_effectivity_context_assignment 
SUBTYPE OF (effectivity_context_assignment);
  SELF\effectivity_context_assignment.assigned_effectivity_assignment: configured_effectivity_assignment;
  items : SET [1:?] OF configured_effectivity_context_item; 
WHERE 
WR1: SIZEOF(SELF.items) = 1; 
END_ENTITY;
 
ENTITY configured_effectivity_assignment 
	SUBTYPE OF (effectivity_assignment);
	  items : SET [1:?] OF configured_effectivity_item; 
	WHERE 
	WR1: (SIZEOF(['EFFECTIVITY_SCHEMA.EFFECTIVITY'] * TYPEOF(SELF.assigned_effectivity) ) = 1) 
	AND (SELF.assigned_effectivity.id = 'configuration validity'); 
	WR2: SIZEOF(SELF.items) = 1; 
	WR3: SIZEOF( QUERY( i <* SELF.items | NOT ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(i)) 
	OR NOT (i\product_definition.frame_of_reference.name IN ['conceptual definition','part occurrence', 'functional definition','alternative definition']) )) = 0; 
	WR4: SELF.role.name IN ['design', 'usage']; 
	WR5: (SELF.role.name <> 'design') 
	OR (SIZEOF( QUERY( i <* SELF.items | ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(i)) AND (i\product_definition.frame_of_reference.name = 'part occurrence') )) = 0); 
	WR6: (SELF.role.name <> 'usage') OR (SIZEOF( QUERY( i <* SELF.items | ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(i)) AND (i\product_definition.frame_of_reference.name = 'conceptual definition') )) = 0); 
	WR7: SELF.role.description IN ['exception', 'inherited', 'local']; 
	WR8: SIZEOF( QUERY( x <* USEDIN(SELF,'MANAGEMENT_RESOURCES_SCHEMA.' + 'EFFECTIVITY_CONTEXT_ASSIGNMENT.ASSIGNED_EFFECTIVITY_ASSIGNMENT') | 'SPECIFICATION_BASED_CONFIGURATION_MIM.CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT' IN TYPEOF(x) )) = 1; 
END_ENTITY;


END_SCHEMA;


--
-- SPECIFICATION_CONTROL_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/specification_control/mim.exp)
--
(*
 $Id: mim.exp,v 1.19 2012/10/11 05:49:08 liutkuviene Exp 
 ISO TC184/SC4/WG12 N8054 - ISO/TS 10303-1112 Specification control - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N6674
*)

SCHEMA Specification_control_mim;

USE FROM Alternative_solution_mim; -- ISO/TS 10303-1109
USE FROM Part_collection_mim; -- ISO/TS 10303-1115
USE FROM Product_placement_mim; -- ISO/TS 10303-1343
USE FROM Requirement_view_definition_mim; 
USE FROM Specification_based_configuration_mim; -- ISO/TS 10303-1108
USE FROM product_definition_schema (product_definition_substitute);


  TYPE class_usage_effectivity_context_item = SELECT
    (product_definition);
  END_TYPE;

  TYPE effectivity_specification_for_replacement  = SELECT BASED_ON effectivity_item WITH
    (product_definition_substitute);
  END_TYPE;

  TYPE instance_usage_context_select  = EXTENSIBLE GENERIC_ENTITY SELECT 
    (product_definition_relationship,
     product_definition_usage);
  END_TYPE;

  ENTITY class_usage_effectivity_context_assignment 
    SUBTYPE OF (effectivity_context_assignment); 
      items : SET [1:?] OF class_usage_effectivity_context_item; 
    WHERE 
      WR1: SELF.role.name = 'class usage influence'; 
      WR2: SIZEOF( QUERY( i <* SELF.items | NOT ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(i)) )) = 0; 
      WR3: ('EFFECTIVITY_APPLICATION_MIM.APPLIED_EFFECTIVITY_ASSIGNMENT' IN TYPEOF(SELF.assigned_effectivity_assignment)) AND 
        (SIZEOF(TYPEOF(SELF.assigned_effectivity_assignment.assigned_effectivity) ) = 1) AND 
        (SELF.assigned_effectivity_assignment.assigned_effectivity.id = 'class usage') AND 
        (SIZEOF( QUERY( i <* SELF.assigned_effectivity_assignment\applied_effectivity_assignment.items | 
        NOT('PRODUCT_CLASS_MIM.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE' IN TYPEOF(i)) )) = 0); 
  END_ENTITY; 

  ENTITY instance_usage_context_assignment 
    SUBTYPE OF (product_definition_context); 
      items : SET [1:?] OF instance_usage_context_select; 
  END_ENTITY; 

  RULE breakdown_element_requires_product_definition FOR 
	  (product_definition_formation);
    WHERE
      WR1: SIZEOF ( QUERY ( pdf <* product_definition_formation | 
        ( SIZEOF ( QUERY ( prpc <* USEDIN ( pdf.of_product ,
        'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	    prpc.name =  'functionality' ) ) =  1 ) AND 
	    ( SIZEOF ( QUERY ( pd <* USEDIN ( pdf ,'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION.FORMATION') | 
	    pd.frame_of_reference.name =  'functional definition' ) ) <1 ) ) ) =  0;
      WR2: SIZEOF ( QUERY ( pdf <* product_definition_formation | 
        ( SIZEOF ( QUERY ( prpc <* USEDIN ( pdf.of_product , 
	    'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
        prpc.name =  'conceptual design' ) ) =  1 ) AND 
        ( SIZEOF (QUERY ( pd <* USEDIN ( pdf , 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION.FORMATION' ) | 
        pd.frame_of_reference.name =  'conceptual definition' ) ) <1) ) ) =  0;
  END_RULE;

  RULE constraint_definition_requires_constraint_category FOR (product_definition);
    LOCAL
      constraint_definitions: SET OF product_definition := [];
    END_LOCAL;
      constraint_definitions :=  QUERY( pd <* product_definition |
      (pd.frame_of_reference.name = 'design constraint definition'));
    WHERE
      WR1: SIZEOF ( QUERY ( pd <* constraint_definitions | 
	    ( SIZEOF ( QUERY ( prpc <* USEDIN ( pd.formation.of_product ,
        'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	    prpc. name ='requirement' ) ) =0 ) ) ) =0;
  END_RULE;

  RULE design_constraint_requires_product_definition FOR (product_definition_formation);
    WHERE
      WR1: SIZEOF ( QUERY ( pdf <* product_definition_formation | (
        SIZEOF ( QUERY ( prpc <* USEDIN ( pdf.of_product ,
        'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	    prpc.name =  'requirement' ) ) >0 ) AND 
        ( SIZEOF ( QUERY ( pd <* USEDIN ( pdf , 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION.FORMATION') | 
	    pd.frame_of_reference.name = 'design constraint definition' ) ) <1 ) ) ) =  0;
  END_RULE; 

  RULE restrict_configuration_design_for_class_breakdown_association FOR
      (configuration_design);
    WHERE
      WR1: SIZEOF ( QUERY ( cd <* configuration_design | 
	    ( cd.name ='functionality' ) AND 
        ( NOT ( 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF ( cd. design ) ) OR 
        ( cd.design\product_definition.frame_of_reference.name<> 'functional definition' ) ) 
        ) ) =0;
      WR2: SIZEOF ( QUERY ( cd <* configuration_design | 
        ( cd.name='realization' ) AND 
        ( NOT ( 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF ( cd.design ) ) OR 
        ( cd.design\product_definition.frame_of_reference.name<> 'conceptual definition' ) ) 
        ) ) =0;
      WR3: SIZEOF ( QUERY ( cd <* configuration_design | 
        ( cd.name IN ['functionality' , 'realization'] ) AND 
        ( NOT ('PRODUCT_CLASS_MIM.PRODUCT_CLASS' IN TYPEOF ( cd.configuration.item_concept ) ) ) 
        ) ) =0;
  END_RULE;

  RULE restrict_configuration_design_for_design_constraint FOR (configuration_design); 
    WHERE 
      WR1: SIZEOF ( QUERY (cd <* configuration_design | 
	    (cd.name = 'design constraint usage') AND 
        (NOT('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF ( cd.design ) ) OR 
        (cd.design\product_definition.frame_of_reference.name <> 'design constraint definition')))) = 0; 
  END_RULE;

  RULE restrict_product_definitions_for_design_constraint_association FOR
      (product_definition_relationship);
    WHERE
      WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
        ( pdr. name = 'design constraint association' ) AND 
	    ( (pdr. relating_product_definition.frame_of_reference.name<>'design constraint definition' ) OR 
	    NOT ( pdr.related_product_definition.frame_of_reference.name IN 
	    ['alternative definition' , 'functional definition' ,'conceptual definition' ] ) ) ) ) =0;
  END_RULE;

END_SCHEMA;



--
-- SPECIFIED_PRODUCT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/specified_product/mim.exp)
--
(*
 $Id: mim.exp,v 1.16 2021/09/13 13:51:07 kevin Exp 
 ISO TC184/SC4/WG12 N11002 - ISO/TS 10303-1104 Specified product - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N8329
*)

SCHEMA Specified_product_mim;

USE FROM Characterizable_object_mim; -- ISO/TS 10303-1765

USE FROM Configuration_item_mim; -- ISO/TS 10303-1056

USE FROM configuration_management_schema(   -- ISO 10303-44
	configurable_item);
	
USE FROM Product_class_mim; -- ISO/TS 10303-1103

  TYPE id_for_product_identification = SELECT BASED_ON identification_item WITH (product_identification);
  END_TYPE;

  ENTITY product_identification
    SUBTYPE OF (configuration_item, characterized_object);
	  SELF\configuration_item.item_concept : product_class;
    WHERE
	  WR1 : SIZEOF(QUERY 
		( cd <* USEDIN ( SELF ,'CONFIGURATION_MANAGEMENT_SCHEMA.CONFIGURATION_DESIGN.CONFIGURATION' ) 
		|
     	( 'PRODUCT_DEFINITION_SCHEMA.'+ 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF ( cd. design ) ) 
     	AND 
    	( SIZEOF ( QUERY 
    	( 
    	prpc <* USEDIN ( cd. design\product_definition_formation.of_product , 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') 
    	| 
        prpc. name IN ['part' , 'raw material' , 'tool'] ) ) >0
     	) 
     	) 
     	) <=1;
	  WR2 : NOT ( 'CONFIGURATION_MANAGEMENT_SCHEMA.'+ 'CONFIGURABLE_ITEM' IN TYPEOF( SELF ) ) 
			XOR ( 'SPECIFIED_PRODUCT_MIM.'+ 'PRODUCT_SPECIFICATION' IN TYPEOF ( SELF ) ) ;
  END_ENTITY;

  ENTITY product_specification
    SUBTYPE OF (product_identification, configurable_item);
  END_ENTITY;

END_SCHEMA;


--
-- STATE_CHARACTERIZED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/state_characterized/mim.exp)
--
(*
 $Id: mim.exp,v 1.17 2010/11/17 14:59:14 robbod Exp 
 ISO TC184/SC4/WG12 N7285 - ISO/TS 10303-1271 State characterized - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N6594
*)
 


SCHEMA State_characterized_mim;

USE FROM Condition_characterized_mim;    -- ISO/TS 10303-1257

USE FROM Condition_evaluation_characterized_mim;    -- ISO/TS 10303-1296

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object); 

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

USE FROM State_observed_mim;    -- ISO/TS 10303-1256


TYPE state_observed_role_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (state_observed_role);
END_TYPE; 

TYPE statechar_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH 
   (ascribable_state);
END_TYPE; 

TYPE statechar_action_method_items = EXTENSIBLE SELECT BASED_ON action_method_items WITH 
   (state_type, 
    state_type_relationship);
END_TYPE; 

TYPE statechar_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_classification_item WITH 
   (state_observed, 
    state_observed_assignment, 
    state_observed_relationship, 
    state_type, 
    state_type_assignment, 
    state_type_relationship);
END_TYPE; 

TYPE statechar_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (state_observed, 
    state_observed_relationship, 
    state_type, 
    state_type_relationship);
END_TYPE; 

TYPE statechar_date_and_time_item = EXTENSIBLE SELECT BASED_ON date_and_time_item WITH 
   (ascribable_state, 
    state_observed, 
    state_observed_assignment, 
    state_observed_relationship, 
    state_type, 
    state_type_assignment, 
    state_type_relationship);
END_TYPE; 

TYPE statechar_date_item = EXTENSIBLE SELECT BASED_ON date_item WITH 
   (ascribable_state, 
    state_observed, 
    state_observed_assignment, 
    state_observed_relationship, 
    state_type, 
    state_type_assignment, 
    state_type_relationship);
END_TYPE; 

TYPE statechar_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (ascribable_state, 
    ascribable_state_relationship, 
    state_observed, 
    state_observed_assignment, 
    state_observed_relationship, 
    state_type, 
    state_type_assignment, 
    state_type_relationship);
END_TYPE; 

TYPE statechar_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (state_observed, 
    state_observed_relationship, 
    state_type, 
    state_type_relationship);
END_TYPE; 

TYPE statechar_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (ascribable_state, 
    state_observed, 
    state_observed_assignment, 
    state_observed_relationship, 
    state_type, 
    state_type_assignment, 
    state_type_relationship);
END_TYPE; 

TYPE statechar_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (ascribable_state, 
    state_observed, 
    state_observed_assignment, 
    state_observed_relationship, 
    state_type, 
    state_type_assignment, 
    state_type_relationship);
END_TYPE; 

ENTITY statechar_applied_object
  SUBTYPE OF (characterized_object, state_observed_assignment);
END_ENTITY;

ENTITY statechar_object
  SUBTYPE OF (characterized_object, state_observed);
END_ENTITY;

ENTITY statechar_relationship_object
  SUBTYPE OF (characterized_object, state_observed_relationship);
END_ENTITY;

ENTITY statechar_type_applied_object
  SUBTYPE OF (characterized_object, state_type_assignment);
END_ENTITY;

ENTITY statechar_type_object
  SUBTYPE OF (characterized_object, state_type);
END_ENTITY;

ENTITY statechar_type_relationship_object
  SUBTYPE OF (characterized_object, state_type_relationship);
END_ENTITY;

END_SCHEMA;  -- State_characterized_mim


--
-- STATE_DEFINITION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/state_definition/mim.exp)
--
(*
   $Id: mim.exp,v 1.26 2009/12/18 14:52:17 robbod Exp 
   ISO TC184/SC4/WG12 N5918 - ISO/TS 10303-1255 State definition - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4880
*) 

SCHEMA State_definition_mim;

USE FROM Activity_mim;    -- ISO/TS 10303-1047

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM Foundation_state_definition_mim;    -- ISO/TS 10303-1469


TYPE state_definition_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH 
   (applied_state_type_assignment);
END_TYPE; 

TYPE state_definition_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (state_type, 
    state_type_assignment, 
    state_type_relationship);
END_TYPE; 

TYPE state_definition_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (state_type, 
    state_type_relationship);
END_TYPE; 

END_SCHEMA;  -- State_definition_mim



--
-- STATE_OBSERVED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/state_observed/mim.exp)
--
(*
   ISO TC184/SC4/WG12 N10285 - ISO/TS 10303-1256 State observed - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5921
*) 

SCHEMA State_observed_mim;

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Foundation_state_definition_mim;    -- ISO/TS 10303-1469

USE FROM management_resources_schema   -- ISO 10303-41
  (identification_role); 

USE FROM State_definition_mim;    -- ISO/TS 10303-1255

USE FROM state_observed_schema   -- ISO 10303-56
  (ascribable_state,
   ascribable_state_relationship,
   state_definition_to_state_assignment_relationship,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_observed_role); 


TYPE state_observed_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (state_observed, 
    state_observed_assignment, 
    state_observed_relationship);
END_TYPE; 

TYPE state_observed_of_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_state_observed_assignment
  SUBTYPE OF (state_observed_assignment);
  items : SET[1:?] OF state_observed_of_item;
END_ENTITY;

ENTITY state_predicted
  SUBTYPE OF (state_observed);
END_ENTITY;

END_SCHEMA;  -- State_observed_mim



--
-- STATE_OBSERVED_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/state_observed_schema/state_observed_schema.exp)
--
(*
ISO 10303 TC184/SC4/WG12 N11073

EXPRESS Source:
ISO 10303-56 ed3 State - State observed schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2023  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-56 ed2 State - State observed schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA state_observed_schema '{iso standard 10303 part(56) version(3) object(1) state_observed_schema(2)}';

REFERENCE FROM basic_attribute_schema	--ISO 10303-41
	(get_id_value,
	id_attribute,
	id_attribute_select
	);
	
REFERENCE FROM state_type_schema   -- ISO 10303-56
  (state_type); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 

  TYPE sos_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    ascribable_state_relationship);
  END_TYPE;

ENTITY ascribable_state;
  name : label;
  description : OPTIONAL text;
  pertaining_state_type : state_type;
  ascribed_state_observed : state_observed;
END_ENTITY;

ENTITY ascribable_state_relationship;
  name : label;
  description : OPTIONAL text;
  relating_ascribable_state : ascribable_state;
  related_ascribable_state 	: ascribable_state;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY state_definition_to_state_assignment_relationship
	SUBTYPE of (ascribable_state_relationship);
	relation_type : STRING;
WHERE
	WR1: acyclic_state_definition_to_state_assignment_relationship(SELF, [SELF\ascribable_state_relationship.related_ascribable_state], 'STATE_OBSERVED_SCHEMA.STATE_DEFINITION_TO_STATE_ASSIGNMENT_RELATIONSHIP');
END_ENTITY;

ENTITY hypothesis_state_to_confirmation_state_relationship
	SUBTYPE of (state_definition_to_state_assignment_relationship);
	confirmed_state 	: ascribable_state;							
	hypothesized_state	: ascribable_state;	
WHERE
	WR1: acyclic_hypothesis_state_to_confirmation_state_relationship(SELF, [confirmed_state], 'STATE_OBSERVED_SCHEMA.HYPOTHESIS_STATE_TO_CONFIRMATION_STATE_RELATIONSHIP');				
END_ENTITY;

ENTITY state_observed;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY state_observed_assignment
  ABSTRACT SUPERTYPE ;
  assigned_state_observed : state_observed;
  role : state_observed_role;
END_ENTITY;

ENTITY state_observed_relationship;
  name : label;
  description : OPTIONAL text;
  relating_state_observed : SET[1:?] OF state_observed;
  related_state_observed : SET[1:?] OF state_observed;
END_ENTITY;

ENTITY state_observed_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

FUNCTION acyclic_state_definition_to_state_assignment_relationship
   (relation          : state_definition_to_state_assignment_relationship;
    relatives         : SET [1:?] OF ascribable_state;
    specific_relation : STRING) : LOGICAL;
   LOCAL
     x                : SET OF ascribable_state_relationship;
   END_LOCAL;
   IF relation.relating_ascribable_state IN
             relatives THEN
     RETURN (FALSE);
   END_IF;             -- IN is based in instance equality
   x := QUERY (sdtsar <* bag_to_set (USEDIN
        (relation.relating_ascribable_state,
         'STATE_OBSERVED_SCHEMA.' +
         'ASCRIBABLE_STATE_RELATIONSHIP.' +
         'RELATED_ASCRIBABLE_STATE')) |
          specific_relation IN TYPEOF (sdtsar));
   REPEAT I := 1 TO HIINDEX(x);             -- pre-checked loop
     IF NOT acyclic_state_definition_to_state_assignment_relationship
       (x[i],
        relatives + relation.relating_ascribable_state,
        specific_relation) THEN
       RETURN(FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);
 END_FUNCTION;
 
 FUNCTION acyclic_hypothesis_state_to_confirmation_state_relationship
   (relation          : hypothesis_state_to_confirmation_state_relationship;
    relatives         : SET [1:?] OF ascribable_state;
    specific_relation : STRING) : LOGICAL;
   LOCAL
     x                : SET OF hypothesis_state_to_confirmation_state_relationship;
   END_LOCAL;
   IF relation.confirmed_state IN
             relatives THEN
     RETURN (FALSE);
   END_IF;             -- IN is based in instance equality
   x := QUERY (hstcsr <* bag_to_set (USEDIN
        (relation.confirmed_state,
         'STATE_OBSERVED_SCHEMA.' +
         'HYPOTHESIS_STATE_TO_CONFIRMATION_STATE_RELATIONSHIP.' +
         'HYPOTHESIZED_STATE')) |
          specific_relation IN TYPEOF (hstcsr));
   REPEAT I := 1 TO HIINDEX(x);             -- pre-checked loop
     IF NOT acyclic_hypothesis_state_to_confirmation_state_relationship
       (x[i],
        relatives + relation.confirmed_state,
        specific_relation) THEN
       RETURN(FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);
 END_FUNCTION;

END_SCHEMA;  -- state_observed_schema


--
-- STATE_TYPE_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/state_type_schema/state_type_schema.exp)
--
(*
Id: state_type_schema.exp,v 1.16 2014/03/04 00:30:42 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N3207

EXPRESS Source:
ISO 10303-56 ed1 State - State type schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-56 ed1 State - State type schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA state_type_schema '{iso standard 10303 part(56) version(1) object(1) state_type_schema(1)}';

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (label,
   text); 


ENTITY state_type;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY state_type_assignment
  ABSTRACT SUPERTYPE ;
  assigned_state_type : state_type;
  role : state_type_role;
END_ENTITY;

ENTITY state_type_relationship;
  name : label;
  description : OPTIONAL text;
  relating_state_type : SET[1:?] OF state_type;
  related_state_type : SET[1:?] OF state_type;
END_ENTITY;

ENTITY state_type_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

END_SCHEMA;  -- state_type_schema


--
-- STRUCTURAL_RESPONSE_DEFINITION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/structural_response_definition_schema/structural_response_definition_schema.exp)
--
(*
Id: structural_response_definition_schema.exp,v 1.3 2015/06/29 19:35:10 dgnedwards Exp $ 
ISO 10303 TC184/SC4/WG12 N0550

EXPRESS Source:
ISO 10303-104 ed1 Finite element analysis - Structural response definition schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-104 ed1 Finite element analysis - Structural response definition schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA structural_response_definition_schema '{iso standard 10303 part(104) version(1) object(1) structural_response_definition_schema(3)}';

  REFERENCE FROM product_property_definition_schema
      (property_definition,
       shape_aspect);

ENTITY structural_response_property
  SUBTYPE OF (property_definition);
END_ENTITY;

ENTITY fea_model_definition
  SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY node_definition
  SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY element_definition
  SUBTYPE OF (shape_aspect);
END_ENTITY;

END_SCHEMA; -- structural_response_definition_schema


--
-- STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/structural_response_representation_schema/structural_response_representation_schema.exp)
--
(*
Id: structural_response_representation_schema.exp,v 1.15 2019/05/07 13:05:17 kevin Exp 
ISO 10303 TC184/SC4/WG12 N10058

EXPRESS Source:
ISO 10303-104 ed2 Finite element analysis - Structural response representation schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2019  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-104 ed2 Finite element analysis - Structural response representation schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA structural_response_representation_schema '{iso standard 10303 part(104) version(4) object(1) structural_response_representation_schema(4)}';

  REFERENCE FROM fea_scalar_vector_tensor_schema   -- ISO 10303-104
      (scalar,
       symmetric_tensor2_2d,
       symmetric_tensor2_3d,
       symmetric_tensor4_2d,
       symmetric_tensor4_3d);

  REFERENCE FROM finite_element_analysis_control_and_result_schema   -- ISO 10303-104
      (curve_element_variable,
       measure_or_unspecified_value,
       surface_2d_edge,
       surface_2d_face,
       surface_3d_edge,
       surface_3d_face,
       surface_element_variable,
       volume_2d_edge,
       volume_2d_face,
       volume_3d_edge,
       volume_3d_face,
       volume_variable);

  REFERENCE FROM geometric_model_schema    -- ISO 10303-42
      (solid_model);

  REFERENCE FROM geometry_schema    -- ISO 10303-42
      (axis2_placement_2d,
       axis2_placement_3d,
       cartesian_point,
       cross_product,
       curve,
       cylindrical_point,
       degenerate_pcurve,
       direction,
       geometric_representation_context,
       geometric_representation_item,
       normalise,
       point,
       point_on_curve,
       point_on_surface,
       point_replica,
       spherical_point,
       surface);

  REFERENCE FROM group_schema    -- ISO 10303-41
      (group,
       group_relationship);

  REFERENCE FROM material_property_definition_schema    -- ISO 10303-45
      (material_property);

  REFERENCE FROM material_property_representation_schema    -- ISO 10303-45
      (material_property_representation);

  REFERENCE FROM measure_schema    -- ISO 10303-41
      (context_dependent_measure,
       length_measure,
       parameter_value,
       plane_angle_measure,
       thermodynamic_temperature_measure);

  REFERENCE FROM product_property_representation_schema    -- ISO 10303-41
      (property_definition_representation);

  REFERENCE FROM representation_schema    -- ISO 10303-43
      (representation,
       representation_item,
       representation_relationship,
       using_representations);

  REFERENCE FROM structural_response_definition_schema   -- ISO 10303-104
      (element_definition,
       fea_model_definition,
       node_definition,
       structural_response_property);

  REFERENCE FROM support_resource_schema    -- ISO 10303-41
      (identifier,
       label,
       text);

TYPE axi_or_plane = ENUMERATION OF
  (axisymmetric,
   planar);
END_TYPE;

TYPE coordinate_system_type = ENUMERATION OF
     (cartesian,
      cylindrical,
      spherical);
END_TYPE;

TYPE element_order = ENUMERATION OF
     (linear,
      quadratic,
      cubic);
END_TYPE;

TYPE plane_2d_element_purpose = SELECT
     (enumerated_plane_2d_element_purpose,
      application_defined_element_purpose);
END_TYPE;

TYPE enumerated_plane_2d_element_purpose = ENUMERATION OF
     (plane_stress,
      plane_strain);
END_TYPE;

TYPE application_defined_element_purpose = STRING;
END_TYPE;

TYPE volume_element_purpose = SELECT
     (enumerated_volume_element_purpose,
      application_defined_element_purpose);
END_TYPE;

TYPE enumerated_volume_element_purpose = ENUMERATION OF
     (stress_displacement);
END_TYPE;

TYPE surface_element_purpose = SELECT
     (enumerated_surface_element_purpose,
      application_defined_element_purpose);
END_TYPE;

TYPE enumerated_surface_element_purpose = ENUMERATION OF
     (membrane_direct,
      membrane_shear,
      bending_direct,
      bending_torsion,
      normal_to_plane_shear);
END_TYPE;

TYPE curve_element_purpose = SELECT
     (enumerated_curve_element_purpose,
      application_defined_element_purpose);
END_TYPE;

TYPE enumerated_curve_element_purpose = ENUMERATION OF
     (axial,
      y_y_bending,
      z_z_bending,
      torsion,
      x_y_shear,
      x_z_shear,
      warping);
END_TYPE;

TYPE volume_3d_element_shape = ENUMERATION OF
     (hexahedron,
      wedge,
      tetrahedron,
      pyramid);
END_TYPE;

TYPE element_2d_shape = ENUMERATION OF
     (quadrilateral,
      triangle);
END_TYPE;

TYPE matrix_property_type = SELECT
  (enumerated_matrix_property_type,
   application_defined_matrix_property_type);
END_TYPE;

TYPE enumerated_matrix_property_type = ENUMERATION OF
     (stiffness,
      mass,
      damping);
END_TYPE;

TYPE application_defined_matrix_property_type = STRING;
END_TYPE;

TYPE surface_matrix_property_type = SELECT
  (enumerated_surface_matrix_property_type,
   application_defined_matrix_property_type);
END_TYPE;

TYPE enumerated_surface_matrix_property_type = ENUMERATION OF
     (membrane_direct,
      membrane_shear,
      bending_direct,
      bending_torsion,
      normal_to_plane_shear,
      membrane_direct_mass,
      membrane_shear_mass,
      bending_direct_mass,
      bending_torsion_mass,
      normal_to_plane_shear_mass,
      mass);
END_TYPE;

TYPE curve_matrix_property_type = SELECT
  (enumerated_curve_matrix_property_type,
   application_defined_matrix_property_type);
END_TYPE;

TYPE enumerated_curve_matrix_property_type = ENUMERATION OF
     (axial,
      y_y_bending,
      z_z_bending,
      torsion,
      x_y_shear,
      x_z_shear,
      warping,
      axial_mass,
      y_y_bending_mass,
      z_z_bending_mass,
      torsion_mass,
      x_y_shear_mass,
      x_z_shear_mass,
      warping_mass,
      mass);
END_TYPE;

TYPE matrix_symmetry = ENUMERATION OF
     (symmetric,
      diagonal);
END_TYPE;

TYPE degree_of_freedom = SELECT
  (enumerated_degree_of_freedom,
   application_defined_degree_of_freedom);
END_TYPE;

TYPE enumerated_degree_of_freedom = ENUMERATION OF
     (x_translation, y_translation, z_translation,
      x_rotation, y_rotation, z_rotation,
      warp);
END_TYPE;

TYPE application_defined_degree_of_freedom = STRING;
END_TYPE;

TYPE curve_element_freedom = SELECT
     (enumerated_curve_element_freedom,
      application_defined_degree_of_freedom);
END_TYPE;

TYPE enumerated_curve_element_freedom = ENUMERATION OF
     (x_translation, y_translation, z_translation,
      x_rotation, y_rotation, z_rotation,
      warp,
      none);
END_TYPE;

TYPE integration_rule = ENUMERATION OF
     (gaussian,
      simpson);
END_TYPE;

TYPE shape_function = ENUMERATION OF
     (lagrangian_function,
      serendipity_function,
      hermitian_function,
      unspecified_function);
END_TYPE;

TYPE volume_2d_element_representation = SELECT
  (axisymmetric_volume_2d_element_representation,
   plane_volume_2d_element_representation);
END_TYPE;

TYPE surface_2d_element_representation = SELECT
  (axisymmetric_surface_2d_element_representation,
   plane_surface_2d_element_representation);
END_TYPE;

TYPE curve_2d_element_representation = SELECT
  (axisymmetric_curve_2d_element_representation,
   plane_curve_2d_element_representation);
END_TYPE;

TYPE volume_2d_element_descriptor = SELECT
     (axisymmetric_volume_2d_element_descriptor,
      plane_volume_2d_element_descriptor);
END_TYPE;

TYPE surface_2d_element_descriptor = SELECT
     (axisymmetric_surface_2d_element_descriptor,
      plane_surface_2d_element_descriptor);
END_TYPE;

TYPE curve_2d_element_descriptor = SELECT
     (axisymmetric_curve_2d_element_descriptor,
      plane_curve_2d_element_descriptor);
END_TYPE;

TYPE volume_3d_element_coordinate_system = SELECT
  (arbitrary_volume_3d_element_coordinate_system,
   parametric_volume_3d_element_coordinate_system);
END_TYPE;

TYPE volume_2d_element_coordinate_system = SELECT
  (arbitrary_volume_2d_element_coordinate_system,
   parametric_volume_2d_element_coordinate_system);
END_TYPE;

TYPE surface_3d_element_coordinate_system = SELECT
  (aligned_surface_3d_element_coordinate_system,
   parametric_surface_3d_element_coordinate_system,
   constant_surface_3d_element_coordinate_system);
END_TYPE;

TYPE surface_2d_element_coordinate_system = SELECT
  (aligned_surface_2d_element_coordinate_system,
   parametric_surface_2d_element_coordinate_system);
END_TYPE;

TYPE curve_3d_element_coordinate_system = SELECT
  (aligned_curve_3d_element_coordinate_system,
   parametric_curve_3d_element_coordinate_system);
END_TYPE;

TYPE curve_element_end_coordinate_system = SELECT
     (fea_axis2_placement_3d,
      curve_3d_element_coordinate_system);
END_TYPE;

TYPE directionally_explicit_element_coordinate_system = SELECT
  (directionally_explicit_element_coordinate_system_arbitrary,
   directionally_explicit_element_coordinate_system_aligned);
END_TYPE;

TYPE element_aspect = SELECT
     (element_volume,
      volume_3d_face,
      volume_2d_face,
      volume_3d_edge,
      volume_2d_edge,
      surface_3d_face,
      surface_2d_face,
      surface_3d_edge,
      surface_2d_edge,
      curve_edge);
END_TYPE;

TYPE element_volume = ENUMERATION OF
     (volume);
END_TYPE;

TYPE curve_edge = ENUMERATION OF
     (element_edge);
END_TYPE;

TYPE node_or_node_group = SELECT
     (node_representation,
      node_group);
END_TYPE;

TYPE element_or_element_group = SELECT
     (element_representation,
      element_group);
END_TYPE;

ENTITY fea_model
  SUPERTYPE OF (ONEOF(fea_model_2d,
                      fea_model_3d))
  SUBTYPE OF (representation);
  creating_software         : text;
  intended_analysis_code    : SET [1:?] OF text;
  analysis_type             : text;
UNIQUE
  UR1:  SELF\representation.name;
END_ENTITY;

ENTITY fea_model_3d
  SUBTYPE OF (fea_model);
WHERE
  WR1: SELF\representation.context_of_items\
       geometric_representation_context.coordinate_space_dimension = 3;
END_ENTITY;

ENTITY fea_model_2d
  SUBTYPE OF (fea_model);
  type_of_2d_analysis       : axi_or_plane;
WHERE
  WR1: SELF\representation.context_of_items\
       geometric_representation_context.coordinate_space_dimension = 2;
END_ENTITY;

ENTITY structural_response_property_definition_representation
  SUBTYPE OF (property_definition_representation);
WHERE
  WR1: (('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
         'STRUCTURAL_RESPONSE_PROPERTY') IN TYPEOF 
         (SELF\property_definition_representation.definition));
  WR2: ((('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.FEA_MODEL'
        IN TYPEOF 
        (SELF\property_definition_representation.used_representation))
        AND
        ('STRUCTURAL_RESPONSE_DEFINITION_SCHEMA.FEA_MODEL_DEFINITION'
        IN TYPEOF 
        (SELF\property_definition_representation.definition.definition)))
       OR
      (('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.ELEMENT_REPRESENTATION'
        IN TYPEOF 
        (SELF\property_definition_representation.used_representation))
        AND
        ('STRUCTURAL_RESPONSE_DEFINITION_SCHEMA.ELEMENT_DEFINITION'
        IN TYPEOF 
        (SELF\property_definition_representation.definition.definition)))
       OR
      (('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.NODE_REPRESENTATION'
        IN TYPEOF 
        (SELF\property_definition_representation.used_representation))
        AND
        ('STRUCTURAL_RESPONSE_DEFINITION_SCHEMA.NODE_DEFINITION'
        IN TYPEOF 
        (SELF\property_definition_representation.definition.definition))));
END_ENTITY;

ENTITY fea_representation_item
  SUPERTYPE OF (ONEOF
               (arbitrary_volume_3d_element_coordinate_system,
                parametric_volume_3d_element_coordinate_system,
                arbitrary_volume_2d_element_coordinate_system,
                parametric_volume_2d_element_coordinate_system,
                aligned_surface_3d_element_coordinate_system,
                parametric_surface_3d_element_coordinate_system,
                constant_surface_3d_element_coordinate_system,
                aligned_surface_2d_element_coordinate_system,
                parametric_surface_2d_element_coordinate_system,
                aligned_curve_3d_element_coordinate_system,
                parametric_curve_3d_element_coordinate_system,
                parametric_curve_3d_element_coordinate_direction,
                curve_2d_element_coordinate_system,
                directionally_explicit_element_coordinate_system_arbitrary,
                directionally_explicit_element_coordinate_system_aligned,
                fea_parametric_point))
  SUBTYPE OF (representation_item);
END_ENTITY;

ENTITY direction_node
  SUBTYPE OF (direction);
  node_1                    : node_representation;
  node_2                    : node_representation;
DERIVE
  SELF\direction.direction_ratios : LIST [2:3] OF REAL := 
                                    build_direction_node (node_1, node_2);
WHERE
  WR1: SIZEOF (QUERY(item <* node_1\representation.items |
              'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF (item))) = 1;
  WR2: SIZEOF (QUERY(item <* node_2\representation.items |
              'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF (item))) = 1;
  WR3: NOT ((direction_ratios[1] = 0.0) AND
            (direction_ratios[2] = 0.0) AND
            (direction_ratios[3] = 0.0));
END_ENTITY;

ENTITY fea_axis2_placement_2d
  SUBTYPE OF (axis2_placement_2d);
  system_type               : coordinate_system_type;
  description               : text;
END_ENTITY;

ENTITY fea_axis2_placement_3d
  SUBTYPE OF (axis2_placement_3d);
  system_type               : coordinate_system_type;
  description               : text;
END_ENTITY;

ENTITY node_set
  SUBTYPE OF (geometric_representation_item);
  nodes                     : SET [1:?] OF node_representation;
WHERE
  WR1: SIZEOF (QUERY (tmp <* nodes | 
               tmp\representation.context_of_items :<>:
               nodes[1]\representation.context_of_items)) = 0;
END_ENTITY;

ENTITY analysis_item_within_representation;
  name                      : label;
  description               : text;
  item                      : representation_item;
  rep                       : representation;
WHERE
  WR1: SIZEOF (QUERY (tmp <* using_representations(item) | 
                      tmp :=: rep)) = 1;
END_ENTITY;

ENTITY node_geometric_relationship;
  node_ref                  : node_or_node_group;
  item                      : analysis_item_within_representation;
WHERE
  WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item);
END_ENTITY;

ENTITY element_geometric_relationship;
  element_ref               : element_or_element_group;
  item                      : analysis_item_within_representation;
  aspect                    : element_aspect;
WHERE
  WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item);
  WR2: consistent_geometric_reference (aspect, item.item);
  WR3: consistent_element_or_group_reference (aspect, element_ref);
END_ENTITY;

ENTITY node_representation
  SUPERTYPE OF (ONEOF
                     (node,
                      dummy_node,
                      geometric_node))
  SUBTYPE OF (representation);
  model_ref                 : fea_model;
UNIQUE
  UR1: model_ref, SELF\representation.name;
END_ENTITY;

ENTITY node
  SUPERTYPE OF (node_with_vector ANDOR
                node_with_solution_coordinate_system)
  SUBTYPE OF (node_representation);
WHERE
  WR1: SIZEOF (QUERY(item <* SELF\representation.items |
              'GEOMETRY_SCHEMA.POINT' 
              IN TYPEOF (item))) = 1;
END_ENTITY;

ENTITY node_with_vector
  SUBTYPE OF (node);
WHERE
  WR1: SIZEOF (QUERY(item <* SELF\representation.items |
              'GEOMETRY_SCHEMA.DIRECTION' 
              IN TYPEOF (item))) = 1;
END_ENTITY;

ENTITY node_with_solution_coordinate_system
  SUBTYPE OF (node);
WHERE
  WR1: ( (SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'FEA_AXIS2_PLACEMENT_3D' 
              IN TYPEOF (item))) = 1)
          AND
          (SELF\representation.context_of_items\
       geometric_representation_context.coordinate_space_dimension = 3) )
     OR
       ( (SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'FEA_AXIS2_PLACEMENT_2D' 
              IN TYPEOF (item))) = 1)
          AND
          (SELF\representation.context_of_items\
       geometric_representation_context.coordinate_space_dimension = 2) );
END_ENTITY;

ENTITY dummy_node
  SUBTYPE OF (node_representation);
END_ENTITY;

ENTITY geometric_node
  SUBTYPE OF (node_representation);
WHERE
  WR1: SIZEOF (QUERY(item <* SELF\representation.items |
              'GEOMETRY_SCHEMA.POINT' 
              IN TYPEOF (item))) = 1;
END_ENTITY;

ENTITY substructure_node_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: 'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.NODE_REPRESENTATION' 
        IN TYPEOF (SELF\representation_relationship.rep_1);
  WR2: 'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.NODE_REPRESENTATION' 
        IN TYPEOF (SELF\representation_relationship.rep_2);
END_ENTITY;

ENTITY element_representation
  SUPERTYPE OF (ONEOF(volume_3d_element_representation,
                      axisymmetric_volume_2d_element_representation,
                      plane_volume_2d_element_representation,
                      surface_3d_element_representation,
                      axisymmetric_surface_2d_element_representation,
                      plane_surface_2d_element_representation,
                      curve_3d_element_representation,
                      axisymmetric_curve_2d_element_representation,
                      plane_curve_2d_element_representation,
                      point_element_representation,
                      directionally_explicit_element_representation,
                      explicit_element_representation,
                      substructure_element_representation))
  SUBTYPE OF (representation);
  node_list                 : LIST [1:?] OF node_representation;
WHERE
  WR1: SIZEOF (QUERY(item <* node_list |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'GEOMETRIC_NODE' 
              IN TYPEOF (item))) = 0;
 END_ENTITY;

ENTITY volume_3d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_3d;
  element_descriptor        : volume_3d_element_descriptor;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY(item <* SELF\representation.items |
               'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
               'PARAMETRIC_VOLUME_3D_ELEMENT_COORDINATE_SYSTEM'
               IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
               'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
               'ARBITRARY_VOLUME_3D_ELEMENT_COORDINATE_SYSTEM'
               IN TYPEOF (item))) = 1;
  WR2: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR3: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_3d_nodes (
        SELF\element_representation.node_list,
        element_descriptor.shape,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;

ENTITY axisymmetric_volume_2d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_2d;
  element_descriptor        : axisymmetric_volume_2d_element_descriptor;
  angle_property            : axisymmetric_2d_element_property;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: model_ref.type_of_2d_analysis = axisymmetric;
  WR2: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'PARAMETRIC_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'ARBITRARY_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
  WR3: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR4: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_2d_nodes (
        SELF\element_representation.node_list,
        element_descriptor.shape,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;

ENTITY plane_volume_2d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_2d;
  element_descriptor        : plane_volume_2d_element_descriptor;
  depth_property            : plane_2d_element_property;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: model_ref.type_of_2d_analysis = planar;
  WR2: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'PARAMETRIC_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'ARBITRARY_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
  WR3: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR4: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_2d_nodes (
        SELF\element_representation.node_list,
        element_descriptor.shape,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;

ENTITY surface_3d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_3d;
  element_descriptor        : surface_3d_element_descriptor;
  property                  : surface_element_property;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'PARAMETRIC_SURFACE_3D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'CONSTANT_SURFACE_3D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'ALIGNED_SURFACE_3D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
  WR2: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_MEMBRANE_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_BENDING_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_SHEAR_STIFFNESS'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR3: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_2d_nodes (
        SELF\element_representation.node_list,
        element_descriptor.shape,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;

ENTITY axisymmetric_surface_2d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_2d;
  element_descriptor        : axisymmetric_surface_2d_element_descriptor;
  property                  : surface_element_property;
  angle_property            : axisymmetric_2d_element_property;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: model_ref.type_of_2d_analysis = axisymmetric;
  WR2: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'PARAMETRIC_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM'
               IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'ALIGNED_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM' 
               IN TYPEOF (item))) = 1;
  WR3: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_MEMBRANE_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_BENDING_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_SHEAR_STIFFNESS'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR4: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_1d_nodes (
        SELF\element_representation.node_list,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;

ENTITY plane_surface_2d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_2d;
  element_descriptor        : plane_surface_2d_element_descriptor;
  property                  : surface_element_property;
  depth_property            : plane_2d_element_property;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: model_ref.type_of_2d_analysis = planar;
  WR2: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'PARAMETRIC_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'ALIGNED_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM' 
              IN TYPEOF (item))) = 1;
  WR3: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_MEMBRANE_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_BENDING_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_SHEAR_STIFFNESS'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR4: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_1d_nodes (
        SELF\element_representation.node_list,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;

ENTITY curve_3d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_3d;
  element_descriptor        : curve_3d_element_descriptor;
  property                  : curve_3d_element_property;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'PARAMETRIC_CURVE_3D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'ALIGNED_CURVE_3D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
  WR2: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR3: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_1d_nodes (
        SELF\element_representation.node_list,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;

ENTITY axisymmetric_curve_2d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_2d;
  element_descriptor        : axisymmetric_curve_2d_element_descriptor;
  property                  : curve_2d_element_property;
  angle_property            : axisymmetric_2d_element_property;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: model_ref.type_of_2d_analysis = axisymmetric;
  WR2: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'CURVE_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
  WR3: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR4: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_0d_nodes (
        SELF\element_representation.node_list);
END_ENTITY;

ENTITY plane_curve_2d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_2d;
  element_descriptor        : plane_curve_2d_element_descriptor;
  property                  : curve_2d_element_property;
  depth_property            : plane_2d_element_property;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: model_ref.type_of_2d_analysis = planar;
  WR2: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'CURVE_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
  WR3: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR4: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_0d_nodes (
        SELF\element_representation.node_list);
END_ENTITY;

ENTITY element_descriptor
  SUPERTYPE OF (ONEOF (volume_3d_element_descriptor,
                       axisymmetric_volume_2d_element_descriptor,
                       plane_volume_2d_element_descriptor,
                       surface_3d_element_descriptor,
                       axisymmetric_surface_2d_element_descriptor,
                       plane_surface_2d_element_descriptor,
                       curve_3d_element_descriptor,
                       axisymmetric_curve_2d_element_descriptor,
                       plane_curve_2d_element_descriptor));
  topology_order            : element_order;
  description               : text;
END_ENTITY;

ENTITY volume_3d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF volume_element_purpose;
  shape                     : volume_3d_element_shape;
END_ENTITY;

ENTITY axisymmetric_volume_2d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF SET [1:?] OF 
                              volume_element_purpose;
  shape                     : element_2d_shape;
END_ENTITY;

ENTITY plane_volume_2d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF SET [1:?] OF 
                              volume_element_purpose;
  shape                     : element_2d_shape;
  assumption                : plane_2d_element_purpose;
END_ENTITY;

ENTITY volume_3d_element_basis;
  descriptor                : volume_3d_element_descriptor;
  variable                  : volume_variable;
  variable_order            : element_order;
  variable_shape_function   : shape_function;
  evaluation_points         : LIST [1:?] OF volume_element_location;
END_ENTITY;

ENTITY volume_2d_element_basis;
  descriptor                : volume_2d_element_descriptor;
  variable                  : volume_variable;
  variable_order            : element_order;
  variable_shape_function   : shape_function;
  evaluation_points         : LIST [1:?] OF volume_element_location;
END_ENTITY;

ENTITY surface_3d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF SET [1:?] OF 
                              surface_element_purpose;
  shape                     : element_2d_shape;
END_ENTITY;

ENTITY axisymmetric_surface_2d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF SET [1:?] OF 
                              surface_element_purpose;
END_ENTITY;

ENTITY plane_surface_2d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF SET [1:?] OF 
                              surface_element_purpose;
  assumption                : plane_2d_element_purpose;
END_ENTITY;

ENTITY surface_3d_element_basis;
  descriptor                : surface_3d_element_descriptor;
  variable                  : surface_element_variable;
  variable_order            : element_order;
  variable_shape_function   : shape_function;
  evaluation_points         : LIST [1:?] OF surface_element_location;
END_ENTITY;

ENTITY surface_2d_element_basis;
  descriptor                : surface_2d_element_descriptor;
  variable                  : surface_element_variable;
  variable_order            : element_order;
  variable_shape_function   : shape_function;
  evaluation_points         : LIST [1:?] OF surface_element_location;
END_ENTITY;

ENTITY curve_3d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF SET [1:?] OF 
                              curve_element_purpose;
END_ENTITY;

ENTITY axisymmetric_curve_2d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF SET [1:?] OF 
                              curve_element_purpose;
END_ENTITY;

ENTITY plane_curve_2d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF SET [1:?] OF 
                              curve_element_purpose;
  assumption                : plane_2d_element_purpose;
END_ENTITY;

ENTITY curve_3d_element_basis;
  descriptor                : curve_3d_element_descriptor;
  variable                  : curve_element_variable;
  variable_order            : element_order;
  variable_shape_function   : shape_function;
  evaluation_points         : LIST [1:?] OF curve_element_location;
END_ENTITY;

ENTITY curve_2d_element_basis;
  descriptor                : curve_2d_element_descriptor;
  variable                  : curve_element_variable;
END_ENTITY;

ENTITY point_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model;
  matrix_set                : SET [1:?] OF point_element_matrix;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'FEA_AXIS2_PLACEMENT_3D'
              IN TYPEOF (item))) = 1;
  FU1:  required_0d_nodes (
        SELF\element_representation.node_list);
END_ENTITY;

ENTITY point_element_matrix
  SUPERTYPE OF (ONEOF(stationary_mass,
                      grounded_spring,
                      grounded_damper));
END_ENTITY;

ENTITY stationary_mass
  SUBTYPE OF (point_element_matrix);
  mass                      : ARRAY [1:3] OF context_dependent_measure;
  moments_of_inertia        : symmetric_tensor2_3d;
  coordinate_system         : fea_axis2_placement_3d;
  offset_vector             : ARRAY [1:3] OF context_dependent_measure;
END_ENTITY;

ENTITY grounded_spring
  SUBTYPE OF (point_element_matrix);
  stiffness_coefficients    : ARRAY [1:6] OF context_dependent_measure;
END_ENTITY;

ENTITY grounded_damper
  SUBTYPE OF (point_element_matrix);
  damping_coefficients      : ARRAY [1:6] OF context_dependent_measure;
END_ENTITY;

ENTITY directionally_explicit_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model;
  systems_and_freedoms      : LIST [2:2] OF system_and_freedom;
  coefficient               : directionally_explicit_element_coefficient;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  FU1:  required_1d_nodes (
        SELF\element_representation.node_list,
        linear);
END_ENTITY;

ENTITY system_and_freedom;
  matrix_coordinate_system  : 
                     directionally_explicit_element_coordinate_system;
  freedom                   : degree_of_freedom;
END_ENTITY;

ENTITY directionally_explicit_element_coefficient;
  property_type             : matrix_property_type;
  coefficient               : context_dependent_measure;
END_ENTITY;

ENTITY explicit_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model;
  matrix                    : explicit_element_matrix;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY(item <* SELF\representation.items |
              ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'FEA_AXIS2_PLACEMENT_3D') 
              IN TYPEOF (item))) = 1;
  WR2:  SIZEOF (matrix.node_dof_list) = 
        SIZEOF (SELF\element_representation.node_list);
END_ENTITY;

ENTITY explicit_element_matrix;
  property_type             : matrix_property_type;
  symmetry                  : matrix_symmetry;
  node_dof_list             : LIST [1:?] OF LIST [1:?] OF degree_of_freedom;
  matrix_values             : LIST [1:?] OF context_dependent_measure;
WHERE
  WR1: SIZEOF (matrix_values) = number_of_terms (node_dof_list, symmetry);
END_ENTITY;

ENTITY substructure_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model;
  substructure_model_ref    : fea_model;
UNIQUE
  UR1: model_ref, SELF\representation.name;
END_ENTITY;

ENTITY aligned_axis_tolerance;
  model_ref                 : fea_model;
  tolerance                 : context_dependent_measure;
END_ENTITY;

ENTITY arbitrary_volume_3d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  coordinate_system         : fea_axis2_placement_3d;
END_ENTITY;

ENTITY parametric_volume_3d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  axis_1                    : INTEGER;
  axis_2                    : INTEGER;
  eu_angles                 : euler_angles;
WHERE
  WR1:  (axis_1 >= 1) AND (axis_1 <= 3) AND
        (axis_2 >= 1) AND (axis_2 <= 3) AND
        NOT (axis_1 = axis_2);
END_ENTITY;

ENTITY arbitrary_volume_2d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  orientation               : direction;
WHERE
  WR1: SELF\geometric_representation_item.dim=2;
END_ENTITY;

ENTITY parametric_volume_2d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  axis                      : INTEGER;
  angle                     : plane_angle_measure;
WHERE
  WR1:  (axis >= 1) AND (axis <= 2);
END_ENTITY;

ENTITY aligned_surface_3d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  coordinate_system         : fea_axis2_placement_3d;
END_ENTITY;

ENTITY parametric_surface_3d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  axis                      : INTEGER;
  angle                     : plane_angle_measure;
WHERE
  WR1:  (axis >= 1) AND (axis <= 2);
END_ENTITY;

ENTITY constant_surface_3d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  axis                      : INTEGER;
  angle                     : plane_angle_measure;
WHERE
  WR1:  (axis >= 1) AND (axis <= 2);
END_ENTITY;

ENTITY aligned_surface_2d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  orientation               : direction;
WHERE
  WR1: SELF\geometric_representation_item.dim=2;
END_ENTITY;

ENTITY parametric_surface_2d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
END_ENTITY;

ENTITY aligned_curve_3d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  coordinate_system         : fea_axis2_placement_3d;
END_ENTITY;

ENTITY parametric_curve_3d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  direction            :  parametric_curve_3d_element_coordinate_direction;
END_ENTITY;

ENTITY parametric_curve_3d_element_coordinate_direction
  SUBTYPE OF (fea_representation_item);
  orientation               : direction;
WHERE
  WR1: SELF.orientation\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY curve_2d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  orientation               : direction;
WHERE
  WR1: SELF\geometric_representation_item.dim=2;
END_ENTITY;

ENTITY directionally_explicit_element_coordinate_system_arbitrary
  SUBTYPE OF (fea_representation_item);
  arbitrary_system          : fea_axis2_placement_3d;
END_ENTITY;

ENTITY directionally_explicit_element_coordinate_system_aligned
  SUBTYPE OF (fea_representation_item);
  aligned_system            : curve_3d_element_coordinate_system;
END_ENTITY;

ENTITY euler_angles;
  angles                    : ARRAY [1:3] OF plane_angle_measure;
END_ENTITY;

ENTITY volume_3d_element_integrated_matrix;
  descriptor                : volume_3d_element_descriptor;
  property_type             : matrix_property_type;
  integration_description   : text;
END_ENTITY;

ENTITY volume_3d_element_integrated_matrix_with_definition
  SUBTYPE OF (volume_3d_element_integrated_matrix);
  integration_definition    : volume_3d_element_field_integration;
END_ENTITY;

TYPE volume_3d_element_field_integration = SELECT
  (element_integration_algebraic,
   volume_3d_element_field_integration_rule,
   volume_3d_element_field_integration_explicit);
END_TYPE;

TYPE element_integration_algebraic = ENUMERATION OF (algebraic);
END_TYPE;

ENTITY volume_3d_element_field_integration_rule;
  integration_method        : integration_rule;
  integration_order         : ARRAY [1:3] OF INTEGER;
END_ENTITY;

ENTITY volume_3d_element_field_integration_explicit;
  integration_positions_and_weights: SET [1:?] OF volume_position_weight;
END_ENTITY;

ENTITY volume_position_weight;
  integration_position      : volume_element_location;
  integration_weight        : context_dependent_measure;
END_ENTITY;

ENTITY volume_2d_element_integrated_matrix;
  descriptor                : volume_2d_element_descriptor;
  property_type             : matrix_property_type;
  integration_description   : text;
END_ENTITY;

ENTITY volume_2d_element_integrated_matrix_with_definition
  SUBTYPE OF (volume_2d_element_integrated_matrix);
  integration_definition    : volume_2d_element_field_integration;
END_ENTITY;

TYPE volume_2d_element_field_integration = SELECT
  (element_integration_algebraic,
   volume_2d_element_field_integration_rule,
   volume_2d_element_field_integration_explicit);
END_TYPE;

ENTITY volume_2d_element_field_integration_rule;
  integration_method        : integration_rule;
  integration_order         : ARRAY [1:2] OF INTEGER;
END_ENTITY;

ENTITY volume_2d_element_field_integration_explicit;
  integration_positions_and_weights: SET [1:?] OF volume_position_weight;
END_ENTITY;

ENTITY surface_3d_element_integrated_matrix;
  descriptor                : surface_3d_element_descriptor;
  property_type             : surface_matrix_property_type;
  integration_description   : text;
END_ENTITY;

ENTITY surface_3d_element_integrated_matrix_with_definition
  SUBTYPE OF (surface_3d_element_integrated_matrix);
  integration_definition    : surface_3d_element_integration;
END_ENTITY;

ENTITY surface_3d_element_integration;
  field                     : surface_3d_element_field_integration;
  section                   : surface_section_integration;
END_ENTITY;

TYPE surface_3d_element_field_integration = SELECT
  (element_integration_algebraic,
   surface_3d_element_field_integration_rule,
   surface_3d_element_field_integration_explicit);
END_TYPE;

TYPE surface_section_integration = SELECT
  (element_integration_algebraic,
   surface_section_integration_rule,
   surface_section_integration_explicit);
END_TYPE;

ENTITY surface_3d_element_field_integration_rule;
  integration_method        : integration_rule;
  integration_order         : ARRAY [1:2] OF INTEGER;
END_ENTITY;

ENTITY surface_3d_element_field_integration_explicit;
  integration_positions_and_weights: SET [1:?] OF surface_position_weight;
END_ENTITY;

ENTITY surface_position_weight;
  integration_position      : surface_element_location;
  integration_weight        : context_dependent_measure;
END_ENTITY;

ENTITY surface_section_integration_rule;
  integration_method        : integration_rule;
  integration_order         : INTEGER;
END_ENTITY;

ENTITY surface_section_integration_explicit;
  integration_positions_and_weights : SET [1:?] OF 
                                      surface_section_position_weight;
END_ENTITY;

ENTITY surface_section_position_weight;
  integration_position      : surface_section_element_location;
  integration_weight        : context_dependent_measure;
END_ENTITY;

ENTITY surface_2d_element_integrated_matrix;
  descriptor                : surface_2d_element_descriptor;
  property_type             : surface_matrix_property_type;
  integration_description   : text;
END_ENTITY;

ENTITY surface_2d_element_integrated_matrix_with_definition
  SUBTYPE OF (surface_2d_element_integrated_matrix);
  integration_definition    : surface_2d_element_integration;
END_ENTITY;

ENTITY surface_2d_element_integration;
  element_length            : surface_2d_element_length_integration;
  section                   : surface_section_integration;
END_ENTITY;

TYPE surface_2d_element_length_integration = SELECT
  (element_integration_algebraic,
   surface_2d_element_length_integration_rule,
   surface_2d_element_length_integration_explicit);
END_TYPE;

ENTITY surface_2d_element_length_integration_rule;
  integration_method        : integration_rule;
  integration_order         : INTEGER;
END_ENTITY;

ENTITY surface_2d_element_length_integration_explicit;
  integration_positions_and_weights: SET [1:?] OF surface_position_weight;
END_ENTITY;

ENTITY curve_3d_element_integrated_matrix;
  descriptor                : curve_3d_element_descriptor;
  property_type             : curve_matrix_property_type;
  integration_description   : text;
END_ENTITY;

ENTITY curve_3d_element_integrated_matrix_with_definition
  SUBTYPE OF (curve_3d_element_integrated_matrix);
  integration_definition    : curve_3d_element_integration;
END_ENTITY;

ENTITY curve_3d_element_integration;
  element_length            : curve_3d_element_length_integration;
  section                   : curve_section_integration_explicit;
END_ENTITY;

TYPE curve_3d_element_length_integration = SELECT
  (element_integration_algebraic,
   curve_3d_element_length_integration_rule,
   curve_3d_element_length_integration_explicit);
END_TYPE;

ENTITY curve_3d_element_length_integration_rule;
  integration_method        : integration_rule;
  integration_order         : INTEGER;
END_ENTITY;

ENTITY curve_3d_element_length_integration_explicit;
  integration_positions_and_weights: SET [1:?] OF 
                                     curve_3d_element_position_weight;
END_ENTITY;

ENTITY curve_3d_element_position_weight;
  integration_position      : curve_volume_element_location;
  integration_weight        : context_dependent_measure;
END_ENTITY;

ENTITY curve_section_integration_explicit;
  integration_positions     : SET [1:?] OF curve_section_element_location;
END_ENTITY;

ENTITY curve_2d_element_integrated_matrix;
  descriptor                : curve_2d_element_descriptor;
  property_type             : curve_matrix_property_type;
  integration_description   : text;
END_ENTITY;

ENTITY curve_2d_element_integrated_matrix_with_definition
  SUBTYPE OF (curve_2d_element_integrated_matrix);
  integration_definition    : curve_2d_element_integration;
END_ENTITY;

ENTITY curve_2d_element_integration;
  section                   : LIST [1:?] OF curve_section_element_location;
END_ENTITY;

ENTITY fea_parametric_point
  SUBTYPE OF(fea_representation_item);
    coordinates  : LIST [1 : 3] OF parameter_value;
  WHERE
    wr1: valid_parametric_coordinate( coordinates );
END_ENTITY;

ENTITY volume_element_location;
  coordinates               : fea_parametric_point;
END_ENTITY;

ENTITY surface_volume_element_location;
  field_location            : surface_element_location;
  section_location          : surface_section_element_location;
END_ENTITY;

ENTITY surface_element_location;
  coordinates               : fea_parametric_point;
END_ENTITY;

ENTITY surface_section_element_location
  SUPERTYPE OF (ONEOF (surface_section_element_location_absolute,
                       surface_section_element_location_dimensionless));
  above_material_discontinuity : LOGICAL;
END_ENTITY;

ENTITY surface_section_element_location_absolute
  SUBTYPE OF (surface_section_element_location);
  offset                    : context_dependent_measure;
END_ENTITY;

ENTITY surface_section_element_location_dimensionless
  SUBTYPE OF (surface_section_element_location);
  coordinate                : LIST [1:1] OF parameter_value;
WHERE
  WR1: valid_parametric_coordinate (coordinate);
END_ENTITY;

ENTITY curve_volume_element_location;
  field_location            : curve_element_location;
  section_location          : curve_section_element_location;
END_ENTITY;

ENTITY curve_element_location;
  coordinate                : fea_parametric_point;
END_ENTITY;

ENTITY curve_section_element_location;
  offsets                   : ARRAY [1:2] of context_dependent_measure;
END_ENTITY;

ENTITY element_material;
  material_id               : identifier;
  description               : text;
  properties                : SET [1:?] OF material_property_representation;
END_ENTITY;

ENTITY fea_material_property_geometric_relationship;
  material_ref              : fea_material_property_representation;
  item                      : analysis_item_within_representation;
WHERE
  WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item);
END_ENTITY;

ENTITY fea_material_property_representation
  SUBTYPE OF (material_property_representation);
WHERE
  WR1: SIZEOF (QUERY (item <* 
       SELF\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_MEMBRANE_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_BENDING_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_SHEAR_STIFFNESS'] * TYPEOF (item)
                  ) = 1
       )) = 1;
  WR2: 'MATERIAL_PROPERTY_DEFINITION_SCHEMA.MATERIAL_PROPERTY' IN 
       TYPEOF (SELF\property_definition_representation.definition);
END_ENTITY;

ENTITY fea_material_property_representation_item
  SUPERTYPE OF (ONEOF (fea_linear_elasticity,
                   fea_mass_density,
                   fea_area_density,
                   fea_tangential_coefficient_of_linear_thermal_expansion,
                   fea_secant_coefficient_of_linear_thermal_expansion,
                   fea_moisture_absorption,
                   fea_shell_membrane_stiffness,
                   fea_shell_bending_stiffness,
                   fea_shell_membrane_bending_coupling_stiffness,
                   fea_shell_shear_stiffness))
  SUBTYPE OF (representation_item);
END_ENTITY;

ENTITY fea_linear_elasticity
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constants             : symmetric_tensor4_3d;
END_ENTITY;

ENTITY fea_mass_density
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constant              : scalar;
END_ENTITY;

ENTITY fea_area_density
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constant              : scalar;
END_ENTITY;

ENTITY fea_tangential_coefficient_of_linear_thermal_expansion
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constants             : symmetric_tensor2_3d;
END_ENTITY;

ENTITY fea_secant_coefficient_of_linear_thermal_expansion
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constants             : symmetric_tensor2_3d;
  reference_temperature     : thermodynamic_temperature_measure;
END_ENTITY;

ENTITY fea_moisture_absorption
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constants             : symmetric_tensor2_3d;
END_ENTITY;

ENTITY fea_shell_membrane_stiffness
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constants             : symmetric_tensor4_2d;
END_ENTITY;

ENTITY fea_shell_bending_stiffness
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constants             : symmetric_tensor4_2d;
END_ENTITY;

ENTITY fea_shell_membrane_bending_coupling_stiffness
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constants             : symmetric_tensor4_2d;
END_ENTITY;

ENTITY fea_shell_shear_stiffness
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constants             : symmetric_tensor2_2d;
END_ENTITY;

ENTITY surface_element_property;
  property_id               : identifier;
  description               : text;
  section                   : surface_section_field;
END_ENTITY;

ENTITY surface_section_field
  SUPERTYPE OF (ONEOF (surface_section_field_constant,
                       surface_section_field_varying));
END_ENTITY;

ENTITY surface_section_field_constant
  SUBTYPE OF (surface_section_field);
  definition                : surface_section;
END_ENTITY;

ENTITY surface_section_field_varying
  SUBTYPE OF (surface_section_field);
  definitions               : LIST [1:?] OF surface_section;
  additional_node_values    : BOOLEAN;
END_ENTITY;

ENTITY surface_section
  SUPERTYPE OF (ONEOF (uniform_surface_section,
                       uniform_surface_section_layered));
  offset                     : measure_or_unspecified_value;
  non_structural_mass        : measure_or_unspecified_value;
  non_structural_mass_offset : measure_or_unspecified_value;
END_ENTITY;

ENTITY uniform_surface_section
  SUBTYPE OF (surface_section);
  thickness                 : context_dependent_measure;
  bending_thickness         : measure_or_unspecified_value;
  shear_thickness           : measure_or_unspecified_value;
END_ENTITY;

ENTITY uniform_surface_section_layered
  SUBTYPE OF (surface_section);
END_ENTITY;

ENTITY fea_surface_section_geometric_relationship;
  section_ref               : surface_section;
  item                      : analysis_item_within_representation;
WHERE
  WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item);
END_ENTITY;

ENTITY curve_3d_element_property;
  property_id               : identifier;
  description               : text;
  interval_definitions      : LIST [1:?] OF curve_element_interval;
  end_offsets               : ARRAY [1:2] OF curve_element_end_offset;
  end_releases              : ARRAY [1:2] OF curve_element_end_release;
END_ENTITY;

ENTITY curve_element_interval
  SUPERTYPE OF (ONEOF (curve_element_interval_constant,
                       curve_element_interval_linearly_varying));
  finish_position           : curve_element_location;
  eu_angles                 : euler_angles;
END_ENTITY;

ENTITY curve_element_interval_constant
  SUBTYPE OF (curve_element_interval);
  section                : curve_element_section_definition;
END_ENTITY;

ENTITY curve_element_interval_linearly_varying
  SUBTYPE OF (curve_element_interval);
  sections               : ARRAY [1:2] OF curve_element_section_definition;
END_ENTITY;

ENTITY curve_2d_element_property;
  property_id               : identifier;
  description               : text;
  section                   : curve_element_section_definition;
END_ENTITY;

ENTITY curve_element_section_definition
  SUPERTYPE OF (curve_element_section_derived_definitions);
  description               : text;
  section_angle             : plane_angle_measure;
END_ENTITY;

ENTITY curve_element_section_derived_definitions
  SUBTYPE OF (curve_element_section_definition);
  cross_sectional_area      : context_dependent_measure;
  shear_area                : ARRAY [1:2] OF measure_or_unspecified_value;
  second_moment_of_area     : ARRAY [1:3] OF context_dependent_measure;
  torsional_constant        : context_dependent_measure;
  warping_constant          : measure_or_unspecified_value;
  location_of_centroid      : ARRAY [1:2] OF measure_or_unspecified_value;
  location_of_shear_centre  : ARRAY [1:2] OF measure_or_unspecified_value;
  location_of_non_structural_mass
                            : ARRAY [1:2] OF measure_or_unspecified_value;
  non_structural_mass       : measure_or_unspecified_value;
  polar_moment              : measure_or_unspecified_value;
END_ENTITY;

ENTITY fea_curve_section_geometric_relationship;
  section_ref               : curve_element_section_definition;
  item                      : analysis_item_within_representation;
WHERE
  WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item);
END_ENTITY;

ENTITY curve_element_end_offset;
  coordinate_system         : curve_element_end_coordinate_system;
  offset_vector             : ARRAY [1:3] OF context_dependent_measure;
END_ENTITY;

ENTITY curve_element_end_release;
  coordinate_system        : curve_element_end_coordinate_system;
  releases                 : LIST [1:?] OF curve_element_end_release_packet;
END_ENTITY;

ENTITY curve_element_end_release_packet;
  release_freedom           : curve_element_freedom;
  release_stiffness         : context_dependent_measure;
END_ENTITY;

ENTITY axisymmetric_2d_element_property;
  angle                     : plane_angle_measure;
END_ENTITY;

ENTITY plane_2d_element_property
  SUPERTYPE OF (simple_plane_2d_element_property);
  depth                     : context_dependent_measure;
END_ENTITY;

ENTITY simple_plane_2d_element_property
  SUBTYPE OF (plane_2d_element_property);
END_ENTITY;

ENTITY fea_group
  SUPERTYPE OF (ONEOF(element_group,
                      node_group))
  SUBTYPE OF (group);
  model_ref                 : fea_model;
END_ENTITY;

ENTITY element_group
  SUBTYPE OF (fea_group);
  elements                  : SET [1:?] OF element_representation;
END_ENTITY;

ENTITY node_group
  SUBTYPE OF (fea_group);
  nodes                     : SET [1:?] OF node_representation;
END_ENTITY;

ENTITY fea_group_relation
  SUBTYPE OF (group_relationship);
WHERE
  WR1: 'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.FEA_GROUP'
        IN TYPEOF (SELF\group_relationship.relating_group);
  WR2: 'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.FEA_GROUP'
        IN TYPEOF (SELF\group_relationship.related_group);
END_ENTITY;

ENTITY volume_3d_element_group
  SUBTYPE OF (element_group);
WHERE
  WR1: SIZEOF(query(item <* elements |
       NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
            'VOLUME_3D_ELEMENT_REPRESENTATION' IN TYPEOF (item))))=0;
END_ENTITY;

ENTITY volume_2d_element_group
  SUBTYPE OF (element_group);
WHERE
  WR1: SIZEOF(QUERY(item <* elements |
       (NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
             'AXISYMMETRIC_VOLUME_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)) AND
        NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
             'PLANE_VOLUME_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)))))=0;
END_ENTITY;

ENTITY surface_3d_element_group
  SUBTYPE OF (element_group);
WHERE
  WR1: SIZEOF(query(item <* elements |
       NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
            'SURFACE_3D_ELEMENT_REPRESENTATION' IN TYPEOF (item))))=0;
END_ENTITY;

ENTITY surface_2d_element_group
  SUBTYPE OF (element_group);
WHERE
  WR1: SIZEOF(QUERY(item <* elements |
       (NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
             'AXISYMMETRIC_SURFACE_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)) AND
        NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
             'PLANE_SURFACE_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)))))=0;
END_ENTITY;

ENTITY curve_3d_element_group
  SUBTYPE OF (element_group);
WHERE
  WR1: SIZEOF(query(item <* elements |
       NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
            'CURVE_3D_ELEMENT_REPRESENTATION' IN TYPEOF (item))))=0;
END_ENTITY;

ENTITY curve_2d_element_group
  SUBTYPE OF (element_group);
WHERE
  WR1: SIZEOF(QUERY(item <* elements |
       (NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
             'AXISYMMETRIC_CURVE_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)) AND
        NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
             'PLANE_CURVE_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)))))=0;
END_ENTITY;

FUNCTION required_0d_nodes
  (node_list                : LIST [1:?] OF node_representation): BOOLEAN;

  RETURN (SIZEOF (node_list) = 1);

END_FUNCTION;

FUNCTION required_1d_nodes
  (node_list                : LIST [1:?] OF node_representation;
   order                    : element_order) : BOOLEAN;  

  LOCAL
   end_nodes                : INTEGER;
   additional_nodes         : INTEGER;
  END_LOCAL;

  end_nodes := 2;

  IF (order = linear) THEN
    additional_nodes := 0;
  END_IF;
  IF (order = quadratic) THEN
    additional_nodes := 1;
  END_IF;
  IF (order = cubic) THEN
    additional_nodes := 2;
  END_IF;

  RETURN (SIZEOF (node_list) = end_nodes + additional_nodes);

END_FUNCTION;

FUNCTION required_2d_nodes
  (node_list                : LIST [1:?] OF node_representation;
   element_shape            : element_2d_shape;
   order                    : element_order) : BOOLEAN;
  LOCAL
    vertex_nodes            : INTEGER;
    edge_nodes              : INTEGER;
    edge_face_body_nodes    : INTEGER;
  END_LOCAL;

  IF (element_shape = element_2d_shape.triangle) THEN
    vertex_nodes := 3;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 3;
      edge_face_body_nodes := 3;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 6;
      edge_face_body_nodes := 7;
    END_IF;
  END_IF;

  IF (element_shape = element_2d_shape.quadrilateral) THEN
    vertex_nodes := 4;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 4;
      edge_face_body_nodes := 5;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 8;
      edge_face_body_nodes := 12;
    END_IF;
  END_IF;

  RETURN ((SIZEOF (node_list) = vertex_nodes + edge_nodes) OR 
          (SIZEOF (node_list) = vertex_nodes + edge_face_body_nodes));

END_FUNCTION;

FUNCTION required_3d_nodes
  (node_list                : LIST [1:?] OF node_representation;
   element_shape            : volume_3d_element_shape;
   order                    : element_order) : BOOLEAN;
  LOCAL
    vertex_nodes            : INTEGER;
    edge_nodes              : INTEGER;
    edge_face_body_nodes    : INTEGER;
  END_LOCAL;

  IF (element_shape = volume_3d_element_shape.hexahedron) THEN
    vertex_nodes := 8;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 12;
      edge_face_body_nodes := 19;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 24;
      edge_face_body_nodes := 56;
    END_IF;
  END_IF;

  IF (element_shape = volume_3d_element_shape.wedge) THEN
    vertex_nodes := 6;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 9;
      edge_face_body_nodes := 12;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 18;
      edge_face_body_nodes := 34;
    END_IF;
  END_IF;

  IF (element_shape = volume_3d_element_shape.tetrahedron) THEN
    vertex_nodes := 4;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 6;
      edge_face_body_nodes := 6;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 12;
      edge_face_body_nodes := 16;
    END_IF;
  END_IF;

  IF (element_shape = volume_3d_element_shape.pyramid) THEN
    vertex_nodes := 5;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 8;
      edge_face_body_nodes := 9;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 16;
      edge_face_body_nodes := 25;
    END_IF;
  END_IF;

  RETURN ((SIZEOF (node_list) = vertex_nodes + edge_nodes) OR 
          (SIZEOF (node_list) = vertex_nodes + edge_face_body_nodes));

END_FUNCTION;

FUNCTION number_of_terms
  (node_dof_list           : LIST [1:?] OF LIST [1:?] OF degree_of_freedom;
   matrix_type             : matrix_symmetry) : INTEGER;
  LOCAL
    num_terms              : INTEGER;
    number_of_freedoms     : INTEGER;
  END_LOCAL;

  number_of_freedoms := 0; (* loop for each item in the outer list*)

  REPEAT i := 1 TO SIZEOF (node_dof_list); (* find size of inner list*)
    number_of_freedoms := number_of_freedoms + SIZEOF (node_dof_list[i]);
  END_REPEAT;

  IF (matrix_type = symmetric) THEN
    num_terms := (number_of_freedoms * (number_of_freedoms+1)) DIV 2;
  END_IF;

  IF (matrix_type = diagonal) THEN
    num_terms := number_of_freedoms;
  END_IF;

RETURN (num_terms);

END_FUNCTION;

FUNCTION valid_parametric_coordinate
    (coordinates            :  LIST [1:3] OF parameter_value): BOOLEAN;

    LOCAL
      i                     : INTEGER;
    END_LOCAL; 

    REPEAT i:=1 TO HIINDEX(coordinates);
      IF ((1.0 < coordinates[i]) OR (coordinates[i] < -1.0)) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;

    RETURN (TRUE);

END_FUNCTION;

FUNCTION build_direction_node
    (node_1                 : node_representation;
     node_2                 : node_representation): LIST [2:3] OF REAL;

LOCAL
  nodal_direction_ratios    : LIST [2:3] OF REAL;
  u                         : direction;
  i                         : INTEGER;
  ndim                      : INTEGER;
  rep_items                 : SET [1:?] of representation_item;
  node_1_point              : cartesian_point;
  node_2_point              : cartesian_point;
END_LOCAL;

rep_items := node_1.items;
REPEAT i := 1 TO SIZEOF(rep_items);
  IF ('GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF(rep_items[i])) THEN
    node_1_point := rep_items[i];
    ESCAPE;
  END_IF; 
END_REPEAT;

rep_items := node_2.items;
REPEAT i := 1 TO SIZEOF(rep_items);
  IF ('GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF(rep_items[i])) THEN
    node_2_point := rep_items[i];
    ESCAPE;
  END_IF; 
END_REPEAT;

ndim := HIINDEX(node_2_point.coordinates);
REPEAT i := 1 TO ndim;
  u.direction_ratios[i] := node_2_point.coordinates[i] - 
                           node_1_point.coordinates[i];
END_REPEAT;

u := normalise (u);
REPEAT i := 1 TO ndim;
  nodal_direction_ratios[i] := u.direction_ratios[i];
END_REPEAT;

RETURN (nodal_direction_ratios);

END_FUNCTION;

FUNCTION consistent_geometric_reference (
  aspect                    : GENERIC;
  item                      : geometric_representation_item) : BOOLEAN;
 
LOCAL
  srrs                      : STRING;
  feacr                     : STRING;
  aspect_type               : SET [1:?] OF STRING;
  item_type                 : SET [1:?] OF STRING;
END_LOCAL;

srrs        := 'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.';
feacr       := 'FINITE_ELEMENT_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.';
aspect_type := TYPEOF (aspect);
item_type   := TYPEOF (item);

IF ('GEOMETRIC_MODEL_SCHEMA.SOLID_MODEL' IN item_type) THEN
  IF ((srrs + 'ELEMENT_VOLUME') IN aspect_type) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF (('GEOMETRY_SCHEMA.SURFACE' IN item_type) OR
    ('TOPOLOGY_SCHEMA.FACE_SURFACE' IN item_type)) THEN
  IF SIZEOF ([(feacr + 'VOLUME_3D_FACE'),
              (feacr + 'VOLUME_2D_FACE'),
              (feacr + 'SURFACE_3D_FACE'),
              (feacr + 'SURFACE_2D_FACE')] *
               aspect_type ) = 1 THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF (('GEOMETRY_SCHEMA.CURVE' IN item_type) OR
    ('TOPOLOGY_SCHEMA.EDGE_CURVE' IN item_type)) THEN
  IF SIZEOF ([(feacr + 'VOLUME_3D_EDGE'),
              (feacr + 'VOLUME_2D_EDGE'),
              (feacr + 'SURFACE_3D_EDGE'), 
              (feacr + 'SURFACE_2D_EDGE'),
              (srrs  + 'CURVE_EDGE')] *
               aspect_type ) = 1 THEN
    RETURN (TRUE);
  END_IF;
END_IF;

RETURN (FALSE);

END_FUNCTION;

FUNCTION consistent_element_or_group_reference (
  aspect                    : GENERIC;
  element                   : GENERIC) : BOOLEAN;
 
LOCAL
  srrs                      : STRING;
  i                         : INTEGER;
END_LOCAL;

srrs := 'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.';

IF ((srrs + 'ELEMENT_REPRESENTATION') IN TYPEOF(element)) THEN
  RETURN (consistent_element_reference (aspect, element));
END_IF;

IF ((srrs + 'ELEMENT_GROUP') IN TYPEOF(element)) THEN
  REPEAT i := 1 TO HIINDEX (element.elements);
    IF NOT (consistent_element_reference (aspect, element.elements[i])) 
     THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_IF;

RETURN (FALSE);

END_FUNCTION;

FUNCTION consistent_element_reference (
  aspect                    : GENERIC;
  element                   : element_representation) : BOOLEAN;

LOCAL
  srrs                      : STRING;
  feacr                     : STRING;
  aspect_type               : SET [1:?] OF STRING;
  element_type              : SET [1:?] OF STRING;
END_LOCAL;

srrs         := 'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.';
feacr        := 'FINITE_ELEMENT_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.';
aspect_type  := TYPEOF (aspect);
element_type := TYPEOF (element);

IF ((srrs + 'ELEMENT_REPRESENTATION')
    IN element_type) THEN
  IF ((srrs + 'ELEMENT_VOLUME') IN aspect_type) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF ((srrs + 'VOLUME_3D_ELEMENT_REPRESENTATION')
    IN element_type) THEN
  IF (((feacr + 'VOLUME_3D_FACE') IN aspect_type) OR
      ((feacr + 'VOLUME_3D_EDGE') IN aspect_type)) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF (((srrs + 'AXISYMMETRIC_VOLUME_2D_ELEMENT_REPRESENTATION')
     IN element_type) OR
    ((srrs + 'PLANE_VOLUME_2D_ELEMENT_REPRESENTATION') 
     IN element_type)) THEN
  IF (((feacr + 'VOLUME_2D_FACE') IN aspect_type) OR
      ((feacr + 'VOLUME_2D_EDGE') IN aspect_type)) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF ((srrs + 'SURFACE_3D_ELEMENT_REPRESENTATION')
    IN element_type) THEN
  IF (((feacr + 'SURFACE_3D_FACE') IN aspect_type) OR
      ((feacr + 'SURFACE_3D_EDGE') IN aspect_type)) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF (((srrs + 'AXISYMMETRIC_SURFACE_2D_ELEMENT_REPRESENTATION')
    IN element_type) OR
    ((srrs + 'PLANE_SURFACE_2D_ELEMENT_REPRESENTATION')
     IN element_type)) THEN
  IF (((feacr + 'SURFACE_2D_FACE') IN aspect_type) OR
      ((feacr + 'SURFACE_2D_EDGE') IN aspect_type)) THEN
  RETURN (TRUE);
  END_IF;
END_IF;

IF (((srrs + 'CURVE_3D_ELEMENT_REPRESENTATION') 
     IN element_type) OR
    ((srrs + 'AXISYMMETRIC_CURVE_2D_ELEMENT_REPRESENTATION') 
     IN element_type) OR
    ((srrs + 'PLANE_CURVE_2D_ELEMENT_REPRESENTATION') 
     IN element_type)) THEN
  IF ((srrs + 'CURVE_EDGE') IN aspect_type) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

RETURN (FALSE);

END_FUNCTION;

END_SCHEMA; -- structural_response_representation_schema


--
-- SUPPORT_RESOURCE_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/support_resource/mim.exp)
--
(*
   $Id: mim.exp,v 1.4 2012/10/11 05:49:06 liutkuviene Exp 
   ISO TC184/SC4/WG12 N8060 - ISO/TS 10303-1800 Support resource - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N7473
*)
SCHEMA Support_resource_mim;
	USE FROM support_resource_schema;
END_SCHEMA;


--
-- SUPPORT_RESOURCE_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/support_resource_schema/support_resource_schema.exp)
--
(*
Id: support_resource_schema.exp,v 1.17 2014/03/04 00:30:42 thomasrthurman Exp 
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Support resource schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Support resource schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA support_resource_schema '{iso standard 10303 part(41) version(7) object(1) support_resource_schema(22)}';
  TYPE identifier = STRING;
  END_TYPE;

  TYPE label = STRING;
  END_TYPE;

  TYPE text = STRING;
  END_TYPE;

  FUNCTION bag_to_set (the_bag : BAG OF GENERIC:intype):SET OF GENERIC:intype;
    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;

    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN (the_set);
  END_FUNCTION;

  FUNCTION type_check_function (the_type : GENERIC; sub_names : SET OF STRING; criterion : INTEGER):LOGICAL;
    IF ((NOT EXISTS(the_type)) OR (SIZEOF(sub_names) = 0)) THEN
      RETURN (UNKNOWN);
    ELSE
      CASE criterion OF 
        0: RETURN (SIZEOF(sub_names * TYPEOF(the_type)) > 0);
        1: RETURN (SIZEOF(sub_names * TYPEOF(the_type)) = 0);
        2: RETURN (SIZEOF(sub_names * TYPEOF(the_type)) = 1);
        3: RETURN (SIZEOF(sub_names * TYPEOF(the_type)) <= 1);
        OTHERWISE : RETURN (UNKNOWN);
      END_CASE;
    END_IF;
  END_FUNCTION;

END_SCHEMA;


--
-- SYSTEMS_ENGINEERING_REPRESENTATION_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/systems_engineering_representation_schema/systems_engineering_representation_schema.exp)
--
(*

ISO 10303 TC184/SC4/WG12 N10250

EXPRESS Source:
ISO 10303-61 ed2 Systems engineering representation - Systems engineering representation schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2019  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-61 ed1 Systems engineering representation - Systems engineering representation schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*) 

SCHEMA systems_engineering_representation_schema '{iso standard 10303 part(61) version(2) object(1) systems_engineering_representation_schema(1)}';

REFERENCE FROM action_schema		-- ISO 10303-41
  (action_method);
REFERENCE FROM iso13584_expressions_schema	-- ISO 13584-20
  (expression);
REFERENCE FROM management_resources_schema	-- ISO 10303-41
  (action_method_assignment);
REFERENCE FROM product_analysis_schema;		-- ISO 10303-53
REFERENCE FROM representation_schema		-- ISO 10303-43
  (representation,
   representation_context,
   representation_item);
REFERENCE FROM state_type_schema;			-- ISO 10303-53
REFERENCE FROM support_resource_schema		-- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);

TYPE analysis_model_idealisation_item = EXTENSIBLE GENERIC_ENTITY SELECT 
  (physical_product_domain);
END_TYPE;

TYPE expression_element = SELECT 
  (expression);
END_TYPE;

TYPE representation_proxy_select = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

TYPE se_representation_proxy_select = SELECT BASED_ON representation_proxy_select WITH
  (action_method,
   state_type,
   state_type_relationship);
END_TYPE;

TYPE state_based_behaviour_element = SELECT 
  (state_type,
   state_type_relationship);
END_TYPE;

ENTITY action_method_assignment_relationship;
  relating_assignment : action_method_assignment;
  related_assignment : action_method_assignment;
END_ENTITY;

ENTITY analysis_model
SUBTYPE OF (representation);
  SELF\representation.context_of_items : analysis_representation_context;
END_ENTITY;

ENTITY analysis_model_relationship;
  id : identifier;
  name : label;
  description : text;
  idealised : analysis_model;
  idealisation : analysis_model_idealisation_item;
END_ENTITY;

ENTITY analysis_representation_context
SUBTYPE OF (representation_context);
END_ENTITY;

ENTITY description_text;
  description : text;
END_ENTITY;

ENTITY description_text_assignment ABSTRACT SUPERTYPE;
  description : description_text;
END_ENTITY;

ENTITY description_text_assignment_relationship;
	id 				: OPTIONAL identifier;
	description 	: OPTIONAL text; 					
	relating 		: description_text_assignment;			
	related 		: description_text_assignment;											
	relation_type	: STRING;							
 WHERE
	WR1 : acyclic_description_text_assignment_relationship(SELF, [related], 'SYSTEMS_ENGINEERING_REPRESENTATION_SCHEMA.DESCRIPTION_TEXT_ASSIGNMENT_RELATIONSHIP');
END_ENTITY;

ENTITY expression_assignment ABSTRACT SUPERTYPE;
  assigned_expression : expression;
  role : expression_role;
END_ENTITY;

ENTITY expression_item_representation_item
SUBTYPE OF (representation_item);
  item : expression_element;
END_ENTITY;

ENTITY expression_representation
SUBTYPE OF (representation);
  SELF\representation.context_of_items : expression_representation_context;
  SELF\representation.items : SET [1 : ?] OF expression_item_representation_item;
END_ENTITY;

ENTITY expression_representation_context
SUBTYPE OF (representation_context);
END_ENTITY;

ENTITY expression_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY functional_model
SUBTYPE OF (representation);
  SELF\representation.context_of_items : functional_representation_context;
  SELF\representation.items : SET [1 : ?] OF functional_representation_item;
END_ENTITY;

ENTITY functional_representation_context
SUBTYPE OF (representation_context);
END_ENTITY;

ENTITY functional_representation_item
SUBTYPE OF (representation_proxy_item);
  SELF\representation_proxy_item.item : action_method;
END_ENTITY;

ENTITY representation_proxy_item
SUBTYPE OF (representation_item);
  item : representation_proxy_select;
END_ENTITY;

ENTITY state_based_behaviour_model
SUBTYPE OF (representation);
  SELF\representation.context_of_items : state_based_behaviour_representation_context;
  SELF\representation.items : SET [1 : ?] OF state_based_behaviour_representation_item;
END_ENTITY;

ENTITY state_based_behaviour_representation_context
SUBTYPE OF (representation_context);
END_ENTITY;

ENTITY state_based_behaviour_representation_item
SUBTYPE OF (representation_proxy_item);
  SELF\representation_proxy_item.item : state_based_behaviour_element;
END_ENTITY;

FUNCTION acyclic_description_text_assignment_relationship (relation : description_text_assignment_relationship; relatives : SET [1:?] OF description_text_assignment; specific_relation : STRING):BOOLEAN;
  LOCAL
    x : SET OF description_text_assignment_relationship;
  END_LOCAL;

  IF relation.relating IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(dtar <* bag_to_set(USEDIN(relation.relating, 'SYSTEMS_ENGINEERING_REPRESENTATION_SCHEMA.' + 'DESCRIPTION_TEXT_ASSIGNMENT_RELATIONSHIP.' + 'RELATED')) | specific_relation IN TYPEOF(dtar));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_description_text_assignment_relationship(x[i], relatives + relation.relating, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
 END_FUNCTION;

END_SCHEMA;





--
-- SYSTEM_BREAKDOWN_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/system_breakdown/mim.exp)
--
(*
 $Id: mim.exp,v 1.10 2004/11/19 21:37:41 robbod Exp 
 ISO TC184/SC4/WG12 N3179 - ISO/TS 10303-1214 System breakdown - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2301
*) 


SCHEMA System_breakdown_mim;

USE FROM Product_breakdown_mim;    -- ISO/TS 10303-1248


ENTITY system_breakdown_context
  SUBTYPE OF (breakdown_context);
END_ENTITY;

ENTITY system_element_usage
  SUBTYPE OF (breakdown_element_usage);
END_ENTITY;

END_SCHEMA;  -- System_breakdown_mim


--
-- SYSTEM_IDENTIFICATION_AND_VERSION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/system_identification_and_version/mim.exp)
--
(*
Id: mim.exp,v 1.13 2009/12/15 15:31:15 mikeward Exp 
ISO TC184/SC4/WG12 N6822 - ISO/TS 10303-1484 System identification and version - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6599
*) 


SCHEMA System_identification_and_version_mim;

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_category,
   product_definition_formation,
   product_related_product_category); 

USE FROM Product_identification_mim;    -- ISO/TS 10303-1017

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

USE FROM Product_version_relationship_mim;    -- ISO/TS 10303-1020


TYPE system_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (product, 
    product_definition_formation);
END_TYPE; 

END_SCHEMA;  -- System_identification_and_version_mim


--
-- SYSTEM_VIEW_DEFINITION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/system_view_definition/mim.exp)
--
(*
Id: mim.exp,v 1.10 2009/12/15 15:51:07 mikeward Exp 
ISO TC184/SC4/WG12 N6825 - ISO/TS 10303-1485 System view definition - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N5927
*) 


SCHEMA System_view_definition_mim;

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_category,
   product_definition,
   product_definition_formation,
   product_related_product_category); 

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019

USE FROM System_identification_and_version_mim;    -- ISO/TS 10303-1484


END_SCHEMA;  -- System_view_definition_mim



--
-- TASK_ELEMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/task_element/mim.exp)
--
(*
   $Id: mim.exp,v 1.10 2008/10/11 11:58:31 abhpf Exp 
   ISO TC184/SC4/WG12 N5930 - ISO/TS 10303-1480 Task_element - EXPRESS MIM 
   Supersedes ISO TC184/SC4/WG12 N4626
*)

SCHEMA Task_element_mim;

USE FROM Activity_method_assignment_mim;

USE FROM Condition_mim;

USE FROM measure_schema
  (count_measure);

USE FROM method_definition_schema;

USE FROM support_resource_schema
  (text);

ENTITY concurrent_task_element
SUBTYPE OF (task_element);
END_ENTITY;

ENTITY decision_point
SUBTYPE OF (action_method_to_select_from, task_element);
DERIVE
  SELF\action_method_to_select_from.number_of_elements : count_measure := 1;
  SELF\action_method.purpose : text := 'decision';
END_ENTITY;

ENTITY end_task
SUBTYPE OF (task_element);
END_ENTITY;

ENTITY exit_loop
SUBTYPE OF (task_element);
END_ENTITY;

ENTITY looping_element
SUBTYPE OF (task_element);
END_ENTITY;

ENTITY start_task
SUBTYPE OF (task_element);
END_ENTITY;

ENTITY task_element
SUBTYPE OF (action_method);
END_ENTITY;

ENTITY task_element_relationship
SUBTYPE OF (action_method_relationship);
END_ENTITY;

ENTITY task_element_sequence
SUBTYPE OF (task_element);
END_ENTITY;

ENTITY task_step
SUBTYPE OF (task_element);
END_ENTITY;

SUBTYPE_CONSTRAINT restrict_task_method_subtypes FOR task_element;
  ONEOF(concurrent_task_element, end_task, exit_loop, looping_element, task_element_sequence, task_step);
END_SUBTYPE_CONSTRAINT;

END_SCHEMA;



--
-- TASK_SPECIFICATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/task_specification/mim.exp)
--
(*
Id: mim.exp,v 1.28 2009/08/11 08:02:57 robbod Exp 
ISO TC184/SC4/WG12 N6091 - ISO/TS 10303-1262 Task specification - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N5933
*) 


SCHEMA Task_specification_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method,
   action_method_relationship); 

USE FROM Activity_method_assignment_mim;    -- ISO/TS 10303-1249

USE FROM Activity_method_mim;    -- ISO/TS 10303-1049

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Condition_mim;    -- ISO/TS 10303-1253

USE FROM Group_mim;    -- ISO/TS 10303-1113

USE FROM State_definition_mim;    -- ISO/TS 10303-1255

USE FROM State_observed_mim;    -- ISO/TS 10303-1256

USE FROM state_observed_schema   -- ISO 10303-56
  (state_observed); 

USE FROM state_type_schema   -- ISO 10303-56
  (state_type); 

USE FROM Task_element_mim;    -- ISO/TS 10303-1480


TYPE task_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (action_method, 
    action_method_relationship, 
    applied_action_method_assignment, 
    applied_state_observed_assignment, 
    applied_state_type_assignment);
END_TYPE; 

TYPE task_specification_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
   (action_method, 
    action_method_relationship);
END_TYPE; 

TYPE task_state_items = EXTENSIBLE SELECT BASED_ON action_method_items WITH 
   (applied_state_observed_assignment, 
    applied_state_type_assignment, 
    state_observed, 
    state_type);
END_TYPE; 

ENTITY advisory_task_step
  SUBTYPE OF (task_step);
END_ENTITY;

ENTITY simultaneous_task_element
  SUBTYPE OF (concurrent_task_element);
END_ENTITY;

ENTITY task_invocation
  SUBTYPE OF (task_element);
END_ENTITY;

ENTITY task_method
  SUBTYPE OF (action_method);
END_ENTITY;

ENTITY task_method_relationship
  SUBTYPE OF (action_method_relationship);
END_ENTITY;

ENTITY task_method_version
  SUBTYPE OF (action_method);
END_ENTITY;

ENTITY task_method_version_relationship
  SUBTYPE OF (action_method_relationship);
END_ENTITY;

ENTITY task_objective
  SUBTYPE OF (action_method);
END_ENTITY;

SUBTYPE_CONSTRAINT restrict_action_method_relationship_subtypes FOR action_method_relationship;
  ONEOF (task_element_relationship,
         task_method_relationship,
         task_method_version_relationship);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT restrict_task_action_method_subtypes FOR action_method;
  ONEOF (task_element,
         task_method,
         task_method_version,
         task_objective);
END_SUBTYPE_CONSTRAINT;

END_SCHEMA;  -- Task_specification_mim



--
-- TIME_INTERVAL_ASSIGNMENT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/time_interval_assignment/mim.exp)
--
(*
 $Id: mim.exp,v 1.4 2003/10/14 14:32:49 robbod Exp 
 ISO TC184/SC4/WG12 N2121 - ISO/TS 10303-1365 Time interval assignment - EXPRESS MIM
*) 


SCHEMA Time_interval_assignment_mim; 

USE FROM date_time_schema   -- ISO 10303-41
  (time_interval_role); 

USE FROM management_resources_schema   -- ISO 10303-41
  (time_interval_assignment); 

USE FROM Time_interval_mim;    -- ISO/TS 10303-1065


TYPE time_interval_item = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY applied_time_interval_assignment
  SUBTYPE OF (time_interval_assignment);
  items : SET[0:?] OF time_interval_item;
END_ENTITY;

END_SCHEMA;  -- Time_interval_assignment_mim



--
-- TIME_INTERVAL_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/time_interval/mim.exp)
--
(*
 $Id: mim.exp,v 1.10 2004/10/22 15:26:05 darla Exp 
 ISO TC184/SC4/WG12 N2119 - ISO/TS 10303-1065 Time interval - EXPRESS MIM
*)

SCHEMA Time_interval_mim; 

USE FROM date_time_schema   -- ISO 10303-41
  (time_interval,
   time_interval_relationship,
   time_interval_with_bounds); 

USE FROM Event_mim;    -- ISO/TS 10303-1064

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


END_SCHEMA;  -- Time_interval_mim


--
-- TOPOLOGY_SCHEMA (/Users/klt/git/wg12-stepdev/stepmod/data/resources/topology_schema/topology_schema.exp)
--
(*
ISO 10303 TC184/SC4/WG12 N11367

EXPRESS Source:
ISO 10303-42 ed8 Geometric and topological representation - Topology schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
and derivations of the Schema:

Copyright ISO 2024 All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-42 ed8 Geometric and topological representation - Topology schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA topology_schema '{iso standard 10303 part(42) version(12) object(1) topology_schema(2)}';
   REFERENCE FROM basic_attribute_schema (aggregate_id_attribute,   -- ISO 10303-41
                                          get_aggregate_id_value,
                                          get_id_value,
                                          id_attribute,
                                          id_attribute_select);
   REFERENCE FROM geometry_schema;                                 -- ISO 10303-42
   REFERENCE FROM geometric_model_schema;                          -- ISO 10303-42
   REFERENCE FROM measure_schema;                                  -- ISO 10303-45
   REFERENCE FROM representation_schema(                           -- ISO 10303-43
                                       definitional_representation,
				       parametric_representation_context,
				       representation,
				       representation_item);
   REFERENCE FROM support_resource_schema (bag_to_set, identifier);   -- ISO 10303-41

CONSTANT
   dummy_tri : topological_representation_item := representation_item('')||
                  topological_representation_item();
END_CONSTANT;

TYPE list_of_reversible_topology_item =
                              LIST [0:?] of reversible_topology_item;
END_TYPE;

TYPE reversible_topology = SELECT
          (reversible_topology_item,
           list_of_reversible_topology_item,
           set_of_reversible_topology_item);
END_TYPE;

TYPE reversible_topology_item = SELECT
  (edge,
   path,
   face,
   face_bound,
   closed_shell,
   open_shell);
END_TYPE;

TYPE set_of_reversible_topology_item =
                     SET [0:?] of reversible_topology_item;
END_TYPE;

TYPE tri_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
  topological_representation_item);
END_TYPE;

TYPE shell = SELECT
  (vertex_shell,
   wire_shell,
   open_shell,
   closed_shell);
END_TYPE;

ENTITY closed_shell
  SUBTYPE OF (connected_face_set);
--IP1:
--IP2:
--IP3:
--IP4:
--IP5:
--IP6:
--IP7:
--IP8:
--IP9:
--IP10:
END_ENTITY;

ENTITY connected_edge_set
  SUBTYPE OF (topological_representation_item);
  ces_edges : SET [1:?] OF edge;
--IP1:
--IP2:
END_ENTITY;

ENTITY connected_edge_sub_set
  SUBTYPE OF (connected_edge_set);
  parent_edge_set : connected_edge_set;
WHERE
  WR1: SELF :<>: parent_edge_set;
--IP1:
END_ENTITY;

ENTITY connected_face_set
  SUPERTYPE OF (ONEOF (closed_shell, open_shell))
  SUBTYPE OF (topological_representation_item);
  cfs_faces : SET [1:?] OF face;
--IP1:
END_ENTITY;

ENTITY connected_face_sub_set
  SUBTYPE OF (connected_face_set);
  parent_face_set   :  connected_face_set;
WHERE
  WR1: SELF :<>: parent_face_set;
--IP1:
END_ENTITY;

ENTITY connected_volume_set
SUBTYPE OF(topological_representation_item);
  cvs_volumes : SET [1:?] OF volume_with_faces;
--IP1:
--IP2:
--IP3:
END_ENTITY;

ENTITY connected_volume_sub_set
SUBTYPE OF(connected_volume_set);
  parent_volume_set : connected_volume_set;
WHERE
  WR1: SELF :<>: parent_volume_set;
--IP1:
END_ENTITY;

ENTITY edge
  SUPERTYPE OF(ONEOF(edge_curve,
                     oriented_edge,
		      subedge))
  SUBTYPE OF (topological_representation_item);
  edge_start : vertex;
  edge_end   : vertex;
--IP1:
--IP2:

END_ENTITY;

ENTITY subedge
  SUBTYPE OF (edge);
  parent_edge   :  edge;
WHERE
  WR1: SELF :<>: parent_edge;
--IP1:
--IP2:
END_ENTITY;

ENTITY edge_curve
  SUBTYPE OF(edge,geometric_representation_item);
  edge_geometry : curve;
  same_sense    : BOOLEAN;
--IP1:
--IP2:
--IP3:
--IP4:
--IP5:
--IP6:
--IP7:
END_ENTITY;

ENTITY edge_loop
  SUBTYPE OF (loop,path);
DERIVE
  ne : INTEGER := SIZEOF(SELF\path.edge_list);
WHERE
  WR1: (SELF\path.edge_list[1].edge_start) :=:
       (SELF\path.edge_list[ne].edge_end);
--IP1:
--IP2:
END_ENTITY;

ENTITY face
  SUPERTYPE OF(ONEOF(face_surface,
		      oriented_face,
                     subface))
  SUBTYPE OF (topological_representation_item);
  bounds : SET[1:?] OF face_bound;
WHERE
  WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
  WR2: SIZEOF(QUERY(temp <* bounds | 'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN
                                              TYPEOF(temp))) <= 1;
--IP1:
--IP2:
--IP3:
--IP4:
--IP5:
END_ENTITY;

ENTITY subface
  SUBTYPE OF (face);
  parent_face   :  face;
WHERE
  WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF)) +
             list_to_set(list_face_loops(parent_face))));
  WR2: SELF :<>: parent_face;
--IP1:
--IP2:
END_ENTITY;

ENTITY face_bound
  SUBTYPE OF(topological_representation_item);
  bound       :  loop;
  orientation :  BOOLEAN;
END_ENTITY;

ENTITY face_outer_bound
  SUBTYPE OF (face_bound);
END_ENTITY;

ENTITY face_surface
  SUBTYPE OF(face,geometric_representation_item);
  face_geometry :  surface;
  same_sense    :  BOOLEAN;
WHERE
  WR1: NOT ('GEOMETRY_SCHEMA.ORIENTED_SURFACE' IN TYPEOF(face_geometry));
--IP1:
--IP2:
--IP3:  
--IP4:
--IP5:
--IP6:
--IP7:
--IP8:
END_ENTITY;


TYPE advanced_face_geometry_select = SELECT (
       b_spline_surface,
       elementary_surface,
       swept_surface);
END_TYPE;

ENTITY advanced_face
   SUBTYPE OF (face_surface);
   SELF\face_surface.face_geometry : advanced_face_geometry_select;
WHERE
   WR1 : SIZEOF (
   QUERY ( elp_fbnds <*
   QUERY ( bnds <* bounds| ('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF (
   QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element)) )) = 0) )) = 0;

   WR2 : SIZEOF (
   QUERY ( elp_fbnds <*
   QUERY ( bnds <* bounds| ('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF (
   QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ( SIZEOF ([ 'GEOMETRY_SCHEMA.LINE', 'GEOMETRY_SCHEMA.CONIC', 'GEOMETRY_SCHEMA.POLYLINE', 'GEOMETRIC_MODEL_SCHEMA.SURFACE_CURVE', 'GEOMETRY_SCHEMA.B_SPLINE_CURVE' ] * TYPEOF (oe.edge_element\edge_curve.edge_geometry)) = 1) )) = 0) )) = 0;

   WR3 : SIZEOF (
   QUERY ( elp_fbnds <*
   QUERY ( bnds <* bounds| ('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF (
   QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ((('TOPOLOGY_SCHEMA.VERTEX_POINT' IN TYPEOF (oe\edge.edge_start)) AND ('GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_start\vertex_point.vertex_geometry))) AND (('TOPOLOGY_SCHEMA.VERTEX_POINT' IN TYPEOF (oe\edge.edge_end)) AND ('GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_end\vertex_point.vertex_geometry)))) )) = 0) )) = 0;

   WR4 : SIZEOF (
   QUERY ( elp_fbnds <*
   QUERY ( bnds <* bounds| ('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (elp_fbnds.bound)) )) = 0;

   WR5 : NOT ('GEOMETRY_SCHEMA.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR ( SIZEOF ([ 'GEOMETRY_SCHEMA.LINE', 'GEOMETRY_SCHEMA.CONIC', 'GEOMETRY_SCHEMA.POLYLINE', 'GEOMETRY_SCHEMA.B_SPLINE_CURVE' ] * TYPEOF (face_geometry\swept_surface.swept_curve)) = 1);

   WR6 : SIZEOF (
   QUERY ( vlp_fbnds <*
   QUERY ( bnds <* bounds| ('TOPOLOGY_SCHEMA.VERTEX_LOOP' IN TYPEOF (bnds.bound)) )| NOT (('TOPOLOGY_SCHEMA.VERTEX_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND ('GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))) )) = 0;

   WR7 : SIZEOF (
   QUERY ( bnd <* bounds| NOT ( SIZEOF ([ 'TOPOLOGY_SCHEMA.EDGE_LOOP', 'TOPOLOGY_SCHEMA.VERTEX_LOOP' ] * TYPEOF (bnd.bound)) = 1) )) = 0;

   WR8 : SIZEOF (
   QUERY ( elp_fbnds <*
   QUERY ( bnds <* bounds| ('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF (
   QUERY ( oe <* elp_fbnds.bound\path.edge_list| ('GEOMETRIC_MODEL_SCHEMA.SURFACE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF (
   QUERY ( sc_ag <* oe.edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry| NOT ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (sc_ag)) )) = 0) )) = 0) )) = 0;

   WR9: (NOT ('GEOMETRY_SCHEMA.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR (NOT ('GEOMETRY_SCHEMA.POLYLINE' IN TYPEOF (face_geometry\swept_surface.swept_curve)) OR ( SIZEOF (face_geometry\swept_surface.swept_curve\polyline.points) >= 3))) AND ( SIZEOF (
   QUERY ( elp_fbnds <*
   QUERY ( bnds <* bounds| ('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF (
   QUERY ( oe <* elp_fbnds.bound\path.edge_list| ('GEOMETRY_SCHEMA.POLYLINE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry\polyline.points) >= 3) )) = 0) )) = 0);
--IP1:
END_ENTITY ;

ENTITY loop
  SUPERTYPE OF (ONEOF(vertex_loop, edge_loop, poly_loop))
  SUBTYPE OF (topological_representation_item);
--IP1:
--IP2:
END_ENTITY;

ENTITY open_path
  SUBTYPE OF (path);
DERIVE
  ne : INTEGER := SIZEOF(SELF\path.edge_list);
WHERE
  WR1: (SELF\path.edge_list[1].edge_element.edge_start) :<>:
                      (SELF\path.edge_list[ne].edge_element.edge_end);
--IP1:
END_ENTITY;

ENTITY open_shell
  SUBTYPE OF (connected_face_set);
--IP1:
--IP2:
--IP3:
--IP4:
--IP5:
--IP6:
--IP7:
--IP8:
--IP9:
END_ENTITY;

ENTITY oriented_closed_shell
  SUBTYPE OF (closed_shell);
  closed_shell_element : closed_shell;
  orientation          : BOOLEAN;
DERIVE
  SELF\connected_face_set.cfs_faces : SET [1:?] OF face
                               := conditional_reverse(SELF.orientation,
                                  SELF.closed_shell_element.cfs_faces);
WHERE
  WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL'
               IN TYPEOF (SELF.closed_shell_element));
END_ENTITY;

ENTITY oriented_edge
  SUBTYPE OF (edge);
  edge_element : edge;
  orientation  : BOOLEAN;
DERIVE
  SELF\edge.edge_start : vertex := boolean_choose (SELF.orientation,
                                           SELF.edge_element.edge_start,
                                           SELF.edge_element.edge_end);
  SELF\edge.edge_end   : vertex := boolean_choose (SELF.orientation,
                                           SELF.edge_element.edge_end,
                                           SELF.edge_element.edge_start);
WHERE
  WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (SELF.edge_element));
END_ENTITY;

ENTITY oriented_face
  SUBTYPE OF (face);
  face_element : face;
  orientation  : BOOLEAN;
DERIVE
  SELF\face.bounds : SET[1:?] OF face_bound
         := conditional_reverse(SELF.orientation,SELF.face_element.bounds);
WHERE
  WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (SELF.face_element));
END_ENTITY;

ENTITY oriented_open_shell
  SUBTYPE OF (open_shell);
  open_shell_element : open_shell;
  orientation        : BOOLEAN;
DERIVE
  SELF\connected_face_set.cfs_faces : SET [1:?] OF face
                               := conditional_reverse(SELF.orientation,
                                     SELF.open_shell_element.cfs_faces);
WHERE
  WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL'
               IN TYPEOF (SELF.open_shell_element));
END_ENTITY;

ENTITY oriented_path
  SUBTYPE OF (path);
  path_element : path;
  orientation  : BOOLEAN;
DERIVE
  SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge := conditional_reverse(SELF.orientation, SELF.path_element.edge_list);
WHERE
  WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (SELF.path_element));
END_ENTITY;

ENTITY path
  SUPERTYPE OF (ONEOF(open_path, edge_loop, oriented_path))
  SUBTYPE OF (topological_representation_item);
  edge_list  : LIST [1:?] OF UNIQUE oriented_edge;
WHERE
  WR1: path_head_to_tail(SELF);
--IP1:
--IP2:
--IP3:
--IP4:
--IP5:
END_ENTITY;

ENTITY subpath
  SUBTYPE OF (path);
  parent_path : path;
WHERE
  WR1: SELF :<>: parent_path;
  WR2: NOT (('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(SELF)) AND ('TOPOLOGY_SCHEMA.OPEN_PATH' IN TYPEOF(parent_path)));
--IP1:
--IP2:
--IP3:
END_ENTITY;


ENTITY poly_loop
  SUBTYPE OF (loop,geometric_representation_item);
  polygon : LIST [3:?] OF UNIQUE cartesian_point;
--IP1:
--IP2:
END_ENTITY;

ENTITY seam_edge
  SUBTYPE OF (oriented_edge);
    pcurve_reference : pcurve ;
WHERE
   WR1 : ( 'TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF (edge_element) )  AND
               ('TOPOLOGY_SCHEMA.SEAM_CURVE' IN TYPEOF
                      (edge_element\edge_curve.edge_geometry)) ;
  WR2 :  pcurve_reference IN edge_element\edge_curve.edge_geometry\
                                surface_curve.associated_geometry ;
END_ENTITY;

ENTITY topological_representation_item
   SUPERTYPE OF (ONEOF(vertex, edge, face_bound, face, vertex_shell,
                   wire_shell, connected_edge_set, connected_face_set,
                   connected_volume_set, volume_with_faces,
                    (loop ANDOR path)))
   SUBTYPE OF (representation_item);
 DERIVE
   permanent_id             : identifier := get_id_value(SELF);
   permanent_aggregate_id   : identifier := get_aggregate_id_value(SELF);
 WHERE
   WR1:
    SIZEOF(USEDIN(SELF,'BASIC_ATTRIBUTE_SCHEMA.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   WR2:
    SIZEOF(USEDIN(SELF,'BASIC_ATTRIBUTE_SCHEMA.AGGREGATE_ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
--IP1:
END_ENTITY;

ENTITY vertex
  SUBTYPE OF (topological_representation_item);
--IP1:
--IP2:
END_ENTITY;

ENTITY vertex_point
SUBTYPE OF(vertex,geometric_representation_item);
  vertex_geometry : point;
--IP1:
END_ENTITY;

ENTITY vertex_loop
  SUBTYPE OF (loop);
  loop_vertex : vertex;
--IP1:
--IP2:
END_ENTITY;

ENTITY volume_with_faces
 ABSTRACT SUPERTYPE OF (ONEOF(volume_with_shell, volume_with_parametric_boundary))
 SUBTYPE OF(geometric_representation_item,
           topological_representation_item);
   volume_geometry : volume;
END_ENTITY;

ENTITY volume_with_parametric_boundary
SUBTYPE OF(volume_with_faces);
  outer_bound : LIST [6:6] OF face;
END_ENTITY;

ENTITY volume_with_shell
SUBTYPE OF(volume_with_faces);
  outer_bound : closed_shell;
END_ENTITY;

ENTITY vertex_shell
  SUBTYPE OF (topological_representation_item);
  vertex_shell_extent : vertex_loop;
--IP1:
--IP2:
END_ENTITY;

ENTITY wire_shell
  SUBTYPE OF (topological_representation_item);
  wire_shell_extent : SET [1:?] OF loop;
WHERE
  WR1: NOT mixed_loop_type_set(wire_shell_extent);
--IP1:
--IP2:
--IP3:
--IP4:
--IP5:
END_ENTITY;

FUNCTION boolean_choose (b : boolean;
          choice1, choice2 : generic : item)  : generic : item;
  IF b THEN
    RETURN (choice1);
  ELSE
    RETURN (choice2);
  END_IF;
END_FUNCTION;

FUNCTION closed_shell_reversed (a_shell : closed_shell) :
                                      oriented_closed_shell;
 LOCAL
   the_reverse : oriented_closed_shell;
 END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
     the_reverse := dummy_tri ||
                   connected_face_set (
                      a_shell\connected_face_set.cfs_faces) ||
                   closed_shell () || oriented_closed_shell(
                    a_shell\oriented_closed_shell.closed_shell_element,
                      NOT(a_shell\oriented_closed_shell.orientation));
  ELSE
     the_reverse := dummy_tri ||
              connected_face_set (
                a_shell\connected_face_set.cfs_faces) ||
              closed_shell () || oriented_closed_shell (a_shell, FALSE);
  END_IF;
  RETURN (the_reverse);
END_FUNCTION;

FUNCTION conditional_reverse (p       : BOOLEAN;
                              an_item : reversible_topology)
                                      : reversible_topology;
  IF p THEN
    RETURN (an_item);
  ELSE
    RETURN (topology_reversed (an_item));
  END_IF;
END_FUNCTION;

FUNCTION edge_curve_pcurves (an_edge  : edge_curve;
                       the_surface_curves : SET OF surface_curve)
      : SET OF pcurve;
LOCAL
  a_curve      : curve;
  result       : SET OF pcurve;
  the_geometry : LIST[1:2] OF pcurve_or_surface;
END_LOCAL;
  a_curve := an_edge.edge_geometry;
  result := [];
  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(a_curve) THEN
    result := result + a_curve;
  ELSE
    IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(a_curve) THEN
      the_geometry := a_curve\surface_curve.associated_geometry;
      REPEAT k := 1 TO SIZEOF(the_geometry);
         IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (the_geometry[k])
         THEN
            result := result + the_geometry[k];
         END_IF;
      END_REPEAT;
    ELSE
      REPEAT j := 1 TO SIZEOF(the_surface_curves);
        the_geometry := the_surface_curves[j].associated_geometry;
        IF the_surface_curves[j].curve_3d :=: a_curve
        THEN
          REPEAT k := 1 TO SIZEOF(the_geometry);
            IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (the_geometry[k])
            THEN
              result := result + the_geometry[k];
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;

  RETURN (result);
END_FUNCTION;

FUNCTION edge_reversed (an_edge : edge) : oriented_edge;
  LOCAL
    the_reverse : oriented_edge;
  END_LOCAL;

  IF ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (an_edge) ) THEN
    the_reverse  := dummy_tri ||
            edge(an_edge.edge_end, an_edge.edge_start) ||
            oriented_edge(an_edge\oriented_edge.edge_element,
                       NOT (an_edge\oriented_edge.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
            edge(an_edge.edge_end, an_edge.edge_start) ||
            oriented_edge(an_edge, FALSE);
  END_IF;
  RETURN (the_reverse);
END_FUNCTION;

FUNCTION face_bound_reversed (a_face_bound : face_bound) : face_bound;
  LOCAL
    the_reverse : face_bound ;
  END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF (a_face_bound) ) THEN
    the_reverse := dummy_tri ||
                     face_bound(a_face_bound\face_bound.bound,
                          NOT (a_face_bound\face_bound.orientation))
                           || face_outer_bound() ;
  ELSE
    the_reverse := dummy_tri ||
        face_bound(a_face_bound.bound, NOT(a_face_bound.orientation));
  END_IF;
 RETURN (the_reverse);
END_FUNCTION;

FUNCTION face_reversed (a_face : face) : oriented_face;
  LOCAL
    the_reverse : oriented_face ;
  END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (a_face) ) THEN
    the_reverse := dummy_tri ||
      face(set_of_topology_reversed(a_face.bounds)) ||
         oriented_face(a_face\oriented_face.face_element,
                          NOT (a_face\oriented_face.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
      face(set_of_topology_reversed(a_face.bounds)) ||
                              oriented_face(a_face, FALSE) ;
  END_IF;
     RETURN (the_reverse);
END_FUNCTION;

--new
FUNCTION get_tri_in_representations (members : SET OF representation) : SET OF topological_representation_item;

 LOCAL
 tri_set : SET OF topological_representation_item := [];
END_LOCAL;

IF SIZEOF(members) = 0 THEN
RETURN(?);
END_IF;

REPEAT i := LOINDEX(members) TO HIINDEX(members);
  REPEAT J := LOINDEX(members[i]\representation.items) TO HIINDEX(members[i]\representation.items);
   IF 'TOPOLOGY_SCHEMA.TOPOLOGICAL_REPRESENTATION_ITEM' IN TYPEOF(members[i]\representation.items[j]) THEN
    tri_set := tri_set + members[i]\representation.items[j];
   END_IF;
  END_REPEAT;
END_REPEAT;

RETURN(tri_set);
END_FUNCTION;

FUNCTION list_face_loops(f: face) : LIST[0:?] OF loop;
   LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;

   REPEAT i := 1 TO SIZEOF(f.bounds);
     loops := loops +(f.bounds[i].bound);
   END_REPEAT;

   RETURN(loops);
 END_FUNCTION;

FUNCTION list_loop_edges(l: loop): LIST[0:?] OF edge;
  LOCAL
    edges : LIST[0:?] OF edge := [];
  END_LOCAL;

  IF 'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(l) THEN
    REPEAT i := 1 TO SIZEOF(l\path.edge_list);
      edges := edges + (l\path.edge_list[i].edge_element);
    END_REPEAT;
  END_IF;

  RETURN(edges);
END_FUNCTION;

FUNCTION list_of_topology_reversed (a_list
                                 : list_of_reversible_topology_item)
                                 : list_of_reversible_topology_item;
  LOCAL
    the_reverse : list_of_reversible_topology_item;
  END_LOCAL;

  the_reverse := [];
  REPEAT i := 1 TO SIZEOF (a_list);
    the_reverse := topology_reversed (a_list [i]) + the_reverse;
  END_REPEAT;

  RETURN (the_reverse);
END_FUNCTION;

FUNCTION list_shell_edges(s : shell) : LIST[0:?] OF edge;
  LOCAL
    edges : LIST[0:?] OF edge := [];
  END_LOCAL;

  REPEAT i := 1 TO SIZEOF(list_shell_loops(s));
    edges := edges + list_loop_edges(list_shell_loops(s)[i]);
  END_REPEAT;

  RETURN(edges);
END_FUNCTION;

FUNCTION list_shell_faces(s : shell) : LIST[0:?] OF face;
  LOCAL
    faces : LIST[0:?] OF face := [];
  END_LOCAL;

  IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s)) OR
     ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s)) THEN
    REPEAT i := 1 TO SIZEOF(s\connected_face_set.cfs_faces);
      faces := faces + s\connected_face_set.cfs_faces[i];
    END_REPEAT;
  END_IF;

  RETURN(faces);
END_FUNCTION;

FUNCTION list_shell_loops(s : shell) : LIST[0:?] OF loop;
  LOCAL
    loops : LIST[0:?] OF loop := [];
  END_LOCAL;

  IF 'TOPOLOGY_SCHEMA.VERTEX_SHELL' IN TYPEOF(s) THEN
    loops := loops + s.vertex_shell_extent;
  END_IF;

  IF 'TOPOLOGY_SCHEMA.WIRE_SHELL' IN TYPEOF(s) THEN
    REPEAT i := 1 TO SIZEOF(s.wire_shell_extent);
      loops := loops + s.wire_shell_extent[i];
    END_REPEAT;
  END_IF;

  IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s)) OR
     ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s)) THEN
    REPEAT i := 1 TO SIZEOF(s.cfs_faces);
      loops := loops + list_face_loops(s.cfs_faces[i]);
    END_REPEAT;
  END_IF;

  RETURN(loops);
END_FUNCTION;

FUNCTION list_to_set(l : LIST [0:?] OF GENERIC:T) : SET OF GENERIC:T;
  LOCAL
    s : SET OF GENERIC:T := [];
  END_LOCAL;

  REPEAT i := 1 TO SIZEOF(l);
    s := s + l[i];
  END_REPEAT;

  RETURN(s);
END_FUNCTION;

FUNCTION mixed_loop_type_set(l: SET[0:?] OF loop): LOGICAL;
   LOCAL
     poly_loop_type: LOGICAL;
   END_LOCAL;
   IF(SIZEOF(l) <= 1) THEN
     RETURN(FALSE);
   END_IF;
   poly_loop_type := ('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[1]));
   REPEAT i := 2 TO SIZEOF(l);
     IF(('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[i])) <> poly_loop_type)
         THEN
         RETURN(TRUE);
      END_IF;
   END_REPEAT;
   RETURN(FALSE);
 END_FUNCTION;

FUNCTION open_shell_reversed ( a_shell : open_shell) :
                                        oriented_open_shell;
  LOCAL
    the_reverse : oriented_open_shell;
  END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
    the_reverse := dummy_tri ||
                 connected_face_set (
                     a_shell\connected_face_set.cfs_faces) ||
                 open_shell () || oriented_open_shell(
                   a_shell\oriented_open_shell.open_shell_element,
                     (NOT (a_shell\oriented_open_shell.orientation)));
  ELSE
    the_reverse := dummy_tri ||
                connected_face_set (
                    a_shell\connected_face_set.cfs_faces) ||
                open_shell () ||  oriented_open_shell (a_shell, FALSE);
  END_IF;
  RETURN (the_reverse);
END_FUNCTION;

FUNCTION path_head_to_tail(a_path : path) : LOGICAL;
  LOCAL
    n : INTEGER;
    p : LOGICAL := TRUE;
  END_LOCAL;

    n := SIZEOF (a_path.edge_list);
    REPEAT i := 2 TO n;
      p := p AND (a_path.edge_list[i-1].edge_end :=:
                  a_path.edge_list[i].edge_start);
    END_REPEAT;

    RETURN (p);
END_FUNCTION;

FUNCTION path_reversed (a_path : path) : oriented_path;
  LOCAL
    the_reverse : oriented_path ;
  END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (a_path) ) THEN
    the_reverse := dummy_tri ||
       path(list_of_topology_reversed (a_path.edge_list)) ||
          oriented_path(a_path\oriented_path.path_element,
                          NOT(a_path\oriented_path.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
                   path(list_of_topology_reversed (a_path.edge_list)) ||
                       oriented_path(a_path, FALSE);
  END_IF;

  RETURN (the_reverse);
END_FUNCTION;

FUNCTION set_of_topology_reversed (a_set : set_of_reversible_topology_item)
                                         : set_of_reversible_topology_item;
  LOCAL
    the_reverse : set_of_reversible_topology_item;
  END_LOCAL;

  the_reverse := [];
  REPEAT i := 1 TO SIZEOF (a_set);
    the_reverse := the_reverse + topology_reversed (a_set [i]);
  END_REPEAT;

  RETURN (the_reverse);
END_FUNCTION;

FUNCTION shell_reversed (a_shell : shell) : shell;
  IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
    RETURN (open_shell_reversed (a_shell));
  ELSE
    IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
      RETURN (closed_shell_reversed (a_shell));
    ELSE
      RETURN (?);
    END_IF;
  END_IF;
END_FUNCTION;

FUNCTION topology_reversed (an_item : reversible_topology)
                                    : reversible_topology;

  IF ('TOPOLOGY_SCHEMA.EDGE' IN TYPEOF (an_item)) THEN
    RETURN (edge_reversed (an_item));
  END_IF;

  IF ('TOPOLOGY_SCHEMA.PATH' IN TYPEOF (an_item)) THEN
    RETURN (path_reversed (an_item));
  END_IF;

  IF ('TOPOLOGY_SCHEMA.FACE_BOUND' IN TYPEOF (an_item)) THEN
    RETURN (face_bound_reversed (an_item));
  END_IF;

  IF ('TOPOLOGY_SCHEMA.FACE' IN TYPEOF (an_item)) THEN
    RETURN (face_reversed (an_item));
  END_IF;

  IF ('TOPOLOGY_SCHEMA.SHELL' IN TYPEOF (an_item)) THEN
    RETURN (shell_reversed (an_item));
  END_IF;

  IF ('SET' IN TYPEOF (an_item)) THEN
    RETURN (set_of_topology_reversed (an_item));
  END_IF;

  IF ('LIST' IN TYPEOF (an_item)) THEN
    RETURN (list_of_topology_reversed (an_item));
  END_IF;

  RETURN (?);
END_FUNCTION;

(*
The FUNCTION valid_tri_ids returns TRUE if each tri has an id and if each id is used only once in the SET of tri.
Note: The value of aggregate_id and of id shall be disjoint in order to support possible
use case where there shall be no more than one id of any kind assigned to a tri.
*)

FUNCTION valid_tri_ids (objs : SET OF topological_representation_item) : BOOLEAN;


LOCAL
   values              : BAG OF identifier := [];
END_LOCAL;

  REPEAT i := LOINDEX(objs) TO HIINDEX(objs);
--each tri shall have at least one id.
   IF NOT(EXISTS(objs[i]\topological_representation_item.permanent_id) OR
          EXISTS(objs[i]\topological_representation_item.permanent_aggregate_id)) THEN
    RETURN(FALSE);
   END_IF;
   values := values + objs[i]\topological_representation_item.permanent_id
                       + objs[i]\topological_representation_item.permanent_aggregate_id;
  END_REPEAT;

--ids are unique across both types
 IF SIZEOF(bag_to_set(values)) <> SIZEOF(values) THEN
   RETURN(FALSE);
 END_IF;

 RETURN (TRUE);
 END_FUNCTION;


FUNCTION vertex_point_pcurves (a_vertex  : vertex_point;
      the_degenerates : SET OF evaluated_degenerate_pcurve)
      : SET OF degenerate_pcurve;
LOCAL
  a_point : point;
  result  : SET OF degenerate_pcurve;
END_LOCAL;
  a_point := a_vertex.vertex_geometry;
  result := [];
  IF 'GEOMETRY_SCHEMA.DEGENERATE_PCURVE' IN TYPEOF(a_point) THEN
    result := result + a_point;
  ELSE
      REPEAT j := 1 TO SIZEOF(the_degenerates);
         IF (the_degenerates[j].equivalent_point :=: a_point)  THEN
            result := result + the_degenerates[j];
         END_IF;
      END_REPEAT;
  END_IF;

  RETURN (result);
END_FUNCTION;

END_SCHEMA; -- end TOPOLOGY schema


--
-- TYPE_OF_PERSON_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/type_of_person/mim.exp)
--
(*
 $Id: mim.exp,v 1.10 2004/11/19 21:37:58 robbod Exp 
 ISO TC184/SC4/WG12 N3185 - ISO/TS 10303-1245 Type of person - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2451
*) 


SCHEMA Type_of_person_mim;

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Experience_mim;    -- ISO/TS 10303-1243

USE FROM experience_schema   -- ISO 10303-41
  (experience_type); 

USE FROM management_resources_schema   -- ISO 10303-41
  (person_type_assignment,
   person_type_definition_assignment); 

USE FROM person_organization_schema   -- ISO 10303-41
  (person_type,
   person_type_definition,
   person_type_definition_relationship); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object); 

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

USE FROM Qualifications_mim;    -- ISO/TS 10303-1244

USE FROM qualifications_schema   -- ISO 10303-41
  (qualification_type); 


TYPE person_definition_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (experience_type, 
    qualification_type);
END_TYPE; 

TYPE person_type_definition_relationship_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (applied_person_type_assignment, 
    applied_person_type_definition_assignment, 
    person_type, 
    person_type_definition, 
    person_type_definition_relationship);
END_TYPE; 

TYPE person_type_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_person_type_assignment
  SUBTYPE OF (person_type_assignment);
  items : SET[1:?] OF person_type_item;
END_ENTITY;

ENTITY applied_person_type_definition_assignment
  SUBTYPE OF (person_type_definition_assignment);
  items : SET[1:?] OF person_definition_item;
END_ENTITY;

ENTITY characterized_person_type_definition
  SUBTYPE OF (characterized_object, person_type_definition);
END_ENTITY;

END_SCHEMA;  -- Type_of_person_mim



--
-- VALUE_WITH_UNIT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/value_with_unit/mim.exp)
--
(*
 $Id: mim.exp,v 1.21 2019/06/05 16:40:05 tom Exp 
 ISO TC184/SC4/WG12 N10400 - ISO/TS 10303-1054 Value with unit - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N9726
*)

SCHEMA Value_with_unit_mim;

USE FROM Maths_value_mim; -- ISO/TS 10303-1092

USE FROM measure_schema; -- ISO-10303-41

USE FROM representation_schema -- ISO-10303-43
 (uncertainty_measure_with_unit);

END_SCHEMA;


--
-- VERIFICATION_AND_VALIDATION_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/verification_and_validation/mim.exp)
--
(*
 $Id: mim.exp,v 1.17 2009/12/18 15:04:39 robbod Exp 
 ISO TC184/SC4/WG12 N6850 - ISO/TS 10303-1488 Verification and validation - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N6602
*) 


SCHEMA Verification_and_validation_mim;

USE FROM Group_mim;    -- ISO/TS 10303-1113

USE FROM Requirement_assignment_mim;    -- ISO/TS 10303-1233

USE FROM State_observed_mim;    -- ISO/TS 10303-1256


TYPE evidence_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (validation, 
    verification);
END_TYPE; 

TYPE v_and_v_state_observed = SELECT BASED_ON state_observed_of_item WITH 
   (group);
END_TYPE; 

TYPE validation_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
   (product_definition_formation);
END_TYPE; 

ENTITY evidence
  SUBTYPE OF (group_assignment);
  items : SET[1:?] OF evidence_item;
END_ENTITY;

ENTITY validation
  SUBTYPE OF (group);
END_ENTITY;

ENTITY verification
  SUBTYPE OF (group);
END_ENTITY;

ENTITY verification_relationship
  SUBTYPE OF (group_relationship);
  SELF\group_relationship.relating_group : verification;
  SELF\group_relationship.related_group : verification;
END_ENTITY;

END_SCHEMA;  -- Verification_and_validation_mim


--
-- WORK_ORDER_CHARACTERIZED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/work_order_characterized/mim.exp)
--
(*
 $Id: mim.exp,v 1.9 2004/11/19 21:37:58 robbod Exp 
 ISO TC184/SC4/WG12 N3188 - ISO/TS 10303-1286 Work order characterized - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2454
*) 


SCHEMA Work_order_characterized_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_directive,
   directed_action); 

USE FROM Ap239_management_resource_information_mim;    -- ISO/TS 10303-1289

USE FROM Document_assignment_mim;    -- ISO/TS 10303-1122

USE FROM Management_resource_information_mim;    -- ISO/TS 10303-1288

USE FROM Work_order_mim;    -- ISO/TS 10303-1043


TYPE wordchar_ap239_mri_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON ap239_mri_attribute_classification_item WITH 
   (action_directive);
END_TYPE; 

TYPE wordchar_ap239_mri_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON ap239_mri_classification_item WITH 
   (action_directive, 
    directed_action);
END_TYPE; 

TYPE wordchar_document_reference_item = SELECT BASED_ON document_reference_item WITH 
   (action_directive);
END_TYPE; 

TYPE wordchar_mri_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_approval_item WITH 
   (action_directive, 
    directed_action);
END_TYPE; 

TYPE wordchar_mri_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_attribute_language_item WITH 
   (action_directive);
END_TYPE; 

TYPE wordchar_mri_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_and_time_item WITH 
   (action_directive, 
    directed_action);
END_TYPE; 

TYPE wordchar_mri_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_item WITH 
   (action_directive, 
    directed_action);
END_TYPE; 

TYPE wordchar_mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_identification_item WITH 
   (action_directive, 
    directed_action);
END_TYPE; 

TYPE wordchar_mri_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_multi_language_attribute_item WITH 
   (action_directive);
END_TYPE; 

TYPE wordchar_mri_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_organization_item WITH 
   (action_directive, 
    directed_action);
END_TYPE; 

TYPE wordchar_mri_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_person_and_organization_item WITH 
   (action_directive, 
    directed_action);
END_TYPE; 

END_SCHEMA;  -- Work_order_characterized_mim


--
-- WORK_ORDER_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/work_order/mim.exp)
--
(*
 $Id: mim.exp,v 1.18 2019/05/28 03:17:50 tom Exp 
 ISO TC184/SC4/WG12 N10269 - ISO/TS 10303-1043 Work order - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N8075
*)

SCHEMA Work_order_mim; 

USE FROM action_schema   -- ISO 10303-41
  (action_directive,
   directed_action,
   directed_action_assignment); 
USE FROM Activity_mim;    -- ISO/TS 10303-1047
USE FROM Work_request_mim;    -- ISO/TS 10303-1042


ENTITY applied_directed_action_assignment
	SUBTYPE OF (directed_action_assignment);
	items : SET[1:?] OF action_request_item;
END_ENTITY;

END_SCHEMA; 


--
-- WORK_OUTPUT_CHARACTERIZED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/work_output_characterized/mim.exp)
--
(*
 $Id: mim.exp,v 1.7 2004/11/19 21:37:58 robbod Exp 
 ISO TC184/SC4/WG12 N3194 - ISO/TS 10303-1301 Work output characterized - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2460
*) 


SCHEMA Work_output_characterized_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method,
   action_method_relationship); 

USE FROM Ap239_properties_mim;    -- ISO/TS 10303-1295

USE FROM Approval_mim;    -- ISO/TS 10303-1012

USE FROM Attribute_classification_mim;    -- ISO/TS 10303-1246

USE FROM Certification_mim;    -- ISO/TS 10303-1044

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM Multi_linguism_mim;    -- ISO/TS 10303-1105

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Process_property_assignment_mim;    -- ISO/TS 10303-1040

USE FROM Security_classification_mim;    -- ISO/TS 10303-1015

USE FROM Work_output_mim;    -- ISO/TS 10303-1300


TYPE work_output_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (action_method);
END_TYPE; 

TYPE work_output_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_classification_item WITH 
   (action_method, 
    action_method_relationship);
END_TYPE; 

TYPE work_output_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (action_method, 
    action_method_relationship);
END_TYPE; 

TYPE work_output_certification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON certification_item WITH 
   (action_method);
END_TYPE; 

TYPE work_output_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (action_method);
END_TYPE; 

TYPE work_output_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (action_method);
END_TYPE; 

TYPE work_output_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (action_method);
END_TYPE; 

TYPE work_output_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (action_method, 
    action_method_relationship);
END_TYPE; 

TYPE work_output_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (action_method);
END_TYPE; 

TYPE work_output_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (action_method);
END_TYPE; 

TYPE work_output_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH 
   (action_method);
END_TYPE; 

END_SCHEMA;  -- Work_output_characterized_mim


--
-- WORK_OUTPUT_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/work_output/mim.exp)
--
(*
 $Id: mim.exp,v 1.11 2004/11/19 21:37:58 robbod Exp 
 ISO TC184/SC4/WG12 N3191 - ISO/TS 10303-1300 Work output - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2457
*) 


SCHEMA Work_output_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method,
   action_method_relationship); 

USE FROM Activity_method_assignment_mim;    -- ISO/TS 10303-1249

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM management_resources_schema   -- ISO 10303-41
  (action_method_assignment,
   action_method_role); 

USE FROM process_property_representation_schema   -- ISO 10303-49
  (action_property_representation); 

USE FROM process_property_schema   -- ISO 10303-49
  (action_property,
   characterized_action_definition); 

USE FROM representation_schema   -- ISO 10303-43
  (representation,
   representation_context,
   representation_item,
   value_representation_item); 

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


TYPE work_output_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (action_method, 
    action_method_assignment, 
    action_method_relationship);
END_TYPE; 

END_SCHEMA;  -- Work_output_mim


--
-- WORK_REQUEST_CHARACTERIZED_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/work_request_characterized/mim.exp)
--
(*
 $Id: mim.exp,v 1.10 2004/11/19 21:37:58 robbod Exp 
 ISO TC184/SC4/WG12 N3197 - ISO/TS 10303-1285 Work request characterized - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2463
*) 


SCHEMA Work_request_characterized_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_request_solution,
   action_request_status,
   versioned_action_request); 

USE FROM Ap239_management_resource_information_mim;    -- ISO/TS 10303-1289

USE FROM Document_assignment_mim;    -- ISO/TS 10303-1122

USE FROM Management_resource_information_mim;    -- ISO/TS 10303-1288

USE FROM Work_request_mim;    -- ISO/TS 10303-1042


TYPE wreqchar_ap239_mri_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON ap239_mri_attribute_classification_item WITH 
   (action_request_solution, 
    action_request_status, 
    applied_action_request_assignment, 
    versioned_action_request);
END_TYPE; 

TYPE wreqchar_ap239_mri_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON ap239_mri_classification_item WITH 
   (action_request_solution, 
    action_request_status, 
    applied_action_request_assignment, 
    versioned_action_request);
END_TYPE; 

TYPE wreqchar_document_reference_item = SELECT BASED_ON document_reference_item WITH 
   (versioned_action_request);
END_TYPE; 

TYPE wreqchar_mri_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_approval_item WITH 
   (action_request_solution, 
    applied_action_request_assignment, 
    versioned_action_request);
END_TYPE; 

TYPE wreqchar_mri_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_attribute_language_item WITH 
   (action_request_solution);
END_TYPE; 

TYPE wreqchar_mri_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_and_time_item WITH 
   (action_request_solution, 
    applied_action_request_assignment, 
    versioned_action_request);
END_TYPE; 

TYPE wreqchar_mri_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_item WITH 
   (action_request_solution, 
    applied_action_request_assignment, 
    versioned_action_request);
END_TYPE; 

TYPE wreqchar_mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_identification_item WITH 
   (applied_action_request_assignment, 
    versioned_action_request);
END_TYPE; 

TYPE wreqchar_mri_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_multi_language_attribute_item WITH 
   (action_request_solution);
END_TYPE; 

TYPE wreqchar_mri_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_organization_item WITH 
   (action_request_solution, 
    applied_action_request_assignment, 
    versioned_action_request);
END_TYPE; 

TYPE wreqchar_mri_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_person_and_organization_item WITH 
   (action_request_solution, 
    applied_action_request_assignment, 
    versioned_action_request);
END_TYPE; 

END_SCHEMA;  -- Work_request_characterized_mim


--
-- WORK_REQUEST_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/work_request/mim.exp)
--
(*
 $Id: mim.exp,v 1.18 2012/10/11 05:49:25 liutkuviene Exp 
 ISO TC184/SC4/WG12 N8078 - ISO/TS 10303-1042 Work request - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1151
*)

SCHEMA Work_request_mim;

USE FROM Activity_method_mim;    -- ISO/TS 10303-1049

USE FROM action_schema   -- ISO 10303-41
  (action_request_solution,
   action_request_status,
   versioned_action_request,
   versioned_action_request_relationship); 

USE FROM management_resources_schema   -- ISO 10303-41
   (action_request_assignment);


TYPE action_request_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

ENTITY applied_action_request_assignment
SUBTYPE OF (action_request_assignment);
  items : SET [1 : ?] OF action_request_item;
END_ENTITY;

END_SCHEMA;


--
-- ZONAL_BREAKDOWN_MIM (/Users/klt/git/wg12-stepdev/stepmod/data/modules/zonal_breakdown/mim.exp)
--
(*
 $Id: mim.exp,v 1.11 2004/11/29 14:08:47 mikeward Exp 
 ISO TC184/SC4/WG12 N3200 - ISO/TS 10303-1217 Zonal breakdown - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2304
*) 


SCHEMA Zonal_breakdown_mim;

USE FROM Group_mim;    -- ISO/TS 10303-1113

USE FROM group_schema   -- ISO 10303-41
  (group); 

USE FROM Product_breakdown_mim;    -- ISO/TS 10303-1248

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition); 

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019


TYPE in_zone_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
   (product_definition);
END_TYPE; 

ENTITY in_zone
  SUBTYPE OF (group);
END_ENTITY;

ENTITY zone_breakdown_context
  SUBTYPE OF (breakdown_context);
END_ENTITY;

ENTITY zone_element_usage
  SUBTYPE OF (breakdown_element_usage);
END_ENTITY;

END_SCHEMA;  -- Zonal_breakdown_mim




