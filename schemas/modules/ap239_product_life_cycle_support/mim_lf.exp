(*
ISO TC184/SC4/WG3 N11453 - ISO/TS 10303-439 AP239 product life cycle support - EXPRESS MIM Long form
Supersedes ISO TC184/SC4/WG3 N11070
*) 

(* Shortform to Longform Conversion
   Express Engine
   5.2.2 (GIT eeng-5.1.4-62-gb392ac4)
   Steel Bank CL 2.4.0 (Unknown Bits)
*)

(* Pretty Printed by Express Engine
      5.2.2 (GIT eeng-5.1.4-62-gb392ac4)
      Steel Bank CL 2.4.0 (Unknown Bits)

     eengine --pretty
       -mode mim_longform
       -schema mim_lf.exp
   Line Width: 120
   Commandline:
     eengine --pretty
       -mode mim_longform
       -schema mim_lf.exp
*)

(* File: /Users/klt/git/wg12-stepdev/stepmod/data/modules/ap239_product_life_cycle_support/mim_lf.exp *)
(* 1 Schema: AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF *)

(*  Interfaces:                 0 *)
(*  Constants:                 28 *)
(*  Types:                    209 *)
(*  Entities:                 959 *)
(*  Subtype_Constraints:        0 *)
(*  Functions:                176 *)
(*  Rules:                     34 *)
(*  Procedures:                 0 *)

-- Schema ap239_product_life_cycle_support_mim_lf;
SCHEMA Ap239_product_life_cycle_support_mim_lf;

CONSTANT
  dummy_gri                     : geometric_representation_item :=
                                  representation_item('') || geometric_representation_item();
  schema_prefix                 : STRING                        := 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.';
  the_binarys                   : elementary_space              := make_elementary_space(es_binarys);
  the_booleans                  : elementary_space              := make_elementary_space(es_booleans);
  the_complex_numbers           : elementary_space              := make_elementary_space(es_complex_numbers);
  the_complex_tuples            : extended_tuple_space          :=
                                  make_extended_tuple_space(the_zero_tuple_space, the_complex_numbers);
  the_empty_atom_based_tuple    : atom_based_tuple              := [];
  the_empty_atom_based_value    : atom_based_value              := the_empty_atom_based_tuple;
  the_empty_maths_tuple         : maths_tuple                   := [];
  the_empty_maths_value         : maths_value                   := the_empty_maths_tuple;
  the_empty_space               : finite_space                  := make_finite_space([]);
  the_generics                  : elementary_space              := make_elementary_space(es_generics);
  the_integer_tuples            : extended_tuple_space          :=
                                  make_extended_tuple_space(the_zero_tuple_space, the_integers);
  the_integers                  : elementary_space              := make_elementary_space(es_integers);
  the_logicals                  : elementary_space              := make_elementary_space(es_logicals);
  the_maths_spaces              : elementary_space              := make_elementary_space(es_maths_spaces);
  the_neg1_one_interval         : finite_real_interval          := make_finite_real_interval(-1.0, closed, 1.0, closed);
  the_neghalfpi_halfpi_interval : finite_real_interval          :=
                                  make_finite_real_interval(-0.5 * PI, closed, 0.5 * PI, closed);
  the_negpi_pi_interval         : finite_real_interval          := make_finite_real_interval(-PI, open, PI, closed);
  the_nonnegative_reals         : real_interval_from_min        := make_real_interval_from_min(0.0, closed);
  the_numbers                   : elementary_space              := make_elementary_space(es_numbers);
  the_real_tuples               : extended_tuple_space          :=
                                  make_extended_tuple_space(the_zero_tuple_space, the_reals);
  the_reals                     : elementary_space              := make_elementary_space(es_reals);
  the_strings                   : elementary_space              := make_elementary_space(es_strings);
  the_tuples                    : extended_tuple_space          :=
                                  make_extended_tuple_space(the_zero_tuple_space, the_generics);
  the_zero_one_interval         : finite_real_interval          := make_finite_real_interval(0.0, closed, 1.0, closed);
  the_zero_pi_interval          : finite_real_interval          := make_finite_real_interval(0.0, closed, PI, closed);
  the_zero_tuple_space          : listed_product_space          := make_listed_product_space([]);
END_CONSTANT;

TYPE absorbed_dose_measure = REAL;
END_TYPE;

TYPE acceleration_measure = REAL;
END_TYPE;

TYPE action_items = SELECT
  (action,
   action_directive,
   action_directive_relationship,
   action_method,
   action_method_assignment,
   action_method_relationship,
   action_property,
   action_property_representation,
   action_relationship,
   action_request_solution,
   action_request_status,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   action_status,
   address,
   alternate_product_relationship,
   analysis_assignment,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_attribute_classification_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_classification_assignment_relationship,
   applied_contract_assignment,
   applied_date_and_time_assignment,
   applied_date_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_experience_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_group_assignment,
   applied_identification_assignment,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_location_representation_assignment,
   applied_name_assignment,
   applied_organization_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_position_in_organization_group_assignment,
   applied_position_in_organization_type_assignment,
   applied_qualification_type_assignment,
   applied_security_classification_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval,
   approval_person_organization,
   approval_relationship,
   approval_status,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage,
   assembly_component_usage_substitute,
   assignment_object_relationship,
   assumption_assignment,
   assumption_relationship,
   attachment_slot_design_to_planned,
   attachment_slot_design_to_realized,
   attachment_slot_on_product,
   attachment_slot_planned_to_realized,
   attribute_language_assignment,
   breakdown_element_group_assignment,
   breakdown_element_usage,
   calendar_date,
   certification,
   characterized_object,
   collection_assignment,
   collection_membership,
   compound_person_name,
   configuration_design,
   configuration_effectivity,
   configuration_item,
   configuration_item_relationship,
   context_dependent_shape_representation,
   contract,
   contract_relationship,
   coordinated_universal_time_offset,
   date_and_time,
   date_and_time_assignment,
   date_assignment,
   derived_unit,
   derived_unit_element,
   description_text,
   descriptive_representation_item,
   document_file,
   document_relationship,
   document_type,
   effectivity,
   effectivity_relationship,
   envelope,
   environment_definition_view,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   executed_action,
   experience,
   experience_type,
   experience_type_relationship,
   external_source,
   general_property,
   general_property_relationship,
   generic_attribute,
   generic_property_relationship,
   group,
   group_relationship,
   hierarchical_interface_connection,
   identification_assignment_relationship,
   interface_connection,
   interface_connector_as_planned,
   interface_connector_as_realized,
   interface_connector_design,
   interface_connector_occurrence,
   interface_definition_connection,
   interface_definition_for,
   item_assumed,
   item_defined_transformation,
   item_identified_representation_usage,
   local_time,
   location,
   location_relationship,
   measure_qualification,
   measure_representation_item,
   measure_with_unit,
   multi_language_attribute_assignment,
   named_unit,
   observation_consequence,
   observed_environment_to_definition_version,
   observed_environment_view,
   organization,
   organization_relationship,
   organization_type,
   organizational_address,
   organizational_project,
   organizational_project_relationship,
   person,
   person_and_organization,
   person_type,
   person_type_definition,
   person_type_definition_relationship,
   position_in_organization,
   position_in_organization_assignment,
   position_in_organization_relationship,
   position_in_organization_type,
   position_in_organization_type_assignment,
   precision_qualifier,
   product,
   product_as_planned,
   product_category,
   product_concept,
   product_concept_context,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_context,
   product_definition_element_relationship,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_group_assignment,
   product_definition_relationship,
   product_design_version_to_individual,
   product_group,
   product_group_membership,
   product_group_relationship,
   product_planned_to_realized,
   product_related_product_category,
   product_relationship,
   property_definition,
   property_definition_relationship,
   property_definition_representation,
   qualification_type,
   qualification_type_relationship,
   representation,
   representation_context,
   representation_item,
   representation_relationship,
   requirement_assignment,
   resource_property,
   resource_property_representation,
   retention,
   risk_impact_assignment,
   risk_perception_source_assignment,
   security_classification,
   shape_aspect,
   shape_aspect_relationship,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_observed_role,
   state_type,
   state_type_relationship,
   state_type_role,
   structured_message,
   task_element,
   task_method,
   task_method_version,
   task_objective,
   time_interval,
   time_interval_relationship,
   time_interval_role,
   type_qualifier,
   uncertainty_qualifier,
   validation,
   value_format_type_qualifier,
   value_function,
   verification,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE action_method_items = SELECT
  (action,
   action_actual,
   action_method,
   action_method_assignment,
   action_method_relationship,
   action_property,
   action_property_representation,
   action_relationship,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_contract_assignment,
   applied_date_and_time_assignment,
   applied_date_assignment,
   applied_description_text_assignment,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_identification_assignment,
   applied_ineffectivity_assignment,
   applied_location_representation_assignment,
   applied_organization_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_security_classification_assignment,
   applied_state_observed_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval,
   ascribable_state,
   breakdown_element_usage,
   calendar_date,
   condition,
   configuration_item,
   contract,
   date_and_time,
   date_and_time_assignment,
   date_assignment,
   document_file,
   effectivity,
   envelope,
   event_occurrence,
   evidence,
   executed_action,
   general_property,
   general_property_relationship,
   group,
   group_relationship,
   hierarchical_interface_connection,
   interface_connection,
   interface_connector_occurrence,
   interface_definition_connection,
   justification_assignment,
   justification_group_assignment,
   justification_item_group_assignment,
   location,
   observation_consequence,
   organization,
   organization_role,
   organization_type,
   organizational_address,
   organizational_project,
   person,
   person_and_organization,
   person_type,
   person_type_definition,
   position_in_organization,
   position_in_organization_type,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_definition,
   product_definition_element_relationship,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_group,
   product_group_membership,
   product_group_relationship,
   product_planned_to_realized,
   product_related_product_category,
   product_relationship,
   property_definition,
   property_definition_representation,
   representation,
   representation_item,
   representation_relationship,
   requirement_assignment,
   resource_property,
   resource_property_representation,
   risk_impact_assignment,
   risk_perception,
   risk_perception_source_assignment,
   state_observed,
   state_observed_relationship,
   state_type,
   state_type_relationship,
   structured_message,
   validation,
   verification,
   versioned_action_request);
END_TYPE;

TYPE action_request_item = SELECT
  (action,
   action_method,
   action_property,
   action_resource,
   applied_action_assignment,
   contract,
   document_file,
   group,
   group_relationship,
   interface_connection,
   interface_connector_occurrence,
   interface_definition_connection,
   organization,
   organizational_project,
   person,
   person_and_organization,
   position_in_organization,
   product,
   product_definition,
   product_definition_formation,
   product_definition_relationship,
   product_group,
   product_group_membership,
   product_identification,
   property_definition,
   resource_property,
   state_observed,
   state_type);
END_TYPE;

TYPE ahead_or_behind = ENUMERATION OF
  (ahead,
   exact,
   behind);
END_TYPE;

TYPE amount_of_substance_measure = REAL;
END_TYPE;

TYPE analysed_item = SELECT
  (action,
   action_method,
   action_method_assignment,
   action_method_relationship,
   action_property,
   action_relationship,
   action_resource_relationship,
   alternate_product_relationship,
   ascribable_state,
   assembly_component_usage_substitute,
   evidence,
   group_relationship,
   interface_connection,
   interface_connector_occurrence,
   observation_consequence,
   organization,
   organization_relationship,
   organizational_project_relationship,
   product,
   product_concept,
   product_definition,
   product_definition_context,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_relationship,
   property_definition,
   requirement_assignment,
   resource_property,
   state_observed,
   state_observed_role,
   state_type,
   validation,
   verification);
END_TYPE;

TYPE approval_item = SELECT
  (action,
   action_directive,
   action_directive_relationship,
   action_method,
   action_method_relationship,
   action_property,
   action_relationship,
   action_request_solution,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_classification_assignment_relationship,
   applied_contract_assignment,
   applied_date_and_time_assignment,
   applied_date_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_experience_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_identification_assignment,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_organization_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_position_in_organization_group_assignment,
   applied_position_in_organization_type_assignment,
   applied_qualification_type_assignment,
   applied_security_classification_assignment,
   applied_state_observed_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval_relationship,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage,
   assembly_component_usage_substitute,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   attachment_slot_as_planned,
   attachment_slot_as_realized,
   attachment_slot_design,
   attachment_slot_design_to_planned,
   attachment_slot_design_to_realized,
   attachment_slot_on_product,
   attachment_slot_planned_to_realized,
   breakdown_element_group_assignment,
   breakdown_element_usage,
   certification,
   collection_assignment,
   collection_membership,
   configuration_design,
   configuration_effectivity,
   configuration_item,
   configuration_item_relationship,
   contract,
   contract_relationship,
   date_and_time_assignment,
   date_assignment,
   descriptive_representation_item,
   directed_action,
   document_file,
   document_relationship,
   effectivity,
   effectivity_relationship,
   envelope,
   envelope_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   executed_action,
   experience_type,
   experience_type_relationship,
   general_property,
   general_property_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   in_zone,
   information_usage_right,
   interface_connection,
   interface_connector_as_planned,
   interface_connector_as_realized,
   interface_connector_definition,
   interface_connector_design,
   interface_connector_design_to_planned,
   interface_connector_design_to_realized,
   interface_connector_occurrence,
   interface_connector_planned_to_realized,
   interface_connector_version,
   interface_definition_for,
   interface_specification_definition,
   interface_specification_version,
   item_assumed,
   justification_assignment,
   justification_group_assignment,
   justification_item_group_assignment,
   justification_support_assignment,
   justification_support_item_group_assignment,
   location_relationship,
   measure_representation_item,
   message_relationship,
   observation,
   observed_environment_to_definition,
   observed_environment_to_definition_version,
   organization_relationship,
   organizational_address,
   organizational_project,
   organizational_project_relationship,
   person_and_organization,
   person_and_organization_address,
   person_type,
   person_type_definition_relationship,
   position_in_organization,
   position_in_organization_relationship,
   position_in_organization_type,
   product,
   product_as_planned,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_context,
   product_definition_element_relationship,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_group_assignment,
   product_definition_relationship,
   product_design_to_individual,
   product_design_version_to_individual,
   product_group,
   product_group_membership,
   product_group_relationship,
   product_in_attachment_slot,
   product_planned_to_realized,
   product_related_product_category,
   product_relationship,
   property_definition,
   property_definition_relationship,
   property_definition_representation,
   qualification_type,
   qualification_type_relationship,
   representation,
   representation_item,
   representation_relationship,
   requirement_assignment,
   requirement_source,
   resource_property,
   risk_impact_assignment,
   risk_perception_source_assignment,
   security_classification,
   selected_item_assignment,
   state_observed_assignment,
   state_observed_relationship,
   state_type,
   state_type_assignment,
   state_type_relationship,
   structured_message,
   time_interval_relationship,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE approval_scope_item = SELECT
  (configuration_item,
   contract,
   executed_action,
   organization,
   organizational_project,
   person_and_organization,
   product_concept);
END_TYPE;

TYPE area_measure = REAL;
END_TYPE;

TYPE assignment_object_select = SELECT
  (action_method,
   action_request_solution,
   analysis_assignment,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_contract_assignment,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_organization_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_position_in_organization_assignment,
   applied_position_in_organization_group_assignment,
   applied_position_in_organization_type_assignment,
   applied_qualification_type_assignment,
   applied_security_classification_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   ascribable_state,
   collection_assignment,
   date_and_time_assignment,
   date_assignment,
   environment_assignment,
   justification_assignment,
   justification_support_assignment,
   observed_environment_assignment,
   organizational_address,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   property_definition,
   property_definition_representation,
   requirement_assignment,
   risk_impact_assignment,
   risk_perception_source_assignment,
   state_observed_assignment);
END_TYPE;

TYPE atom_based_tuple = LIST OF atom_based_value;
END_TYPE;

TYPE atom_based_value = SELECT
  (atom_based_tuple,
   maths_atom);
END_TYPE;

TYPE attribute_classification_item = SELECT
  (action,
   action_directive,
   action_method,
   action_method_relationship,
   action_property,
   action_property_representation,
   action_relationship,
   action_request_solution,
   action_request_status,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   address,
   alternate_product_relationship,
   application_context,
   application_context_element,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_location_representation_assignment,
   approval,
   approval_relationship,
   approval_role,
   approval_status,
   breakdown_context,
   breakdown_element_group_assignment,
   breakdown_element_usage,
   certification,
   certification_type,
   context_dependent_unit,
   contract_type,
   conversion_based_unit,
   date_role,
   date_time_role,
   derived_unit,
   descriptive_representation_item,
   document_relationship,
   document_type,
   document_usage_role,
   effectivity,
   effectivity_relationship,
   envelope,
   envelope_relationship,
   event_occurrence_context_role,
   event_occurrence_relationship,
   executed_action,
   general_property,
   general_property_relationship,
   group,
   identification_role,
   information_right,
   information_usage_right,
   interface_connection,
   interface_connector_definition,
   interface_definition_connection,
   interface_specification_definition,
   location,
   location_relationship,
   measure_representation_item,
   measure_with_unit,
   message_relationship,
   name_attribute,
   named_unit,
   object_role,
   organization_relationship,
   organization_role,
   organizational_address,
   organizational_project_relationship,
   organizational_project_role,
   person_and_organization_address,
   person_and_organization_role,
   product,
   product_category,
   product_concept,
   product_concept_context,
   product_context,
   product_definition,
   product_definition_context,
   product_definition_formation_relationship,
   product_definition_group_assignment,
   product_definition_relationship,
   product_design_version_to_individual,
   product_relationship,
   property_definition,
   property_definition_relationship,
   property_definition_representation,
   representation,
   representation_context,
   representation_item,
   resource_property,
   resource_property_representation,
   security_classification_level,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_type,
   state_type_assignment,
   state_type_relationship,
   structured_message,
   time_interval_relationship,
   uncertainty_measure_with_unit,
   usage_association,
   versioned_action_request);
END_TYPE;

TYPE attribute_language_item = SELECT
  (action,
   action_directive,
   action_directive_relationship,
   action_method,
   action_method_relationship,
   action_property,
   action_relationship,
   action_request_solution,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   address,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_classification_assignment_relationship,
   applied_description_text_assignment_relationship,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_experience_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_identification_assignment,
   applied_location_assignment,
   applied_location_representation_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   approval,
   approval_relationship,
   approval_status,
   ascribable_state,
   ascribable_state_relationship,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   attribute_value_assignment,
   certification,
   certification_type,
   class,
   compound_address,
   contract,
   date_and_time_assignment,
   date_assignment,
   date_role,
   date_time_role,
   description_text,
   document_relationship,
   document_usage_role,
   effectivity,
   effectivity_relationship,
   envelope,
   envelope_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   executed_action,
   experience_type,
   external_class_library,
   external_source,
   general_property,
   general_property_relationship,
   generic_attribute,
   generic_property_relationship,
   group,
   group_relationship,
   identification_role,
   in_zone,
   information_right,
   information_usage_right,
   interface_connection,
   interface_connector_occurrence,
   interface_definition_connection,
   interface_definition_for,
   item_assumed,
   justification_assignment,
   justification_group_assignment,
   justification_item_group_assignment,
   justification_support_assignment,
   justification_support_item_group_assignment,
   location,
   location_relationship,
   location_representation_relationship,
   measure_qualification,
   measure_representation_item,
   message_relationship,
   multi_language_attribute_assignment,
   object_role,
   observation,
   observation_consequence,
   organization,
   organization_relationship,
   organization_type,
   organizational_project,
   organizational_project_relationship,
   organizational_project_role,
   person_and_organization,
   person_type,
   person_type_definition,
   person_type_definition_relationship,
   position_in_organization,
   position_in_organization_assignment,
   position_in_organization_relationship,
   position_in_organization_type,
   product,
   product_concept,
   product_concept_context,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category,
   product_concept_relationship,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_group,
   product_group_relationship,
   product_relationship,
   property_definition,
   property_definition_relationship,
   property_definition_representation,
   qualification_type,
   representation,
   representation_context,
   representation_item,
   representation_relationship,
   requirement_assignment,
   requirement_source,
   resource_property,
   retention,
   risk_impact_assignment,
   risk_perception_source_assignment,
   satisfies_requirement,
   security_classification,
   state_observed,
   state_observed_relationship,
   state_type,
   state_type_relationship,
   structured_message,
   time_interval,
   time_interval_relationship,
   uncertainty_qualifier,
   validation,
   verification,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE attribute_select = SELECT
  (product_group_context,
   product_group_purpose);
END_TYPE;

TYPE attribute_type = SELECT
  (label,
   text);
END_TYPE;

TYPE capacitance_measure = REAL;
END_TYPE;

TYPE category_usage_item = SELECT
  (product_class);
END_TYPE;

TYPE celsius_temperature_measure = REAL;
END_TYPE;

TYPE certification_item = SELECT
  (action,
   action_method,
   action_resource,
   alternate_product_relationship,
   analysis_assignment,
   applied_action_method_assignment,
   applied_qualification_type_assignment,
   assembly_component_usage,
   configuration_item,
   evidence,
   group_relationship,
   interface_connection,
   interface_connector_version,
   interface_definition_connection,
   interface_specification_version,
   organizational_project,
   product,
   product_as_planned,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_occurrence,
   product_definition_occurrence_reference,
   product_definition_relationship,
   product_group,
   product_group_relationship,
   product_planned_to_realized,
   product_relationship);
END_TYPE;

TYPE chained_representation_link = SELECT
  (mapped_item,
   representation_context,
   representation_relationship);
END_TYPE;

TYPE characterized_action_definition = SELECT
  (action,
   action_method,
   action_method_relationship,
   action_relationship);
END_TYPE;

TYPE characterized_definition = SELECT
  (characterized_item,
   characterized_object,
   characterized_product_definition);
END_TYPE;

TYPE characterized_item = SELECT
  (dimensional_size,
   item_identified_representation_usage);
END_TYPE;

TYPE characterized_product_definition = SELECT
  (product_definition,
   product_definition_occurrence,
   product_definition_relationship);
END_TYPE;

TYPE characterized_resource_definition = SELECT
  (action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship);
END_TYPE;

TYPE class_usage_effectivity_context_item = SELECT
  (product_definition);
END_TYPE;

TYPE classification_item = SELECT
  (action,
   action_directive,
   action_directive_relationship,
   action_method,
   action_method_assignment,
   action_method_relationship,
   action_property,
   action_property_representation,
   action_relationship,
   action_request_solution,
   action_request_status,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   action_status,
   address,
   alternate_product_relationship,
   analysis_assignment,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_classification_assignment_relationship,
   applied_contract_assignment,
   applied_date_and_time_assignment,
   applied_date_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_experience_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_identification_assignment,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_location_representation_assignment,
   applied_organization_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_position_in_organization_group_assignment,
   applied_position_in_organization_type_assignment,
   applied_qualification_type_assignment,
   applied_security_classification_assignment,
   applied_state_observed_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval,
   approval_person_organization,
   approval_relationship,
   approval_status,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage_substitute,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   attachment_slot_design_to_planned,
   attachment_slot_design_to_realized,
   attachment_slot_on_product,
   attachment_slot_planned_to_realized,
   attribute_language_assignment,
   breakdown_context,
   breakdown_element_group_assignment,
   breakdown_element_usage,
   breakdown_of,
   calendar_date,
   certification,
   characterized_object,
   class,
   classified_item,
   collection_assignment,
   collection_membership,
   compound_person_name,
   compound_person_name_assignment,
   configuration_design,
   configuration_effectivity,
   configuration_item,
   configuration_item_relationship,
   connection_definition_to_connection,
   context_dependent_unit,
   contract,
   contract_relationship,
   conversion_based_unit,
   date_and_time,
   date_and_time_assignment,
   date_assignment,
   derived_unit,
   descriptive_representation_item,
   directed_action,
   document_file,
   document_relationship,
   effectivity,
   effectivity_relationship,
   envelope,
   envelope_relationship,
   environment_assignment,
   environment_definition,
   environment_definition_version,
   environment_view_definition_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   executed_action,
   experience,
   experience_type,
   experience_type_relationship,
   external_class_library,
   general_property,
   general_property_relationship,
   generic_attribute,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   in_zone,
   inclusion_product_concept_feature,
   information_right,
   information_usage_right,
   interface_connection,
   interface_connector_as_planned,
   interface_connector_as_realized,
   interface_connector_definition,
   interface_connector_design,
   interface_connector_design_to_planned,
   interface_connector_design_to_realized,
   interface_connector_occurrence,
   interface_connector_planned_to_realized,
   interface_definition_connection,
   interface_definition_for,
   item_assumed,
   justification_group_assignment,
   justification_support_assignment,
   language,
   local_time,
   location,
   location_relationship,
   location_representation_relationship,
   measure_qualification,
   measure_representation_item,
   measure_with_unit,
   message_relationship,
   multi_language_attribute_assignment,
   named_unit,
   observation,
   observation_consequence,
   observation_relationship,
   observed_environment,
   observed_environment_assignment,
   observed_environment_to_definition,
   observed_environment_to_definition_version,
   observed_environment_version,
   observed_environment_view_definition_relationship,
   organization,
   organization_relationship,
   organization_type,
   organizational_address,
   organizational_project,
   organizational_project_relationship,
   person,
   person_and_organization,
   person_and_organization_address,
   person_type,
   person_type_definition,
   person_type_definition_relationship,
   position_in_organization,
   position_in_organization_relationship,
   position_in_organization_type,
   product,
   product_category,
   product_concept,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_group_assignment,
   product_definition_relationship,
   product_definition_shape,
   product_design_to_individual,
   product_design_version_to_individual,
   product_group,
   product_group_membership,
   product_group_relationship,
   product_planned_to_realized,
   product_relationship,
   property_definition,
   property_definition_relationship,
   property_definition_representation,
   qualification_type,
   qualification_type_relationship,
   representation,
   representation_context,
   representation_item,
   representation_relationship,
   requirement_assignment,
   requirement_source,
   resource_property,
   resource_property_representation,
   retention,
   risk_impact_assignment,
   risk_perception_relationship,
   risk_perception_source_assignment,
   satisfies_requirement,
   security_classification,
   selected_item,
   selected_item_assignment,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_observed_role,
   state_type,
   state_type_assignment,
   state_type_relationship,
   structured_message,
   time_interval_relationship,
   uncertainty_measure_with_unit,
   usage_association,
   validation,
   verification,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE classified_item = SELECT
  (product,
   product_definition,
   product_definition_formation);
END_TYPE;

TYPE compound_item_definition = SELECT
  (list_representation_item,
   set_representation_item);
END_TYPE;

TYPE conductance_measure = REAL;
END_TYPE;

TYPE configuration_design_item = SELECT
  (product_definition,
   product_definition_formation,
   product_definition_occurrence);
END_TYPE;

TYPE configured_effectivity_context_item = SELECT
  (product_concept_feature_association);
END_TYPE;

TYPE configured_effectivity_item = SELECT
  (product_definition);
END_TYPE;

TYPE context_dependent_measure = REAL;
END_TYPE;

TYPE contract_item = SELECT
  (action,
   action_directive,
   action_method,
   action_method_relationship,
   action_resource,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_classification_assignment,
   applied_description_text_assignment,
   applied_external_identification_assignment,
   applied_identification_assignment,
   configuration_item,
   dependent_product_definition_exchange_context,
   external_class_library,
   externally_defined_class,
   group,
   information_usage_right,
   interface_connector_as_planned,
   interface_connector_as_realized,
   interface_connector_design,
   organization,
   organizational_project,
   person_and_organization,
   product,
   product_as_planned,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_group,
   product_group_relationship,
   requirement_assignment,
   requirement_source,
   requirement_view_definition_relationship,
   security_classification,
   structured_message,
   validation,
   verification,
   versioned_action_request);
END_TYPE;

TYPE count_measure = NUMBER;
END_TYPE;

TYPE date_and_time_item = SELECT
  (action,
   action_directive,
   action_directive_relationship,
   action_method,
   action_method_relationship,
   action_property,
   action_property_representation,
   action_relationship,
   action_request_solution,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   address,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_classification_assignment_relationship,
   applied_contract_assignment,
   applied_date_and_time_assignment,
   applied_date_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_experience_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_identification_assignment,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_location_representation_assignment,
   applied_organization_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_position_in_organization_group_assignment,
   applied_position_in_organization_type_assignment,
   applied_qualification_type_assignment,
   applied_security_classification_assignment,
   applied_state_observed_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval,
   approval_person_organization,
   approval_relationship,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage,
   assembly_component_usage_substitute,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   attachment_slot_design_to_planned,
   attachment_slot_design_to_realized,
   attachment_slot_planned_to_realized,
   breakdown_element_group_assignment,
   breakdown_element_usage,
   certification,
   collection_assignment,
   collection_membership,
   configuration_design,
   configuration_effectivity,
   configuration_item,
   configuration_item_relationship,
   contract,
   contract_relationship,
   date_and_time_assignment,
   date_assignment,
   descriptive_representation_item,
   directed_action,
   document_file,
   document_relationship,
   effectivity,
   effectivity_relationship,
   envelope,
   envelope_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   executed_action,
   experience,
   experience_type_relationship,
   general_property,
   general_property_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   hierarchical_interface_connection,
   identification_assignment_relationship,
   information_right,
   information_usage_right,
   interface_connection,
   interface_connector_as_planned,
   interface_connector_as_realized,
   interface_connector_design_to_planned,
   interface_connector_design_to_realized,
   interface_connector_occurrence,
   interface_connector_planned_to_realized,
   interface_definition_connection,
   interface_definition_for,
   item_assumed,
   justification_assignment,
   justification_group_assignment,
   justification_item_group_assignment,
   justification_support_assignment,
   justification_support_item_group_assignment,
   location,
   location_relationship,
   measure_representation_item,
   message_relationship,
   observation,
   observed_environment_to_definition,
   observed_environment_to_definition_version,
   organization,
   organization_relationship,
   organizational_address,
   organizational_project,
   organizational_project_relationship,
   person,
   person_and_organization,
   person_and_organization_address,
   person_type_definition_relationship,
   position_in_organization_relationship,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_group_assignment,
   product_definition_relationship,
   product_design_to_individual,
   product_design_version_to_individual,
   product_group,
   product_group_membership,
   product_group_relationship,
   product_in_attachment_slot,
   product_planned_to_realized,
   product_related_product_category,
   product_relationship,
   property_definition,
   property_definition_relationship,
   property_definition_representation,
   qualification_type_relationship,
   representation,
   representation_item,
   representation_relationship,
   requirement_assignment,
   requirement_source,
   resource_property,
   resource_property_representation,
   risk_impact_assignment,
   risk_perception_relationship,
   risk_perception_source_assignment,
   security_classification,
   selected_item,
   selected_item_assignment,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_type,
   state_type_assignment,
   state_type_relationship,
   structured_message,
   time_interval_relationship,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE date_item = SELECT
  (action,
   action_directive,
   action_directive_relationship,
   action_method,
   action_method_relationship,
   action_property,
   action_property_representation,
   action_relationship,
   action_request_solution,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   address,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_classification_assignment_relationship,
   applied_contract_assignment,
   applied_date_and_time_assignment,
   applied_date_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_experience_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_identification_assignment,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_location_representation_assignment,
   applied_organization_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_position_in_organization_group_assignment,
   applied_position_in_organization_type_assignment,
   applied_qualification_type_assignment,
   applied_security_classification_assignment,
   applied_state_observed_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval,
   approval_person_organization,
   approval_relationship,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage,
   assembly_component_usage_substitute,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   attachment_slot_design_to_planned,
   attachment_slot_design_to_realized,
   attachment_slot_planned_to_realized,
   breakdown_element_group_assignment,
   breakdown_element_usage,
   certification,
   collection_assignment,
   collection_membership,
   configuration_design,
   configuration_effectivity,
   configuration_item,
   configuration_item_relationship,
   contract,
   contract_relationship,
   date_and_time_assignment,
   date_assignment,
   descriptive_representation_item,
   directed_action,
   document_file,
   document_relationship,
   effectivity,
   effectivity_relationship,
   envelope,
   envelope_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   executed_action,
   experience,
   experience_type_relationship,
   general_property,
   general_property_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   hierarchical_interface_connection,
   identification_assignment_relationship,
   information_right,
   information_usage_right,
   interface_connection,
   interface_connector_as_planned,
   interface_connector_as_realized,
   interface_connector_design_to_planned,
   interface_connector_design_to_realized,
   interface_connector_occurrence,
   interface_connector_planned_to_realized,
   interface_definition_connection,
   interface_definition_for,
   item_assumed,
   justification_assignment,
   justification_group_assignment,
   justification_item_group_assignment,
   justification_support_assignment,
   justification_support_item_group_assignment,
   location,
   location_relationship,
   measure_representation_item,
   message_relationship,
   observed_environment_to_definition,
   observed_environment_to_definition_version,
   organization,
   organization_relationship,
   organizational_address,
   organizational_project,
   organizational_project_relationship,
   person,
   person_and_organization,
   person_and_organization_address,
   person_type_definition_relationship,
   position_in_organization_relationship,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_group_assignment,
   product_definition_relationship,
   product_design_to_individual,
   product_design_version_to_individual,
   product_group,
   product_group_membership,
   product_group_relationship,
   product_in_attachment_slot,
   product_planned_to_realized,
   product_related_product_category,
   product_relationship,
   property_definition,
   property_definition_relationship,
   property_definition_representation,
   qualification_type_relationship,
   representation,
   representation_item,
   representation_relationship,
   requirement_assignment,
   requirement_source,
   resource_property,
   resource_property_representation,
   risk_impact_assignment,
   risk_perception_relationship,
   risk_perception_source_assignment,
   security_classification,
   selected_item,
   selected_item_assignment,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_type,
   state_type_assignment,
   state_type_relationship,
   structured_message,
   time_interval_relationship,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE date_time_or_event_occurrence = SELECT
  (date_time_select,
   event_occurrence);
END_TYPE;

TYPE date_time_select = SELECT
  (date,
   date_and_time,
   local_time);
END_TYPE;

TYPE day_in_month_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 31};
END_TYPE;

TYPE day_in_week_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 7};
END_TYPE;

TYPE day_in_year_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 366};
END_TYPE;

TYPE derived_property_select = SELECT
  (action_property,
   dimensional_location,
   dimensional_size,
   property_definition,
   resource_property);
END_TYPE;

TYPE description_attribute_select = SELECT
  (action_request_solution,
   application_context,
   approval_role,
   configuration_design,
   context_dependent_shape_representation,
   date_role,
   date_time_role,
   effectivity,
   external_source,
   generic_attribute,
   organization_role,
   organizational_project,
   person_and_organization,
   person_and_organization_role,
   property_definition_representation,
   representation);
END_TYPE;

TYPE description_item = SELECT
  (action,
   action_directive,
   action_directive_relationship,
   action_method,
   action_method_relationship,
   action_property,
   action_property_representation,
   action_relationship,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   address,
   address_component,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_classification_assignment_relationship,
   applied_contract_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_identification_assignment,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_location_representation_assignment,
   applied_organization_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_group_assignment,
   applied_qualification_type_assignment,
   applied_security_classification_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval,
   approval_relationship,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage_substitute,
   assignment_object_relationship,
   certification,
   collection_assignment,
   collection_membership,
   compound_address,
   configuration_design,
   configuration_item,
   configuration_item_relationship,
   contract,
   contract_relationship,
   date_and_time_assignment,
   date_assignment,
   document_file,
   document_relationship,
   effectivity,
   effectivity_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   experience,
   experience_type,
   experience_type_relationship,
   external_source,
   general_property,
   general_property_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   item_identified_representation_usage,
   location,
   location_relationship,
   measure_qualification,
   observation_consequence,
   organization,
   organization_relationship,
   organization_type,
   organizational_project,
   organizational_project_relationship,
   person,
   person_and_organization,
   person_type,
   person_type_definition,
   person_type_definition_relationship,
   position_in_organization,
   position_in_organization_assignment,
   position_in_organization_relationship,
   position_in_organization_type,
   position_in_organization_type_assignment,
   product,
   product_concept,
   product_concept_context,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_group_membership,
   product_relationship,
   property_definition,
   property_definition_representation,
   qualification_type,
   qualification_type_relationship,
   representation,
   representation_context,
   representation_item,
   representation_relationship,
   resource_property,
   resource_property_representation,
   risk_impact_assignment,
   risk_perception_source_assignment,
   security_classification,
   shape_aspect,
   shape_aspect_relationship,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_observed_role,
   state_type,
   state_type_relationship,
   state_type_role,
   time_interval,
   time_interval_relationship,
   uncertainty_measure_with_unit,
   uncertainty_qualifier,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE descriptive_measure = STRING;
END_TYPE;

TYPE dimension_count = INTEGER;
WHERE
  WR1: SELF > 0;
END_TYPE;

TYPE document_reference_item = SELECT
  (action,
   action_directive,
   action_method,
   action_method_relationship,
   action_property,
   action_property_representation,
   action_relationship,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   address,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_contract_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_identification_assignment,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_location_representation_assignment,
   applied_organization_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_position_in_organization_assignment,
   applied_position_in_organization_group_assignment,
   applied_position_in_organization_type_assignment,
   applied_security_classification_assignment,
   applied_state_observed_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval,
   approval_relationship,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage,
   assembly_component_usage_substitute,
   assumption,
   assumption_assignment,
   assumption_relationship,
   attachment_slot_design_to_planned,
   attachment_slot_design_to_realized,
   attachment_slot_planned_to_realized,
   breakdown_context,
   breakdown_element_group_assignment,
   breakdown_element_usage,
   certification,
   class,
   configuration_design,
   configuration_item,
   contract,
   contract_relationship,
   date_and_time_assignment,
   date_assignment,
   descriptive_representation_item,
   document_relationship,
   effectivity,
   effectivity_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   executed_action,
   experience,
   experience_type,
   external_source,
   general_property,
   general_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   information_right,
   information_usage_right,
   interface_connection,
   interface_connector_as_planned,
   interface_connector_as_realized,
   interface_connector_design,
   interface_connector_design_to_planned,
   interface_connector_design_to_realized,
   interface_connector_occurrence,
   interface_connector_planned_to_realized,
   interface_definition_connection,
   item_assumed,
   item_identified_representation_usage,
   justification_assignment,
   justification_group_assignment,
   justification_item_group_assignment,
   justification_support_assignment,
   justification_support_item_group_assignment,
   location,
   location_relationship,
   measure_qualification,
   measure_representation_item,
   observation,
   observation_consequence,
   observed_environment_to_definition,
   observed_environment_to_definition_version,
   organization,
   organization_relationship,
   organization_type,
   organizational_address,
   organizational_project,
   organizational_project_relationship,
   person,
   person_and_organization,
   person_type,
   person_type_definition,
   person_type_definition_relationship,
   position_in_organization,
   position_in_organization_assignment,
   position_in_organization_relationship,
   position_in_organization_type,
   position_in_organization_type_assignment,
   product,
   product_concept,
   product_concept_context,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_group_assignment,
   product_definition_relationship,
   product_design_to_individual,
   product_design_version_to_individual,
   product_group,
   product_group_membership,
   product_group_relationship,
   product_planned_to_realized,
   product_relationship,
   property_definition,
   property_definition_representation,
   qualification_type,
   qualification_type_relationship,
   qualified_representation_item,
   representation,
   representation_item,
   representation_relationship,
   requirement_assignment,
   requirement_source,
   resource_property,
   resource_property_representation,
   retention,
   risk_impact_assignment,
   risk_perception_source_assignment,
   security_classification,
   selected_item,
   shape_aspect,
   shape_aspect_relationship,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_observed_role,
   state_type,
   state_type_relationship,
   state_type_role,
   structured_message,
   time_interval,
   time_interval_relationship,
   uncertainty_measure_with_unit,
   uncertainty_qualifier,
   versioned_action_request);
END_TYPE;

TYPE dose_equivalent_measure = REAL;
END_TYPE;

TYPE dotted_express_identifier = STRING;
WHERE
  SYNTAX: dotted_identifiers_syntax(SELF);
END_TYPE;

TYPE effectivity_item = SELECT
  (action,
   action_directive,
   action_directive_relationship,
   action_method,
   action_method_assignment,
   action_method_relationship,
   action_property,
   action_property_representation,
   action_relationship,
   action_resource_relationship,
   action_resource_requirement_relationship,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_classification_assignment_relationship,
   applied_contract_assignment,
   applied_date_and_time_assignment,
   applied_date_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_identification_assignment,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_organization_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_position_in_organization_group_assignment,
   applied_position_in_organization_type_assignment,
   applied_qualification_type_assignment,
   applied_security_classification_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval,
   approval_relationship,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage,
   assembly_component_usage_substitute,
   assignment_object_relationship,
   assumption,
   attachment_slot_as_planned,
   attachment_slot_as_realized,
   attachment_slot_design,
   attachment_slot_design_to_planned,
   attachment_slot_design_to_realized,
   attachment_slot_on_product,
   attachment_slot_planned_to_realized,
   breakdown_element_group_assignment,
   breakdown_element_usage,
   collection_assignment,
   collection_membership,
   compound_person_name,
   configuration_design,
   configuration_item,
   configuration_item_relationship,
   configured_effectivity_assignment,
   contract,
   contract_relationship,
   date_and_time_assignment,
   date_assignment,
   document_file,
   document_relationship,
   document_type,
   effectivity_relationship,
   envelope_relationship,
   event_occurrence_relationship,
   evidence,
   experience_type_relationship,
   general_property,
   general_property_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   interface_connection,
   interface_connector_design_to_planned,
   interface_connector_design_to_realized,
   interface_connector_occurrence,
   interface_connector_planned_to_realized,
   interface_definition_for,
   justification_group_assignment,
   justification_support_assignment,
   location_relationship,
   make_from_usage_option,
   message_relationship,
   multi_language_attribute_assignment,
   observed_environment_to_definition,
   observed_environment_to_definition_version,
   organization,
   organization_relationship,
   organizational_address,
   organizational_project,
   organizational_project_relationship,
   person_and_organization,
   person_and_organization_address,
   person_type_definition_relationship,
   position_in_organization_relationship,
   product,
   product_class,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_group_assignment,
   product_definition_relationship,
   product_definition_substitute,
   product_design_to_individual,
   product_design_version_to_individual,
   product_group,
   product_group_membership,
   product_group_relationship,
   product_in_attachment_slot,
   product_planned_to_realized,
   product_relationship,
   property_definition,
   property_definition_representation,
   qualification_type_relationship,
   representation,
   representation_item,
   representation_relationship,
   requirement_assignment,
   requirement_source,
   resource_property,
   resource_property_representation,
   risk_impact_assignment,
   risk_perception_source_assignment,
   security_classification,
   selected_item_assignment,
   state_observed_assignment,
   state_observed_relationship,
   state_type_assignment,
   state_type_relationship,
   time_interval_relationship,
   versioned_action_request_relationship);
END_TYPE;

TYPE electric_charge_measure = REAL;
END_TYPE;

TYPE electric_current_measure = REAL;
END_TYPE;

TYPE electric_potential_measure = REAL;
END_TYPE;

TYPE elementary_function_enumerators = ENUMERATION OF
  (ef_and,
   ef_or,
   ef_not,
   ef_xor,
   ef_negate_i,
   ef_add_i,
   ef_subtract_i,
   ef_multiply_i,
   ef_divide_i,
   ef_mod_i,
   ef_exponentiate_i,
   ef_eq_i,
   ef_ne_i,
   ef_gt_i,
   ef_lt_i,
   ef_ge_i,
   ef_le_i,
   ef_abs_i,
   ef_max_i,
   ef_min_i,
   ef_if_i,
   ef_negate_r,
   ef_reciprocal_r,
   ef_add_r,
   ef_subtract_r,
   ef_multiply_r,
   ef_divide_r,
   ef_mod_r,
   ef_exponentiate_r,
   ef_exponentiate_ri,
   ef_eq_r,
   ef_ne_r,
   ef_gt_r,
   ef_lt_r,
   ef_ge_r,
   ef_le_r,
   ef_abs_r,
   ef_max_r,
   ef_min_r,
   ef_acos_r,
   ef_asin_r,
   ef_atan2_r,
   ef_cos_r,
   ef_exp_r,
   ef_ln_r,
   ef_log2_r,
   ef_log10_r,
   ef_sin_r,
   ef_sqrt_r,
   ef_tan_r,
   ef_if_r,
   ef_form_c,
   ef_rpart_c,
   ef_ipart_c,
   ef_negate_c,
   ef_reciprocal_c,
   ef_add_c,
   ef_subtract_c,
   ef_multiply_c,
   ef_divide_c,
   ef_exponentiate_c,
   ef_exponentiate_ci,
   ef_eq_c,
   ef_ne_c,
   ef_conjugate_c,
   ef_abs_c,
   ef_arg_c,
   ef_cos_c,
   ef_exp_c,
   ef_ln_c,
   ef_sin_c,
   ef_sqrt_c,
   ef_tan_c,
   ef_if_c,
   ef_subscript_s,
   ef_eq_s,
   ef_ne_s,
   ef_gt_s,
   ef_lt_s,
   ef_ge_s,
   ef_le_s,
   ef_subsequence_s,
   ef_concat_s,
   ef_size_s,
   ef_format,
   ef_value,
   ef_like,
   ef_if_s,
   ef_subscript_b,
   ef_eq_b,
   ef_ne_b,
   ef_gt_b,
   ef_lt_b,
   ef_ge_b,
   ef_le_b,
   ef_subsequence_b,
   ef_concat_b,
   ef_size_b,
   ef_if_b,
   ef_subscript_t,
   ef_eq_t,
   ef_ne_t,
   ef_concat_t,
   ef_size_t,
   ef_entuple,
   ef_detuple,
   ef_insert,
   ef_remove,
   ef_if_t,
   ef_sum_it,
   ef_product_it,
   ef_add_it,
   ef_subtract_it,
   ef_scalar_mult_it,
   ef_dot_prod_it,
   ef_sum_rt,
   ef_product_rt,
   ef_add_rt,
   ef_subtract_rt,
   ef_scalar_mult_rt,
   ef_dot_prod_rt,
   ef_norm_rt,
   ef_sum_ct,
   ef_product_ct,
   ef_add_ct,
   ef_subtract_ct,
   ef_scalar_mult_ct,
   ef_dot_prod_ct,
   ef_norm_ct,
   ef_if,
   ef_ensemble,
   ef_member_of);
END_TYPE;

TYPE elementary_space_enumerators = ENUMERATION OF
  (es_numbers,
   es_complex_numbers,
   es_reals,
   es_integers,
   es_logicals,
   es_booleans,
   es_strings,
   es_binarys,
   es_maths_spaces,
   es_maths_functions,
   es_generics);
END_TYPE;

TYPE energy_measure = REAL;
END_TYPE;

TYPE event_occurrence_item = SELECT
  (action,
   action_directive,
   action_directive_relationship,
   action_method,
   action_method_relationship,
   action_property,
   action_relationship,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   address,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_classification_assignment_relationship,
   applied_contract_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_location_representation_assignment,
   applied_organization_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_position_in_organization_group_assignment,
   applied_position_in_organization_type_assignment,
   applied_qualification_type_assignment,
   applied_security_classification_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval,
   approval_relationship,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage_substitute,
   assignment_object_relationship,
   assumption,
   certification,
   collection_assignment,
   collection_membership,
   configuration_design,
   configuration_item_relationship,
   contract,
   contract_relationship,
   date_and_time_assignment,
   date_assignment,
   document_file,
   document_relationship,
   effectivity,
   effectivity_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   experience,
   experience_type_relationship,
   general_property,
   general_property_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   location,
   location_relationship,
   organization,
   organization_relationship,
   organizational_project,
   organizational_project_relationship,
   person,
   person_and_organization,
   person_type_definition_relationship,
   position_in_organization_relationship,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_group_membership,
   product_identification,
   product_relationship,
   property_definition,
   property_definition_representation,
   qualification_type_relationship,
   representation,
   representation_item,
   representation_relationship,
   risk_impact_assignment,
   risk_perception_source_assignment,
   security_classification,
   state_observed_assignment,
   state_observed_relationship,
   state_type_relationship,
   time_interval_relationship,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE evidence_item = SELECT
  (action_actual,
   action_method,
   action_relationship,
   action_status,
   analysis_assignment,
   applied_action_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_contract_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_ineffectivity_assignment,
   applied_organization_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_security_classification_assignment,
   applied_usage_right,
   date_and_time_assignment,
   date_assignment,
   group_relationship,
   justification_assignment,
   justification_support_assignment,
   person_and_organization,
   product,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_relationship,
   property_definition,
   property_definition_representation,
   representation,
   representation_item,
   risk_impact_assignment,
   validation,
   verification);
END_TYPE;

TYPE experience_item = SELECT
  (action_actual,
   action_resource,
   experience_type,
   experience_type_classification_item);
END_TYPE;

TYPE experience_type_classification_item = classification_item;
WHERE
  WR1: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION' IN TYPEOF(SELF));
  WR2: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_DIRECTIVE' IN TYPEOF(SELF));
  WR3: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_DIRECTIVE_RELATIONSHIP' IN TYPEOF(SELF));
  WR4: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_METHOD' IN TYPEOF(SELF));
  WR5: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_METHOD_ASSIGNMENT' IN TYPEOF(SELF));
  WR6: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_METHOD_RELATIONSHIP' IN TYPEOF(SELF));
  WR7: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_PROPERTY' IN TYPEOF(SELF));
  WR8: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_PROPERTY_REPRESENTATION' IN TYPEOF(SELF));
  WR9: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_RELATIONSHIP' IN TYPEOF(SELF));
  WR10: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_REQUEST_SOLUTION' IN TYPEOF(SELF));
  WR11: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_REQUEST_STATUS' IN TYPEOF(SELF));
  WR12: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_RESOURCE' IN TYPEOF(SELF));
  WR13: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_RESOURCE_RELATIONSHIP' IN TYPEOF(SELF));
  WR14: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_RESOURCE_REQUIREMENT' IN TYPEOF(SELF));
  WR15: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_RESOURCE_REQUIREMENT_RELATIONSHIP' IN TYPEOF(SELF));
  WR16: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_STATUS' IN TYPEOF(SELF));
  WR17: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ADDRESS' IN TYPEOF(SELF));
  WR18: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ALTERNATE_PRODUCT_RELATIONSHIP' IN TYPEOF(SELF));
  WR19: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ANALYSIS_ASSIGNMENT' IN TYPEOF(SELF));
  WR20: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_ACTION_ASSIGNMENT' IN TYPEOF(SELF));
  WR21: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_ACTION_METHOD_ASSIGNMENT' IN TYPEOF(SELF));
  WR22: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_ACTION_REQUEST_ASSIGNMENT' IN TYPEOF(SELF));
  WR23: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_APPROVAL_ASSIGNMENT' IN TYPEOF(SELF));
  WR24: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_CERTIFICATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR25: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_CLASSIFICATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR26: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_CLASSIFICATION_ASSIGNMENT_RELATIONSHIP' IN TYPEOF(SELF));
  WR27: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_CONTRACT_ASSIGNMENT' IN TYPEOF(SELF));
  WR28: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_DATE_AND_TIME_ASSIGNMENT' IN TYPEOF(SELF));
  WR29: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_DATE_ASSIGNMENT' IN TYPEOF(SELF));
  WR30: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_DESCRIPTION_TEXT_ASSIGNMENT' IN TYPEOF(SELF));
  WR31: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_DESCRIPTION_TEXT_ASSIGNMENT_RELATIONSHIP' IN
             TYPEOF(SELF));
  WR32: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_DIRECTED_ACTION_ASSIGNMENT' IN TYPEOF(SELF));
  WR33: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_DOCUMENT_REFERENCE' IN TYPEOF(SELF));
  WR34: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT' IN TYPEOF(SELF));
  WR35: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_EFFECTIVITY_ASSIGNMENT' IN TYPEOF(SELF));
  WR36: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_EVENT_OCCURRENCE_ASSIGNMENT' IN TYPEOF(SELF));
  WR37: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_EXPERIENCE_ASSIGNMENT' IN TYPEOF(SELF));
  WR38: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR39: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT_RELATIONSHIP' IN
             TYPEOF(SELF));
  WR40: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_IDENTIFICATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR41: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_INEFFECTIVITY_ASSIGNMENT' IN TYPEOF(SELF));
  WR42: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_LOCATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR43: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_LOCATION_REPRESENTATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR44: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_ORGANIZATIONAL_PROJECT_ASSIGNMENT' IN TYPEOF(SELF));
  WR45: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_ORGANIZATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR46: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_ORGANIZATION_TYPE_ASSIGNMENT' IN TYPEOF(SELF));
  WR47: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR48: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_PERSON_TYPE_ASSIGNMENT' IN TYPEOF(SELF));
  WR49: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_PERSON_TYPE_DEFINITION_ASSIGNMENT' IN TYPEOF(SELF));
  WR50: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_POSITION_IN_ORGANIZATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR51: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_POSITION_IN_ORGANIZATION_GROUP_ASSIGNMENT' IN
             TYPEOF(SELF));
  WR52: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_POSITION_IN_ORGANIZATION_TYPE_ASSIGNMENT' IN
             TYPEOF(SELF));
  WR53: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_QUALIFICATION_TYPE_ASSIGNMENT' IN TYPEOF(SELF));
  WR54: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR55: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_STATE_OBSERVED_ASSIGNMENT' IN TYPEOF(SELF));
  WR56: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_STATE_TYPE_ASSIGNMENT' IN TYPEOF(SELF));
  WR57: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_TIME_INTERVAL_ASSIGNMENT' IN TYPEOF(SELF));
  WR58: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_USAGE_RIGHT' IN TYPEOF(SELF));
  WR59: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPROVAL' IN TYPEOF(SELF));
  WR60: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPROVAL_PERSON_ORGANIZATION' IN TYPEOF(SELF));
  WR61: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPROVAL_RELATIONSHIP' IN TYPEOF(SELF));
  WR62: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPROVAL_STATUS' IN TYPEOF(SELF));
  WR63: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASCRIBABLE_STATE' IN TYPEOF(SELF));
  WR64: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASCRIBABLE_STATE_RELATIONSHIP' IN TYPEOF(SELF));
  WR65: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASSEMBLY_COMPONENT_USAGE_SUBSTITUTE' IN TYPEOF(SELF));
  WR66: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASSIGNMENT_OBJECT_RELATIONSHIP' IN TYPEOF(SELF));
  WR67: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASSUMPTION' IN TYPEOF(SELF));
  WR68: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASSUMPTION_ASSIGNMENT' IN TYPEOF(SELF));
  WR69: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASSUMPTION_RELATIONSHIP' IN TYPEOF(SELF));
  WR70: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ATTACHMENT_SLOT_DESIGN_TO_PLANNED' IN TYPEOF(SELF));
  WR71: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ATTACHMENT_SLOT_DESIGN_TO_REALIZED' IN TYPEOF(SELF));
  WR72: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ATTACHMENT_SLOT_ON_PRODUCT' IN TYPEOF(SELF));
  WR73: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ATTACHMENT_SLOT_PLANNED_TO_REALIZED' IN TYPEOF(SELF));
  WR74: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT' IN TYPEOF(SELF));
  WR75: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BREAKDOWN_CONTEXT' IN TYPEOF(SELF));
  WR76: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BREAKDOWN_ELEMENT_GROUP_ASSIGNMENT' IN TYPEOF(SELF));
  WR77: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BREAKDOWN_ELEMENT_USAGE' IN TYPEOF(SELF));
  WR78: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BREAKDOWN_OF' IN TYPEOF(SELF));
  WR79: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CALENDAR_DATE' IN TYPEOF(SELF));
  WR80: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CERTIFICATION' IN TYPEOF(SELF));
  WR81: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CHARACTERIZED_OBJECT' IN TYPEOF(SELF));
  WR82: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CLASS' IN TYPEOF(SELF));
  WR83: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CLASSIFIED_ITEM' IN TYPEOF(SELF));
  WR84: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COLLECTION_ASSIGNMENT' IN TYPEOF(SELF));
  WR85: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COLLECTION_MEMBERSHIP' IN TYPEOF(SELF));
  WR86: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COMPOUND_PERSON_NAME' IN TYPEOF(SELF));
  WR87: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COMPOUND_PERSON_NAME_ASSIGNMENT' IN TYPEOF(SELF));
  WR88: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONFIGURATION_DESIGN' IN TYPEOF(SELF));
  WR89: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONFIGURATION_EFFECTIVITY' IN TYPEOF(SELF));
  WR90: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONFIGURATION_ITEM' IN TYPEOF(SELF));
  WR91: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONFIGURATION_ITEM_RELATIONSHIP' IN TYPEOF(SELF));
  WR92: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONNECTION_DEFINITION_TO_CONNECTION' IN TYPEOF(SELF));
  WR93: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONTEXT_DEPENDENT_UNIT' IN TYPEOF(SELF));
  WR94: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONTRACT' IN TYPEOF(SELF));
  WR95: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONTRACT_RELATIONSHIP' IN TYPEOF(SELF));
  WR96: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONVERSION_BASED_UNIT' IN TYPEOF(SELF));
  WR97: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DATE_AND_TIME' IN TYPEOF(SELF));
  WR98: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DATE_AND_TIME_ASSIGNMENT' IN TYPEOF(SELF));
  WR99: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DATE_ASSIGNMENT' IN TYPEOF(SELF));
  WR100: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DERIVED_UNIT' IN TYPEOF(SELF));
  WR101: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(SELF));
  WR102: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DIRECTED_ACTION' IN TYPEOF(SELF));
  WR103: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DOCUMENT_FILE' IN TYPEOF(SELF));
  WR104: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DOCUMENT_RELATIONSHIP' IN TYPEOF(SELF));
  WR105: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EFFECTIVITY' IN TYPEOF(SELF));
  WR106: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EFFECTIVITY_RELATIONSHIP' IN TYPEOF(SELF));
  WR107: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ENVELOPE' IN TYPEOF(SELF));
  WR108: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ENVELOPE_RELATIONSHIP' IN TYPEOF(SELF));
  WR109: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ENVIRONMENT_ASSIGNMENT' IN TYPEOF(SELF));
  WR110: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ENVIRONMENT_DEFINITION' IN TYPEOF(SELF));
  WR111: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ENVIRONMENT_DEFINITION_VERSION' IN TYPEOF(SELF));
  WR112: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ENVIRONMENT_VIEW_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF));
  WR113: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EVENT_OCCURRENCE' IN TYPEOF(SELF));
  WR114: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EVENT_OCCURRENCE_RELATIONSHIP' IN TYPEOF(SELF));
  WR115: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EVIDENCE' IN TYPEOF(SELF));
  WR116: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXECUTED_ACTION' IN TYPEOF(SELF));
  WR117: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXPERIENCE' IN TYPEOF(SELF));
  WR118: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXPERIENCE_TYPE_RELATIONSHIP' IN TYPEOF(SELF));
  WR119: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXTERNAL_CLASS_LIBRARY' IN TYPEOF(SELF));
  WR120: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GENERAL_PROPERTY' IN TYPEOF(SELF));
  WR121: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GENERAL_PROPERTY_RELATIONSHIP' IN TYPEOF(SELF));
  WR122: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GENERIC_ATTRIBUTE' IN TYPEOF(SELF));
  WR123: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GENERIC_PROPERTY_RELATIONSHIP' IN TYPEOF(SELF));
  WR124: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GROUP' IN TYPEOF(SELF));
  WR125: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GROUP_RELATIONSHIP' IN TYPEOF(SELF));
  WR126: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP' IN TYPEOF(SELF));
  WR127: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF(SELF));
  WR128: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INFORMATION_RIGHT' IN TYPEOF(SELF));
  WR129: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INFORMATION_USAGE_RIGHT' IN TYPEOF(SELF));
  WR130: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_CONNECTION' IN TYPEOF(SELF));
  WR131: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_CONNECTOR_AS_PLANNED' IN TYPEOF(SELF));
  WR132: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_CONNECTOR_AS_REALIZED' IN TYPEOF(SELF));
  WR133: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_CONNECTOR_DEFINITION' IN TYPEOF(SELF));
  WR134: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_CONNECTOR_DESIGN' IN TYPEOF(SELF));
  WR135: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_CONNECTOR_DESIGN_TO_PLANNED' IN TYPEOF(SELF));
  WR136: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_CONNECTOR_DESIGN_TO_REALIZED' IN TYPEOF(SELF));
  WR137: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_CONNECTOR_OCCURRENCE' IN TYPEOF(SELF));
  WR138: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_CONNECTOR_PLANNED_TO_REALIZED' IN TYPEOF(SELF));
  WR139: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_DEFINITION_CONNECTION' IN TYPEOF(SELF));
  WR140: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_DEFINITION_FOR' IN TYPEOF(SELF));
  WR141: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.IN_ZONE' IN TYPEOF(SELF));
  WR142: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ITEM_ASSUMED' IN TYPEOF(SELF));
  WR143: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.JUSTIFICATION_GROUP_ASSIGNMENT' IN TYPEOF(SELF));
  WR144: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.JUSTIFICATION_SUPPORT_ASSIGNMENT' IN TYPEOF(SELF));
  WR145: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LANGUAGE' IN TYPEOF(SELF));
  WR146: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LOCAL_TIME' IN TYPEOF(SELF));
  WR147: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LOCATION' IN TYPEOF(SELF));
  WR148: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LOCATION_RELATIONSHIP' IN TYPEOF(SELF));
  WR149: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LOCATION_REPRESENTATION_RELATIONSHIP' IN TYPEOF(SELF));
  WR150: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MEASURE_QUALIFICATION' IN TYPEOF(SELF));
  WR151: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(SELF));
  WR152: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MEASURE_WITH_UNIT' IN TYPEOF(SELF));
  WR153: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MESSAGE_RELATIONSHIP' IN TYPEOF(SELF));
  WR154: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT' IN TYPEOF(SELF));
  WR155: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAMED_UNIT' IN TYPEOF(SELF));
  WR156: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVATION' IN TYPEOF(SELF));
  WR157: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVATION_CONSEQUENCE' IN TYPEOF(SELF));
  WR158: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVATION_RELATIONSHIP' IN TYPEOF(SELF));
  WR159: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVED_ENVIRONMENT' IN TYPEOF(SELF));
  WR160: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVED_ENVIRONMENT_ASSIGNMENT' IN TYPEOF(SELF));
  WR161: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVED_ENVIRONMENT_TO_DEFINITION' IN TYPEOF(SELF));
  WR162: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVED_ENVIRONMENT_TO_DEFINITION_VERSION' IN TYPEOF(SELF));
  WR163: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVED_ENVIRONMENT_VERSION' IN TYPEOF(SELF));
  WR164: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVED_ENVIRONMENT_VIEW_DEFINITION_RELATIONSHIP' IN
              TYPEOF(SELF));
  WR165: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORGANIZATION' IN TYPEOF(SELF));
  WR166: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORGANIZATIONAL_ADDRESS' IN TYPEOF(SELF));
  WR167: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORGANIZATIONAL_PROJECT' IN TYPEOF(SELF));
  WR168: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORGANIZATIONAL_PROJECT_RELATIONSHIP' IN TYPEOF(SELF));
  WR169: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORGANIZATION_RELATIONSHIP' IN TYPEOF(SELF));
  WR170: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORGANIZATION_TYPE' IN TYPEOF(SELF));
  WR171: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PERSON' IN TYPEOF(SELF));
  WR172: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PERSON_AND_ORGANIZATION' IN TYPEOF(SELF));
  WR173: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PERSON_AND_ORGANIZATION_ADDRESS' IN TYPEOF(SELF));
  WR174: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PERSON_TYPE' IN TYPEOF(SELF));
  WR175: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PERSON_TYPE_DEFINITION' IN TYPEOF(SELF));
  WR176: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PERSON_TYPE_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF));
  WR177: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POSITION_IN_ORGANIZATION' IN TYPEOF(SELF));
  WR178: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POSITION_IN_ORGANIZATION_RELATIONSHIP' IN TYPEOF(SELF));
  WR179: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POSITION_IN_ORGANIZATION_TYPE' IN TYPEOF(SELF));
  WR180: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT' IN TYPEOF(SELF));
  WR181: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CATEGORY' IN TYPEOF(SELF));
  WR182: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CONCEPT' IN TYPEOF(SELF));
  WR183: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CONCEPT_FEATURE_ASSOCIATION' IN TYPEOF(SELF));
  WR184: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE' IN TYPEOF(SELF));
  WR185: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CONCEPT_RELATIONSHIP' IN TYPEOF(SELF));
  WR186: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(SELF));
  WR187: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_CONTEXT' IN TYPEOF(SELF));
  WR188: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF));
  WR189: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_FORMATION_RELATIONSHIP' IN TYPEOF(SELF));
  WR190: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_GROUP_ASSIGNMENT' IN TYPEOF(SELF));
  WR191: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF));
  WR192: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(SELF));
  WR193: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DESIGN_TO_INDIVIDUAL' IN TYPEOF(SELF));
  WR194: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DESIGN_VERSION_TO_INDIVIDUAL' IN TYPEOF(SELF));
  WR195: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_GROUP' IN TYPEOF(SELF));
  WR196: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_GROUP_MEMBERSHIP' IN TYPEOF(SELF));
  WR197: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_GROUP_RELATIONSHIP' IN TYPEOF(SELF));
  WR198: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_PLANNED_TO_REALIZED' IN TYPEOF(SELF));
  WR199: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATIONSHIP' IN TYPEOF(SELF));
  WR200: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION' IN TYPEOF(SELF));
  WR201: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF));
  WR202: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION' IN TYPEOF(SELF));
  WR203: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.QUALIFICATION_TYPE' IN TYPEOF(SELF));
  WR204: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.QUALIFICATION_TYPE_RELATIONSHIP' IN TYPEOF(SELF));
  WR205: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION' IN TYPEOF(SELF));
  WR206: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_CONTEXT' IN TYPEOF(SELF));
  WR207: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(SELF));
  WR208: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_RELATIONSHIP' IN TYPEOF(SELF));
  WR209: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REQUIREMENT_ASSIGNMENT' IN TYPEOF(SELF));
  WR210: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REQUIREMENT_SOURCE' IN TYPEOF(SELF));
  WR211: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RESOURCE_PROPERTY' IN TYPEOF(SELF));
  WR212: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RESOURCE_PROPERTY_REPRESENTATION' IN TYPEOF(SELF));
  WR213: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RETENTION' IN TYPEOF(SELF));
  WR214: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RISK_IMPACT_ASSIGNMENT' IN TYPEOF(SELF));
  WR215: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RISK_PERCEPTION_RELATIONSHIP' IN TYPEOF(SELF));
  WR216: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RISK_PERCEPTION_SOURCE_ASSIGNMENT' IN TYPEOF(SELF));
  WR217: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SATISFIES_REQUIREMENT' IN TYPEOF(SELF));
  WR218: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SECURITY_CLASSIFICATION' IN TYPEOF(SELF));
  WR219: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SELECTED_ITEM' IN TYPEOF(SELF));
  WR220: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SELECTED_ITEM_ASSIGNMENT' IN TYPEOF(SELF));
  WR221: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STATE_OBSERVED' IN TYPEOF(SELF));
  WR222: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STATE_OBSERVED_ASSIGNMENT' IN TYPEOF(SELF));
  WR223: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STATE_OBSERVED_RELATIONSHIP' IN TYPEOF(SELF));
  WR224: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STATE_OBSERVED_ROLE' IN TYPEOF(SELF));
  WR225: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STATE_TYPE' IN TYPEOF(SELF));
  WR226: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STATE_TYPE_ASSIGNMENT' IN TYPEOF(SELF));
  WR227: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STATE_TYPE_RELATIONSHIP' IN TYPEOF(SELF));
  WR228: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STRUCTURED_MESSAGE' IN TYPEOF(SELF));
  WR229: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.TIME_INTERVAL_RELATIONSHIP' IN TYPEOF(SELF));
  WR230: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.UNCERTAINTY_MEASURE_WITH_UNIT' IN TYPEOF(SELF));
  WR231: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.USAGE_ASSOCIATION' IN TYPEOF(SELF));
  WR232: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VALIDATION' IN TYPEOF(SELF));
  WR233: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VERIFICATION' IN TYPEOF(SELF));
  WR234: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VERSIONED_ACTION_REQUEST' IN TYPEOF(SELF));
  WR235: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VERSIONED_ACTION_REQUEST_RELATIONSHIP' IN TYPEOF(SELF));
END_TYPE;

TYPE experience_type_item = SELECT
  (action_method,
   action_resource_requirement,
   executed_action,
   organization,
   person,
   person_and_organization);
END_TYPE;

TYPE express_identifier = dotted_express_identifier;
WHERE
  SYNTAX: dot_count(SELF) = 0;
END_TYPE;

TYPE extension_options = ENUMERATION OF
  (eo_none,
   eo_cont,
   eo_cont_right,
   eo_cont_left);
END_TYPE;

TYPE external_identification_item = SELECT
  (action,
   action_directive,
   action_method,
   action_resource,
   action_resource_requirement,
   action_status,
   address,
   address_component,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_experience_assignment,
   applied_external_identification_assignment,
   applied_location_representation_assignment,
   applied_position_in_organization_assignment,
   approval,
   approval_status,
   ascribable_state,
   assumption,
   attribute_language_assignment,
   breakdown_context,
   calendar_date,
   certification,
   collection_assignment,
   collection_membership,
   compound_address,
   contract,
   coordinated_universal_time_offset,
   date_and_time,
   derived_unit,
   derived_unit_element,
   document_file,
   effectivity,
   event_occurrence,
   evidence,
   executed_action,
   experience,
   experience_type,
   external_class_library,
   external_source,
   externally_defined_class,
   externally_defined_context_dependent_unit,
   externally_defined_conversion_based_unit,
   externally_defined_general_property,
   externally_defined_representation_item,
   general_property,
   generic_product_definition_reference,
   group,
   information_right,
   information_usage_right,
   interface_definition_connection,
   interface_definition_for,
   item_assumed,
   language,
   local_time,
   location,
   measure_with_unit,
   named_unit,
   organization,
   organization_type,
   organizational_project,
   person,
   person_and_organization,
   person_type,
   position_in_organization,
   position_in_organization_type,
   precision_qualifier,
   product,
   product_category,
   product_concept,
   product_concept_context,
   product_concept_feature,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_identification,
   property_definition,
   qualification_type,
   representation,
   representation_context,
   representation_item,
   requirement_source,
   security_classification,
   state_observed,
   state_observed_role,
   state_type,
   state_type_role,
   task_objective,
   time_interval,
   type_qualifier,
   uncertainty_qualifier,
   usage_association,
   value_format_type_qualifier,
   versioned_action_request);
END_TYPE;

TYPE force_measure = REAL;
END_TYPE;

TYPE founded_item_select = SELECT
  (representation_item);
END_TYPE;

TYPE frequency_measure = REAL;
END_TYPE;

TYPE generic_attribute_list_select = SELECT
  (address,
   name_attribute,
   person);
END_TYPE;

TYPE generic_attribute_select = SELECT
  (address,
   generic_attribute);
END_TYPE;

TYPE generic_property_definition_select = SELECT
  (action_property,
   dimensional_location,
   dimensional_size,
   property_definition,
   resource_property);
END_TYPE;

TYPE geometric_item_specific_usage_select = SELECT
  (shape_aspect,
   shape_aspect_relationship);
END_TYPE;

TYPE geometric_model_item = SELECT
  (geometric_representation_item);
END_TYPE;

TYPE groupable_item = SELECT
  (action,
   action_directive,
   action_directive_relationship,
   action_method,
   action_method_assignment,
   action_method_relationship,
   action_property,
   action_property_representation,
   action_relationship,
   action_request_solution,
   action_request_status,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   action_status,
   address,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_attribute_classification_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_classification_assignment_relationship,
   applied_contract_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_experience_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_group_assignment,
   applied_identification_assignment,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_location_representation_assignment,
   applied_name_assignment,
   applied_organization_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_position_in_organization_group_assignment,
   applied_position_in_organization_type_assignment,
   applied_qualification_type_assignment,
   applied_security_classification_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval,
   approval_person_organization,
   approval_relationship,
   approval_status,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage,
   assembly_component_usage_substitute,
   assignment_object_relationship,
   assumption,
   attribute_language_assignment,
   calendar_date,
   certification,
   class,
   collection_assignment,
   collection_membership,
   compound_person_name,
   configuration_design,
   configuration_item,
   configuration_item_relationship,
   context_dependent_shape_representation,
   contract,
   contract_relationship,
   coordinated_universal_time_offset,
   date_and_time,
   date_and_time_assignment,
   date_assignment,
   derived_unit,
   derived_unit_element,
   description_text,
   document_file,
   document_relationship,
   effectivity,
   effectivity_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   executed_action,
   experience,
   experience_type,
   experience_type_relationship,
   external_class_library,
   external_source,
   general_property,
   general_property_relationship,
   generic_attribute,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   information_right,
   information_usage_right,
   interface_definition_connection,
   interface_definition_for,
   item_defined_transformation,
   item_identified_representation_usage,
   justification_assignment,
   justification_group_assignment,
   justification_item_group_assignment,
   justification_support_assignment,
   justification_support_item_group_assignment,
   language,
   local_time,
   location,
   location_relationship,
   location_representation_item,
   measure_qualification,
   measure_with_unit,
   multi_language_attribute_assignment,
   named_unit,
   organization,
   organization_relationship,
   organization_type,
   organizational_project,
   organizational_project_relationship,
   package_product_concept_feature,
   person,
   person_and_organization,
   person_type,
   person_type_definition,
   person_type_definition_relationship,
   position_in_organization,
   position_in_organization_assignment,
   position_in_organization_relationship,
   position_in_organization_type,
   position_in_organization_type_assignment,
   precision_qualifier,
   product,
   product_category,
   product_concept,
   product_concept_context,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_group_membership,
   product_relationship,
   property_definition,
   property_definition_representation,
   qualification_type,
   qualification_type_relationship,
   representation,
   representation_context,
   representation_item,
   representation_relationship,
   requirement_assignment,
   requirement_source,
   resource_property,
   resource_property_representation,
   risk_impact_assignment,
   risk_perception_source_assignment,
   satisfies_requirement,
   security_classification,
   shape_aspect,
   shape_aspect_relationship,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_observed_role,
   state_type,
   state_type_assignment,
   state_type_relationship,
   state_type_role,
   time_interval,
   time_interval_relationship,
   time_interval_role,
   type_qualifier,
   uncertainty_qualifier,
   usage_association,
   value_format_type_qualifier,
   value_function,
   versioned_action_request,
   versioned_action_request_relationship);
WHERE
  WR1: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GROUP' IN TYPEOF(SELF));
END_TYPE;

TYPE hour_in_day = INTEGER;
WHERE
  WR1: {0 <= SELF < 24};
END_TYPE;

TYPE id_attribute_select = SELECT
  (action,
   address,
   application_context,
   ascribable_state_relationship,
   dimensional_size,
   group,
   organizational_project,
   product_category,
   property_definition,
   representation,
   shape_aspect,
   shape_aspect_relationship);
END_TYPE;

TYPE identification_item = SELECT
  (action,
   action_directive,
   action_directive_relationship,
   action_method,
   action_method_relationship,
   action_property,
   action_relationship,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   address,
   address_component,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_classification_assignment_relationship,
   applied_contract_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_location_representation_assignment,
   applied_organization_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_position_in_organization_group_assignment,
   applied_position_in_organization_type_assignment,
   applied_qualification_type_assignment,
   applied_security_classification_assignment,
   applied_state_observed_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval,
   approval_relationship,
   approval_status,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage_substitute,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   certification,
   class,
   collection_assignment,
   collection_membership,
   compound_address,
   configuration_design,
   configuration_effectivity,
   configuration_item,
   configuration_item_relationship,
   contract,
   contract_relationship,
   date_and_time_assignment,
   date_assignment,
   dependent_product_definition_exchange_context,
   derived_unit,
   descriptive_representation_item,
   directed_action,
   document_file,
   document_relationship,
   effectivity,
   effectivity_relationship,
   envelope_relationship,
   environment_assignment,
   environment_definition,
   environment_definition_version,
   environment_view_definition_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   executed_action,
   experience,
   experience_type,
   experience_type_relationship,
   external_class_library,
   general_property,
   general_property_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   information_right,
   information_usage_right,
   interface_connection,
   interface_connector_as_planned,
   interface_connector_as_realized,
   interface_connector_design,
   interface_connector_occurrence,
   interface_definition_connection,
   item_assumed,
   justification_assignment,
   justification_group_assignment,
   justification_item_group_assignment,
   justification_support_assignment,
   justification_support_item_group_assignment,
   location,
   location_relationship,
   measure_representation_item,
   message_relationship,
   named_unit,
   observation,
   observation_consequence,
   observed_environment,
   observed_environment_assignment,
   observed_environment_to_definition,
   observed_environment_version,
   observed_environment_view_definition_relationship,
   organization,
   organization_relationship,
   organization_type,
   organizational_address,
   organizational_project,
   organizational_project_relationship,
   person,
   person_and_organization,
   person_type,
   person_type_definition,
   person_type_definition_relationship,
   position_in_organization,
   position_in_organization_relationship,
   position_in_organization_type,
   product,
   product_as_planned,
   product_class,
   product_concept,
   product_concept_context,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_shape,
   product_design_to_individual,
   product_group,
   product_group_membership,
   product_group_relationship,
   product_identification,
   product_relationship,
   property_definition,
   property_definition_relationship,
   property_definition_representation,
   qualification_type,
   qualification_type_relationship,
   qualified_representation_item,
   representation,
   representation_context,
   representation_relationship,
   requirement_assignment,
   requirement_source,
   resource_property,
   retention,
   risk_impact_assignment,
   risk_perception_source_assignment,
   security_classification,
   security_classification_level,
   shape_aspect_relationship,
   shape_representation,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_type,
   state_type_assignment,
   state_type_relationship,
   structured_message,
   time_interval,
   time_interval_relationship,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE identifier = STRING;
END_TYPE;

TYPE illuminance_measure = REAL;
END_TYPE;

TYPE inductance_measure = REAL;
END_TYPE;

TYPE input_selector = positive_integer;
END_TYPE;

TYPE instance_usage_context_select = SELECT
  (breakdown_element_realization,
   product_definition_relationship,
   product_definition_usage);
END_TYPE;

TYPE ir_usage_item = action_items;
END_TYPE;

TYPE item_identified_representation_usage_definition = SELECT
  (dimensional_size,
   represented_definition);
END_TYPE;

TYPE item_identified_representation_usage_select = SELECT
  (list_representation_item,
   representation_item,
   set_representation_item);
END_TYPE;

TYPE justification_item = SELECT
  (action,
   action_method,
   action_method_relationship,
   action_property,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   analysis_assignment,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_approval_assignment,
   applied_classification_assignment,
   applied_description_text_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_location_assignment,
   applied_state_observed_assignment,
   applied_state_type_assignment,
   approval,
   ascribable_state,
   collection_membership,
   configuration_design,
   descriptive_representation_item,
   document_relationship,
   effectivity,
   evidence,
   executed_action,
   general_property,
   general_property_relationship,
   group,
   group_relationship,
   interface_connection,
   interface_connector_occurrence,
   interface_definition_connection,
   measure_representation_item,
   organizational_project,
   product,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_planned_to_realized,
   property_definition,
   representation,
   resource_property,
   state_observed_assignment,
   state_type_assignment,
   structured_message,
   validation,
   verification);
END_TYPE;

TYPE justification_support_item = SELECT
  (action,
   action_directive,
   action_method,
   action_method_relationship,
   action_property,
   action_request_solution,
   analysis_assignment,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_location_assignment,
   applied_organization_assignment,
   applied_person_and_organization_assignment,
   applied_state_observed_assignment,
   applied_state_type_assignment,
   approval,
   ascribable_state,
   assembly_component_usage,
   certification,
   contract,
   descriptive_representation_item,
   document_relationship,
   effectivity,
   event_occurrence,
   evidence,
   executed_action,
   general_property,
   general_property_relationship,
   group_relationship,
   interface_connection,
   interface_connector_occurrence,
   interface_definition_connection,
   location,
   measure_representation_item,
   observation,
   organizational_project,
   product,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_planned_to_realized,
   property_definition,
   resource_property,
   risk_impact_assignment,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_type,
   state_type_assignment,
   state_type_relationship,
   structured_message,
   validation,
   verification,
   versioned_action_request);
END_TYPE;

TYPE label = STRING;
END_TYPE;

TYPE length_measure = REAL;
END_TYPE;

TYPE list_representation_item = LIST [1 : ?] OF representation_item;
END_TYPE;

TYPE location_item = SELECT
  (action,
   action_method,
   action_request_solution,
   action_resource,
   action_resource_requirement,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_certification_assignment,
   applied_contract_assignment,
   assembly_component_usage,
   certification,
   collection_assignment,
   contract,
   contract_relationship,
   document_file,
   environment_definition_view,
   group_relationship,
   information_usage_right,
   interface_connection,
   interface_connector_occurrence,
   interface_definition_connection,
   observation_consequence,
   observed_environment_view,
   organization,
   organization_type,
   organizational_project,
   person,
   person_and_organization,
   person_type,
   person_type_definition,
   position_in_organization,
   position_in_organization_type,
   product,
   product_definition,
   product_definition_formation,
   product_definition_relationship,
   product_group);
END_TYPE;

TYPE location_representation_item = SELECT
  (interface_connection,
   interface_connector_occurrence,
   interface_definition_connection,
   organizational_address,
   person_and_organization_address,
   product,
   product_definition_formation);
END_TYPE;

TYPE lower_upper = ENUMERATION OF
  (lower,
   upper);
END_TYPE;

TYPE luminous_flux_measure = REAL;
END_TYPE;

TYPE luminous_intensity_measure = REAL;
END_TYPE;

TYPE magnetic_flux_density_measure = REAL;
END_TYPE;

TYPE magnetic_flux_measure = REAL;
END_TYPE;

TYPE mass_measure = REAL;
END_TYPE;

TYPE maths_atom = SELECT
  (maths_enum_atom,
   maths_simple_atom);
END_TYPE;

TYPE maths_binary = BINARY;
END_TYPE;

TYPE maths_boolean = BOOLEAN;
END_TYPE;

TYPE maths_enum_atom = SELECT
  (elementary_function_enumerators,
   elementary_space_enumerators,
   extension_options,
   lower_upper,
   open_closed,
   ordering_type,
   repackage_options,
   space_constraint_type,
   symmetry_type);
END_TYPE;

TYPE maths_expression = SELECT
  (atom_based_value,
   generic_expression,
   maths_tuple);
END_TYPE;

TYPE maths_function_select = SELECT
  (elementary_function_enumerators,
   maths_function);
END_TYPE;

TYPE maths_integer = INTEGER;
END_TYPE;

TYPE maths_logical = LOGICAL;
END_TYPE;

TYPE maths_number = NUMBER;
END_TYPE;

TYPE maths_real = REAL;
END_TYPE;

TYPE maths_simple_atom = SELECT
  (maths_binary,
   maths_boolean,
   maths_integer,
   maths_logical,
   maths_number,
   maths_real,
   maths_string);
END_TYPE;

TYPE maths_space_or_function = SELECT
  (maths_function,
   maths_space);
END_TYPE;

TYPE maths_string = STRING;
END_TYPE;

TYPE maths_tuple = LIST [0 : ?] OF maths_value;
END_TYPE;

TYPE maths_value = SELECT
  (atom_based_value,
   generic_expression,
   maths_tuple);
WHERE
  CONSTANCY: NOT ('GENERIC_EXPRESSION' IN stripped_typeof(SELF)) OR expression_is_constant(SELF);
END_TYPE;

TYPE measure_value = SELECT
  (absorbed_dose_measure,
   acceleration_measure,
   amount_of_substance_measure,
   area_measure,
   capacitance_measure,
   celsius_temperature_measure,
   conductance_measure,
   context_dependent_measure,
   count_measure,
   descriptive_measure,
   dose_equivalent_measure,
   electric_charge_measure,
   electric_current_measure,
   electric_potential_measure,
   energy_measure,
   force_measure,
   frequency_measure,
   illuminance_measure,
   inductance_measure,
   length_measure,
   luminous_flux_measure,
   luminous_intensity_measure,
   magnetic_flux_density_measure,
   magnetic_flux_measure,
   mass_measure,
   non_negative_length_measure,
   numeric_measure,
   parameter_value,
   plane_angle_measure,
   positive_length_measure,
   positive_plane_angle_measure,
   positive_ratio_measure,
   power_measure,
   pressure_measure,
   radioactivity_measure,
   ratio_measure,
   resistance_measure,
   solid_angle_measure,
   thermodynamic_temperature_measure,
   time_measure,
   velocity_measure,
   volume_measure);
END_TYPE;

TYPE message = STRING;
END_TYPE;

TYPE minute_in_hour = INTEGER;
WHERE
  WR1: {0 <= SELF <= 59};
END_TYPE;

TYPE month_in_year_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 12};
END_TYPE;

TYPE multi_language_attribute_item = SELECT
  (action,
   action_directive,
   action_directive_relationship,
   action_method,
   action_method_relationship,
   action_property,
   action_relationship,
   action_request_solution,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   address,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_classification_assignment_relationship,
   applied_description_text_assignment_relationship,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_experience_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_identification_assignment,
   applied_location_representation_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_position_in_organization_assignment,
   approval,
   approval_relationship,
   approval_status,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage,
   assembly_component_usage_substitute,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   attachment_slot_design_to_planned,
   attachment_slot_design_to_realized,
   attachment_slot_on_product,
   attachment_slot_planned_to_realized,
   breakdown_element_group_assignment,
   breakdown_element_usage,
   certification,
   certification_type,
   compound_address,
   configuration_item,
   contract,
   date_and_time_assignment,
   date_assignment,
   date_role,
   date_time_role,
   description_text,
   document_relationship,
   document_usage_role,
   effectivity,
   effectivity_relationship,
   envelope,
   envelope_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   executed_action,
   experience,
   experience_type,
   external_source,
   general_property,
   general_property_relationship,
   generic_attribute,
   generic_property_relationship,
   group,
   group_relationship,
   identification_role,
   information_right,
   information_usage_right,
   interface_connection,
   interface_connector_occurrence,
   interface_definition_connection,
   interface_definition_for,
   item_assumed,
   justification_assignment,
   justification_group_assignment,
   justification_item_group_assignment,
   justification_support_assignment,
   justification_support_item_group_assignment,
   location,
   location_relationship,
   measure_qualification,
   measure_representation_item,
   message_relationship,
   object_role,
   observation,
   observation_consequence,
   organization,
   organization_relationship,
   organization_type,
   organizational_project,
   organizational_project_relationship,
   organizational_project_role,
   person_and_organization,
   person_type,
   person_type_definition,
   person_type_definition_relationship,
   position_in_organization,
   position_in_organization_assignment,
   position_in_organization_relationship,
   position_in_organization_type,
   product,
   product_concept,
   product_concept_context,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_relationship,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_group_assignment,
   product_definition_relationship,
   product_group,
   product_group_relationship,
   product_relationship,
   property_definition,
   property_definition_relationship,
   property_definition_representation,
   qualification_type,
   qualification_type_relationship,
   representation,
   representation_context,
   representation_item,
   representation_relationship,
   requirement_assignment,
   requirement_source,
   resource_property,
   retention,
   risk_impact_assignment,
   risk_perception_source_assignment,
   security_classification,
   state_observed,
   state_observed_relationship,
   state_type,
   state_type_relationship,
   structured_message,
   time_interval,
   time_interval_relationship,
   uncertainty_qualifier,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE name_attribute_select = SELECT
  (action_request_solution,
   address,
   configuration_design,
   context_dependent_shape_representation,
   derived_unit,
   effectivity,
   person,
   person_and_organization,
   product_definition,
   product_definition_substitute,
   property_definition_representation);
END_TYPE;

TYPE name_item = SELECT
  (applied_action_assignment,
   applied_action_method_assignment,
   external_class_library,
   observation_consequence);
END_TYPE;

TYPE non_negative_length_measure = length_measure;
WHERE
  WR1: SELF >= 0.0;
END_TYPE;

TYPE nonnegative_integer = INTEGER;
WHERE
  NONNEGATIVITY: SELF >= 0;
END_TYPE;

TYPE numeric_measure = NUMBER;
END_TYPE;

TYPE observation_date = SELECT
  (observation);
END_TYPE;

TYPE one_or_two = positive_integer;
WHERE
  IN_RANGE: (SELF = 1) OR (SELF = 2);
END_TYPE;

TYPE open_closed = ENUMERATION OF
  (open,
   closed);
END_TYPE;

TYPE ordering_type = ENUMERATION OF
  (by_rows,
   by_columns);
END_TYPE;

TYPE organization_item = SELECT
  (action,
   action_directive,
   action_directive_relationship,
   action_method,
   action_method_relationship,
   action_property,
   action_property_representation,
   action_relationship,
   action_request_solution,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   address,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_classification_assignment_relationship,
   applied_contract_assignment,
   applied_date_and_time_assignment,
   applied_date_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_identification_assignment,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_location_representation_assignment,
   applied_organization_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_position_in_organization_group_assignment,
   applied_position_in_organization_type_assignment,
   applied_security_classification_assignment,
   applied_state_observed_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval,
   approval_relationship,
   approval_status,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage,
   assembly_component_usage_substitute,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   breakdown_element_group_assignment,
   breakdown_element_usage,
   certification,
   class,
   collection_assignment,
   collection_membership,
   configuration_design,
   configuration_effectivity,
   configuration_item,
   configuration_item_relationship,
   contract,
   contract_relationship,
   date_and_time_assignment,
   date_assignment,
   descriptive_representation_item,
   directed_action,
   document_file,
   document_relationship,
   effectivity,
   effectivity_relationship,
   envelope,
   envelope_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   executed_action,
   experience_type_relationship,
   general_property,
   general_property_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   information_right,
   information_usage_right,
   interface_connection,
   interface_connector_as_planned,
   interface_connector_as_realized,
   interface_connector_occurrence,
   interface_definition_connection,
   interface_definition_for,
   item_assumed,
   justification_assignment,
   justification_group_assignment,
   justification_item_group_assignment,
   justification_support_assignment,
   justification_support_item_group_assignment,
   location,
   location_relationship,
   measure_representation_item,
   message_relationship,
   observation,
   observed_environment_to_definition,
   organization,
   organization_relationship,
   organizational_address,
   organizational_project,
   organizational_project_relationship,
   person,
   person_and_organization,
   person_and_organization_address,
   person_type,
   person_type_definition_relationship,
   position_in_organization_relationship,
   position_in_organization_type,
   product,
   product_category,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_group_assignment,
   product_definition_relationship,
   product_design_to_individual,
   product_group,
   product_group_membership,
   product_group_relationship,
   product_related_product_category,
   product_relationship,
   property_definition,
   property_definition_relationship,
   property_definition_representation,
   qualification_type_relationship,
   representation,
   representation_item,
   representation_relationship,
   requirement_assignment,
   requirement_source,
   resource_property,
   resource_property_representation,
   risk_impact_assignment,
   risk_perception_source_assignment,
   security_classification,
   selected_item,
   selected_item_assignment,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_type,
   state_type_assignment,
   state_type_relationship,
   structured_message,
   time_interval_relationship,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE organization_type_item = SELECT
  (organization);
END_TYPE;

TYPE parameter_value = REAL;
END_TYPE;

TYPE person_and_organization_item = SELECT
  (action,
   action_directive,
   action_directive_relationship,
   action_method,
   action_method_relationship,
   action_property,
   action_property_representation,
   action_relationship,
   action_request_solution,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship,
   address,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_classification_assignment_relationship,
   applied_contract_assignment,
   applied_date_and_time_assignment,
   applied_date_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_directed_action_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_external_identification_assignment_relationship,
   applied_identification_assignment,
   applied_ineffectivity_assignment,
   applied_location_assignment,
   applied_location_representation_assignment,
   applied_organization_assignment,
   applied_organization_type_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_person_type_assignment,
   applied_person_type_definition_assignment,
   applied_position_in_organization_assignment,
   applied_position_in_organization_group_assignment,
   applied_position_in_organization_type_assignment,
   applied_qualification_type_assignment,
   applied_security_classification_assignment,
   applied_state_observed_assignment,
   applied_state_type_assignment,
   applied_time_interval_assignment,
   applied_usage_right,
   approval,
   approval_relationship,
   approval_status,
   ascribable_state,
   ascribable_state_relationship,
   assembly_component_usage,
   assembly_component_usage_substitute,
   assignment_object_relationship,
   assumption,
   assumption_assignment,
   assumption_relationship,
   breakdown_element_group_assignment,
   breakdown_element_usage,
   certification,
   class,
   collection_assignment,
   collection_membership,
   configuration_design,
   configuration_effectivity,
   configuration_item,
   configuration_item_relationship,
   contract,
   contract_relationship,
   date_and_time_assignment,
   date_assignment,
   descriptive_representation_item,
   directed_action,
   document_file,
   document_relationship,
   effectivity,
   effectivity_relationship,
   envelope,
   envelope_relationship,
   event_occurrence,
   event_occurrence_relationship,
   evidence,
   executed_action,
   experience_type_relationship,
   general_property,
   general_property_relationship,
   generic_property_relationship,
   group,
   group_relationship,
   identification_assignment_relationship,
   information_right,
   information_usage_right,
   interface_connection,
   interface_connector_as_planned,
   interface_connector_as_realized,
   interface_connector_occurrence,
   interface_definition_connection,
   interface_definition_for,
   item_assumed,
   justification_assignment,
   justification_group_assignment,
   justification_item_group_assignment,
   justification_support_assignment,
   justification_support_item_group_assignment,
   location,
   location_relationship,
   measure_representation_item,
   message_relationship,
   observation,
   observed_environment_to_definition,
   organization,
   organization_relationship,
   organizational_address,
   organizational_project,
   organizational_project_relationship,
   person,
   person_and_organization,
   person_and_organization_address,
   person_type,
   person_type_definition_relationship,
   position_in_organization_relationship,
   position_in_organization_type,
   product,
   product_category,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category_usage,
   product_concept_relationship,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_group_assignment,
   product_definition_relationship,
   product_design_to_individual,
   product_group,
   product_group_membership,
   product_group_relationship,
   product_related_product_category,
   product_relationship,
   property_definition,
   property_definition_relationship,
   property_definition_representation,
   qualification_type,
   qualification_type_relationship,
   representation,
   representation_item,
   representation_relationship,
   requirement_assignment,
   requirement_source,
   resource_property,
   resource_property_representation,
   risk_impact_assignment,
   risk_perception_source_assignment,
   security_classification,
   selected_item,
   selected_item_assignment,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_type,
   state_type_assignment,
   state_type_relationship,
   structured_message,
   time_interval_relationship,
   versioned_action_request,
   versioned_action_request_relationship);
END_TYPE;

TYPE person_definition_item = SELECT
  (experience_type,
   qualification_type);
END_TYPE;

TYPE person_organization_item = SELECT
  (person);
END_TYPE;

TYPE person_organization_select = SELECT
  (organization,
   person,
   person_and_organization);
END_TYPE;

TYPE person_type_item = SELECT
  (analysis_assignment,
   group,
   person,
   person_and_organization,
   position_in_organization,
   position_in_organization_type);
END_TYPE;

TYPE plane_angle_measure = REAL;
END_TYPE;

TYPE position_in_organization_group_assignment_item = SELECT
  (position_in_organization_assignment);
END_TYPE;

TYPE position_in_organization_group_item = SELECT
  (applied_organization_assignment,
   applied_person_and_organization_assignment,
   approval_person_organization,
   product,
   product_definition,
   product_definition_formation);
END_TYPE;

TYPE position_in_organization_item = SELECT
  (action_directive,
   action_resource,
   action_resource_requirement,
   address,
   applied_organization_assignment,
   applied_person_and_organization_assignment,
   approval_person_organization,
   organization,
   organizational_project,
   person,
   product,
   product_definition,
   product_definition_formation,
   product_group,
   requirement_view_definition_relationship,
   versioned_action_request);
END_TYPE;

TYPE position_in_organization_type_item = SELECT
  (action_directive,
   action_resource,
   action_resource_requirement,
   applied_organization_assignment,
   applied_person_and_organization_assignment,
   approval_person_organization,
   person_type,
   position_in_organization,
   product,
   product_definition,
   product_definition_formation,
   product_group,
   requirement_view_definition_relationship,
   versioned_action_request);
END_TYPE;

TYPE positive_integer = nonnegative_integer;
WHERE
  POSITIVITY: SELF > 0;
END_TYPE;

TYPE positive_length_measure = non_negative_length_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

TYPE positive_ratio_measure = ratio_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

TYPE power_measure = REAL;
END_TYPE;

TYPE pressure_measure = REAL;
END_TYPE;

TYPE process_or_process_relationship = SELECT
  (relationship_with_condition);
END_TYPE;

TYPE product_definition_occurrence_or_reference = SELECT
  (product_definition_occurrence,
   product_definition_occurrence_reference);
END_TYPE;

TYPE product_definition_or_assembly_relationship = SELECT
  (assembly_component_usage,
   product_definition);
END_TYPE;

TYPE product_definition_or_breakdown_element_usage = SELECT
  (product,
   product_definition,
   product_definition_formation,
   product_definition_usage);
END_TYPE;

TYPE product_definition_or_product_definition_relationship = SELECT
  (action_method,
   action_resource,
   executed_action,
   interface_connector_occurrence,
   product,
   product_definition,
   product_definition_formation,
   product_definition_usage,
   product_group);
END_TYPE;

TYPE product_definition_or_reference = SELECT
  (generic_product_definition_reference,
   product_class,
   product_definition,
   product_definition_formation,
   product_definition_occurrence,
   product_specification);
END_TYPE;

TYPE product_definition_or_reference_or_occurrence = product_definition_or_reference;
WHERE
  WR1: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GENERIC_PRODUCT_DEFINITION_REFERENCE' IN TYPEOF(SELF));
  WR2: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CLASS' IN TYPEOF(SELF));
END_TYPE;

TYPE product_or_formation_or_definition = SELECT
  (product,
   product_definition,
   product_definition_formation);
END_TYPE;

TYPE product_select = SELECT
  (action_method,
   environment_definition_view,
   executed_action,
   location,
   organization,
   organization_type,
   person,
   person_and_organization,
   product,
   product_concept,
   product_definition_formation,
   product_group);
END_TYPE;

TYPE product_space = SELECT
  (listed_product_space,
   uniform_product_space);
END_TYPE;

TYPE project_group_name_item = SELECT
  (applied_position_in_organization_group_assignment);
END_TYPE;

TYPE project_item = SELECT
  (action,
   action_method,
   action_method_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   assembly_component_usage,
   configuration_item,
   general_property,
   group,
   product,
   product_concept,
   product_definition,
   product_definition_formation,
   product_definition_occurrence,
   product_definition_occurrence_reference,
   product_group,
   product_group_membership,
   product_group_relationship,
   representation_item);
END_TYPE;

TYPE radioactivity_measure = REAL;
END_TYPE;

TYPE ratio_measure = REAL;
END_TYPE;

TYPE real_interval = SELECT
  (elementary_space,
   finite_real_interval,
   real_interval_from_min,
   real_interval_to_max);
WHERE
  WR1: NOT ('ELEMENTARY_SPACE' IN stripped_typeof(SELF)) OR (SELF\elementary_space.space_id = es_reals);
END_TYPE;

TYPE relationship_with_condition = SELECT
  (action_method_relationship,
   action_relationship,
   context_dependent_action_method_relationship,
   context_dependent_action_relationship);
END_TYPE;

TYPE repackage_options = ENUMERATION OF
  (ro_nochange,
   ro_wrap_as_tuple,
   ro_unwrap_tuple);
END_TYPE;

TYPE representation_or_representation_reference = SELECT
  (representation,
   representation_reference);
END_TYPE;

TYPE representation_proxy_select = SELECT
  (action_method,
   product_definition_formation,
   state_type,
   state_type_relationship);
END_TYPE;

TYPE represented_definition = SELECT
  (general_property,
   property_definition,
   property_definition_relationship,
   shape_aspect,
   shape_aspect_relationship);
END_TYPE;

TYPE requirement_assigned_item = SELECT
  (action_method,
   action_resource_requirement,
   alternate_product_relationship,
   applied_action_method_assignment,
   applied_state_observed_assignment,
   applied_state_type_assignment,
   assembly_component_usage,
   assembly_component_usage_substitute,
   breakdown_element_group_assignment,
   breakdown_element_usage,
   collection_membership,
   configuration_item,
   interface_connection,
   interface_connector_occurrence,
   organizational_project,
   product,
   product_definition,
   product_definition_formation,
   product_definition_group_assignment,
   product_group,
   product_group_membership,
   product_in_attachment_slot,
   product_relationship,
   state_observed,
   state_type,
   validation,
   verification,
   versioned_action_request);
END_TYPE;

TYPE requirement_satisfaction_item = SELECT
  (requirement_assigned_item);
END_TYPE;

TYPE requirement_source_item = SELECT
  (action_method,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_state_observed_assignment,
   applied_state_type_assignment,
   contract,
   executed_action,
   interface_connector_occurrence,
   organization,
   organizational_project,
   person_and_organization,
   product,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_usage,
   state_observed,
   state_type,
   validation,
   verification);
END_TYPE;

TYPE resistance_measure = REAL;
END_TYPE;

TYPE risk_action = SELECT
  (risk_acceptance,
   risk_analysis,
   risk_assessment,
   risk_communication,
   risk_control,
   risk_estimation,
   risk_evaluation,
   risk_identification,
   risk_treatment);
END_TYPE;

TYPE risk_impact_item = SELECT
  (action_method,
   action_relationship,
   action_resource,
   action_resource_relationship,
   applied_action_assignment,
   applied_organization_assignment,
   applied_person_and_organization_assignment,
   approval,
   ascribable_state,
   ascribable_state_relationship,
   executed_action,
   general_property,
   general_property_relationship,
   organization,
   person,
   person_and_organization,
   product,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   representation,
   representation_item,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_type_relationship);
END_TYPE;

TYPE risk_perception_source_item = SELECT
  (action,
   action_method,
   action_relationship,
   action_resource,
   action_resource_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_organization_assignment,
   applied_person_and_organization_assignment,
   approval,
   approval_person_organization,
   ascribable_state,
   ascribable_state_relationship,
   document_file,
   general_property,
   general_property_relationship,
   justification_assignment,
   justification_group_assignment,
   justification_item_group_assignment,
   justification_support_assignment,
   justification_support_item_group_assignment,
   organization,
   person,
   person_and_organization,
   product,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_relationship,
   property_definition,
   representation,
   representation_item,
   state_observed,
   state_observed_assignment,
   state_observed_relationship,
   state_type,
   state_type_relationship);
END_TYPE;

TYPE role_select = SELECT
  (action_assignment,
   action_request_assignment,
   approval_assignment,
   approval_date_time,
   certification_assignment,
   contract_assignment,
   directed_action_assignment,
   document_reference,
   effectivity_assignment,
   generic_attribute,
   group_assignment,
   name_assignment,
   security_classification_assignment);
END_TYPE;

TYPE second_in_minute = REAL;
WHERE
  WR1: {0 <= SELF < 60.0};
END_TYPE;

TYPE security_classification_item = SELECT
  (action,
   action_directive,
   action_method,
   action_method_relationship,
   action_resource,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_classification_assignment,
   applied_description_text_assignment,
   applied_description_text_assignment_relationship,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_external_identification_assignment,
   applied_identification_assignment,
   applied_state_observed_assignment,
   applied_state_type_assignment,
   assembly_component_usage,
   assembly_component_usage_substitute,
   attachment_slot_design_to_planned,
   attachment_slot_design_to_realized,
   attachment_slot_on_product,
   attachment_slot_planned_to_realized,
   breakdown_element_group_assignment,
   breakdown_element_usage,
   conditional_configuration,
   configuration_design,
   configuration_effectivity,
   configuration_item,
   connection_definition_to_connection,
   document_file,
   evidence,
   general_property,
   group,
   group_relationship,
   hierarchical_interface_connection,
   identification_assignment_relationship,
   interface_connection,
   interface_connector_as_planned,
   interface_connector_as_realized,
   interface_connector_design,
   interface_connector_occurrence,
   interface_definition_connection,
   interface_definition_for,
   observation,
   organizational_project,
   product,
   product_as_planned,
   product_class,
   product_concept_feature,
   product_concept_feature_category,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_group_assignment,
   product_definition_relationship,
   product_design_to_individual,
   product_design_version_to_individual,
   product_group,
   product_group_membership,
   product_group_relationship,
   product_relationship,
   property_definition,
   property_definition_representation,
   representation,
   requirement_assignment,
   requirement_source,
   structured_message,
   validation,
   verification,
   versioned_action_request);
END_TYPE;

TYPE selected_item_context_items = SELECT
  (configuration_item,
   contract,
   organizational_project,
   product,
   product_concept,
   product_definition_formation);
END_TYPE;

TYPE selected_item_select = classification_item;
WHERE
  WR1: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION' IN TYPEOF(SELF));
  WR2: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_DIRECTIVE' IN TYPEOF(SELF));
  WR3: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_DIRECTIVE_RELATIONSHIP' IN TYPEOF(SELF));
  WR4: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_METHOD' IN TYPEOF(SELF));
  WR5: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_METHOD_ASSIGNMENT' IN TYPEOF(SELF));
  WR6: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_METHOD_RELATIONSHIP' IN TYPEOF(SELF));
  WR7: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_PROPERTY' IN TYPEOF(SELF));
  WR8: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_PROPERTY_REPRESENTATION' IN TYPEOF(SELF));
  WR9: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_RELATIONSHIP' IN TYPEOF(SELF));
  WR10: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_REQUEST_SOLUTION' IN TYPEOF(SELF));
  WR11: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_REQUEST_STATUS' IN TYPEOF(SELF));
  WR12: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_RESOURCE' IN TYPEOF(SELF));
  WR13: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_RESOURCE_RELATIONSHIP' IN TYPEOF(SELF));
  WR14: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_RESOURCE_REQUIREMENT' IN TYPEOF(SELF));
  WR15: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_RESOURCE_REQUIREMENT_RELATIONSHIP' IN TYPEOF(SELF));
  WR16: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_STATUS' IN TYPEOF(SELF));
  WR17: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ADDRESS' IN TYPEOF(SELF));
  WR18: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ALTERNATE_PRODUCT_RELATIONSHIP' IN TYPEOF(SELF));
  WR19: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ANALYSIS_ASSIGNMENT' IN TYPEOF(SELF));
  WR20: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_ACTION_ASSIGNMENT' IN TYPEOF(SELF));
  WR21: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_ACTION_METHOD_ASSIGNMENT' IN TYPEOF(SELF));
  WR22: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_ACTION_REQUEST_ASSIGNMENT' IN TYPEOF(SELF));
  WR23: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_APPROVAL_ASSIGNMENT' IN TYPEOF(SELF));
  WR24: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_CERTIFICATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR25: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_CLASSIFICATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR26: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_CLASSIFICATION_ASSIGNMENT_RELATIONSHIP' IN TYPEOF(SELF));
  WR27: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_CONTRACT_ASSIGNMENT' IN TYPEOF(SELF));
  WR28: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_DATE_AND_TIME_ASSIGNMENT' IN TYPEOF(SELF));
  WR29: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_DATE_ASSIGNMENT' IN TYPEOF(SELF));
  WR30: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_DESCRIPTION_TEXT_ASSIGNMENT' IN TYPEOF(SELF));
  WR31: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_DESCRIPTION_TEXT_ASSIGNMENT_RELATIONSHIP' IN
             TYPEOF(SELF));
  WR32: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_DIRECTED_ACTION_ASSIGNMENT' IN TYPEOF(SELF));
  WR33: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_DOCUMENT_REFERENCE' IN TYPEOF(SELF));
  WR34: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT' IN TYPEOF(SELF));
  WR35: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_EFFECTIVITY_ASSIGNMENT' IN TYPEOF(SELF));
  WR36: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_EVENT_OCCURRENCE_ASSIGNMENT' IN TYPEOF(SELF));
  WR37: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_EXPERIENCE_ASSIGNMENT' IN TYPEOF(SELF));
  WR38: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR39: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT_RELATIONSHIP' IN
             TYPEOF(SELF));
  WR40: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_IDENTIFICATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR41: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_INEFFECTIVITY_ASSIGNMENT' IN TYPEOF(SELF));
  WR42: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_LOCATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR43: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_LOCATION_REPRESENTATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR44: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_ORGANIZATIONAL_PROJECT_ASSIGNMENT' IN TYPEOF(SELF));
  WR45: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_ORGANIZATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR46: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_ORGANIZATION_TYPE_ASSIGNMENT' IN TYPEOF(SELF));
  WR47: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR48: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_PERSON_TYPE_ASSIGNMENT' IN TYPEOF(SELF));
  WR49: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_PERSON_TYPE_DEFINITION_ASSIGNMENT' IN TYPEOF(SELF));
  WR50: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_POSITION_IN_ORGANIZATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR51: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_POSITION_IN_ORGANIZATION_GROUP_ASSIGNMENT' IN
             TYPEOF(SELF));
  WR52: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_POSITION_IN_ORGANIZATION_TYPE_ASSIGNMENT' IN
             TYPEOF(SELF));
  WR53: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_QUALIFICATION_TYPE_ASSIGNMENT' IN TYPEOF(SELF));
  WR54: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT' IN TYPEOF(SELF));
  WR55: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_STATE_OBSERVED_ASSIGNMENT' IN TYPEOF(SELF));
  WR56: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_STATE_TYPE_ASSIGNMENT' IN TYPEOF(SELF));
  WR57: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_TIME_INTERVAL_ASSIGNMENT' IN TYPEOF(SELF));
  WR58: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_USAGE_RIGHT' IN TYPEOF(SELF));
  WR59: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPROVAL' IN TYPEOF(SELF));
  WR60: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPROVAL_PERSON_ORGANIZATION' IN TYPEOF(SELF));
  WR61: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPROVAL_RELATIONSHIP' IN TYPEOF(SELF));
  WR62: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPROVAL_STATUS' IN TYPEOF(SELF));
  WR63: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASCRIBABLE_STATE' IN TYPEOF(SELF));
  WR64: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASCRIBABLE_STATE_RELATIONSHIP' IN TYPEOF(SELF));
  WR65: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASSEMBLY_COMPONENT_USAGE_SUBSTITUTE' IN TYPEOF(SELF));
  WR66: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASSIGNMENT_OBJECT_RELATIONSHIP' IN TYPEOF(SELF));
  WR67: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASSUMPTION' IN TYPEOF(SELF));
  WR68: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASSUMPTION_ASSIGNMENT' IN TYPEOF(SELF));
  WR69: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASSUMPTION_RELATIONSHIP' IN TYPEOF(SELF));
  WR70: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ATTACHMENT_SLOT_DESIGN_TO_PLANNED' IN TYPEOF(SELF));
  WR71: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ATTACHMENT_SLOT_DESIGN_TO_REALIZED' IN TYPEOF(SELF));
  WR72: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ATTACHMENT_SLOT_ON_PRODUCT' IN TYPEOF(SELF));
  WR73: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ATTACHMENT_SLOT_PLANNED_TO_REALIZED' IN TYPEOF(SELF));
  WR74: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT' IN TYPEOF(SELF));
  WR75: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BREAKDOWN_CONTEXT' IN TYPEOF(SELF));
  WR76: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BREAKDOWN_ELEMENT_GROUP_ASSIGNMENT' IN TYPEOF(SELF));
  WR77: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BREAKDOWN_ELEMENT_USAGE' IN TYPEOF(SELF));
  WR78: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BREAKDOWN_OF' IN TYPEOF(SELF));
  WR79: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CALENDAR_DATE' IN TYPEOF(SELF));
  WR80: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CERTIFICATION' IN TYPEOF(SELF));
  WR81: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CHARACTERIZED_OBJECT' IN TYPEOF(SELF));
  WR82: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CLASS' IN TYPEOF(SELF));
  WR83: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CLASSIFIED_ITEM' IN TYPEOF(SELF));
  WR84: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COLLECTION_ASSIGNMENT' IN TYPEOF(SELF));
  WR85: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COLLECTION_MEMBERSHIP' IN TYPEOF(SELF));
  WR86: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COMPOUND_PERSON_NAME' IN TYPEOF(SELF));
  WR87: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COMPOUND_PERSON_NAME_ASSIGNMENT' IN TYPEOF(SELF));
  WR88: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONFIGURATION_DESIGN' IN TYPEOF(SELF));
  WR89: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONFIGURATION_EFFECTIVITY' IN TYPEOF(SELF));
  WR90: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONFIGURATION_ITEM' IN TYPEOF(SELF));
  WR91: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONFIGURATION_ITEM_RELATIONSHIP' IN TYPEOF(SELF));
  WR92: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONNECTION_DEFINITION_TO_CONNECTION' IN TYPEOF(SELF));
  WR93: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONTEXT_DEPENDENT_UNIT' IN TYPEOF(SELF));
  WR94: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONTRACT' IN TYPEOF(SELF));
  WR95: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONTRACT_RELATIONSHIP' IN TYPEOF(SELF));
  WR96: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONVERSION_BASED_UNIT' IN TYPEOF(SELF));
  WR97: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DATE_AND_TIME' IN TYPEOF(SELF));
  WR98: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DATE_AND_TIME_ASSIGNMENT' IN TYPEOF(SELF));
  WR99: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DATE_ASSIGNMENT' IN TYPEOF(SELF));
  WR100: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DERIVED_UNIT' IN TYPEOF(SELF));
  WR101: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(SELF));
  WR102: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DIRECTED_ACTION' IN TYPEOF(SELF));
  WR103: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DOCUMENT_FILE' IN TYPEOF(SELF));
  WR104: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DOCUMENT_RELATIONSHIP' IN TYPEOF(SELF));
  WR105: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EFFECTIVITY' IN TYPEOF(SELF));
  WR106: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EFFECTIVITY_RELATIONSHIP' IN TYPEOF(SELF));
  WR107: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ENVELOPE' IN TYPEOF(SELF));
  WR108: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ENVELOPE_RELATIONSHIP' IN TYPEOF(SELF));
  WR109: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ENVIRONMENT_ASSIGNMENT' IN TYPEOF(SELF));
  WR110: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ENVIRONMENT_DEFINITION' IN TYPEOF(SELF));
  WR111: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ENVIRONMENT_DEFINITION_VERSION' IN TYPEOF(SELF));
  WR112: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ENVIRONMENT_VIEW_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF));
  WR113: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EVENT_OCCURRENCE' IN TYPEOF(SELF));
  WR114: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EVENT_OCCURRENCE_RELATIONSHIP' IN TYPEOF(SELF));
  WR115: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EVIDENCE' IN TYPEOF(SELF));
  WR116: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXECUTED_ACTION' IN TYPEOF(SELF));
  WR117: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXPERIENCE' IN TYPEOF(SELF));
  WR118: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXPERIENCE_TYPE' IN TYPEOF(SELF));
  WR119: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXPERIENCE_TYPE_RELATIONSHIP' IN TYPEOF(SELF));
  WR120: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXTERNAL_CLASS_LIBRARY' IN TYPEOF(SELF));
  WR121: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GENERAL_PROPERTY' IN TYPEOF(SELF));
  WR122: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GENERAL_PROPERTY_RELATIONSHIP' IN TYPEOF(SELF));
  WR123: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GENERIC_ATTRIBUTE' IN TYPEOF(SELF));
  WR124: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GENERIC_PROPERTY_RELATIONSHIP' IN TYPEOF(SELF));
  WR125: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GROUP' IN TYPEOF(SELF));
  WR126: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GROUP_RELATIONSHIP' IN TYPEOF(SELF));
  WR127: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP' IN TYPEOF(SELF));
  WR128: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF(SELF));
  WR129: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INFORMATION_RIGHT' IN TYPEOF(SELF));
  WR130: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INFORMATION_USAGE_RIGHT' IN TYPEOF(SELF));
  WR131: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_CONNECTOR_AS_PLANNED' IN TYPEOF(SELF));
  WR132: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_CONNECTOR_AS_REALIZED' IN TYPEOF(SELF));
  WR133: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_CONNECTOR_DESIGN' IN TYPEOF(SELF));
  WR134: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_CONNECTOR_DESIGN_TO_PLANNED' IN TYPEOF(SELF));
  WR135: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_CONNECTOR_DESIGN_TO_REALIZED' IN TYPEOF(SELF));
  WR136: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_CONNECTOR_PLANNED_TO_REALIZED' IN TYPEOF(SELF));
  WR137: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERFACE_DEFINITION_FOR' IN TYPEOF(SELF));
  WR138: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.IN_ZONE' IN TYPEOF(SELF));
  WR139: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ITEM_ASSUMED' IN TYPEOF(SELF));
  WR140: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.JUSTIFICATION_GROUP_ASSIGNMENT' IN TYPEOF(SELF));
  WR141: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.JUSTIFICATION_SUPPORT_ASSIGNMENT' IN TYPEOF(SELF));
  WR142: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LANGUAGE' IN TYPEOF(SELF));
  WR143: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LOCAL_TIME' IN TYPEOF(SELF));
  WR144: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LOCATION' IN TYPEOF(SELF));
  WR145: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LOCATION_RELATIONSHIP' IN TYPEOF(SELF));
  WR146: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LOCATION_REPRESENTATION_RELATIONSHIP' IN TYPEOF(SELF));
  WR147: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MEASURE_QUALIFICATION' IN TYPEOF(SELF));
  WR148: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(SELF));
  WR149: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MEASURE_WITH_UNIT' IN TYPEOF(SELF));
  WR150: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MESSAGE_RELATIONSHIP' IN TYPEOF(SELF));
  WR151: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT' IN TYPEOF(SELF));
  WR152: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAMED_UNIT' IN TYPEOF(SELF));
  WR153: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVATION' IN TYPEOF(SELF));
  WR154: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVATION_CONSEQUENCE' IN TYPEOF(SELF));
  WR155: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVATION_RELATIONSHIP' IN TYPEOF(SELF));
  WR156: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVED_ENVIRONMENT' IN TYPEOF(SELF));
  WR157: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVED_ENVIRONMENT_ASSIGNMENT' IN TYPEOF(SELF));
  WR158: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVED_ENVIRONMENT_TO_DEFINITION' IN TYPEOF(SELF));
  WR159: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVED_ENVIRONMENT_TO_DEFINITION_VERSION' IN TYPEOF(SELF));
  WR160: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVED_ENVIRONMENT_VERSION' IN TYPEOF(SELF));
  WR161: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OBSERVED_ENVIRONMENT_VIEW_DEFINITION_RELATIONSHIP' IN
              TYPEOF(SELF));
  WR162: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORGANIZATION' IN TYPEOF(SELF));
  WR163: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORGANIZATIONAL_ADDRESS' IN TYPEOF(SELF));
  WR164: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORGANIZATIONAL_PROJECT' IN TYPEOF(SELF));
  WR165: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORGANIZATIONAL_PROJECT_RELATIONSHIP' IN TYPEOF(SELF));
  WR166: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORGANIZATION_RELATIONSHIP' IN TYPEOF(SELF));
  WR167: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORGANIZATION_TYPE' IN TYPEOF(SELF));
  WR168: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PERSON' IN TYPEOF(SELF));
  WR169: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PERSON_AND_ORGANIZATION' IN TYPEOF(SELF));
  WR170: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PERSON_AND_ORGANIZATION_ADDRESS' IN TYPEOF(SELF));
  WR171: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PERSON_TYPE' IN TYPEOF(SELF));
  WR172: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PERSON_TYPE_DEFINITION' IN TYPEOF(SELF));
  WR173: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PERSON_TYPE_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF));
  WR174: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POSITION_IN_ORGANIZATION' IN TYPEOF(SELF));
  WR175: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POSITION_IN_ORGANIZATION_RELATIONSHIP' IN TYPEOF(SELF));
  WR176: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POSITION_IN_ORGANIZATION_TYPE' IN TYPEOF(SELF));
  WR177: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CATEGORY' IN TYPEOF(SELF));
  WR178: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CONCEPT' IN TYPEOF(SELF));
  WR179: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CONCEPT_FEATURE_ASSOCIATION' IN TYPEOF(SELF));
  WR180: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE' IN TYPEOF(SELF));
  WR181: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CONCEPT_RELATIONSHIP' IN TYPEOF(SELF));
  WR182: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(SELF));
  WR183: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_CONTEXT' IN TYPEOF(SELF));
  WR184: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_FORMATION_RELATIONSHIP' IN TYPEOF(SELF));
  WR185: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_GROUP_ASSIGNMENT' IN TYPEOF(SELF));
  WR186: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF));
  WR187: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(SELF));
  WR188: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DESIGN_TO_INDIVIDUAL' IN TYPEOF(SELF));
  WR189: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DESIGN_VERSION_TO_INDIVIDUAL' IN TYPEOF(SELF));
  WR190: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_GROUP' IN TYPEOF(SELF));
  WR191: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_GROUP_MEMBERSHIP' IN TYPEOF(SELF));
  WR192: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_GROUP_RELATIONSHIP' IN TYPEOF(SELF));
  WR193: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_PLANNED_TO_REALIZED' IN TYPEOF(SELF));
  WR194: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATIONSHIP' IN TYPEOF(SELF));
  WR195: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION' IN TYPEOF(SELF));
  WR196: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF));
  WR197: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION' IN TYPEOF(SELF));
  WR198: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.QUALIFICATION_TYPE' IN TYPEOF(SELF));
  WR199: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.QUALIFICATION_TYPE_RELATIONSHIP' IN TYPEOF(SELF));
  WR200: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION' IN TYPEOF(SELF));
  WR201: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_CONTEXT' IN TYPEOF(SELF));
  WR202: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(SELF));
  WR203: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_RELATIONSHIP' IN TYPEOF(SELF));
  WR204: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REQUIREMENT_ASSIGNMENT' IN TYPEOF(SELF));
  WR205: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REQUIREMENT_SOURCE' IN TYPEOF(SELF));
  WR206: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RESOURCE_PROPERTY' IN TYPEOF(SELF));
  WR207: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RESOURCE_PROPERTY_REPRESENTATION' IN TYPEOF(SELF));
  WR208: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RETENTION' IN TYPEOF(SELF));
  WR209: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RISK_IMPACT_ASSIGNMENT' IN TYPEOF(SELF));
  WR210: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RISK_PERCEPTION_RELATIONSHIP' IN TYPEOF(SELF));
  WR211: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RISK_PERCEPTION_SOURCE_ASSIGNMENT' IN TYPEOF(SELF));
  WR212: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SATISFIES_REQUIREMENT' IN TYPEOF(SELF));
  WR213: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SECURITY_CLASSIFICATION' IN TYPEOF(SELF));
  WR214: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SELECTED_ITEM' IN TYPEOF(SELF));
  WR215: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SELECTED_ITEM_ASSIGNMENT' IN TYPEOF(SELF));
  WR216: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STATE_OBSERVED' IN TYPEOF(SELF));
  WR217: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STATE_OBSERVED_ASSIGNMENT' IN TYPEOF(SELF));
  WR218: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STATE_OBSERVED_RELATIONSHIP' IN TYPEOF(SELF));
  WR219: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STATE_OBSERVED_ROLE' IN TYPEOF(SELF));
  WR220: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STATE_TYPE' IN TYPEOF(SELF));
  WR221: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STATE_TYPE_ASSIGNMENT' IN TYPEOF(SELF));
  WR222: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STATE_TYPE_RELATIONSHIP' IN TYPEOF(SELF));
  WR223: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STRUCTURED_MESSAGE' IN TYPEOF(SELF));
  WR224: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.TIME_INTERVAL_RELATIONSHIP' IN TYPEOF(SELF));
  WR225: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.UNCERTAINTY_MEASURE_WITH_UNIT' IN TYPEOF(SELF));
  WR226: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.USAGE_ASSOCIATION' IN TYPEOF(SELF));
  WR227: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VALIDATION' IN TYPEOF(SELF));
  WR228: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VERIFICATION' IN TYPEOF(SELF));
  WR229: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VERSIONED_ACTION_REQUEST' IN TYPEOF(SELF));
  WR230: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VERSIONED_ACTION_REQUEST_RELATIONSHIP' IN TYPEOF(SELF));
END_TYPE;

TYPE set_representation_item = SET [1 : ?] OF representation_item;
END_TYPE;

TYPE shape_aspect_or_characterized_object = SELECT
  (characterized_object,
   shape_aspect);
END_TYPE;

TYPE shape_model = SELECT
  (shape_representation);
END_TYPE;

TYPE si_prefix = ENUMERATION OF
  (exa,
   peta,
   tera,
   giga,
   mega,
   kilo,
   hecto,
   deca,
   deci,
   centi,
   milli,
   micro,
   nano,
   pico,
   femto,
   atto);
END_TYPE;

TYPE si_unit_name = ENUMERATION OF
  (metre,
   gram,
   second,
   ampere,
   kelvin,
   mole,
   candela,
   radian,
   steradian,
   hertz,
   newton,
   pascal,
   joule,
   watt,
   coulomb,
   volt,
   farad,
   ohm,
   siemens,
   weber,
   tesla,
   henry,
   degree_celsius,
   lumen,
   lux,
   becquerel,
   gray,
   sievert);
END_TYPE;

TYPE solid_angle_measure = REAL;
END_TYPE;

TYPE source_item = SELECT
  (identifier,
   message);
END_TYPE;

TYPE space_constraint_type = ENUMERATION OF
  (sc_equal,
   sc_subspace,
   sc_member);
END_TYPE;

TYPE state_observed_of_item = SELECT
  (action,
   action_directive,
   action_method,
   action_property,
   action_relationship,
   action_resource,
   action_resource_relationship,
   action_resource_requirement,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_approval_assignment,
   applied_contract_assignment,
   applied_directed_action_assignment,
   applied_external_identification_assignment,
   applied_location_assignment,
   applied_organizational_project_assignment,
   approval,
   assembly_component_usage,
   assembly_component_usage_substitute,
   assumption,
   attachment_slot_design_to_planned,
   attachment_slot_design_to_realized,
   attachment_slot_on_product,
   attachment_slot_planned_to_realized,
   breakdown_element_group_assignment,
   breakdown_element_usage,
   certification,
   collection_membership,
   configuration_design,
   configuration_item,
   contract,
   document_file,
   evidence,
   executed_action,
   group,
   group_relationship,
   interface_connection,
   interface_connector_as_planned,
   interface_connector_as_realized,
   interface_connector_definition,
   interface_connector_design,
   interface_connector_occurrence,
   interface_connector_version,
   interface_definition_connection,
   interface_specification_definition,
   interface_specification_version,
   location,
   organization,
   organizational_project,
   person_and_organization,
   product,
   product_as_planned,
   product_category,
   product_concept,
   product_definition,
   product_definition_element_relationship,
   product_definition_formation,
   product_definition_group_assignment,
   product_definition_relationship,
   product_group,
   product_in_attachment_slot,
   property_definition,
   requirement_assignment,
   resource_property,
   risk_impact_assignment,
   security_classification,
   state_observed_assignment,
   structured_message,
   task_method_version,
   versioned_action_request);
END_TYPE;

TYPE state_type_of_item = SELECT
  (action,
   action_directive,
   action_method,
   action_property,
   action_relationship,
   action_resource,
   action_resource_relationship,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_method_assignment,
   applied_external_identification_assignment,
   approval,
   assembly_component_usage,
   assembly_component_usage_substitute,
   assumption,
   attachment_slot_design_to_planned,
   attachment_slot_design_to_realized,
   attachment_slot_on_product,
   attachment_slot_planned_to_realized,
   breakdown_element_group_assignment,
   breakdown_element_usage,
   certification,
   configuration_item,
   contract,
   document_file,
   evidence,
   executed_action,
   group_relationship,
   interface_connection,
   interface_connector_as_planned,
   interface_connector_as_realized,
   interface_connector_definition,
   interface_connector_design,
   interface_connector_occurrence,
   interface_connector_version,
   interface_definition_connection,
   interface_specification_definition,
   interface_specification_version,
   location,
   organization,
   organizational_project,
   person_and_organization,
   product,
   product_as_planned,
   product_category,
   product_concept,
   product_definition,
   product_definition_formation,
   product_definition_group_assignment,
   product_definition_relationship,
   product_group,
   product_in_attachment_slot,
   risk_attitude,
   risk_impact_assignment,
   security_classification,
   validation,
   verification,
   versioned_action_request);
END_TYPE;

TYPE supported_item = SELECT
  (action,
   action_directive,
   action_method);
END_TYPE;

TYPE symmetry_type = ENUMERATION OF
  (identity,
   skew,
   hermitian,
   skew_hermitian);
END_TYPE;

TYPE text = STRING;
END_TYPE;

TYPE thermodynamic_temperature_measure = REAL;
END_TYPE;

TYPE time_interval_item = SELECT
  (action,
   action_directive,
   action_method,
   action_method_relationship,
   action_resource,
   action_resource_requirement,
   address,
   analysis_assignment,
   applied_action_assignment,
   applied_certification_assignment,
   applied_classification_assignment,
   applied_contract_assignment,
   applied_date_and_time_assignment,
   applied_date_assignment,
   applied_description_text_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_event_occurrence_assignment,
   applied_identification_assignment,
   applied_location_representation_assignment,
   approval,
   approval_person_organization,
   assumption,
   assumption_assignment,
   assumption_relationship,
   certification,
   class,
   contract,
   document_file,
   effectivity,
   event_occurrence,
   evidence,
   general_property,
   group_relationship,
   identification_assignment_relationship,
   interface_connection,
   interface_connector_occurrence,
   interface_definition_connection,
   item_assumed,
   location,
   organization,
   organization_relationship,
   organizational_address,
   organizational_project,
   person,
   person_and_organization,
   person_and_organization_address,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_category,
   product_definition,
   product_definition_formation,
   product_identification,
   representation,
   representation_item,
   requirement_source,
   satisfies_requirement,
   security_classification,
   validation,
   verification,
   versioned_action_request);
END_TYPE;

TYPE time_measure = REAL;
END_TYPE;

TYPE transformation = SELECT
  (functionally_defined_transformation,
   item_defined_transformation);
END_TYPE;

TYPE tuple_space = SELECT
  (extended_tuple_space,
   product_space);
END_TYPE;

TYPE unit = SELECT
  (derived_unit,
   named_unit);
END_TYPE;

TYPE value_format_type = identifier;
WHERE
  WR1: LENGTH(SELF) <= 80;
END_TYPE;

TYPE value_qualifier = SELECT
  (maths_value_precision_qualifier,
   precision_qualifier,
   type_qualifier,
   uncertainty_qualifier,
   value_format_type_qualifier);
END_TYPE;

TYPE vector_or_direction = SELECT
  (direction,
   vector);
END_TYPE;

TYPE velocity_measure = REAL;
END_TYPE;

TYPE volume_measure = REAL;
END_TYPE;

TYPE week_in_year_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 53};
END_TYPE;

TYPE year_number = INTEGER;
WHERE
  WR1: (SELF > 1581);
END_TYPE;

TYPE zero_or_one = nonnegative_integer;
WHERE
  IN_RANGE: (SELF = 0) OR (SELF = 1);
END_TYPE;

ENTITY abs_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY absorbed_dose_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ABSORBED_DOSE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY absorbed_dose_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.gray);
END_ENTITY;

ENTITY abstracted_expression_function
  SUBTYPE OF (maths_function, quantifier_expression);
DERIVE
  SELF\quantifier_expression.variables                            : LIST [1 : ?] OF UNIQUE generic_variable := remove_first(SELF\multiple_arity_generic_expression.operands);
  expr                                 : generic_expression                      := SELF\multiple_arity_generic_expression.operands[1];
WHERE
  WR1: SIZEOF(QUERY(operand <* SELF\multiple_arity_generic_expression.operands | NOT (has_values_space(operand)))) = 0;
END_ENTITY;

ENTITY acceleration_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACCELERATION_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY acceleration_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensional_exponents(1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0);
END_ENTITY;

ENTITY acos_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY action;
  name          : label;
  description   : OPTIONAL text;
  chosen_method : action_method;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY action_actual
  SUBTYPE OF (executed_action);
END_ENTITY;

ENTITY action_assignment
  ABSTRACT SUPERTYPE OF ((ONEOF(applied_usage_right, applied_action_assignment)));
  assigned_action : action;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY action_directive;
  name        : label;
  description : OPTIONAL text;
  analysis    : text;
  comment     : text;
  requests    : SET [1 : ?] OF versioned_action_request;
END_ENTITY;

ENTITY action_directive_relationship;
  name          : label;
  description   : OPTIONAL STRING;
  relating      : action_directive;
  related       : action_directive;
  relation_type : STRING;
WHERE
  WR1: acyclic_action_directive_relationship(SELF, [related],
                                             'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_DIRECTIVE_RELATIONSHIP');
END_ENTITY;

ENTITY action_happening
  SUBTYPE OF (action_relationship);
END_ENTITY;

ENTITY action_method
  SUPERTYPE OF (ONEOF(task_element, task_method, task_method_version, task_objective));
  name        : label;
  description : OPTIONAL text;
  consequence : text;
  purpose     : text;
END_ENTITY;

ENTITY action_method_assignment
  ABSTRACT SUPERTYPE;
  assigned_action_method : action_method;
  role                   : action_method_role;
END_ENTITY;

ENTITY action_method_relationship
  SUPERTYPE OF (ONEOF(task_element_relationship, task_method_relationship, task_method_version_relationship));
  name            : label;
  description     : OPTIONAL text;
  relating_method : action_method;
  related_method  : action_method;
END_ENTITY;

ENTITY action_method_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY action_method_to_select_from
  SUBTYPE OF (action_method);
  number_of_elements : count_measure;
WHERE
  WR1: number_of_elements >= 1;
  WR2: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_METHOD_RELATIONSHIP.RELATING_METHOD')) >=
       number_of_elements;
END_ENTITY;

ENTITY action_method_with_associated_documents
  SUBTYPE OF (action_method);
  documents : SET [1 : ?] OF document;
END_ENTITY;

ENTITY action_method_with_associated_documents_constrained
  SUBTYPE OF (action_method_with_associated_documents);
  usage_constraints : SET [1 : ?] OF document_usage_constraint;
WHERE
  WR1: SIZEOF(QUERY(item
                    <* usage_constraints
                    | NOT (item.source IN SELF\action_method_with_associated_documents.documents))) =
       0;
END_ENTITY;

ENTITY action_property;
  name        : label;
  description : text;
  definition  : characterized_action_definition;
END_ENTITY;

ENTITY action_property_representation;
  name           : label;
  description    : text;
  property       : action_property;
  representation : representation;
END_ENTITY;

ENTITY action_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_action : action;
  related_action  : action;
END_ENTITY;

ENTITY action_request_assignment
  ABSTRACT SUPERTYPE;
  assigned_action_request : versioned_action_request;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY action_request_solution;
  method  : action_method;
  request : versioned_action_request;
DERIVE
  description : text  := get_description_value(SELF);
  name        : label := get_name_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY action_request_status;
  status           : label;
  assigned_request : versioned_action_request;
END_ENTITY;

ENTITY action_resource;
  name        : label;
  description : OPTIONAL text;
  usage       : SET [1 : ?] OF supported_item;
  kind        : action_resource_type;
END_ENTITY;

ENTITY action_resource_relationship;
  name              : label;
  description       : OPTIONAL text;
  relating_resource : action_resource;
  related_resource  : action_resource;
END_ENTITY;

ENTITY action_resource_requirement;
  name        : label;
  description : text;
  kind        : resource_requirement_type;
  operations  : SET [1 : ?] OF characterized_action_definition;
END_ENTITY;

ENTITY action_resource_requirement_relationship;
  name                                 : label;
  description                          : text;
  relating_action_resource_requirement : action_resource_requirement;
  related_action_resource_requirement  : action_resource_requirement;
WHERE
  WR1: relating_action_resource_requirement :<>: related_action_resource_requirement;
END_ENTITY;

ENTITY action_resource_type;
  name : label;
END_ENTITY;

ENTITY action_status;
  status          : label;
  assigned_action : executed_action;
END_ENTITY;

ENTITY address;
  internal_location       : OPTIONAL label;
  street_number           : OPTIONAL label;
  street                  : OPTIONAL label;
  postal_box              : OPTIONAL label;
  town                    : OPTIONAL label;
  region                  : OPTIONAL label;
  postal_code             : OPTIONAL label;
  country                 : OPTIONAL label;
  facsimile_number        : OPTIONAL label;
  telephone_number        : OPTIONAL label;
  electronic_mail_address : OPTIONAL label;
  telex_number            : OPTIONAL label;
DERIVE
  name : label      := get_name_value(SELF);
  url  : identifier := get_id_value(SELF);
WHERE
  WR1: EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR
       EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR
       EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number);
END_ENTITY;

ENTITY address_component
  SUBTYPE OF (generic_attribute);
END_ENTITY;

ENTITY advisory_task_step
  SUBTYPE OF (task_step);
END_ENTITY;

ENTITY alternate_product_relationship;
  name       : label;
  definition : OPTIONAL text;
  alternate  : product;
  base       : product;
  basis      : text;
UNIQUE
  UR1: alternate, base;
WHERE
  WR1: alternate :<>: base;
END_ENTITY;

ENTITY amount_of_substance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY amount_of_substance_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY analysis_assignment
  SUBTYPE OF (group);
END_ENTITY;

ENTITY analysis_item
  SUBTYPE OF (group_assignment);
  items                                : SET [1 : 1] OF analysed_item;
  SELF\group_assignment.assigned_group : analysis_assignment;
END_ENTITY;

ENTITY analysis_model
  SUBTYPE OF (representation);
  SELF\representation.context_of_items : analysis_representation_context;
END_ENTITY;

ENTITY analysis_representation_context
  SUBTYPE OF (representation_context);
END_ENTITY;

ENTITY and_expression
  SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;

ENTITY application_context;
  application : label;
DERIVE
  description : text       := get_description_value(SELF);
  id          : identifier := get_id_value(SELF);
INVERSE
  context_elements : SET [1:?] OF application_context_element FOR frame_of_reference;
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY application_context_element
  SUPERTYPE OF (ONEOF(product_concept_context, product_context, product_definition_context));
  name               : label;
  frame_of_reference : application_context;
END_ENTITY;

ENTITY application_defined_function
  SUBTYPE OF (maths_function);
  explicit_domain : tuple_space;
  explicit_range  : tuple_space;
  parameters      : LIST OF maths_value;
WHERE
  WR1: expression_is_constant(explicit_domain);
  WR2: expression_is_constant(explicit_range);
END_ENTITY;

ENTITY application_protocol_definition;
  status                                    : label;
  application_interpreted_model_schema_name : label;
  application_protocol_year                 : year_number;
  application                               : application_context;
END_ENTITY;

ENTITY applied_action_assignment
  SUBTYPE OF (action_assignment);
  items : SET [1 : ?] OF action_items;
END_ENTITY;

ENTITY applied_action_method_assignment
  SUBTYPE OF (action_method_assignment);
  items : SET [1 : ?] OF action_method_items;
END_ENTITY;

ENTITY applied_action_request_assignment
  SUBTYPE OF (action_request_assignment);
  items : SET [1 : ?] OF action_request_item;
END_ENTITY;

ENTITY applied_approval_assignment
  SUBTYPE OF (approval_assignment);
  items : SET [1 : ?] OF approval_item;
END_ENTITY;

ENTITY applied_approval_scope
  SUBTYPE OF (approval_assignment);
  items : SET [1 : ?] OF approval_scope_item;
END_ENTITY;

ENTITY applied_attribute_classification_assignment
  SUBTYPE OF (attribute_classification_assignment);
  SELF\attribute_classification_assignment.assigned_class : class;
  items                                                   : SET [1 : ?] OF attribute_classification_item;
END_ENTITY;

ENTITY applied_certification_assignment
  SUBTYPE OF (certification_assignment);
  items : SET [1 : ?] OF certification_item;
END_ENTITY;

ENTITY applied_classification_assignment
  SUBTYPE OF (classification_assignment);
  items : SET [1 : ?] OF classification_item;
END_ENTITY;

ENTITY applied_classification_assignment_relationship
  SUBTYPE OF (classification_assignment_relationship);
  SELF\classification_assignment_relationship.related  : applied_classification_assignment;
  SELF\classification_assignment_relationship.relating : applied_classification_assignment;
END_ENTITY;

ENTITY applied_contract_assignment
  SUBTYPE OF (contract_assignment);
  items : SET [1 : ?] OF contract_item;
END_ENTITY;

ENTITY applied_date_and_time_assignment
  SUBTYPE OF (date_and_time_assignment);
  items : SET [1 : ?] OF date_and_time_item;
END_ENTITY;

ENTITY applied_date_assignment
  SUBTYPE OF (date_assignment);
  items : SET [1 : ?] OF date_item;
END_ENTITY;

ENTITY applied_description_text_assignment
  SUBTYPE OF (description_text_assignment);
  items : SET [1 : ?] OF description_item;
END_ENTITY;

ENTITY applied_description_text_assignment_relationship
  SUBTYPE OF (description_text_assignment_relationship);
  SELF\description_text_assignment_relationship.related  : applied_description_text_assignment;
  SELF\description_text_assignment_relationship.relating : applied_description_text_assignment;
END_ENTITY;

ENTITY applied_directed_action_assignment
  SUBTYPE OF (directed_action_assignment);
  items : SET [1 : ?] OF action_request_item;
END_ENTITY;

ENTITY applied_document_reference
  SUBTYPE OF (document_reference);
  items : SET [1 : ?] OF document_reference_item;
END_ENTITY;

ENTITY applied_document_usage_constraint_assignment
  SUBTYPE OF (document_usage_constraint_assignment);
  items : SET [1 : ?] OF document_reference_item;
END_ENTITY;

ENTITY applied_effectivity_assignment
  SUBTYPE OF (effectivity_assignment);
  items : SET [1 : ?] OF effectivity_item;
END_ENTITY;

ENTITY applied_effectivity_context_assignment
  SUBTYPE OF (effectivity_context_assignment);
  items : SET [1 : ?] OF product;
END_ENTITY;

ENTITY applied_event_occurrence_assignment
  SUBTYPE OF (event_occurrence_assignment);
  items : SET [1 : ?] OF event_occurrence_item;
END_ENTITY;

ENTITY applied_experience_assignment
  SUBTYPE OF (experience_assignment);
  items : SET [1 : ?] OF experience_item;
END_ENTITY;

ENTITY applied_experience_type_assignment
  SUBTYPE OF (experience_type_assignment);
  items : SET [1 : ?] OF experience_type_item;
END_ENTITY;

ENTITY applied_external_identification_assignment
  SUBTYPE OF (external_identification_assignment);
  items : SET [1 : ?] OF external_identification_item;
END_ENTITY;

ENTITY applied_external_identification_assignment_relationship
  SUBTYPE OF (external_identification_assignment_relationship);
  SELF\external_identification_assignment_relationship.related  : applied_external_identification_assignment;
  SELF\external_identification_assignment_relationship.relating : applied_external_identification_assignment;
END_ENTITY;

ENTITY applied_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET [1 : ?] OF groupable_item;
END_ENTITY;

ENTITY applied_identification_assignment
  SUBTYPE OF (identification_assignment);
  items : SET [1 : ?] OF identification_item;
END_ENTITY;

ENTITY applied_ineffectivity_assignment
  SUBTYPE OF (effectivity_assignment);
  items : SET [1 : ?] OF effectivity_item;
WHERE
  WR1: SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LOT_EFFECTIVITY',
               'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SERIAL_NUMBERED_EFFECTIVITY',
               'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_EFFECTIVITY'] *
              TYPEOF(SELF.assigned_effectivity)) =
       0;
END_ENTITY;

ENTITY applied_location_assignment
  SUBTYPE OF (location_assignment);
  items : SET [1 : ?] OF location_item;
END_ENTITY;

ENTITY applied_location_representation_assignment
  SUBTYPE OF (location_representation_assignment);
  items : SET [1 : ?] OF location_representation_item;
END_ENTITY;

ENTITY applied_name_assignment
  SUBTYPE OF (name_assignment);
  item : name_item;
END_ENTITY;

ENTITY applied_organization_assignment
  SUBTYPE OF (organization_assignment);
  items : SET [1 : ?] OF organization_item;
END_ENTITY;

ENTITY applied_organization_type_assignment
  SUBTYPE OF (organization_type_assignment);
  items : SET [1 : ?] OF organization_type_item;
END_ENTITY;

ENTITY applied_organizational_project_assignment
  SUBTYPE OF (organizational_project_assignment);
  items : SET [1 : ?] OF project_item;
END_ENTITY;

ENTITY applied_person_and_organization_assignment
  SUBTYPE OF (person_and_organization_assignment);
  items : SET [1 : ?] OF person_and_organization_item;
END_ENTITY;

ENTITY applied_person_type_assignment
  SUBTYPE OF (person_type_assignment);
  items : SET [1 : ?] OF person_type_item;
END_ENTITY;

ENTITY applied_person_type_definition_assignment
  SUBTYPE OF (person_type_definition_assignment);
  items : SET [1 : ?] OF person_definition_item;
END_ENTITY;

ENTITY applied_position_in_organization_assignment
  SUBTYPE OF (position_in_organization_assignment);
  items : SET [1 : ?] OF position_in_organization_item;
END_ENTITY;

ENTITY applied_position_in_organization_assignment_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET [1 : ?] OF position_in_organization_group_assignment_item;
END_ENTITY;

ENTITY applied_position_in_organization_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET [1 : ?] OF position_in_organization_group_item;
END_ENTITY;

ENTITY applied_position_in_organization_type_assignment
  SUBTYPE OF (position_in_organization_type_assignment);
  items : SET [1 : ?] OF position_in_organization_type_item;
END_ENTITY;

ENTITY applied_project_group_name_assignment
  SUBTYPE OF (name_assignment);
  items : SET [1 : ?] OF project_group_name_item;
END_ENTITY;

ENTITY applied_qualification_type_assignment
  SUBTYPE OF (qualification_type_assignment);
  items : SET [1 : ?] OF person_organization_item;
END_ENTITY;

ENTITY applied_security_classification_assignment
  SUBTYPE OF (security_classification_assignment);
  items : SET [1 : ?] OF security_classification_item;
END_ENTITY;

ENTITY applied_state_observed_assignment
  SUBTYPE OF (state_observed_assignment);
  items : SET [1 : ?] OF state_observed_of_item;
END_ENTITY;

ENTITY applied_state_type_assignment
  SUBTYPE OF (state_type_assignment);
  items : SET [1 : ?] OF state_type_of_item;
END_ENTITY;

ENTITY applied_time_interval_assignment
  SUBTYPE OF (time_interval_assignment);
  items : SET [0 : ?] OF time_interval_item;
END_ENTITY;

ENTITY applied_usage_right
  SUBTYPE OF (action_assignment);
  items : SET [1 : ?] OF ir_usage_item;
END_ENTITY;

ENTITY approval;
  status : approval_status;
  level  : label;
END_ENTITY;

ENTITY approval_assignment
  ABSTRACT SUPERTYPE;
  assigned_approval : approval;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY approval_date_time;
  date_time      : date_time_select;
  dated_approval : approval;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY approval_person_organization;
  person_organization : person_organization_select;
  authorized_approval : approval;
  role                : approval_role;
END_ENTITY;

ENTITY approval_relationship;
  name              : label;
  description       : OPTIONAL text;
  relating_approval : approval;
  related_approval  : approval;
END_ENTITY;

ENTITY approval_role;
  role : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY approval_status;
  name : label;
END_ENTITY;

ENTITY area_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.AREA_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY area_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensional_exponents(2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
END_ENTITY;

ENTITY ascribable_state;
  name                    : label;
  description             : OPTIONAL text;
  pertaining_state_type   : state_type;
  ascribed_state_observed : state_observed;
END_ENTITY;

ENTITY ascribable_state_relationship;
  name                      : label;
  description               : OPTIONAL text;
  relating_ascribable_state : ascribable_state;
  related_ascribable_state  : ascribable_state;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY asin_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY assembly_component_usage
  SUPERTYPE OF (quantified_assembly_component_usage ANDOR
                ONEOF(multi_level_reference_designator, next_assembly_usage_occurrence, promissory_usage_occurrence,
                      specified_higher_usage_occurrence))
  SUBTYPE OF (product_definition_usage);
  reference_designator : OPTIONAL identifier;
END_ENTITY;

ENTITY assembly_component_usage_substitute;
  name       : label;
  definition : OPTIONAL text;
  base       : assembly_component_usage;
  substitute : assembly_component_usage;
UNIQUE
  UR1: base, substitute;
WHERE
  WR1: base.relating_product_definition :=: substitute.relating_product_definition;
  WR2: base :<>: substitute;
END_ENTITY;

ENTITY assigned_analysis
  SUBTYPE OF (group_assignment);
  items                                : SET [1 : 1] OF product_definition_formation;
  SELF\group_assignment.assigned_group : analysis_assignment;
END_ENTITY;

ENTITY assigned_requirement
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_assignment;
  items                                : SET [1 : 1] OF product_definition;
END_ENTITY;

ENTITY assignment_object_relationship;
  id            : OPTIONAL identifier;
  description   : OPTIONAL text;
  relating      : assignment_object_select;
  related       : assignment_object_select;
  relation_type : STRING;
WHERE
  WR1: acyclic_assignment_object_relationship(SELF, [related],
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASSIGNMENT_OBJECT_RELATIONSHIP');
END_ENTITY;

ENTITY assumption
  SUBTYPE OF (state_observed);
END_ENTITY;

ENTITY assumption_assignment
  SUBTYPE OF (characterized_applied_state_observed_assignment);
END_ENTITY;

ENTITY assumption_relationship
  SUBTYPE OF (state_observed_relationship);
END_ENTITY;

ENTITY atan_function
  SUBTYPE OF (binary_function_call);
END_ENTITY;

ENTITY atom_based_literal
  SUBTYPE OF (generic_literal);
  lit_value : atom_based_value;
END_ENTITY;

ENTITY attachment_slot_as_planned
  SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY attachment_slot_as_realized
  SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY attachment_slot_design
  SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY attachment_slot_design_to_planned
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : attachment_slot_design;
  SELF\product_definition_formation_relationship.related_product_definition_formation  : attachment_slot_as_planned;
WHERE
  WR1: SELF.relating_product_definition_formation.of_product :=: SELF.related_product_definition_formation.of_product;
END_ENTITY;

ENTITY attachment_slot_design_to_realized
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : attachment_slot_design;
  SELF\product_definition_formation_relationship.related_product_definition_formation  : attachment_slot_as_realized;
WHERE
  WR1: SELF.relating_product_definition_formation.of_product :=: SELF.related_product_definition_formation.of_product;
END_ENTITY;

ENTITY attachment_slot_on_product
  SUBTYPE OF (product_definition_relationship);
END_ENTITY;

ENTITY attachment_slot_planned_to_realized
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : attachment_slot_as_planned;
  SELF\product_definition_formation_relationship.related_product_definition_formation  : attachment_slot_as_realized;
WHERE
  WR1: SELF.relating_product_definition_formation.of_product :=: SELF.related_product_definition_formation.of_product;
END_ENTITY;

ENTITY attribute_classification_assignment
  ABSTRACT SUPERTYPE;
  assigned_class : group;
  attribute_name : label;
  role           : classification_role;
END_ENTITY;

ENTITY attribute_language_assignment
  SUBTYPE OF (attribute_classification_assignment);
  SELF\attribute_classification_assignment.assigned_class : language;
  items                                                   : SET [1 : ?] OF attribute_language_item;
WHERE
  WR1: SELF\attribute_classification_assignment.role.name IN ['primary','translated'];
  WR2: SELF\attribute_classification_assignment.attribute_name <> '';
END_ENTITY;

ENTITY attribute_value_assignment
  ABSTRACT SUPERTYPE;
  attribute_name  : label;
  attribute_value : attribute_type;
  role            : attribute_value_role;
END_ENTITY;

ENTITY attribute_value_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY axis1_placement
  SUBTYPE OF (placement);
  axis : OPTIONAL direction;
DERIVE
  z : direction := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY axis2_placement_2d
  SUBTYPE OF (placement);
  ref_direction : OPTIONAL direction;
DERIVE
  p : LIST [2 : 2] OF direction := build_2axes(ref_direction);
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY axis2_placement_3d
  SUBTYPE OF (placement);
  axis          : OPTIONAL direction;
  ref_direction : OPTIONAL direction;
DERIVE
  p : LIST [3 : 3] OF direction := build_axes(axis, ref_direction);
WHERE
  WR1: SELF\placement.location.dim = 3;
  WR2: (NOT (EXISTS(axis))) OR (axis.dim = 3);
  WR3: (NOT (EXISTS(ref_direction))) OR (ref_direction.dim = 3);
  WR4: (NOT (EXISTS(axis))) OR (NOT (EXISTS(ref_direction))) OR (cross_product(axis, ref_direction).magnitude > 0.0);
END_ENTITY;

ENTITY b_spline_basis
  SUBTYPE OF (maths_function, generic_literal);
  degree         : nonnegative_integer;
  repeated_knots : LIST [2 : ?] OF REAL;
DERIVE
  order     : positive_integer := degree + 1;
  num_basis : positive_integer := SIZEOF(repeated_knots) - order;
WHERE
  WR1: num_basis >= order;
  WR2: nondecreasing(repeated_knots);
  WR3: repeated_knots[order] < repeated_knots[num_basis + 1];
END_ENTITY;

ENTITY b_spline_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  basis                                 : LIST [1 : ?] OF b_spline_basis;
DERIVE
  coef : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_table(coef);
  WR2: (space_dimension(coef.range) = 1) AND (number_superspace_of(factor1(coef.range)) = the_reals);
  WR3: SIZEOF(basis) <= SIZEOF(shape_of_array(coef));
  WR4: compare_basis_and_coef(basis, coef);
END_ENTITY;

ENTITY banded_matrix
  SUBTYPE OF (linearized_table_function);
  default_entry : maths_value;
  below         : INTEGER;
  above         : INTEGER;
  order         : ordering_type;
WHERE
  WR1: SIZEOF(SELF\explicit_table_function.shape) = 2;
  WR2: -below <= above;
  WR3: member_of(default_entry, factor1(SELF\linearized_table_function.source.range));
END_ENTITY;

ENTITY basic_sparse_matrix
  SUBTYPE OF (explicit_table_function, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [3 : 3] OF maths_function;
  default_entry                                   : maths_value;
  order                                           : ordering_type;
DERIVE
  index : maths_function := SELF\multiple_arity_generic_expression.operands[1];
  loc   : maths_function := SELF\multiple_arity_generic_expression.operands[2];
  val   : maths_function := SELF\multiple_arity_generic_expression.operands[3];
WHERE
  WR1: function_is_1d_table(index);
  WR2: function_is_1d_table(loc);
  WR3: function_is_1d_table(val);
  WR4: check_sparse_index_domain(index.domain, index_base, shape, order);
  WR5: check_sparse_index_to_loc(index.range, loc.domain);
  WR6: loc.domain = val.domain;
  WR7: check_sparse_loc_range(loc.range, index_base, shape, order);
  WR8: member_of(default_entry, val.range);
END_ENTITY;

ENTITY binary_boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(xor_expression, equals_expression))
  SUBTYPE OF (boolean_expression, binary_generic_expression);
END_ENTITY;

ENTITY binary_function_call
  ABSTRACT SUPERTYPE OF (ONEOF(atan_function))
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY binary_generic_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (generic_expression);
  operands : LIST [2 : 2] OF generic_expression;
END_ENTITY;

ENTITY binary_literal
  SUBTYPE OF (generic_literal);
  lit_value : BINARY;
END_ENTITY;

ENTITY binary_numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(minus_expression, div_expression, mod_expression, slash_expression, power_expression,
                               binary_function_call))
  SUBTYPE OF (numeric_expression, binary_generic_expression);
  SELF\binary_generic_expression.operands : LIST [2 : 2] OF numeric_expression;
END_ENTITY;

ENTITY boolean_defined_function
  ABSTRACT SUPERTYPE
  SUBTYPE OF (defined_function, boolean_expression);
END_ENTITY;

ENTITY boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(simple_boolean_expression, unary_boolean_expression, binary_boolean_expression,
                               multiple_arity_boolean_expression, comparison_expression, interval_expression,
                               boolean_defined_function))
  SUBTYPE OF (expression);
END_ENTITY;

ENTITY boolean_literal
  SUBTYPE OF (simple_boolean_expression, generic_literal);
  the_value : BOOLEAN;
END_ENTITY;

ENTITY boolean_variable
  SUBTYPE OF (simple_boolean_expression, variable);
END_ENTITY;

ENTITY bound_variable_semantics
  SUBTYPE OF (variable_semantics);
END_ENTITY;

ENTITY breakdown_context
  SUPERTYPE OF (ONEOF(functional_breakdown_context, physical_breakdown_context, system_breakdown_context,
                      zone_breakdown_context))
  SUBTYPE OF (product_definition_relationship);
END_ENTITY;

ENTITY breakdown_element_group_assignment
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_definition_element_relationship;
  items                                : SET [1 : 1] OF product_definition_or_breakdown_element_usage;
END_ENTITY;

ENTITY breakdown_element_realization
  SUBTYPE OF (characterized_object, product_definition_element_relationship);
END_ENTITY;

ENTITY breakdown_element_usage
  SUPERTYPE OF (ONEOF(functional_element_usage, physical_element_usage, system_element_usage, zone_element_usage))
  SUBTYPE OF (product_definition_relationship);
END_ENTITY;

ENTITY breakdown_of
  SUBTYPE OF (product_definition_relationship);
END_ENTITY;

ENTITY calendar_date
  SUBTYPE OF (date);
  day_component   : day_in_month_number;
  month_component : month_in_year_number;
WHERE
  WR1: valid_calendar_date(SELF);
END_ENTITY;

ENTITY capacitance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CAPACITANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY capacitance_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.farad);
END_ENTITY;

ENTITY cartesian_complex_number_region
  SUBTYPE OF (maths_space, generic_literal);
  real_constraint : real_interval;
  imag_constraint : real_interval;
WHERE
  WR1: min_exists(real_constraint) OR max_exists(real_constraint) OR min_exists(imag_constraint) OR
       max_exists(imag_constraint);
END_ENTITY;

ENTITY cartesian_point
  SUBTYPE OF (point);
  coordinates : LIST [1 : 3] OF length_measure;
END_ENTITY;

ENTITY cartesian_transformation_operator
  SUPERTYPE OF (ONEOF(cartesian_transformation_operator_2d, cartesian_transformation_operator_3d))
  SUBTYPE OF (geometric_representation_item, functionally_defined_transformation);
  axis1        : OPTIONAL direction;
  axis2        : OPTIONAL direction;
  local_origin : cartesian_point;
  scale        : OPTIONAL REAL;
DERIVE
  scl : REAL := NVL(scale, 1.0);
WHERE
  WR1: scl > 0.0;
END_ENTITY;

ENTITY cartesian_transformation_operator_2d
  SUBTYPE OF (cartesian_transformation_operator);
DERIVE
  u : LIST [2 : 2] OF direction := base_axis(2, SELF\cartesian_transformation_operator.axis1,
                                             SELF\cartesian_transformation_operator.axis2, ?);
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY cartesian_transformation_operator_3d
  SUBTYPE OF (cartesian_transformation_operator);
  axis3 : OPTIONAL direction;
DERIVE
  u : LIST [3 : 3] OF direction := base_axis(3, SELF\cartesian_transformation_operator.axis1,
                                             SELF\cartesian_transformation_operator.axis2, axis3);
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY causal_consequence
  SUBTYPE OF (product_definition_relationship);
  SELF\product_definition_relationship.relating_product_definition : risk_consequence;
  SELF\product_definition_relationship.related_product_definition  : risk_consequence;
END_ENTITY;

ENTITY celsius_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY certification;
  name    : label;
  purpose : text;
  kind    : certification_type;
END_ENTITY;

ENTITY certification_assignment
  ABSTRACT SUPERTYPE;
  assigned_certification : certification;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY certification_type;
  description : label;
END_ENTITY;

ENTITY chain_based_geometric_item_specific_usage
  SUBTYPE OF (geometric_item_specific_usage, chain_based_item_identified_representation_usage);
END_ENTITY;

ENTITY chain_based_item_identified_representation_usage
  SUBTYPE OF (item_identified_representation_usage);
  nodes           : LIST [2 : ?] OF UNIQUE representation;
  undirected_link : LIST [1 : ?] OF chained_representation_link;
DERIVE
  root                                                          : representation                              := nodes[1];
  SELF\item_identified_representation_usage.used_representation                                           : representation                              := nodes[HIINDEX(nodes)];
  leaf                                                          : representation                              := used_representation;
  directed_link                                                 : LIST [1 : ?] OF representation_relationship := get_directed_link(nodes,
                                                                                                                                   undirected_link);
WHERE
  WR1: EXISTS(directed_link);
END_ENTITY;

ENTITY characterizable_applied_action_assignment
  SUBTYPE OF (applied_action_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_action
  SUBTYPE OF (action, characterized_object);
END_ENTITY;

ENTITY characterized_action_directive
  SUBTYPE OF (action_directive, characterized_object);
END_ENTITY;

ENTITY characterized_action_directive_relationship
  SUBTYPE OF (action_directive_relationship, characterized_object);
END_ENTITY;

ENTITY characterized_action_method
  SUBTYPE OF (action_method, characterized_object);
END_ENTITY;

ENTITY characterized_action_method_relationship
  SUBTYPE OF (action_method_relationship, characterized_object);
END_ENTITY;

ENTITY characterized_action_property
  SUBTYPE OF (action_property, characterized_object);
END_ENTITY;

ENTITY characterized_action_relationship
  SUBTYPE OF (action_relationship, characterized_object);
END_ENTITY;

ENTITY characterized_action_resource
  SUBTYPE OF (action_resource, characterized_object);
END_ENTITY;

ENTITY characterized_action_resource_relationship
  SUBTYPE OF (action_resource_relationship, characterized_object);
END_ENTITY;

ENTITY characterized_action_resource_requirement
  SUBTYPE OF (action_resource_requirement, characterized_object);
END_ENTITY;

ENTITY characterized_action_resource_requirement_relationship
  SUBTYPE OF (action_resource_requirement_relationship, characterized_object);
END_ENTITY;

ENTITY characterized_address
  SUBTYPE OF (address, characterized_object);
END_ENTITY;

ENTITY characterized_alternate_product_relationship
  SUBTYPE OF (alternate_product_relationship, characterized_object);
END_ENTITY;

ENTITY characterized_applied_action_assignment
  SUBTYPE OF (applied_action_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_action_method_assignment
  SUBTYPE OF (applied_action_method_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_action_request_assignment
  SUBTYPE OF (applied_action_request_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_approval_assignment
  SUBTYPE OF (applied_approval_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_certification_assignment
  SUBTYPE OF (applied_certification_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_contract_assignment
  SUBTYPE OF (applied_contract_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_directed_action_assignment
  SUBTYPE OF (applied_directed_action_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_document_reference
  SUBTYPE OF (applied_document_reference, characterized_object);
END_ENTITY;

ENTITY characterized_applied_document_usage_constraint_assignment
  SUBTYPE OF (applied_document_usage_constraint_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_effectivity_assignment
  SUBTYPE OF (applied_effectivity_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_event_occurrence_assignment
  SUBTYPE OF (applied_event_occurrence_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_ineffectivity_assignment
  SUBTYPE OF (applied_ineffectivity_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_location_assignment
  SUBTYPE OF (applied_location_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_organization_assignment
  SUBTYPE OF (applied_organization_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_organizational_project_assignment
  SUBTYPE OF (applied_organizational_project_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_person_and_organization_assignment
  SUBTYPE OF (applied_person_and_organization_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_person_type_assignment
  SUBTYPE OF (applied_person_type_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_position_in_organization_assignment
  SUBTYPE OF (applied_position_in_organization_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_position_in_organization_group_assignment
  SUBTYPE OF (applied_position_in_organization_group_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_position_in_organization_type_assignment
  SUBTYPE OF (applied_position_in_organization_type_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_qualification_type_assignment
  SUBTYPE OF (applied_qualification_type_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_security_classification_assignment
  SUBTYPE OF (applied_security_classification_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_state_assignment
  SUBTYPE OF (applied_state_observed_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_state_observed_assignment
  SUBTYPE OF (applied_state_observed_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_state_type_assignment
  SUBTYPE OF (applied_state_type_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_time_interval_assignment
  SUBTYPE OF (applied_time_interval_assignment, characterized_object);
END_ENTITY;

ENTITY characterized_applied_usage_right
  SUBTYPE OF (applied_usage_right, characterized_object);
END_ENTITY;

ENTITY characterized_approval
  SUBTYPE OF (approval, characterized_object);
END_ENTITY;

ENTITY characterized_class
  SUBTYPE OF (characterized_object, class);
END_ENTITY;

ENTITY characterized_collection_assignment
  SUBTYPE OF (characterized_object, collection_assignment);
END_ENTITY;

ENTITY characterized_configuration_item_relationship
  SUBTYPE OF (characterized_object, configuration_item_relationship);
END_ENTITY;

ENTITY characterized_contract
  SUBTYPE OF (characterized_object, contract);
END_ENTITY;

ENTITY characterized_contract_relationship
  SUBTYPE OF (characterized_object, contract_relationship);
END_ENTITY;

ENTITY characterized_date_and_time_assignment
  SUBTYPE OF (characterized_object, date_and_time_assignment);
END_ENTITY;

ENTITY characterized_date_assignment
  SUBTYPE OF (characterized_object, date_assignment);
END_ENTITY;

ENTITY characterized_document_relationship
  SUBTYPE OF (characterized_object, document_relationship);
END_ENTITY;

ENTITY characterized_evidence
  SUBTYPE OF (characterized_object, evidence);
END_ENTITY;

ENTITY characterized_experience
  SUBTYPE OF (characterized_object, experience);
END_ENTITY;

ENTITY characterized_general_property_relationship
  SUBTYPE OF (characterized_object, general_property_relationship);
END_ENTITY;

ENTITY characterized_group
  SUBTYPE OF (characterized_object, group);
END_ENTITY;

ENTITY characterized_group_relationship
  SUBTYPE OF (characterized_object, group_relationship);
END_ENTITY;

ENTITY characterized_interface_connection
  SUBTYPE OF (characterized_object, interface_connection);
END_ENTITY;

ENTITY characterized_interface_connector_occurrence
  SUBTYPE OF (characterized_object, interface_connector_occurrence);
END_ENTITY;

ENTITY characterized_interface_definition_connection
  SUBTYPE OF (characterized_object, interface_definition_connection);
END_ENTITY;

ENTITY characterized_location_object
  SUBTYPE OF (characterized_object, location);
END_ENTITY;

ENTITY characterized_object;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY characterized_object_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_object : characterized_object;
  related_object  : characterized_object;
END_ENTITY;

ENTITY characterized_organization
  SUBTYPE OF (characterized_object, organization);
END_ENTITY;

ENTITY characterized_organization_relationship
  SUBTYPE OF (characterized_object, organization_relationship);
END_ENTITY;

ENTITY characterized_organizational_address
  SUBTYPE OF (characterized_object, organizational_address);
END_ENTITY;

ENTITY characterized_organizational_project
  SUBTYPE OF (characterized_object, organizational_project);
END_ENTITY;

ENTITY characterized_organizational_project_relationship
  SUBTYPE OF (characterized_object, organizational_project_relationship);
END_ENTITY;

ENTITY characterized_person
  SUBTYPE OF (characterized_object, person);
END_ENTITY;

ENTITY characterized_person_and_organization
  SUBTYPE OF (characterized_object, person_and_organization);
END_ENTITY;

ENTITY characterized_person_type_definition
  SUBTYPE OF (characterized_object, person_type_definition);
END_ENTITY;

ENTITY characterized_person_type_definition_relationship
  SUBTYPE OF (characterized_object, person_type_definition_relationship);
END_ENTITY;

ENTITY characterized_product
  SUBTYPE OF (characterized_object, product);
END_ENTITY;

ENTITY characterized_product_concept
  SUBTYPE OF (characterized_object, product_concept);
END_ENTITY;

ENTITY characterized_product_concept_feature
  SUBTYPE OF (product_concept_feature, characterized_object);
END_ENTITY;

ENTITY characterized_product_concept_feature_association
  SUBTYPE OF (characterized_object, product_concept_feature_association);
END_ENTITY;

ENTITY characterized_product_concept_feature_category
  SUBTYPE OF (product_concept_feature_category, characterized_object);
END_ENTITY;

ENTITY characterized_product_concept_feature_category_usage
  SUBTYPE OF (characterized_object, product_concept_feature_category_usage);
END_ENTITY;

ENTITY characterized_product_definition_formation
  SUBTYPE OF (characterized_object, product_definition_formation);
END_ENTITY;

ENTITY characterized_product_definition_formation_relationship
  SUBTYPE OF (characterized_object, product_definition_formation_relationship);
END_ENTITY;

ENTITY characterized_product_relationship
  SUBTYPE OF (characterized_object, product_relationship);
END_ENTITY;

ENTITY characterized_representation_relationship
  SUBTYPE OF (characterized_object, representation_relationship);
END_ENTITY;

ENTITY characterized_risk_perception_source_assignment
  SUBTYPE OF (characterized_object, risk_perception_source_assignment);
END_ENTITY;

ENTITY characterized_versioned_action_request
  SUBTYPE OF (characterized_object, versioned_action_request);
END_ENTITY;

ENTITY characterized_versioned_action_request_relationship
  SUBTYPE OF (characterized_object, versioned_action_request_relationship);
END_ENTITY;

ENTITY class
  SUBTYPE OF (group);
END_ENTITY;

ENTITY class_by_extension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY class_by_intension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY class_system
  SUBTYPE OF (group);
END_ENTITY;

ENTITY class_usage_effectivity_context_assignment
  SUBTYPE OF (effectivity_context_assignment);
  items : SET [1 : ?] OF class_usage_effectivity_context_item;
WHERE
  WR1: SELF.role.name = 'class usage influence';
  WR2: SIZEOF(QUERY(i
                    <* SELF.items
                    | NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)))) =
       0;
  WR3: ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_EFFECTIVITY_ASSIGNMENT' IN
        TYPEOF(SELF.assigned_effectivity_assignment)) AND
       (SIZEOF(TYPEOF(SELF.assigned_effectivity_assignment.assigned_effectivity)) = 1) AND
       (SELF.assigned_effectivity_assignment.assigned_effectivity.id = 'class usage') AND
       (SIZEOF(QUERY(i
                     <* SELF.assigned_effectivity_assignment\applied_effectivity_assignment.items
                     | NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE' IN
                            TYPEOF(i)))) =
        0);
END_ENTITY;

ENTITY classification_assignment
  ABSTRACT SUPERTYPE;
  assigned_class : group;
  role           : classification_role;
END_ENTITY;

ENTITY classification_assignment_relationship;
  id            : OPTIONAL identifier;
  description   : OPTIONAL text;
  relating      : classification_assignment;
  related       : classification_assignment;
  relation_type : STRING;
WHERE
  WR1: acyclic_classification_assignment_relationship(SELF, [related],
                                                      'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CLASSIFICATION_ASSIGNMENT_RELATIONSHIP');
END_ENTITY;

ENTITY classification_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY collection
  SUBTYPE OF (product);
END_ENTITY;

ENTITY collection_assignment
  SUBTYPE OF (applied_group_assignment);
END_ENTITY;

ENTITY collection_membership
  SUBTYPE OF (applied_group_assignment);
END_ENTITY;

ENTITY collection_relationship
  SUBTYPE OF (product_relationship);
  SELF\product_relationship.relating_product : collection;
  SELF\product_relationship.related_product  : collection;
DERIVE
  related_collection  : collection := SELF\product_relationship.related_product;
  relating_collection : collection := SELF\product_relationship.relating_product;
END_ENTITY;

ENTITY collection_version
  SUBTYPE OF (product_definition_formation);
  SELF\product_definition_formation.of_product : collection;
DERIVE
  of_collection : collection := SELF\product_definition_formation.of_product;
END_ENTITY;

ENTITY collection_version_relationship
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : collection_version;
  SELF\product_definition_formation_relationship.related_product_definition_formation  : collection_version;
DERIVE
  related_version  : collection_version := SELF\product_definition_formation_relationship.related_product_definition_formation;
  relating_version : collection_version := SELF\product_definition_formation_relationship.relating_product_definition_formation;
END_ENTITY;

ENTITY collection_version_sequence_relationship
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : collection_version;
  SELF\product_definition_formation_relationship.related_product_definition_formation  : collection_version;
DERIVE
  successor   : collection_version := SELF\product_definition_formation_relationship.related_product_definition_formation;
  predecessor : collection_version := SELF\product_definition_formation_relationship.relating_product_definition_formation;
END_ENTITY;

ENTITY collection_view_definition
  SUBTYPE OF (product_definition);
  SELF\product_definition.formation : collection_version;
DERIVE
  defined_version : collection_version := SELF\product_definition.formation;
END_ENTITY;

ENTITY comparison_equal
  SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_expression
  ABSTRACT SUPERTYPE OF (ONEOF(comparison_equal, comparison_greater, comparison_greater_equal, comparison_less,
                               comparison_less_equal, comparison_not_equal, like_expression))
  SUBTYPE OF (boolean_expression, binary_generic_expression);
  SELF\binary_generic_expression.operands : LIST [2 : 2] OF expression;
WHERE
  WR1: (('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NUMERIC_EXPRESSION' IN
         TYPEOF(SELF\binary_generic_expression.operands[1])) AND
        ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NUMERIC_EXPRESSION' IN
         TYPEOF(SELF\binary_generic_expression.operands[2]))) OR
       (('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BOOLEAN_EXPRESSION' IN
         TYPEOF(SELF\binary_generic_expression.operands[1])) AND
        ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BOOLEAN_EXPRESSION' IN
         TYPEOF(SELF\binary_generic_expression.operands[2]))) OR
       (('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STRING_EXPRESSION' IN
         TYPEOF(SELF\binary_generic_expression.operands[1])) AND
        ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STRING_EXPRESSION' IN
         TYPEOF(SELF\binary_generic_expression.operands[2])));
END_ENTITY;

ENTITY comparison_greater
  SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_greater_equal
  SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_less
  SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_less_equal
  SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_not_equal
  SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY complex_number_literal
  SUBTYPE OF (generic_literal);
  real_part : REAL;
  imag_part : REAL;
END_ENTITY;

ENTITY complex_number_literal_polar
  SUBTYPE OF (complex_number_literal);
  modulus  : REAL;
  argument : REAL;
DERIVE
  SELF\complex_number_literal.real_part                             : REAL := modulus * COS(argument);
  SELF\complex_number_literal.imag_part                             : REAL := modulus * SIN(argument);
WHERE
  WR1: modulus >= 0;
  WR2: {0 <= argument <= 2 * PI};
END_ENTITY;

ENTITY composite_shape_aspect
  SUBTYPE OF (shape_aspect);
INVERSE
  component_relationships : SET [2:?] OF shape_aspect_relationship FOR relating_shape_aspect;
END_ENTITY;

ENTITY compound_address
  SUBTYPE OF (address);
END_ENTITY;

ENTITY compound_person_name
  SUBTYPE OF (generic_attribute_list_assignment);
END_ENTITY;

ENTITY compound_person_name_assignment
  SUBTYPE OF (name_attribute);
END_ENTITY;

ENTITY compound_representation_item
  SUBTYPE OF (representation_item);
  item_element : compound_item_definition;
END_ENTITY;

ENTITY concat_expression
  SUBTYPE OF (string_expression, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [2 : ?] OF string_expression;
END_ENTITY;

ENTITY concept_feature_operator;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY concept_feature_relationship;
  name                             : label;
  description                      : OPTIONAL text;
  relating_product_concept_feature : product_concept_feature;
  related_product_concept_feature  : product_concept_feature;
END_ENTITY;

ENTITY concept_feature_relationship_with_condition
  SUBTYPE OF (concept_feature_relationship);
  conditional_operator : concept_feature_operator;
END_ENTITY;

ENTITY concurrent_action_method
  SUBTYPE OF (action_method_relationship);
END_ENTITY;

ENTITY concurrent_task_element
  SUBTYPE OF (task_element);
END_ENTITY;

ENTITY condition
  SUBTYPE OF (action_method);
END_ENTITY;

ENTITY conditional_concept_feature
  SUBTYPE OF (product_concept_feature);
  condition : concept_feature_relationship_with_condition;
END_ENTITY;

ENTITY conditional_configuration
  SUBTYPE OF (conditional_effectivity);
  configuration_type : STRING;
  inheritance_type   : STRING;
END_ENTITY;

ENTITY conditional_effectivity
  SUBTYPE OF (condition, effectivity);
END_ENTITY;

ENTITY conductance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONDUCTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY conductance_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.siemens);
END_ENTITY;

ENTITY configurable_item
  SUBTYPE OF (configuration_item);
  item_concept_feature : SET [1 : ?] OF product_concept_feature_association;
END_ENTITY;

ENTITY configuration_design;
  configuration : configuration_item;
  design        : configuration_design_item;
DERIVE
  name        : label := get_name_value(SELF);
  description : text  := get_description_value(SELF);
UNIQUE
  UR1: configuration, design;
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY configuration_effectivity
  SUBTYPE OF (product_definition_effectivity);
  configuration : configuration_design;
UNIQUE
  UR1: configuration, SELF\product_definition_effectivity.usage, SELF\effectivity.id;
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_USAGE' IN
       TYPEOF(SELF\product_definition_effectivity.usage);
END_ENTITY;

ENTITY configuration_item;
  id           : identifier;
  name         : label;
  description  : OPTIONAL text;
  item_concept : product_concept;
  purpose      : OPTIONAL label;
END_ENTITY;

ENTITY configuration_item_hierarchical_relationship
  SUBTYPE OF (configuration_item_relationship);
END_ENTITY;

ENTITY configuration_item_relationship;
  name                        : label;
  description                 : OPTIONAL text;
  relating_configuration_item : configuration_item;
  related_configuration_item  : configuration_item;
END_ENTITY;

ENTITY configuration_item_revision_sequence
  SUBTYPE OF (configuration_item_relationship);
END_ENTITY;

ENTITY configured_effectivity_assignment
  SUBTYPE OF (effectivity_assignment);
  items : SET [1 : ?] OF configured_effectivity_item;
WHERE
  WR1: (SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EFFECTIVITY'] * TYPEOF(SELF.assigned_effectivity)) = 1) AND
       (SELF.assigned_effectivity.id = 'configuration validity');
  WR2: SIZEOF(SELF.items) = 1;
  WR3: SIZEOF(QUERY(i
                    <* SELF.items
                    | NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) OR
                          NOT (i\product_definition.frame_of_reference.name IN
                               ['conceptual definition',
                                'part occurrence',
                                'functional definition',
                                'alternative definition']))) =
       0;
  WR4: SELF.role.name IN ['design','usage'];
  WR5: (SELF.role.name <> 'design') OR
       (SIZEOF(QUERY(i
                     <* SELF.items
                     | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) AND
                       (i\product_definition.frame_of_reference.name = 'part occurrence'))) =
        0);
  WR6: (SELF.role.name <> 'usage') OR
       (SIZEOF(QUERY(i
                     <* SELF.items
                     | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) AND
                       (i\product_definition.frame_of_reference.name = 'conceptual definition'))) =
        0);
  WR7: SELF.role.description IN ['exception','inherited','local'];
  WR8: SIZEOF(QUERY(x
                    <* USEDIN(SELF,
                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EFFECTIVITY_CONTEXT_ASSIGNMENT.ASSIGNED_EFFECTIVITY_ASSIGNMENT')
                    | 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT' IN
                      TYPEOF(x))) =
       1;
END_ENTITY;

ENTITY configured_effectivity_context_assignment
  SUBTYPE OF (effectivity_context_assignment);
  SELF\effectivity_context_assignment.assigned_effectivity_assignment : configured_effectivity_assignment;
  items                                                               : SET [1 : ?] OF configured_effectivity_context_item;
WHERE
  WR1: SIZEOF(SELF.items) = 1;
END_ENTITY;

ENTITY connection_definition_to_connection
  SUBTYPE OF (group);
END_ENTITY;

ENTITY constant_function
  SUBTYPE OF (maths_function, generic_literal);
  sole_output      : maths_value;
  source_of_domain : maths_space_or_function;
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
END_ENTITY;

ENTITY constituent_shape_aspect
  SUBTYPE OF (shape_aspect);
  parent : shape_aspect;
DERIVE
  SELF\shape_aspect.of_shape                   : product_definition_shape := get_product_definition_shape(SELF);
END_ENTITY;

ENTITY contained_acceptance
  SUBTYPE OF (risk_activity_structure);
  SELF\action_relationship.relating_action : risk_control;
  SELF\action_relationship.related_action  : risk_acceptance;
END_ENTITY;

ENTITY contained_analysis
  SUBTYPE OF (risk_activity_structure);
  SELF\action_relationship.relating_action : risk_assessment;
  SELF\action_relationship.related_action  : risk_analysis;
END_ENTITY;

ENTITY contained_communication
  SUBTYPE OF (risk_activity_structure);
  SELF\action_relationship.relating_action : risk_control;
  SELF\action_relationship.related_action  : risk_communication;
END_ENTITY;

ENTITY contained_estimation
  SUBTYPE OF (risk_activity_structure);
  SELF\action_relationship.relating_action : risk_analysis;
  SELF\action_relationship.related_action  : risk_estimation;
END_ENTITY;

ENTITY contained_evaluation
  SUBTYPE OF (risk_activity_structure);
  SELF\action_relationship.relating_action : risk_assessment;
  SELF\action_relationship.related_action  : risk_evaluation;
END_ENTITY;

ENTITY contained_identification
  SUBTYPE OF (risk_activity_structure);
  SELF\action_relationship.relating_action : risk_analysis;
  SELF\action_relationship.related_action  : risk_identification;
END_ENTITY;

ENTITY contained_treatments
  SUBTYPE OF (risk_activity_structure);
  SELF\action_relationship.relating_action : risk_control;
  SELF\action_relationship.related_action  : risk_treatment;
END_ENTITY;

ENTITY containing_message
  SUBTYPE OF (group_assignment);
  items                                : SET [1 : 1] OF structured_message;
  SELF\group_assignment.assigned_group : message_contents_group;
DERIVE
  message_contents_group : message_contents_group := SELF\group_assignment.assigned_group;
END_ENTITY;

ENTITY context_dependent_action_method_relationship;
  name                  : label;
  relating_relationship : action_method_relationship;
  related_relationship  : action_method_relationship;
UNIQUE
  UR1: relating_relationship, related_relationship;
WHERE
  WR1: relating_relationship.relating_method :=: related_relationship.relating_method;
END_ENTITY;

ENTITY context_dependent_action_relationship;
  name                  : label;
  relating_relationship : action_relationship;
  related_relationship  : action_relationship;
UNIQUE
  UR1: relating_relationship, related_relationship;
WHERE
  WR1: relating_relationship.relating_action :=: related_relationship.relating_action;
END_ENTITY;

ENTITY context_dependent_shape_representation;
  representation_relation      : shape_representation_relationship;
  represented_product_relation : product_definition_shape;
DERIVE
  description : text  := get_description_value(SELF);
  name        : label := get_name_value(SELF);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP' IN
       TYPEOF(represented_product_relation\property_definition.definition);
  WR2: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR3: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY context_dependent_unit
  SUBTYPE OF (named_unit);
  name : label;
END_ENTITY;

ENTITY contract;
  name    : label;
  purpose : text;
  kind    : contract_type;
END_ENTITY;

ENTITY contract_assignment
  ABSTRACT SUPERTYPE;
  assigned_contract : contract;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY contract_relationship;
  id                : identifier;
  name              : label;
  description       : OPTIONAL text;
  relating_contract : contract;
  related_contract  : contract;
END_ENTITY;

ENTITY contract_type;
  description : label;
END_ENTITY;

ENTITY conversion_based_unit
  SUBTYPE OF (named_unit);
  name              : label;
  conversion_factor : measure_with_unit;
WHERE
  WR1: SELF\named_unit.dimensions = derive_dimensional_exponents(conversion_factor\measure_with_unit.unit_component);
END_ENTITY;

ENTITY coordinated_universal_time_offset;
  hour_offset   : INTEGER;
  minute_offset : OPTIONAL INTEGER;
  sense         : ahead_or_behind;
DERIVE
  actual_minute_offset : INTEGER := NVL(minute_offset, 0);
WHERE
  WR1: {0 <= hour_offset < 24};
  WR2: {0 <= actual_minute_offset <= 59};
  WR3: NOT (((hour_offset <> 0) OR (actual_minute_offset <> 0)) AND (sense = exact));
END_ENTITY;

ENTITY cos_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY curve
  SUBTYPE OF (geometric_representation_item);
  -- IP1:
  -- IP2:
  -- IP3:
END_ENTITY;

ENTITY date
  SUPERTYPE OF (ONEOF(calendar_date, ordinal_date, week_of_year_and_day_date, year_month));
  year_component : year_number;
END_ENTITY;

ENTITY date_and_time;
  date_component : date;
  time_component : local_time;
END_ENTITY;

ENTITY date_and_time_assignment
  ABSTRACT SUPERTYPE;
  assigned_date_and_time : date_and_time;
  role                   : date_time_role;
END_ENTITY;

ENTITY date_assignment
  ABSTRACT SUPERTYPE;
  assigned_date : date;
  role          : date_role;
END_ENTITY;

ENTITY date_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY date_time_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY dated_effectivity
  SUBTYPE OF (effectivity);
  effectivity_end_date   : OPTIONAL date_time_or_event_occurrence;
  effectivity_start_date : OPTIONAL date_time_or_event_occurrence;
WHERE
  WR1: EXISTS(effectivity_end_date) OR EXISTS(effectivity_start_date);
END_ENTITY;

ENTITY decision_point
  SUBTYPE OF (action_method_to_select_from, task_element);
DERIVE
  SELF\action_method_to_select_from.number_of_elements                                   : count_measure := 1;
  SELF\action_method.purpose                                              : text          := 'decision';
END_ENTITY;

ENTITY defined_function
  ABSTRACT SUPERTYPE OF ((ONEOF(numeric_defined_function, string_defined_function, boolean_defined_function)) ANDOR
                         sql_mappable_defined_function);
END_ENTITY;

ENTITY definite_integral_expression
  SUBTYPE OF (quantifier_expression);
  lower_limit_neg_infinity : BOOLEAN;
  upper_limit_pos_infinity : BOOLEAN;
DERIVE
  integrand                            : generic_expression                      := SELF\multiple_arity_generic_expression.operands[1];
  variable_of_integration              : maths_variable                          := SELF\multiple_arity_generic_expression.operands[2];
  SELF\quantifier_expression.variables                            : LIST [1 : 1] OF UNIQUE generic_variable := [variable_of_integration];
WHERE
  WR1: has_values_space(integrand);
  WR2: space_is_continuum(values_space_of(integrand));
  WR3: definite_integral_expr_check(SELF\multiple_arity_generic_expression.operands, lower_limit_neg_infinity,
                                    upper_limit_pos_infinity);
END_ENTITY;

ENTITY definite_integral_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  variable_of_integration               : input_selector;
  lower_limit_neg_infinity              : BOOLEAN;
  upper_limit_pos_infinity              : BOOLEAN;
DERIVE
  integrand : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: space_is_continuum(integrand.range);
  WR2: definite_integral_check(integrand.domain, variable_of_integration, lower_limit_neg_infinity,
                               upper_limit_pos_infinity);
END_ENTITY;

ENTITY definitional_product_definition_usage
  SUBTYPE OF (product_definition_usage);
UNIQUE
  UR1: relating_product_definition, related_product_definition;
END_ENTITY;

ENTITY definitional_representation_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: acyclic_representation_relationship(SELF, [SELF\representation_relationship.rep_2],
                                           'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION');
END_ENTITY;

ENTITY dependent_product_definition_exchange_context
  ABSTRACT SUPERTYPE
  SUBTYPE OF (product_definition_context);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) *
              ['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INDENTIFICATION_DEPENDENT_PRODUCT_DEFINITION_EXCHANGE_CONTEXT',
               'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LANGUAGE_DEPENDENT_PRODUCT_DEFINITION_EXCHANGE_CONTEXT']) >
       0;
END_ENTITY;

ENTITY dependent_variable_definition
  SUBTYPE OF (unary_generic_expression);
  name        : label;
  description : text;
END_ENTITY;

ENTITY derived_unit
  SUPERTYPE OF (ONEOF(absorbed_dose_unit, acceleration_unit, radioactivity_unit, area_unit, capacitance_unit,
                      dose_equivalent_unit, electric_charge_unit, conductance_unit, electric_potential_unit,
                      energy_unit, magnetic_flux_density_unit, force_unit, frequency_unit, illuminance_unit,
                      inductance_unit, magnetic_flux_unit, power_unit, pressure_unit, resistance_unit, velocity_unit,
                      volume_unit));
  elements : SET [1 : ?] OF derived_unit_element;
DERIVE
  name : label := get_name_value(SELF);
WHERE
  WR1: (SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (elements[1].exponent <> 1.0));
  WR2: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY derived_unit_element;
  unit     : named_unit;
  exponent : REAL;
END_ENTITY;

ENTITY description_attribute;
  attribute_value : text;
  described_item  : description_attribute_select;
END_ENTITY;

ENTITY description_text;
  description : text;
END_ENTITY;

ENTITY description_text_assignment
  ABSTRACT SUPERTYPE;
  description : description_text;
END_ENTITY;

ENTITY description_text_assignment_relationship;
  id            : OPTIONAL identifier;
  description   : OPTIONAL text;
  relating      : description_text_assignment;
  related       : description_text_assignment;
  relation_type : STRING;
WHERE
  WR1: acyclic_description_text_assignment_relationship(SELF, [related],
                                                        'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_TEXT_ASSIGNMENT_RELATIONSHIP');
END_ENTITY;

ENTITY descriptive_representation_item
  SUBTYPE OF (representation_item);
  description : text;
END_ENTITY;

ENTITY dimensional_exponents;
  length_exponent                    : REAL;
  mass_exponent                      : REAL;
  time_exponent                      : REAL;
  electric_current_exponent          : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent       : REAL;
  luminous_intensity_exponent        : REAL;
END_ENTITY;

ENTITY dimensional_location
  SUBTYPE OF (shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
  WR2: SELF\shape_aspect_relationship.relating_shape_aspect.of_shape :=:
       SELF\shape_aspect_relationship.related_shape_aspect.of_shape;
  WR3: (SELF\shape_aspect_relationship.relating_shape_aspect\shape_aspect.product_definitional <> UNKNOWN) AND
       (SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.product_definitional <> UNKNOWN);
END_ENTITY;

ENTITY dimensional_size;
  applies_to : shape_aspect;
  name       : label;
DERIVE
  id : identifier := get_id_value(SELF);
UNIQUE
  UR1: id, applies_to;
WHERE
  WR1: applies_to.product_definitional = TRUE;
  WR2: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY directed_action
  SUBTYPE OF (executed_action);
  directive : action_directive;
END_ENTITY;

ENTITY directed_action_assignment
  ABSTRACT SUPERTYPE;
  assigned_directed_action : directed_action;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY direction
  SUBTYPE OF (geometric_representation_item);
  direction_ratios : LIST [2 : 3] OF REAL;
WHERE
  WR1: SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
END_ENTITY;

ENTITY div_expression
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY document;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
  kind        : document_type;
INVERSE
  representation_types : SET [0:?] OF document_representation_type FOR represented_document;
END_ENTITY;

ENTITY document_file
  SUBTYPE OF (document, characterized_object);
WHERE
  WR1: SELF\characterized_object.name = '';
  WR2: NOT EXISTS(SELF\characterized_object.description);
  WR3: SIZEOF(QUERY(drt <* SELF\document.representation_types | drt.name IN ['digital','physical'])) = 1;
END_ENTITY;

ENTITY document_product_association
  ABSTRACT SUPERTYPE;
  name              : label;
  description       : OPTIONAL text;
  relating_document : document;
  related_product   : product_or_formation_or_definition;
END_ENTITY;

ENTITY document_product_equivalence
  SUBTYPE OF (document_product_association);
WHERE
  WR1: SELF\document_product_association.name = 'equivalence';
  WR2: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT' IN
            TYPEOF(SELF\document_product_association.related_product)) OR
           ((SELF\document_product_association.relating_document.kind.product_data_type =
             'configuration controlled document') AND
            (SIZEOF(QUERY(prpc
                          <* USEDIN(SELF\document_product_association.related_product,
                                    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                          | prpc.name = 'document')) =
             1));
  WR3: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product)) OR
           ((SELF\document_product_association.relating_document.kind.product_data_type =
             'configuration controlled document version') AND
            (SIZEOF(QUERY(prpc
                          <* USEDIN(SELF.related_product\product_definition_formation.of_product,
                                    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                          | prpc.name = 'document')) =
             1));
  WR4: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product)) OR
           ((SELF\document_product_association.relating_document.kind.product_data_type =
             'configuration controlled document definition') AND
            (SIZEOF(QUERY(prpc
                          <* USEDIN(SELF\document_product_association.related_product\product_definition.formation.of_product,
                                    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                          | prpc.name = 'document')) =
             1));
END_ENTITY;

ENTITY document_reference
  ABSTRACT SUPERTYPE;
  assigned_document : document;
  source            : label;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY document_relationship;
  name              : label;
  description       : OPTIONAL text;
  relating_document : document;
  related_document  : document;
END_ENTITY;

ENTITY document_representation_type;
  name                 : label;
  represented_document : document;
END_ENTITY;

ENTITY document_type;
  product_data_type : label;
END_ENTITY;

ENTITY document_usage_constraint;
  source                : document;
  subject_element       : label;
  subject_element_value : text;
END_ENTITY;

ENTITY document_usage_constraint_assignment
  ABSTRACT SUPERTYPE;
  assigned_document_usage : document_usage_constraint;
  role                    : document_usage_role;
END_ENTITY;

ENTITY document_usage_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY dose_equivalent_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DOSE_EQUIVALENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY dose_equivalent_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.sievert);
END_ENTITY;

ENTITY effectivity
  SUPERTYPE OF (ONEOF(serial_numbered_effectivity, dated_effectivity, lot_effectivity,
                      time_interval_based_effectivity));
  id : identifier;
DERIVE
  name        : label := get_name_value(SELF);
  description : text  := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY effectivity_assignment
  ABSTRACT SUPERTYPE;
  assigned_effectivity : effectivity;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY effectivity_context_assignment
  ABSTRACT SUPERTYPE;
  assigned_effectivity_assignment : effectivity_assignment;
  role                            : effectivity_context_role;
END_ENTITY;

ENTITY effectivity_context_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY effectivity_relationship;
  name                 : label;
  description          : OPTIONAL text;
  related_effectivity  : effectivity;
  relating_effectivity : effectivity;
END_ENTITY;

ENTITY electric_charge_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ELECTRIC_CHARGE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY electric_charge_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.coulomb);
END_ENTITY;

ENTITY electric_current_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ELECTRIC_CURRENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY electric_current_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY electric_potential_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ELECTRIC_POTENTIAL_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY electric_potential_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.volt);
END_ENTITY;

ENTITY elementary_function
  SUBTYPE OF (maths_function, generic_literal);
  func_id : elementary_function_enumerators;
END_ENTITY;

ENTITY elementary_space
  SUBTYPE OF (maths_space, generic_literal);
  space_id : elementary_space_enumerators;
END_ENTITY;

ENTITY end_task
  SUBTYPE OF (task_element);
END_ENTITY;

ENTITY energy_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ENERGY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY energy_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.joule);
END_ENTITY;

ENTITY envelope
  SUBTYPE OF (characterized_object, product);
END_ENTITY;

ENTITY envelope_relationship
  SUBTYPE OF (product_relationship);
END_ENTITY;

ENTITY environment;
  syntactic_representation : generic_variable;
  semantics                : variable_semantics;
END_ENTITY;

ENTITY environment_assignment
  SUBTYPE OF (group);
END_ENTITY;

ENTITY environment_definition
  SUBTYPE OF (product);
END_ENTITY;

ENTITY environment_definition_version
  SUBTYPE OF (product_definition_formation);
  SELF\product_definition_formation.of_product : environment_definition;
DERIVE
  of_environment : environment_definition := SELF\product_definition_formation.of_product;
END_ENTITY;

ENTITY environment_definition_view
  SUBTYPE OF (product_definition);
  SELF\product_definition.formation : environment_definition_version;
DERIVE
  defined_environment_version : environment_definition_version := SELF\product_definition.formation;
END_ENTITY;

ENTITY environment_view_definition_relationship
  SUBTYPE OF (product_definition_relationship);
  SELF\product_definition_relationship.relating_product_definition : environment_definition_view;
  SELF\product_definition_relationship.related_product_definition  : environment_definition_view;
DERIVE
  related_environment  : environment_definition_view := SELF\product_definition_relationship.related_product_definition;
  relating_environment : environment_definition_view := SELF\product_definition_relationship.relating_product_definition;
END_ENTITY;

ENTITY equals_expression
  SUBTYPE OF (binary_boolean_expression);
END_ENTITY;

ENTITY event_occurrence;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_assignment
  ABSTRACT SUPERTYPE;
  assigned_event_occurrence : event_occurrence;
  role                      : event_occurrence_role;
END_ENTITY;

ENTITY event_occurrence_characterized_object
  SUBTYPE OF (characterized_object, event_occurrence);
END_ENTITY;

ENTITY event_occurrence_context_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_relationship;
  name           : label;
  description    : OPTIONAL text;
  relating_event : event_occurrence;
  related_event  : event_occurrence;
END_ENTITY;

ENTITY event_occurrence_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_probability
  SUBTYPE OF (property_definition);
  SELF\property_definition.definition : event_occurrence_characterized_object;
END_ENTITY;

ENTITY evidence
  SUBTYPE OF (group_assignment);
  items : SET [1 : ?] OF evidence_item;
END_ENTITY;

ENTITY exclusive_product_concept_feature_category
  SUBTYPE OF (product_concept_feature_category);
END_ENTITY;

ENTITY executed_action
  SUBTYPE OF (action);
END_ENTITY;

ENTITY exit_loop
  SUBTYPE OF (task_element);
END_ENTITY;

ENTITY exp_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY expanded_uncertainty
  SUBTYPE OF (standard_uncertainty);
  coverage_factor : REAL;
END_ENTITY;

ENTITY experience;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY experience_assignment
  ABSTRACT SUPERTYPE;
  id                  : identifier;
  name                : label;
  description         : OPTIONAL text;
  assigned_experience : experience;
  role                : experience_role;
END_ENTITY;

ENTITY experience_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY experience_type;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY experience_type_assignment
  ABSTRACT SUPERTYPE;
  id                       : identifier;
  name                     : label;
  description              : OPTIONAL text;
  assigned_experience_type : experience_type;
  role                     : experience_type_role;
END_ENTITY;

ENTITY experience_type_relationship;
  id                       : identifier;
  name                     : label;
  description              : OPTIONAL text;
  relating_experience_type : experience_type;
  related_experience_type  : experience_type;
END_ENTITY;

ENTITY experience_type_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY explicit_table_function
  ABSTRACT SUPERTYPE OF (ONEOF(listed_real_data, listed_integer_data, listed_logical_data, listed_string_data,
                               listed_complex_number_data, listed_data, externally_listed_data,
                               linearized_table_function, basic_sparse_matrix))
  SUBTYPE OF (maths_function);
  index_base : zero_or_one;
  shape      : LIST [1 : ?] OF positive_integer;
END_ENTITY;

ENTITY expression
  ABSTRACT SUPERTYPE OF (ONEOF(numeric_expression, boolean_expression, string_expression))
  SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY expression_denoted_function
  SUBTYPE OF (maths_function, unary_generic_expression);
DERIVE
  expr : generic_expression := SELF\unary_generic_expression.operand;
WHERE
  WR1: (schema_prefix + 'FUNCTION_SPACE') IN TYPEOF(values_space_of(expr));
END_ENTITY;

ENTITY extended_tuple_space
  SUBTYPE OF (maths_space, generic_literal);
  base     : tuple_space;
  extender : maths_space;
WHERE
  WR1: expression_is_constant(base) AND expression_is_constant(extender);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: extender <> the_empty_space;
END_ENTITY;

ENTITY external_class_library
  SUBTYPE OF (external_source);
END_ENTITY;

ENTITY external_identification_assignment
  ABSTRACT SUPERTYPE
  SUBTYPE OF (identification_assignment);
  source : external_source;
END_ENTITY;

ENTITY external_identification_assignment_relationship;
  id            : OPTIONAL identifier;
  description   : OPTIONAL text;
  relating      : external_identification_assignment;
  related       : external_identification_assignment;
  relation_type : STRING;
WHERE
  WR1: acyclic_external_identification_assignment_relationship(SELF, [related],
                                                               'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXTERNAL_IDENTIFICATION_ASSIGNMENT_RELATIONSHIP');
END_ENTITY;

ENTITY external_source;
  source_id : source_item;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY external_source_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_source : external_source;
  related_source  : external_source;
END_ENTITY;

ENTITY externally_defined_class
  SUBTYPE OF (class, externally_defined_item);
END_ENTITY;

ENTITY externally_defined_context_dependent_unit
  SUBTYPE OF (context_dependent_unit, externally_defined_item);
END_ENTITY;

ENTITY externally_defined_conversion_based_unit
  SUBTYPE OF (conversion_based_unit, externally_defined_item);
END_ENTITY;

ENTITY externally_defined_general_property
  SUBTYPE OF (general_property, externally_defined_item);
END_ENTITY;

ENTITY externally_defined_item;
  item_id : source_item;
  source  : external_source;
END_ENTITY;

ENTITY externally_defined_item_relationship;
  name          : label;
  description   : OPTIONAL text;
  relating_item : externally_defined_item;
  related_item  : externally_defined_item;
END_ENTITY;

ENTITY externally_defined_item_with_multiple_references
  SUBTYPE OF (externally_defined_item);
  references : LIST [1 : ?] OF UNIQUE source_item;
UNIQUE
  UR1: references;
WHERE
  WR1: NOT (SELF\externally_defined_item.item_id IN references);
END_ENTITY;

ENTITY externally_defined_representation
  SUBTYPE OF (representation, externally_defined_item);
  SELF\representation.items : SET [1 : ?] OF externally_defined_representation_item;
END_ENTITY;

ENTITY externally_defined_representation_item
  SUBTYPE OF (representation_item, externally_defined_item);
END_ENTITY;

ENTITY externally_defined_string
  SUBTYPE OF (externally_defined_representation_item);
END_ENTITY;

ENTITY externally_listed_data
  SUBTYPE OF (explicit_table_function, generic_literal, externally_defined_item);
  value_range : maths_space;
WHERE
  WR1: expression_is_constant(value_range);
END_ENTITY;

ENTITY feature_component_relationship
  SUBTYPE OF (shape_aspect_relationship);
WHERE
  WR1: ((SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COMPOSITE_SHAPE_ASPECT',
                 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPLICATE_FEATURE',
                 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.TRANSITION_FEATURE',
                 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MODIFIED_PATTERN'] *
                TYPEOF(SELF.relating_shape_aspect)) =
         1) OR
        ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MACHINING_FEATURE_DEFINITION' IN
         TYPEOF(SELF.relating_shape_aspect.of_shape.definition)) OR
        ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.FEATURE_COMPONENT_DEFINITION' IN
         TYPEOF(SELF.relating_shape_aspect.of_shape.definition)));
END_ENTITY;

ENTITY feature_definition
  SUBTYPE OF (characterized_object);
END_ENTITY;

ENTITY final_solution
  SUBTYPE OF (product_definition_formation);
  status : STRING;
INVERSE
  specification : SET [1:?] OF product_definition FOR formation;
END_ENTITY;

ENTITY finite_function
  SUBTYPE OF (maths_function, generic_literal);
  pairs : SET [1 : ?] OF LIST [2 : 2] OF maths_value;
WHERE
  WR1: VALUE_UNIQUE(list_selected_components(pairs, 1));
END_ENTITY;

ENTITY finite_integer_interval
  SUBTYPE OF (maths_space, generic_literal);
  min : INTEGER;
  max : INTEGER;
DERIVE
  size : positive_integer := max - min + 1;
WHERE
  WR1: min <= max;
END_ENTITY;

ENTITY finite_real_interval
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
  max         : REAL;
  max_closure : open_closed;
WHERE
  WR1: min < max;
END_ENTITY;

ENTITY finite_space
  SUBTYPE OF (maths_space, generic_literal);
  members : SET OF maths_value;
WHERE
  WR1: VALUE_UNIQUE(members);
  WR2: SIZEOF(QUERY(expr
                    <* QUERY(member
                             <* members
                             | 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GENERIC_EXPRESSION' IN TYPEOF(member))
                    | NOT expression_is_constant(expr))) =
       0;
  WR3: no_cyclic_space_reference(SELF, []);
END_ENTITY;

ENTITY force_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.FORCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY force_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.newton);
END_ENTITY;

ENTITY format_function
  SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
  value_to_format : generic_expression := SELF\binary_generic_expression.operands[1];
  format_string   : generic_expression := SELF\binary_generic_expression.operands[2];
WHERE
  WR1: (('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NUMERIC_EXPRESSION') IN TYPEOF(value_to_format)) AND
       (('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STRING_EXPRESSION') IN TYPEOF(format_string));
END_ENTITY;

ENTITY free_variable_semantics
  SUBTYPE OF (variable_semantics);
END_ENTITY;

ENTITY frequency_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.FREQUENCY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY frequency_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.hertz);
END_ENTITY;

ENTITY function_application
  SUBTYPE OF (multiple_arity_generic_expression);
  func      : maths_function_select;
  arguments : LIST [1 : ?] OF maths_expression;
DERIVE
  SELF\multiple_arity_generic_expression.operands                                        : LIST [2 : ?] OF generic_expression := [convert_to_maths_function(func)] +
                                                                                                                                 convert_to_operands(arguments);
WHERE
  WR1: function_applicability(func, arguments);
END_ENTITY;

ENTITY function_space
  SUBTYPE OF (maths_space, generic_literal);
  domain_constraint : space_constraint_type;
  domain_argument   : maths_space;
  range_constraint  : space_constraint_type;
  range_argument    : maths_space;
WHERE
  WR1: expression_is_constant(domain_argument) AND expression_is_constant(range_argument);
  WR2: (domain_argument <> the_empty_space) AND (range_argument <> the_empty_space);
  WR3: (domain_constraint <> sc_member) OR NOT member_of(the_empty_space, domain_argument);
  WR4: (range_constraint <> sc_member) OR NOT member_of(the_empty_space, range_argument);
  WR5: NOT (any_space_satisfies(domain_constraint, domain_argument) AND
            any_space_satisfies(range_constraint, range_argument));
END_ENTITY;

ENTITY functional_breakdown_context
  SUBTYPE OF (breakdown_context);
END_ENTITY;

ENTITY functional_element_usage
  SUBTYPE OF (breakdown_element_usage);
END_ENTITY;

ENTITY functionally_defined_transformation;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY general_feature
  SUBTYPE OF (shape_feature_definition);
WHERE
  WR1: (SIZEOF(get_property_definition_representations(SELF)) <= 1) AND
       (SIZEOF(QUERY(pdr
                     <* get_property_definition_representations(SELF)
                     | 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN
                       TYPEOF(pdr.used_representation))) <=
        1);
  WR2: SIZEOF(QUERY(sa <* get_shape_aspects(SELF) | sa.description = 'course of travel occurrence')) =
       SIZEOF(QUERY(sa
                    <* get_shape_aspects(SELF)
                    | (sa.description = 'course of travel occurrence') AND
                      (SIZEOF(QUERY(sar
                                    <* USEDIN(sa,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')
                                    | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_DEFINING_RELATIONSHIP' IN
                                       TYPEOF(sar)) AND
                                      (sar.name = 'course of travel'))) =
                       1)));
  WR3: SIZEOF(QUERY(sa <* get_shape_aspects(SELF) | sa.description = 'course of travel occurrence')) =
       SIZEOF(QUERY(sa
                    <* get_shape_aspects(SELF)
                    | (sa.description = 'course of travel occurrence') AND
                      (SIZEOF(QUERY(sar
                                    <* USEDIN(sa,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')
                                    | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_DEFINING_RELATIONSHIP' IN
                                       TYPEOF(sar)) AND
                                      ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PATH_FEATURE_COMPONENT' IN
                                       TYPEOF(sar.relating_shape_aspect)))) =
                       1)));
  WR4: SIZEOF(QUERY(sa <* get_shape_aspects(SELF) | sa.description = 'boundary occurrence')) =
       SIZEOF(QUERY(sa
                    <* get_shape_aspects(SELF)
                    | (sa.description = 'boundary occurrence') AND
                      (SIZEOF(QUERY(sar
                                    <* USEDIN(sa,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')
                                    | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_DEFINING_RELATIONSHIP' IN
                                       TYPEOF(sar)) AND
                                      (sar.description = 'profile usage'))) =
                       1)));
  WR5: (SIZEOF(QUERY(sa
                     <* get_shape_aspects(SELF)
                     | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COMPOSITE_SHAPE_ASPECT' IN TYPEOF(sa)))) <=
        1) AND
       (SIZEOF(QUERY(sa
                     <* get_shape_aspects(SELF)
                     | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COMPOSITE_SHAPE_ASPECT' IN TYPEOF(sa)) AND
                       (sa.name = 'general compound feature') AND
                       (SIZEOF(QUERY(sar
                                     <* USEDIN(sa,
                                               'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')
                                     | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.FEATURE_COMPONENT_RELATIONSHIP' IN
                                        TYPEOF(sar)) AND
                                       ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INSTANCED_FEATURE' IN
                                        TYPEOF(sar.related_shape_aspect)))) >=
                        2))) <=
        1);
END_ENTITY;

ENTITY general_linear_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  sum_index                             : one_or_two;
DERIVE
  mat : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_2d_table(mat);
  WR2: (space_dimension(mat.range) = 1) AND subspace_of_es(factor1(mat.range), es_numbers);
END_ENTITY;

ENTITY general_property;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY general_property_association;
  name               : label;
  description        : OPTIONAL text;
  base_definition    : general_property;
  derived_definition : derived_property_select;
WHERE
  WR1: (SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DIMENSIONAL_LOCATION',
                'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DIMENSIONAL_SIZE',
                'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GEOMETRIC_TOLERANCE'] *
               TYPEOF(derived_definition)) >
        0) OR
       (SIZEOF(USEDIN(derived_definition,
                      'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GENERAL_PROPERTY_ASSOCIATION.DERIVED_DEFINITION')) =
        1);
  WR2: (SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DIMENSIONAL_LOCATION',
                'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DIMENSIONAL_SIZE',
                'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GEOMETRIC_TOLERANCE'] *
               TYPEOF(derived_definition)) >
        0) OR
       (derived_definition.name = base_definition.name);
END_ENTITY;

ENTITY general_property_relationship;
  name              : label;
  description       : OPTIONAL text;
  relating_property : general_property;
  related_property  : general_property;
END_ENTITY;

ENTITY generic_attribute;
  attribute_name  : label;
  attribute_value : text;
END_ENTITY;

ENTITY generic_attribute_list_assignment;
  attribute_name      : label;
  attributes          : LIST [1 : ?] OF generic_attribute;
  item_with_attribute : generic_attribute_list_select;
END_ENTITY;

ENTITY generic_expression
  ABSTRACT SUPERTYPE OF (ONEOF(simple_generic_expression, unary_generic_expression, binary_generic_expression,
                               multiple_arity_generic_expression));
WHERE
  WR1: is_acyclic(SELF);
END_ENTITY;

ENTITY generic_literal
  ABSTRACT SUPERTYPE
  SUBTYPE OF (simple_generic_expression);
END_ENTITY;

ENTITY generic_product_definition_reference
  ABSTRACT SUPERTYPE OF (ONEOF(product_definition_reference, product_definition_reference_with_local_representation));
  source : external_source;
END_ENTITY;

ENTITY generic_property_relationship;
  name          : label;
  description   : text;
  relating      : generic_property_definition_select;
  related       : generic_property_definition_select;
  relation_type : STRING;
WHERE
  WR1: acyclic_generic_property_relationship(SELF, [related],
                                             'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GENERIC_PROPERTY_RELATIONSHIP');
END_ENTITY;

ENTITY generic_variable
  ABSTRACT SUPERTYPE
  SUBTYPE OF (simple_generic_expression);
INVERSE
  interpretation : environment FOR syntactic_representation;
END_ENTITY;

ENTITY geometric_item_specific_usage
  SUBTYPE OF (item_identified_representation_usage);
  SELF\item_identified_representation_usage.definition          : geometric_item_specific_usage_select;
  SELF\item_identified_representation_usage.used_representation : shape_model;
  SELF\item_identified_representation_usage.identified_item     : geometric_model_item;
END_ENTITY;

ENTITY geometric_representation_context
  SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
END_ENTITY;

ENTITY geometric_representation_item
  SUPERTYPE OF ((ONEOF(cartesian_transformation_operator, curve, direction, placement, point, surface, vector, volume)))
  SUBTYPE OF (representation_item);
DERIVE
  dim : dimension_count := dimension_of(SELF);
WHERE
  WR1: SIZEOF(QUERY(using_rep
                    <* using_representations(SELF)
                    | NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN
                           TYPEOF(using_rep.context_of_items)))) =
       0;
END_ENTITY;

ENTITY global_uncertainty_assigned_context
  SUBTYPE OF (representation_context);
  uncertainty : SET [1 : ?] OF uncertainty_measure_with_unit;
END_ENTITY;

ENTITY global_unit_assigned_context
  SUBTYPE OF (representation_context);
  units : SET [1 : ?] OF unit;
END_ENTITY;

ENTITY group;
  name        : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY group_assignment
  ABSTRACT SUPERTYPE;
  assigned_group : group;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY group_relationship;
  name           : label;
  description    : OPTIONAL text;
  relating_group : group;
  related_group  : group;
END_ENTITY;

ENTITY hierarchical_interface_connection
  SUBTYPE OF (interface_connection);
END_ENTITY;

ENTITY homogeneous_linear_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  sum_index                             : one_or_two;
DERIVE
  mat : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_2d_table(mat);
  WR2: (space_dimension(mat.range) = 1) AND subspace_of_es(factor1(mat.range), es_numbers);
END_ENTITY;

ENTITY id_attribute;
  attribute_value : identifier;
  identified_item : id_attribute_select;
END_ENTITY;

ENTITY identification_assignment
  ABSTRACT SUPERTYPE;
  assigned_id : identifier;
  role        : identification_role;
END_ENTITY;

ENTITY identification_assignment_relationship;
  name                               : label;
  description                        : OPTIONAL text;
  relating_identification_assignment : identification_assignment;
  related_identification_assignment  : identification_assignment;
END_ENTITY;

ENTITY identification_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY illuminance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ILLUMINANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY illuminance_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.lux);
END_ENTITY;

ENTITY imported_curve_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : curve;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;

ENTITY imported_point_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry : point;
END_ENTITY;

ENTITY imported_surface_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : surface;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;

ENTITY imported_volume_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : volume;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;

ENTITY in_zone
  SUBTYPE OF (group);
END_ENTITY;

ENTITY inclusion_product_concept_feature
  SUBTYPE OF (conditional_concept_feature);
WHERE
  WR1: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PACKAGE_PRODUCT_CONCEPT_FEATURE' IN TYPEOF(SELF));
  WR2: SIZEOF(QUERY(cfr
                    <* USEDIN(SELF,
                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONCEPT_FEATURE_RELATIONSHIP.RELATING_PRODUCT_CONCEPT_FEATURE')
                    | 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN
                      TYPEOF(cfr))) +
       SIZEOF(QUERY(cfr
                    <* USEDIN(SELF,
                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONCEPT_FEATURE_RELATIONSHIP.RELATED_PRODUCT_CONCEPT_FEATURE')
                    | 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN
                      TYPEOF(cfr))) =
       0;
  WR3: SELF.condition.conditional_operator.name = 'implication';
END_ENTITY;

ENTITY index_expression
  SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
  operand : generic_expression := SELF\binary_generic_expression.operands[1];
  index   : generic_expression := SELF\binary_generic_expression.operands[2];
WHERE
  WR1: ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STRING_EXPRESSION' IN TYPEOF(operand)) AND
       ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(index));
  WR2: is_int_expr(index);
END_ENTITY;

ENTITY inductance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INDUCTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY inductance_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.henry);
END_ENTITY;

ENTITY information_right
  SUBTYPE OF (action_method);
END_ENTITY;

ENTITY information_usage_right
  SUBTYPE OF (action_method);
END_ENTITY;

ENTITY instance_usage_context_assignment
  SUBTYPE OF (product_definition_context);
  items : SET [1 : ?] OF instance_usage_context_select;
END_ENTITY;

ENTITY instanced_feature
  SUBTYPE OF (feature_definition, shape_aspect);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
  WR2: SELF.product_definitional;
END_ENTITY;

ENTITY int_literal
  SUBTYPE OF (literal_number);
  SELF\literal_number.the_value : INTEGER;
END_ENTITY;

ENTITY int_numeric_variable
  SUBTYPE OF (numeric_variable);
END_ENTITY;

ENTITY int_value_function
  SUBTYPE OF (value_function);
END_ENTITY;

ENTITY integer_defined_function
  ABSTRACT SUPERTYPE
  SUBTYPE OF (numeric_defined_function);
END_ENTITY;

ENTITY integer_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min : INTEGER;
END_ENTITY;

ENTITY integer_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max : INTEGER;
END_ENTITY;

ENTITY integer_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST [1 : ?] OF INTEGER;
END_ENTITY;

ENTITY interface_connection
  SUBTYPE OF (group);
END_ENTITY;

ENTITY interface_connector_as_planned
  SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY interface_connector_as_realized
  SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY interface_connector_definition
  SUBTYPE OF (product_definition);
END_ENTITY;

ENTITY interface_connector_design
  SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY interface_connector_design_to_planned
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : interface_connector_design;
  SELF\product_definition_formation_relationship.related_product_definition_formation  : interface_connector_as_planned;
WHERE
  WR1: SELF.relating_product_definition_formation.of_product :=: SELF.related_product_definition_formation.of_product;
END_ENTITY;

ENTITY interface_connector_design_to_realized
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : interface_connector_design;
  SELF\product_definition_formation_relationship.related_product_definition_formation  : interface_connector_as_realized;
WHERE
  WR1: SELF.relating_product_definition_formation.of_product :=: SELF.related_product_definition_formation.of_product;
END_ENTITY;

ENTITY interface_connector_occurrence
  SUBTYPE OF (group);
END_ENTITY;

ENTITY interface_connector_planned_to_realized
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : interface_connector_as_planned;
  SELF\product_definition_formation_relationship.related_product_definition_formation  : interface_connector_as_realized;
WHERE
  WR1: SELF.relating_product_definition_formation.of_product :=: SELF.related_product_definition_formation.of_product;
END_ENTITY;

ENTITY interface_connector_version
  SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY interface_definition_connection
  SUBTYPE OF (product_definition_relationship);
END_ENTITY;

ENTITY interface_definition_for
  SUBTYPE OF (product_definition_relationship);
END_ENTITY;

ENTITY interface_specification_definition
  SUBTYPE OF (product_definition);
END_ENTITY;

ENTITY interface_specification_version
  SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY interval_expression
  SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
DERIVE
  interval_low  : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
  interval_item : generic_expression := SELF\multiple_arity_generic_expression.operands[2];
  interval_high : generic_expression := SELF\multiple_arity_generic_expression.operands[3];
WHERE
  WR1: ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXPRESSION' IN TYPEOF(interval_low)) AND
       ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXPRESSION' IN TYPEOF(interval_item)) AND
       ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXPRESSION' IN TYPEOF(interval_high));
  WR2: (('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STRING_EXPRESSION' IN TYPEOF(SELF.interval_low)) AND
        ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STRING_EXPRESSION' IN TYPEOF(SELF.interval_high)) AND
        ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STRING_EXPRESSION' IN TYPEOF(SELF.interval_item))) OR
       (('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(SELF.interval_low)) AND
        ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(SELF.interval_item)) AND
        ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(SELF.interval_high)));
END_ENTITY;

ENTITY item_assumed
  SUBTYPE OF (characterized_applied_state_observed_assignment);
END_ENTITY;

ENTITY item_defined_transformation;
  name             : label;
  description      : OPTIONAL text;
  transform_item_1 : representation_item;
  transform_item_2 : representation_item;
END_ENTITY;

ENTITY item_identified_representation_usage;
  name                : label;
  description         : OPTIONAL text;
  definition          : item_identified_representation_usage_definition;
  used_representation : representation;
  identified_item     : item_identified_representation_usage_select;
UNIQUE
  UR1: used_representation, identified_item;
  UR2: used_representation, definition;
WHERE
  WR1: valid_identified_item_in_representation(identified_item, used_representation);
END_ENTITY;

ENTITY justification_assignment
  SUBTYPE OF (group);
END_ENTITY;

ENTITY justification_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET [1 : 1] OF product;
END_ENTITY;

ENTITY justification_item_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET [1 : 1] OF justification_item;
END_ENTITY;

ENTITY justification_support_assignment
  SUBTYPE OF (group);
END_ENTITY;

ENTITY justification_support_item_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET [1 : 1] OF justification_support_item;
END_ENTITY;

ENTITY known_source
  SUBTYPE OF (external_source, pre_defined_item);
END_ENTITY;

ENTITY language
  SUBTYPE OF (group);
WHERE
  WR1: SELF\group.name <> '';
  -- Informal proposition
  -- - IP1: The name attribute of the language shall be an alpha-3 bibliographic code of ISO 639-2.
  -- - IP2: If present, the description attribute shall identify a country with an alpha-2 code specified in ISO 3166-1. 
END_ENTITY;

ENTITY length_function
  SUBTYPE OF (numeric_expression, unary_generic_expression);
  SELF\unary_generic_expression.operand : string_expression;
END_ENTITY;

ENTITY length_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LENGTH_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY length_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 1.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY like_expression
  SUBTYPE OF (comparison_expression);
WHERE
  WR1: ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STRING_EXPRESSION' IN
        TYPEOF(SELF\binary_generic_expression.operands[1])) AND
       ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STRING_EXPRESSION' IN
        TYPEOF(SELF\binary_generic_expression.operands[2]));
END_ENTITY;

ENTITY linearized_table_function
  SUPERTYPE OF (ONEOF(standard_table_function, regular_table_function, triangular_matrix, symmetric_matrix,
                      banded_matrix))
  SUBTYPE OF (explicit_table_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  first                                 : INTEGER;
DERIVE
  source : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_1d_array(source);
  WR2: member_of(first, source\maths_function.domain);
END_ENTITY;

ENTITY listed_complex_number_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [2 : ?] OF REAL;
DERIVE
  SELF\explicit_table_function.shape                              : LIST [1 : ?] OF positive_integer := [SIZEOF(values) DIV
                                                                                                         2];
WHERE
  WR1: NOT ODD(SIZEOF(values));
END_ENTITY;

ENTITY listed_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values      : LIST [1 : ?] OF maths_value;
  value_range : maths_space;
DERIVE
  SELF\explicit_table_function.shape                              : LIST [1 : ?] OF positive_integer := [SIZEOF(values)];
WHERE
  WR1: expression_is_constant(value_range);
  WR2: SIZEOF(QUERY(val <* values | NOT (member_of(val, value_range)))) = 0;
END_ENTITY;

ENTITY listed_integer_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1 : ?] OF INTEGER;
DERIVE
  SELF\explicit_table_function.shape                              : LIST [1 : ?] OF positive_integer := [SIZEOF(values)];
END_ENTITY;

ENTITY listed_logical_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1 : ?] OF LOGICAL;
DERIVE
  SELF\explicit_table_function.shape                              : LIST [1 : ?] OF positive_integer := [SIZEOF(values)];
END_ENTITY;

ENTITY listed_product_space
  SUBTYPE OF (maths_space, generic_literal);
  factors : LIST OF maths_space;
WHERE
  WR1: SIZEOF(QUERY(space <* factors | NOT (expression_is_constant(space)))) = 0;
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: NOT (the_empty_space IN factors);
END_ENTITY;

ENTITY listed_real_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1 : ?] OF REAL;
DERIVE
  SELF\explicit_table_function.shape                              : LIST [1 : ?] OF positive_integer := [SIZEOF(values)];
END_ENTITY;

ENTITY listed_string_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1 : ?] OF STRING;
DERIVE
  SELF\explicit_table_function.shape                              : LIST [1 : ?] OF positive_integer := [SIZEOF(values)];
END_ENTITY;

ENTITY literal_number
  ABSTRACT SUPERTYPE OF (ONEOF(int_literal, real_literal))
  SUBTYPE OF (simple_numeric_expression, generic_literal);
  the_value : NUMBER;
END_ENTITY;

ENTITY local_time;
  hour_component   : hour_in_day;
  minute_component : OPTIONAL minute_in_hour;
  second_component : OPTIONAL second_in_minute;
  zone             : coordinated_universal_time_offset;
WHERE
  WR1: valid_time(SELF);
END_ENTITY;

ENTITY location;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY location_assignment
  ABSTRACT SUPERTYPE;
  id                : identifier;
  name              : label;
  description       : OPTIONAL text;
  assigned_location : location;
  role              : location_role;
END_ENTITY;

ENTITY location_relationship;
  id                : identifier;
  name              : label;
  description       : OPTIONAL text;
  relating_location : location;
  related_location  : location;
END_ENTITY;

ENTITY location_representation_assignment
  ABSTRACT SUPERTYPE;
  id                   : identifier;
  name                 : label;
  description          : OPTIONAL text;
  represented_location : location;
  role                 : location_representation_role;
END_ENTITY;

ENTITY location_representation_relationship
  SUBTYPE OF (group);
END_ENTITY;

ENTITY location_representation_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY location_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY log_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log10_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log2_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY logical_literal
  SUBTYPE OF (generic_literal);
  lit_value : LOGICAL;
END_ENTITY;

ENTITY looping_element
  SUBTYPE OF (task_element);
END_ENTITY;

ENTITY lot_effectivity
  SUBTYPE OF (effectivity);
  effectivity_lot_id   : identifier;
  effectivity_lot_size : measure_with_unit;
END_ENTITY;

ENTITY luminous_flux_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LUMINOUS_FLUX_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY luminous_flux_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.lumen);
END_ENTITY;

ENTITY luminous_intensity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LUMINOUS_INTENSITY_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY luminous_intensity_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
END_ENTITY;

ENTITY magnetic_flux_density_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MAGNETIC_FLUX_DENSITY_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY magnetic_flux_density_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.tesla);
END_ENTITY;

ENTITY magnetic_flux_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MAGNETIC_FLUX_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY magnetic_flux_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.weber);
END_ENTITY;

ENTITY make_from_usage_option
  SUBTYPE OF (product_definition_usage);
  ranking           : INTEGER;
  ranking_rationale : text;
  quantity          : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component))) OR (quantity.value_component > 0);
END_ENTITY;

ENTITY mapped_item
  SUBTYPE OF (representation_item);
  mapping_source : representation_map;
  mapping_target : representation_item;
WHERE
  WR1: acyclic_mapped_representation(SELF);
END_ENTITY;

ENTITY mass_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MASS_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY mass_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY mathematical_description;
  described  : maths_expression;
  describing : STRING;
  encoding   : label;
END_ENTITY;

ENTITY maths_boolean_variable
  SUBTYPE OF (maths_variable, boolean_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space, es_booleans);
END_ENTITY;

ENTITY maths_enum_literal
  SUBTYPE OF (generic_literal);
  lit_value : maths_enum_atom;
END_ENTITY;

ENTITY maths_function
  ABSTRACT SUPERTYPE OF (ONEOF(finite_function, constant_function, selector_function, elementary_function,
                               restriction_function, repackaging_function, reindexed_array_function,
                               series_composed_function, parallel_composed_function, explicit_table_function,
                               homogeneous_linear_function, general_linear_function, b_spline_basis, b_spline_function,
                               rationalize_function, partial_derivative_function, definite_integral_function,
                               abstracted_expression_function, expression_denoted_function, imported_point_function,
                               imported_curve_function, imported_surface_function, imported_volume_function,
                               application_defined_function))
  SUBTYPE OF (generic_expression);
DERIVE
  domain : tuple_space := derive_function_domain(SELF);
  range  : tuple_space := derive_function_range(SELF);
END_ENTITY;

ENTITY maths_integer_variable
  SUBTYPE OF (maths_variable, int_numeric_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space, es_integers);
END_ENTITY;

ENTITY maths_real_variable
  SUBTYPE OF (maths_variable, real_numeric_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space, es_reals);
END_ENTITY;

ENTITY maths_space
  ABSTRACT SUPERTYPE OF (ONEOF(elementary_space, finite_integer_interval, integer_interval_from_min,
                               integer_interval_to_max, finite_real_interval, real_interval_from_min,
                               real_interval_to_max, cartesian_complex_number_region, polar_complex_number_region,
                               finite_space, uniform_product_space, listed_product_space, extended_tuple_space,
                               function_space))
  SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY maths_string_variable
  SUBTYPE OF (maths_variable, string_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space, es_strings);
END_ENTITY;

ENTITY maths_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST OF maths_value;
END_ENTITY;

ENTITY maths_value_precision_qualifier;
  precision_value : maths_value;
END_ENTITY;

ENTITY maths_variable
  SUBTYPE OF (generic_variable);
  values_space : maths_space;
  name         : label;
WHERE
  WR1: expression_is_constant(values_space);
END_ENTITY;

ENTITY maximum_function
  SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;

ENTITY measure_qualification;
  name              : label;
  description       : text;
  qualified_measure : measure_with_unit;
  qualifiers        : SET [1 : ?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp
                    <* qualifiers
                    | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRECISION_QUALIFIER' IN TYPEOF(temp)) OR
                      ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MATHS_VALUE_PRECISION_QUALIFIER' IN TYPEOF(temp)))) <
       2;
  WR2: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_ITEM' IN
            TYPEOF(SELF\measure_qualification.qualified_measure));
END_ENTITY;

ENTITY measure_representation_item
  SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY;

ENTITY measure_with_unit
  SUPERTYPE OF (ONEOF(length_measure_with_unit, mass_measure_with_unit, time_measure_with_unit,
                      electric_current_measure_with_unit, thermodynamic_temperature_measure_with_unit,
                      celsius_temperature_measure_with_unit, amount_of_substance_measure_with_unit,
                      luminous_intensity_measure_with_unit, plane_angle_measure_with_unit,
                      solid_angle_measure_with_unit, area_measure_with_unit, volume_measure_with_unit,
                      ratio_measure_with_unit, acceleration_measure_with_unit, capacitance_measure_with_unit,
                      electric_charge_measure_with_unit, conductance_measure_with_unit,
                      electric_potential_measure_with_unit, energy_measure_with_unit,
                      magnetic_flux_density_measure_with_unit, force_measure_with_unit, frequency_measure_with_unit,
                      illuminance_measure_with_unit, inductance_measure_with_unit, luminous_flux_measure_with_unit,
                      magnetic_flux_measure_with_unit, power_measure_with_unit, pressure_measure_with_unit,
                      resistance_measure_with_unit, velocity_measure_with_unit, absorbed_dose_measure_with_unit,
                      radioactivity_measure_with_unit, dose_equivalent_measure_with_unit));
  value_component : measure_value;
  unit_component  : unit;
WHERE
  WR1: valid_units(SELF);
END_ENTITY;

ENTITY message_contents_assignment
  SUBTYPE OF (group_assignment);
  items                                : SET [1 : ?] OF representation;
  SELF\group_assignment.assigned_group : message_contents_group;
DERIVE
  message_contents_group : message_contents_group := SELF\group_assignment.assigned_group;
END_ENTITY;

ENTITY message_contents_group
  SUBTYPE OF (group);
END_ENTITY;

ENTITY message_relationship
  SUBTYPE OF (product_relationship);
  SELF\product_relationship.relating_product : structured_message;
  SELF\product_relationship.related_product  : structured_message;
DERIVE
  related_message  : structured_message := SELF\product_relationship.related_product;
  relating_message : structured_message := SELF\product_relationship.relating_product;
END_ENTITY;

ENTITY minimum_function
  SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;

ENTITY minus_expression
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY minus_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY mod_expression
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY monitor
  SUBTYPE OF (risk_activity_structure);
  SELF\action_relationship.relating_action : risk_control;
  SELF\action_relationship.related_action  : risk_assessment;
END_ENTITY;

ENTITY mult_expression
  SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY multi_language_attribute_assignment
  SUBTYPE OF (attribute_value_assignment);
  items : SET [1 : ?] OF multi_language_attribute_item;
DERIVE
  translation_language : language := language_indication[1]\attribute_classification_assignment.assigned_class;
INVERSE
  language_indication : SET [1:1] OF attribute_language_assignment FOR items;
WHERE
  WR1: (SELF\attribute_value_assignment.role.name = 'alternate language');
  WR2: SIZEOF(QUERY(ala
                    <* language_indication
                    | (ala\attribute_classification_assignment.attribute_name = 'attribute_value') AND
                      (ala\attribute_classification_assignment.role.name = 'translated'))) =
       1;
  WR3: SELF\attribute_value_assignment.attribute_name <> '';
  WR4: SIZEOF(QUERY(ci
                    <* items
                    | SIZEOF(QUERY(ata
                                   <* USEDIN(ci,
                                             'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS')
                                   | (ata\attribute_value_assignment.attribute_name =
                                      SELF\attribute_value_assignment.attribute_name) AND
                                     (ata.translation_language :=: translation_language))) >
                      1)) =
       0;
  WR5: SIZEOF(QUERY(ci
                    <* items
                    | SIZEOF(QUERY(ata
                                   <* USEDIN(ci,
                                             'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS')
                                   | (ata\attribute_classification_assignment.role.name = 'primary') AND
                                     (ata\attribute_classification_assignment.attribute_name =
                                      SELF\attribute_value_assignment.attribute_name) AND
                                     (ata\attribute_classification_assignment.assigned_class :=:
                                      translation_language))) >
                      0)) =
       0;
END_ENTITY;

ENTITY multi_level_reference_designator
  SUBTYPE OF (assembly_component_usage);
  location : LIST [1 : ?] OF UNIQUE next_assembly_usage_occurrence;
DERIVE
  SELF\product_definition_relationship.relating_product_definition                                      : product_definition              := location[1]\product_definition_relationship.relating_product_definition;
  root                                                             : product_definition              := relating_product_definition;
  SELF\product_definition_relationship.related_product_definition                                       : product_definition_or_reference := location[HIINDEX(location)]\product_definition_relationship.related_product_definition;
  leaf                                                             : product_definition_or_reference := related_product_definition;
UNIQUE
  UR1: location;
WHERE
  WR1: unambiguously_specified_multi_level_reference_designator(location);
  WR2: SIZEOF(QUERY(cp <* location | NOT (EXISTS(cp\assembly_component_usage.reference_designator)))) = 0;
END_ENTITY;

ENTITY multiple_arity_boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(and_expression, or_expression))
  SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [2 : ?] OF boolean_expression;
END_ENTITY;

ENTITY multiple_arity_function_call
  ABSTRACT SUPERTYPE OF (ONEOF(maximum_function, minimum_function))
  SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY multiple_arity_generic_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (generic_expression);
  operands : LIST [2 : ?] OF generic_expression;
END_ENTITY;

ENTITY multiple_arity_numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(plus_expression, mult_expression, multiple_arity_function_call))
  SUBTYPE OF (numeric_expression, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [2 : ?] OF numeric_expression;
END_ENTITY;

ENTITY name_assignment
  ABSTRACT SUPERTYPE;
  assigned_name : label;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY name_attribute;
  attribute_value : label;
  named_item      : name_attribute_select;
END_ENTITY;

ENTITY named_unit
  SUPERTYPE OF (ONEOF(si_unit, conversion_based_unit, context_dependent_unit) ANDOR
                ONEOF(length_unit, mass_unit, time_unit, electric_current_unit, thermodynamic_temperature_unit,
                      amount_of_substance_unit, luminous_flux_unit, luminous_intensity_unit, plane_angle_unit,
                      solid_angle_unit, ratio_unit));
  dimensions : dimensional_exponents;
END_ENTITY;

ENTITY next_assembly_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
DERIVE
  product_definition_occurrence_id : identifier := SELF\product_definition_relationship.related_product_definition\product_definition_occurrence.id;
UNIQUE
  UR1: SELF\assembly_component_usage.reference_designator,
       SELF\product_definition_relationship.relating_product_definition;
  UR2: product_definition_occurrence_id, SELF\product_definition_relationship.relating_product_definition;
END_ENTITY;

ENTITY not_expression
  SUBTYPE OF (unary_boolean_expression);
  SELF\unary_generic_expression.operand : boolean_expression;
END_ENTITY;

ENTITY numeric_defined_function
  ABSTRACT SUPERTYPE OF (ONEOF(integer_defined_function, real_defined_function))
  SUBTYPE OF (numeric_expression, defined_function);
END_ENTITY;

ENTITY numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(simple_numeric_expression, unary_numeric_expression, binary_numeric_expression,
                               multiple_arity_numeric_expression, length_function, value_function,
                               numeric_defined_function))
  SUBTYPE OF (expression);
DERIVE
  is_int       : BOOLEAN := is_int_expr(SELF);
  sql_mappable : BOOLEAN := is_sql_mappable(SELF);
END_ENTITY;

ENTITY numeric_variable
  SUPERTYPE OF (ONEOF(int_numeric_variable, real_numeric_variable))
  SUBTYPE OF (simple_numeric_expression, variable);
WHERE
  WR1: ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INT_NUMERIC_VARIABLE' IN TYPEOF(SELF)) OR
       ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REAL_NUMERIC_VARIABLE' IN TYPEOF(SELF));
END_ENTITY;

ENTITY object_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY observation
  SUBTYPE OF (action_actual);
END_ENTITY;

ENTITY observation_consequence
  SUBTYPE OF (applied_action_assignment);
END_ENTITY;

ENTITY observation_relationship
  SUBTYPE OF (action_relationship);
END_ENTITY;

ENTITY observed_environment
  SUBTYPE OF (product);
END_ENTITY;

ENTITY observed_environment_assignment
  SUBTYPE OF (group);
END_ENTITY;

ENTITY observed_environment_to_definition
  SUBTYPE OF (product_relationship);
  SELF\product_relationship.relating_product : environment_definition;
  SELF\product_relationship.related_product  : observed_environment;
DERIVE
  observed_environment : observed_environment   := SELF\product_relationship.related_product;
  defined_environment  : environment_definition := SELF\product_relationship.relating_product;
END_ENTITY;

ENTITY observed_environment_to_definition_version
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : environment_definition_version;
  SELF\product_definition_formation_relationship.related_product_definition_formation  : observed_environment_version;
DERIVE
  observed_environment_version : observed_environment_version   := SELF\product_definition_formation_relationship.related_product_definition_formation;
  defined_environment_version  : environment_definition_version := SELF\product_definition_formation_relationship.relating_product_definition_formation;
END_ENTITY;

ENTITY observed_environment_to_definition_view
  SUBTYPE OF (product_definition_relationship);
  SELF\product_definition_relationship.relating_product_definition : observed_environment_view;
  SELF\product_definition_relationship.related_product_definition  : environment_definition_view;
DERIVE
  observed_environment_view : environment_definition_view := SELF\product_definition_relationship.related_product_definition;
  defined_environment_view  : observed_environment_view   := SELF\product_definition_relationship.relating_product_definition;
END_ENTITY;

ENTITY observed_environment_version
  SUBTYPE OF (product_definition_formation);
  SELF\product_definition_formation.of_product : observed_environment;
DERIVE
  of_environment : observed_environment := SELF\product_definition_formation.of_product;
END_ENTITY;

ENTITY observed_environment_view
  SUBTYPE OF (product_definition);
  SELF\product_definition.formation : observed_environment_version;
DERIVE
  observed_environment_version : observed_environment_version := SELF\product_definition.formation;
END_ENTITY;

ENTITY observed_environment_view_definition_relationship
  SUBTYPE OF (product_definition_relationship);
  SELF\product_definition_relationship.relating_product_definition : observed_environment_view;
  SELF\product_definition_relationship.related_product_definition  : observed_environment_view;
DERIVE
  related_environment  : observed_environment_view := SELF\product_definition_relationship.related_product_definition;
  relating_environment : observed_environment_view := SELF\product_definition_relationship.relating_product_definition;
END_ENTITY;

ENTITY odd_function
  SUBTYPE OF (unary_boolean_expression);
  SELF\unary_generic_expression.operand : numeric_expression;
WHERE
  WR1: is_int_expr(operand);
END_ENTITY;

ENTITY or_expression
  SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;

ENTITY ordinal_date
  SUBTYPE OF (date);
  day_component : day_in_year_number;
WHERE
  WR1: (NOT leap_year(SELF.year_component) AND {1 <= day_component <= 365}) OR
       (leap_year(SELF.year_component) AND {1 <= day_component <= 366});
END_ENTITY;

ENTITY organization;
  id          : OPTIONAL identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organization_assignment
  ABSTRACT SUPERTYPE;
  assigned_organization : organization;
  role                  : organization_role;
END_ENTITY;

ENTITY organization_relationship;
  name                  : label;
  description           : OPTIONAL text;
  relating_organization : organization;
  related_organization  : organization;
END_ENTITY;

ENTITY organization_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY organization_type;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organization_type_assignment
  ABSTRACT SUPERTYPE;
  id                         : identifier;
  name                       : label;
  description                : OPTIONAL text;
  assigned_organization_type : organization_type;
  role                       : organization_type_role;
END_ENTITY;

ENTITY organization_type_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organizational_address
  SUBTYPE OF (address);
  organizations : SET [1 : ?] OF organization;
  description   : OPTIONAL text;
END_ENTITY;

ENTITY organizational_project;
  name                      : label;
  description               : OPTIONAL text;
  responsible_organizations : SET [1 : ?] OF organization;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY organizational_project_assignment
  ABSTRACT SUPERTYPE;
  assigned_organizational_project : organizational_project;
  role                            : organizational_project_role;
END_ENTITY;

ENTITY organizational_project_relationship;
  name                            : label;
  description                     : OPTIONAL text;
  relating_organizational_project : organizational_project;
  related_organizational_project  : organizational_project;
END_ENTITY;

ENTITY organizational_project_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY package_product_concept_feature
  SUBTYPE OF (product_concept_feature);
WHERE
  WR1: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF(SELF));
  WR2: SIZEOF(QUERY(cfr
                    <* USEDIN(SELF,
                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONCEPT_FEATURE_RELATIONSHIP.RELATING_PRODUCT_CONCEPT_FEATURE')
                    | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN
                       TYPEOF(cfr)) AND
                      (SIZEOF(QUERY(ipcf
                                    <* USEDIN(cfr,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONDITIONAL_CONCEPT_FEATURE.CONDITION')
                                    | 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INCLUSION_PRODUCT_CONCEPT_FEATURE' IN
                                      TYPEOF(ipcf))) =
                       1))) >
       0;
END_ENTITY;

ENTITY parallel_composed_function
  SUBTYPE OF (maths_function, multiple_arity_generic_expression);
  source_of_domain : maths_space_or_function;
  prep_functions   : LIST [1 : ?] OF maths_function;
  final_function   : maths_function_select;
DERIVE
  SELF\multiple_arity_generic_expression.operands                                        : LIST [2 : ?] OF generic_expression := convert_to_operands_prcmfn(source_of_domain,
                                                                                                                                                            prep_functions,
                                                                                                                                                            final_function);
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
  WR3: parallel_composed_function_domain_check(domain_from(source_of_domain), prep_functions);
  WR4: parallel_composed_function_composability_check(prep_functions, final_function);
END_ENTITY;

ENTITY partial_derivative_expression
  SUBTYPE OF (unary_generic_expression);
  d_variables : LIST [1 : ?] OF maths_variable;
  extension   : extension_options;
DERIVE
  derivand : generic_expression := SELF\unary_generic_expression.operand;
WHERE
  WR1: has_values_space(derivand);
  WR2: space_is_continuum(values_space_of(derivand));
  WR3: SIZEOF(QUERY(vbl
                    <* d_variables
                    | (NOT subspace_of(values_space_of(vbl), the_reals)) AND
                      (NOT subspace_of(values_space_of(vbl), the_complex_numbers)))) =
       0;
END_ENTITY;

ENTITY partial_derivative_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  d_variables                           : LIST [1 : ?] OF input_selector;
  extension                             : extension_options;
DERIVE
  derivand : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: space_is_continuum(derivand.range);
  WR2: partial_derivative_check(derivand.domain, d_variables);
END_ENTITY;

ENTITY person;
  id            : identifier;
  last_name     : OPTIONAL label;
  first_name    : OPTIONAL label;
  middle_names  : OPTIONAL LIST [1 : ?] OF label;
  prefix_titles : OPTIONAL LIST [1 : ?] OF label;
  suffix_titles : OPTIONAL LIST [1 : ?] OF label;
WHERE
  WR1: EXISTS(last_name) OR EXISTS(first_name);
END_ENTITY;

ENTITY person_and_organization;
  the_person       : person;
  the_organization : organization;
DERIVE
  name        : label := get_name_value(SELF);
  description : text  := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY person_and_organization_address
  SUBTYPE OF (organizational_address, personal_address);
  SELF\organizational_address.organizations : SET [1 : 1] OF organization;
  SELF\personal_address.people              : SET [1 : 1] OF person;
WHERE
  WR1: SIZEOF(QUERY(pao
                    <* USEDIN(SELF\personal_address.people[1],
                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PERSON_AND_ORGANIZATION.THE_PERSON')
                    | pao.the_organization :=: SELF\organizational_address.organizations[1])) =
       1;
END_ENTITY;

ENTITY person_and_organization_assignment
  ABSTRACT SUPERTYPE;
  assigned_person_and_organization : person_and_organization;
  role                             : person_and_organization_role;
END_ENTITY;

ENTITY person_and_organization_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY person_name_component
  SUBTYPE OF (generic_attribute);
END_ENTITY;

ENTITY person_type;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY person_type_assignment
  ABSTRACT SUPERTYPE;
  id                   : identifier;
  name                 : label;
  description          : OPTIONAL text;
  assigned_person_type : person_type;
  role                 : person_type_role;
END_ENTITY;

ENTITY person_type_definition;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
  formation   : person_type_definition_formation;
END_ENTITY;

ENTITY person_type_definition_assignment
  ABSTRACT SUPERTYPE;
  id                              : identifier;
  name                            : label;
  description                     : OPTIONAL text;
  assigned_person_type_definition : person_type_definition;
  role                            : person_type_definition_role;
END_ENTITY;

ENTITY person_type_definition_formation;
  id             : identifier;
  name           : label;
  description    : OPTIONAL text;
  of_person_type : person_type;
END_ENTITY;

ENTITY person_type_definition_relationship;
  id                              : identifier;
  name                            : label;
  description                     : OPTIONAL text;
  relating_person_type_definition : person_type_definition;
  related_person_type_definition  : person_type_definition;
END_ENTITY;

ENTITY person_type_definition_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY person_type_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY personal_address
  SUBTYPE OF (address);
  people      : SET [1 : ?] OF person;
  description : OPTIONAL text;
END_ENTITY;

ENTITY physical_breakdown_context
  SUBTYPE OF (breakdown_context);
END_ENTITY;

ENTITY physical_element_usage
  SUBTYPE OF (breakdown_element_usage);
END_ENTITY;

ENTITY placed_feature
  SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY placement
  SUPERTYPE OF (ONEOF(axis1_placement, axis2_placement_2d, axis2_placement_3d))
  SUBTYPE OF (geometric_representation_item);
  location : cartesian_point;
END_ENTITY;

ENTITY plane_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY plane_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY plus_expression
  SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY point
  SUPERTYPE OF (ONEOF(cartesian_point))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY polar_complex_number_region
  SUBTYPE OF (maths_space, generic_literal);
  centre               : complex_number_literal;
  distance_constraint  : real_interval;
  direction_constraint : finite_real_interval;
WHERE
  WR1: min_exists(distance_constraint) AND (real_min(distance_constraint) >= 0.0);
  WR2: {-PI <= direction_constraint.min < PI};
  WR3: direction_constraint.max - direction_constraint.min <= 2.0 * PI;
  WR4: (direction_constraint.max - direction_constraint.min < 2.0 * PI) OR (direction_constraint.min_closure = open);
  WR5: (direction_constraint.max - direction_constraint.min < 2.0 * PI) OR (direction_constraint.max_closure = open) OR
       (direction_constraint.min = -PI);
  WR6: (real_min(distance_constraint) > 0.0) OR max_exists(distance_constraint) OR
       (direction_constraint.max - direction_constraint.min < 2.0 * PI) OR (direction_constraint.max_closure = open);
END_ENTITY;

ENTITY position_in_organization;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization_assignment
  ABSTRACT SUPERTYPE;
  id                                : identifier;
  name                              : label;
  description                       : OPTIONAL text;
  assigned_position_in_organization : position_in_organization;
  role                              : position_in_organization_role;
END_ENTITY;

ENTITY position_in_organization_relationship;
  id                                : identifier;
  name                              : label;
  description                       : OPTIONAL text;
  relating_position_in_organization : position_in_organization;
  related_position_in_organization  : position_in_organization;
END_ENTITY;

ENTITY position_in_organization_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization_type;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization_type_assignment
  ABSTRACT SUPERTYPE;
  id                                     : identifier;
  name                                   : label;
  description                            : OPTIONAL text;
  assigned_position_in_organization_type : position_in_organization_type;
  role                                   : position_in_organization_type_role;
END_ENTITY;

ENTITY position_in_organization_type_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY positive_length_measure_with_unit
  SUBTYPE OF (length_measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POSITIVE_LENGTH_MEASURE' IN
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY positive_plane_angle_measure_with_unit
  SUBTYPE OF (plane_angle_measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' IN
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY power_expression
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY power_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POWER_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY power_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.watt);
END_ENTITY;

ENTITY pre_defined_item;
  name : label;
END_ENTITY;

ENTITY precision_qualifier;
  precision_value : INTEGER;
END_ENTITY;

ENTITY pressure_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRESSURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY pressure_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.pascal);
END_ENTITY;

ENTITY probability_representation
  SUBTYPE OF (property_definition_representation);
  SELF\property_definition_representation.definition : event_probability;
END_ENTITY;

ENTITY process_or_process_relationship_effectivity
  SUBTYPE OF (effectivity);
  effective_process_or_process_relationship : process_or_process_relationship;
END_ENTITY;

ENTITY product;
  id                 : identifier;
  name               : label;
  description        : OPTIONAL text;
  frame_of_reference : SET [1 : ?] OF product_context;
END_ENTITY;

ENTITY product_as_planned
  SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY product_category;
  name        : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY product_class
  SUBTYPE OF (product_concept, characterized_object);
END_ENTITY;

ENTITY product_concept;
  id             : identifier;
  name           : label;
  description    : OPTIONAL text;
  market_context : product_concept_context;
UNIQUE
  UR1: id;
END_ENTITY;

ENTITY product_concept_context
  SUBTYPE OF (application_context_element);
  market_segment_type : label;
END_ENTITY;

ENTITY product_concept_feature;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY product_concept_feature_association;
  name        : label;
  description : OPTIONAL text;
  concept     : product_concept;
  feature     : product_concept_feature;
END_ENTITY;

ENTITY product_concept_feature_category
  SUBTYPE OF (group);
WHERE
  WR1: SIZEOF(QUERY(aga
                    <* USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GROUP_ASSIGNMENT.ASSIGNED_GROUP')
                    | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(aga)) AND
                      ((aga\group_assignment.role\object_role.name <> 'specification category member') OR
                       (SIZEOF(QUERY(i
                                     <* aga\applied_group_assignment.items
                                     | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CONCEPT_FEATURE' IN
                                        TYPEOF(i)) AND
                                       NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONDITIONAL_CONCEPT_FEATURE' IN
                                            TYPEOF(i)))) <>
                        SIZEOF(aga\applied_group_assignment.items))))) =
       0;
END_ENTITY;

ENTITY product_concept_feature_category_usage
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_concept_feature_category;
  items                                : SET [1 : ?] OF category_usage_item;
WHERE
  WR1: SELF.role.name IN ['mandatory category usage','optional category usage'];
END_ENTITY;

ENTITY product_concept_relationship;
  name                     : label;
  description              : OPTIONAL text;
  relating_product_concept : product_concept;
  related_product_concept  : product_concept;
END_ENTITY;

ENTITY product_context
  SUBTYPE OF (application_context_element);
  discipline_type : label;
END_ENTITY;

ENTITY product_definition;
  id                 : identifier;
  description        : OPTIONAL text;
  formation          : product_definition_formation;
  frame_of_reference : product_definition_context;
DERIVE
  name : label := get_name_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY product_definition_context
  SUBTYPE OF (application_context_element);
  life_cycle_stage : label;
END_ENTITY;

ENTITY product_definition_context_association;
  definition         : product_definition;
  frame_of_reference : product_definition_context;
  role               : product_definition_context_role;
END_ENTITY;

ENTITY product_definition_context_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY product_definition_effectivity
  SUBTYPE OF (effectivity);
  usage : product_definition_relationship;
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0;
END_ENTITY;

ENTITY product_definition_element_relationship
  SUBTYPE OF (group);
END_ENTITY;

ENTITY product_definition_formation;
  id          : identifier;
  description : OPTIONAL text;
  of_product  : product;
UNIQUE
  UR1: id, of_product;
END_ENTITY;

ENTITY product_definition_formation_relationship;
  id                                    : identifier;
  name                                  : label;
  description                           : OPTIONAL text;
  relating_product_definition_formation : product_definition_formation;
  related_product_definition_formation  : product_definition_formation;
END_ENTITY;

ENTITY product_definition_group_assignment
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_definition_element_relationship;
  items                                : SET [1 : 1] OF product_definition_or_product_definition_relationship;
END_ENTITY;

ENTITY product_definition_occurrence
  SUPERTYPE OF (product_definition_specified_occurrence ANDOR
                product_definition_occurrence_reference_with_local_representation);
  id          : identifier;
  name        : OPTIONAL label;
  description : OPTIONAL text;
  definition  : OPTIONAL product_definition_or_reference_or_occurrence;
  quantity    : OPTIONAL measure_with_unit;
DERIVE
  descendant_occurrences : SET [0 : ?] OF product_definition_specified_occurrence := get_descendant_occurrences(SELF);
INVERSE
  assembly_usages   : SET [0:?] OF assembly_component_usage FOR related_product_definition;
  child_occurrences : SET [0:?] OF product_definition_specified_occurrence FOR occurrence_usage;
WHERE
  WR1: NOT (('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_OCCURRENCE' IN TYPEOF(definition)) OR
            ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_OCCURRENCE_REFERENCE' IN
             TYPEOF(definition))) OR
           ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_SPECIFIED_OCCURRENCE' IN TYPEOF(SELF));
  WR2: EXISTS(definition) OR
       (SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONFIGURATION_DESIGN.DESIGN')) > 0);
  WR3: NOT ('NUMBER' IN TYPEOF(quantity\measure_with_unit.value_component)) OR
           (quantity\measure_with_unit.value_component > 0);
END_ENTITY;

ENTITY product_definition_occurrence_reference
  SUBTYPE OF (product_definition_reference);
  product_occurrence_id : identifier;
END_ENTITY;

ENTITY product_definition_occurrence_reference_with_local_representation
  SUBTYPE OF (product_definition_occurrence, generic_product_definition_reference);
END_ENTITY;

ENTITY product_definition_occurrence_relationship;
  name             : label;
  description      : OPTIONAL text;
  occurrence       : product_definition;
  occurrence_usage : assembly_component_usage;
WHERE
  WR1: occurrence_usage.relating_product_definition :<>: occurrence;
  WR2: occurrence_usage.related_product_definition :<>: occurrence;
  WR3: occurrence.formation :=: occurrence_usage.related_product_definition.formation;
END_ENTITY;

ENTITY product_definition_reference
  SUBTYPE OF (generic_product_definition_reference);
  product_id                      : identifier;
  product_definition_formation_id : identifier;
  product_definition_id           : identifier;
  id_owning_organization_name     : OPTIONAL label;
END_ENTITY;

ENTITY product_definition_reference_with_local_representation
  SUBTYPE OF (generic_product_definition_reference, product_definition);
END_ENTITY;

ENTITY product_definition_relationship
  SUPERTYPE OF (ONEOF(attachment_slot_on_product, breakdown_context, breakdown_element_usage, breakdown_of,
                      interface_definition_connection, interface_definition_for, product_in_attachment_slot));
  id                          : identifier;
  name                        : label;
  description                 : OPTIONAL text;
  relating_product_definition : product_definition_or_reference;
  related_product_definition  : product_definition_or_reference;
END_ENTITY;

ENTITY product_definition_shape
  SUBTYPE OF (property_definition);
UNIQUE
  UR1: SELF\property_definition.definition;
WHERE
  WR1: SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CHARACTERIZED_PRODUCT_DEFINITION',
               'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CHARACTERIZED_OBJECT'] *
              TYPEOF(SELF\property_definition.definition)) >
       0;
END_ENTITY;

ENTITY product_definition_specified_occurrence
  SUBTYPE OF (product_definition_occurrence);
  SELF\product_definition_occurrence.definition : product_definition_occurrence_or_reference;
  occurrence_usage                              : product_definition_occurrence_or_reference;
UNIQUE
  UR1: occurrence_usage, id;
WHERE
  WR1: SIZEOF(assembly_usages) = 0;
  WR2: acyclic_product_definition_specified_occurrence(SELF, SELF\product_definition_occurrence.definition);
END_ENTITY;

ENTITY product_definition_substitute;
  description           : OPTIONAL text;
  context_relationship  : product_definition_relationship;
  substitute_definition : product_definition;
DERIVE
  name : label := get_name_value(SELF);
WHERE
  WR1: context_relationship.related_product_definition :<>: substitute_definition;
  WR2: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY product_definition_usage
  SUPERTYPE OF (ONEOF(make_from_usage_option, assembly_component_usage))
  SUBTYPE OF (product_definition_relationship);
UNIQUE
  UR1: SELF\product_definition_relationship.id, SELF\product_definition_relationship.relating_product_definition,
       SELF\product_definition_relationship.related_product_definition;
WHERE
  WR1: acyclic_product_definition_relationship(SELF, [SELF\product_definition_relationship.related_product_definition],
                                               'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_USAGE');
END_ENTITY;

ENTITY product_definition_with_associated_documents
  SUBTYPE OF (product_definition);
  documentation_ids : SET [1 : ?] OF document;
END_ENTITY;

ENTITY product_design_to_individual
  SUBTYPE OF (product_relationship);
DERIVE
  product_design     : product := SELF\product_relationship.relating_product;
  individual_product : product := SELF\product_relationship.related_product;
END_ENTITY;

ENTITY product_design_version_to_individual
  SUBTYPE OF (product_definition_formation_relationship);
DERIVE
  product_design_version : product_definition_formation := SELF\product_definition_formation_relationship.relating_product_definition_formation;
  individual_product     : product_definition_formation := SELF\product_definition_formation_relationship.related_product_definition_formation;
END_ENTITY;

ENTITY product_group
  SUBTYPE OF (group);
END_ENTITY;

ENTITY product_group_attribute_assignment
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_group_attributes;
  attributes                           : SET [1 : 1] OF attribute_select;
END_ENTITY;

ENTITY product_group_attribute_set
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_group;
  product_group_attributes             : SET [1 : 1] OF product_group_attributes;
END_ENTITY;

ENTITY product_group_attributes
  SUBTYPE OF (group);
END_ENTITY;

ENTITY product_group_context
  SUBTYPE OF (descriptive_representation_item);
END_ENTITY;

ENTITY product_group_membership
  SUBTYPE OF (characterized_object, group_assignment);
  member : product_select;
END_ENTITY;

ENTITY product_group_membership_rules
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_group;
  product_group_rules                  : SET [1 : 1] OF product_group_rules;
END_ENTITY;

ENTITY product_group_purpose
  SUBTYPE OF (descriptive_representation_item);
END_ENTITY;

ENTITY product_group_relationship
  SUBTYPE OF (group_relationship);
END_ENTITY;

ENTITY product_group_rule
  SUBTYPE OF (descriptive_representation_item);
END_ENTITY;

ENTITY product_group_rule_assignment
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_group_rules;
  product_group_rules                  : SET [1 : ?] OF product_group_rule;
END_ENTITY;

ENTITY product_group_rules
  SUBTYPE OF (group);
END_ENTITY;

ENTITY product_identification
  SUBTYPE OF (configuration_item, characterized_object);
  SELF\configuration_item.item_concept : product_class;
WHERE
  WR1: SIZEOF(QUERY(cd
                    <* USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONFIGURATION_DESIGN.CONFIGURATION')
                    | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(cd.design)) AND
                      (SIZEOF(QUERY(prpc
                                    <* USEDIN(cd.design\product_definition_formation.of_product,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                                    | prpc.name IN ['part','raw material','tool'])) >
                       0))) <=
       1;
  WR2: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONFIGURABLE_ITEM' IN TYPEOF(SELF)) XOR
           ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_SPECIFICATION' IN TYPEOF(SELF));
END_ENTITY;

ENTITY product_in_attachment_slot
  SUBTYPE OF (product_definition_relationship);
END_ENTITY;

ENTITY product_planned_to_realized
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : product_as_planned;
DERIVE
  realized_product : product_definition_formation := SELF\product_definition_formation_relationship.related_product_definition_formation;
  planned_product  : product_as_planned           := SELF\product_definition_formation_relationship.relating_product_definition_formation;
END_ENTITY;

ENTITY product_related_product_category
  SUBTYPE OF (product_category);
  products : SET [1 : ?] OF product;
END_ENTITY;

ENTITY product_relationship;
  id               : identifier;
  name             : label;
  description      : OPTIONAL text;
  relating_product : product;
  related_product  : product;
END_ENTITY;

ENTITY product_specification
  SUBTYPE OF (product_identification, configurable_item);
END_ENTITY;

ENTITY promissory_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;

ENTITY property_definition;
  name        : label;
  description : OPTIONAL text;
  definition  : characterized_definition;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY property_definition_relationship;
  name                         : label;
  description                  : text;
  relating_property_definition : property_definition;
  related_property_definition  : property_definition;
END_ENTITY;

ENTITY property_definition_representation;
  definition          : represented_definition;
  used_representation : representation;
DERIVE
  description : text  := get_description_value(SELF);
  name        : label := get_name_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY qualification_type;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualification_type_assignment
  ABSTRACT SUPERTYPE;
  id                          : identifier;
  name                        : label;
  description                 : OPTIONAL text;
  assigned_qualification_type : qualification_type;
  role                        : qualification_type_role;
END_ENTITY;

ENTITY qualification_type_relationship;
  id                          : identifier;
  name                        : label;
  description                 : OPTIONAL text;
  relating_qualification_type : qualification_type;
  related_qualification_type  : qualification_type;
END_ENTITY;

ENTITY qualification_type_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualified_representation_item
  SUBTYPE OF (representation_item);
  qualifiers : SET [1 : ?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp
                    <* qualifiers
                    | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRECISION_QUALIFIER' IN TYPEOF(temp)) OR
                      ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MATHS_VALUE_PRECISION_QUALIFIER' IN TYPEOF(temp)))) <
       2;
END_ENTITY;

ENTITY qualitative_uncertainty
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : text;
END_ENTITY;

ENTITY quantified_assembly_component_usage
  SUBTYPE OF (assembly_component_usage);
  quantity : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component))) OR (quantity.value_component > 0);
END_ENTITY;

ENTITY quantifier_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (multiple_arity_generic_expression);
  variables : LIST [1 : ?] OF UNIQUE generic_variable;
WHERE
  WR1: SIZEOF(QUERY(vrbl <* variables | NOT (vrbl IN SELF\multiple_arity_generic_expression.operands))) = 0;
  WR2: SIZEOF(QUERY(vrbl
                    <* variables
                    | NOT ((schema_prefix + 'BOUND_VARIABLE_SEMANTICS') IN TYPEOF(vrbl.interpretation.semantics)))) =
       0;
END_ENTITY;

ENTITY radioactivity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RADIOACTIVITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY radioactivity_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.becquerel);
END_ENTITY;

ENTITY ratio_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RATIO_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY ratio_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY rationalize_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
DERIVE
  fun : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: (space_dimension(fun.domain) = 1) AND (space_dimension(fun.range) = 1);
  WR2: number_tuple_subspace_check(factor1(fun.range));
  WR3: space_dimension(factor1(fun.range)) > 1;
END_ENTITY;

ENTITY real_defined_function
  ABSTRACT SUPERTYPE
  SUBTYPE OF (numeric_defined_function);
END_ENTITY;

ENTITY real_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
END_ENTITY;

ENTITY real_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max         : REAL;
  max_closure : open_closed;
END_ENTITY;

ENTITY real_literal
  SUBTYPE OF (literal_number);
  SELF\literal_number.the_value : REAL;
END_ENTITY;

ENTITY real_numeric_variable
  SUBTYPE OF (numeric_variable);
END_ENTITY;

ENTITY real_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST [1 : ?] OF REAL;
END_ENTITY;

ENTITY regular_table_function
  SUBTYPE OF (linearized_table_function);
  increments : LIST [1 : ?] OF INTEGER;
WHERE
  WR1: SIZEOF(increments) = SIZEOF(SELF\explicit_table_function.shape);
  WR2: extremal_position_check(SELF);
END_ENTITY;

ENTITY reindexed_array_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  starting_indices                      : LIST [1 : ?] OF INTEGER;
WHERE
  WR1: function_is_array(SELF\unary_generic_expression.operand);
  WR2: SIZEOF(starting_indices) = SIZEOF(shape_of_array(SELF\unary_generic_expression.operand));
END_ENTITY;

ENTITY related_consequence
  SUBTYPE OF (product_definition_relationship);
  SELF\product_definition_relationship.relating_product_definition : risk_perception;
  SELF\product_definition_relationship.related_product_definition  : risk_consequence;
END_ENTITY;

ENTITY relationship_condition;
  name                     : label;
  applicable_relationships : SET [1 : ?] OF relationship_with_condition;
  condition_description    : text;
END_ENTITY;

ENTITY relative_event_occurrence
  SUBTYPE OF (event_occurrence);
  base_event : event_occurrence;
  offset     : time_measure_with_unit;
END_ENTITY;

ENTITY repackaging_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  input_repack                          : repackage_options;
  output_repack                         : repackage_options;
  selected_output                       : nonnegative_integer;
WHERE
  WR1: (input_repack <> ro_wrap_as_tuple) OR
       ((space_dimension(operand.domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(operand.domain))));
  WR2: (output_repack <> ro_unwrap_tuple) OR
       ((space_dimension(operand.range) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(operand.range))));
  WR3: selected_output <= space_dimension(repackage(operand.range, output_repack));
END_ENTITY;

ENTITY representation;
  name             : label;
  items            : SET [1 : ?] OF representation_item;
  context_of_items : representation_context;
DERIVE
  id          : identifier := get_id_value(SELF);
  description : text       := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY representation_context;
  context_identifier : identifier;
  context_type       : text;
INVERSE
  representations_in_context : SET [1:?] OF representation FOR context_of_items;
END_ENTITY;

ENTITY representation_context_reference;
  context_identifier : identifier;
INVERSE
  representations_in_context : SET [1:?] OF representation_reference FOR context_of_items;
END_ENTITY;

ENTITY representation_item
  SUPERTYPE OF (ONEOF(compound_representation_item, mapped_item, value_representation_item));
  name : label;
WHERE
  WR1: SIZEOF(using_representations(SELF)) > 0;
END_ENTITY;

ENTITY representation_item_relationship;
  name                         : label;
  description                  : OPTIONAL text;
  relating_representation_item : representation_item;
  related_representation_item  : representation_item;
END_ENTITY;

ENTITY representation_map;
  mapping_origin        : representation_item;
  mapped_representation : representation;
INVERSE
  map_usage : SET [1:?] OF mapped_item FOR mapping_source;
WHERE
  WR1: item_in_context(mapping_origin, mapped_representation\representation.context_of_items);
END_ENTITY;

ENTITY representation_proxy_item
  SUBTYPE OF (representation_item);
  item : representation_proxy_select;
END_ENTITY;

ENTITY representation_reference;
  id               : identifier;
  context_of_items : representation_context_reference;
END_ENTITY;

ENTITY representation_relationship;
  name        : label;
  description : OPTIONAL text;
  rep_1       : representation_or_representation_reference;
  rep_2       : representation_or_representation_reference;
END_ENTITY;

ENTITY representation_relationship_with_transformation
  SUBTYPE OF (representation_relationship);
  transformation_operator : transformation;
WHERE
  WR1: SELF\representation_relationship.rep_1.context_of_items :<>:
       SELF\representation_relationship.rep_2.context_of_items;
  WR2: NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ITEM_DEFINED_TRANSFORMATION' IN
            TYPEOF(transformation_operator)) OR
           (SELF\representation_relationship.rep_1 IN
            using_representations(transformation_operator\item_defined_transformation.transform_item_1)) AND
           (SELF\representation_relationship.rep_2 IN
            using_representations(transformation_operator\item_defined_transformation.transform_item_2));
END_ENTITY;

ENTITY requirement_assigned_object
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_assignment;
  items                                : SET [1 : 1] OF requirement_assigned_item;
END_ENTITY;

ENTITY requirement_assignment
  SUBTYPE OF (characterized_object, group);
END_ENTITY;

ENTITY requirement_for_action_resource
  SUBTYPE OF (action_resource_requirement);
  resources : SET [1 : ?] OF action_resource;
END_ENTITY;

ENTITY requirement_source
  SUBTYPE OF (group);
END_ENTITY;

ENTITY requirement_view_definition_relationship
  SUBTYPE OF (product_definition_relationship);
END_ENTITY;

ENTITY resistance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RESISTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY resistance_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.ohm);
END_ENTITY;

ENTITY resource_property;
  name        : label;
  description : text;
  resource    : characterized_resource_definition;
END_ENTITY;

ENTITY resource_property_representation;
  name           : label;
  description    : text;
  property       : resource_property;
  representation : representation;
END_ENTITY;

ENTITY resource_requirement_type;
  name        : label;
  description : text;
END_ENTITY;

ENTITY restriction_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_space;
END_ENTITY;

ENTITY retention
  SUBTYPE OF (action);
WHERE
  WR1: SIZEOF(QUERY(aa
                    <* USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_ASSIGNMENT.ASSIGNED_ACTION')
                    | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_ACTION_ASSIGNMENT' IN TYPEOF(aa)) AND
                      (aa.role.name = 'retention'))) >=
       1;
  WR2: (SIZEOF(QUERY(atia
                     <* USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_TIME_INTERVAL_ASSIGNMENT.ITEMS')
                     | (atia.role.name = 'minimum retention period'))) =
        1) AND
       (SIZEOF(QUERY(atia
                     <* USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_TIME_INTERVAL_ASSIGNMENT.ITEMS')
                     | (atia.role.name = 'maximum retention period'))) =
        1) AND
       (SIZEOF(QUERY(atia1
                     <* USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_TIME_INTERVAL_ASSIGNMENT.ITEMS')
                     | (atia1.role.name = 'minimum retention period') AND
                       ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.TIME_INTERVAL_WITH_BOUNDS' IN
                        TYPEOF(atia1.assigned_time_interval)) AND
                       (EXISTS(atia1.assigned_time_interval\time_interval_with_bounds.secondary_bound) OR
                        EXISTS(atia1.assigned_time_interval\time_interval_with_bounds.duration)) AND
                       (SIZEOF(QUERY(atia2
                                     <* USEDIN(SELF,
                                               'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_TIME_INTERVAL_ASSIGNMENT.ITEMS')
                                     | (atia2.role.name = 'maximum retention period') AND
                                       ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.TIME_INTERVAL_WITH_BOUNDS' IN
                                        TYPEOF(atia2.assigned_time_interval)) AND
                                       (EXISTS(atia2.assigned_time_interval\time_interval_with_bounds.secondary_bound) OR
                                        EXISTS(atia2.assigned_time_interval\time_interval_with_bounds.duration)) AND
                                       (atia1.assigned_time_interval\time_interval_with_bounds.primary_bound :=:
                                        atia2.assigned_time_interval\time_interval_with_bounds.primary_bound))) =
                        1))) =
        1);
  WR3: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_RELATIONSHIP.RELATING_ACTION')) +
       SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_RELATIONSHIP.RELATED_ACTION')) =
       0;
END_ENTITY;

ENTITY right_to_usage_association
  SUBTYPE OF (action_method_relationship);
  SELF\action_method_relationship.relating_method : information_usage_right;
  SELF\action_method_relationship.related_method  : information_right;
DERIVE
  right_applied : information_right       := SELF\action_method_relationship.related_method;
  right_usage   : information_usage_right := SELF\action_method_relationship.relating_method;
END_ENTITY;

ENTITY risk
  SUBTYPE OF (product);
END_ENTITY;

ENTITY risk_acceptance
  SUBTYPE OF (action);
END_ENTITY;

ENTITY risk_activity_structure
  SUBTYPE OF (action_relationship);
  SELF\action_relationship.relating_action : risk_action;
  SELF\action_relationship.related_action  : risk_action;
DERIVE
  child  : risk_action := SELF\action_relationship.related_action;
  parent : risk_action := SELF\action_relationship.relating_action;
END_ENTITY;

ENTITY risk_analysis
  SUBTYPE OF (action);
END_ENTITY;

ENTITY risk_assessment
  SUBTYPE OF (action);
END_ENTITY;

ENTITY risk_attitude
  SUBTYPE OF (property_definition_representation);
  SELF\property_definition_representation.definition : risk_level;
DERIVE
  criticality_factor : representation := SELF\property_definition_representation.used_representation;
END_ENTITY;

ENTITY risk_communication
  SUBTYPE OF (action);
END_ENTITY;

ENTITY risk_consequence
  SUBTYPE OF (product_definition);
  SELF\product_definition.formation : risk_perception_formation;
END_ENTITY;

ENTITY risk_control
  SUBTYPE OF (action);
END_ENTITY;

ENTITY risk_estimation
  SUBTYPE OF (action);
END_ENTITY;

ENTITY risk_evaluation
  SUBTYPE OF (action);
END_ENTITY;

ENTITY risk_event
  SUBTYPE OF (applied_action_method_assignment);
  SELF\applied_action_method_assignment.items : SET [1 : 1] OF risk_perception;
WHERE
  WR1: SELF\action_method_assignment.role.name = 'risk of event';
END_ENTITY;

ENTITY risk_identification
  SUBTYPE OF (action);
END_ENTITY;

ENTITY risk_impact_assignment;
  assigned_risk_consequence : risk_consequence;
  items                     : SET [1 : ?] OF risk_impact_item;
END_ENTITY;

ENTITY risk_level
  SUBTYPE OF (property_definition);
  SELF\property_definition.definition : risk_perception_characterized_object;
END_ENTITY;

ENTITY risk_measure
  SUBTYPE OF (action_method);
END_ENTITY;

ENTITY risk_perception
  SUBTYPE OF (product_definition);
  SELF\product_definition.formation          : risk_perception_formation;
  SELF\product_definition.frame_of_reference : risk_perception_context;
DERIVE
  risk_perception_context : risk_perception_context := SELF\product_definition.frame_of_reference;
END_ENTITY;

ENTITY risk_perception_characterized_object
  SUBTYPE OF (characterized_object, risk_perception);
END_ENTITY;

ENTITY risk_perception_context
  SUBTYPE OF (product_definition_context);
END_ENTITY;

ENTITY risk_perception_formation
  SUBTYPE OF (product_definition_formation);
  SELF\product_definition_formation.of_product : risk;
DERIVE
  of_risk : risk := SELF\product_definition_formation.of_product;
END_ENTITY;

ENTITY risk_perception_relationship
  SUBTYPE OF (product_definition_relationship);
  SELF\product_definition_relationship.relating_product_definition : risk_perception;
  SELF\product_definition_relationship.related_product_definition  : risk_perception;
END_ENTITY;

ENTITY risk_perception_source_assignment;
  assigned_risk : risk_perception;
  items         : SET [1 : ?] OF risk_perception_source_item;
END_ENTITY;

ENTITY risk_relationship
  SUBTYPE OF (product_relationship);
  SELF\product_relationship.relating_product : risk;
  SELF\product_relationship.related_product  : risk;
DERIVE
  related_risk  : risk := SELF\product_relationship.related_product;
  relating_risk : risk := SELF\product_relationship.relating_product;
END_ENTITY;

ENTITY risk_treatment
  SUBTYPE OF (action);
  SELF\action.chosen_method : risk_measure;
END_ENTITY;

ENTITY rm_characterizable_address
  SUBTYPE OF (address, characterized_object);
END_ENTITY;

ENTITY rm_characterizable_applied_action_assignment
  SUBTYPE OF (applied_action_assignment, characterized_object);
END_ENTITY;

ENTITY rm_characterizable_applied_action_method_assignment
  SUBTYPE OF (applied_action_method_assignment, characterized_object);
END_ENTITY;

ENTITY rm_characterizable_applied_document_reference
  SUBTYPE OF (applied_document_reference, characterized_object);
END_ENTITY;

ENTITY rm_characterizable_applied_document_usage_constraint_assignment
  SUBTYPE OF (applied_document_usage_constraint_assignment, characterized_object);
END_ENTITY;

ENTITY rm_characterizable_applied_organization_assignment
  SUBTYPE OF (applied_organization_assignment, characterized_object);
END_ENTITY;

ENTITY rm_characterizable_applied_person_and_organization_assignment
  SUBTYPE OF (applied_person_and_organization_assignment, characterized_object);
END_ENTITY;

ENTITY rm_characterizable_person
  SUBTYPE OF (characterized_object, person);
END_ENTITY;

ENTITY rm_characterizable_person_and_organization
  SUBTYPE OF (characterized_object, person_and_organization);
END_ENTITY;

ENTITY rm_characterizable_risk_impact_assignment
  SUBTYPE OF (characterized_object, risk_impact_assignment);
END_ENTITY;

ENTITY rm_characterizable_state_observed
  SUBTYPE OF (characterized_object, state_observed);
END_ENTITY;

ENTITY rm_characterizable_state_observed_assignment
  SUBTYPE OF (characterized_object, state_observed_assignment);
END_ENTITY;

ENTITY rm_characterizable_state_observed_relationship
  SUBTYPE OF (characterized_object, state_observed_relationship);
END_ENTITY;

ENTITY rm_characterizable_state_type
  SUBTYPE OF (characterized_object, state_type);
END_ENTITY;

ENTITY rm_characterizable_state_type_assignment
  SUBTYPE OF (characterized_object, state_type_assignment);
END_ENTITY;

ENTITY rm_characterizable_state_type_relationship
  SUBTYPE OF (characterized_object, state_type_relationship);
END_ENTITY;

ENTITY role_association;
  role           : object_role;
  item_with_role : role_select;
END_ENTITY;

ENTITY satisfied_requirement
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : satisfies_requirement;
  items                                : SET [1 : 1] OF product_definition;
END_ENTITY;

ENTITY satisfies_requirement
  SUBTYPE OF (group);
END_ENTITY;

ENTITY satisfying_item
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : satisfies_requirement;
  items                                : SET [1 : 1] OF requirement_satisfaction_item;
END_ENTITY;

ENTITY security_classification;
  name           : label;
  purpose        : text;
  security_level : security_classification_level;
END_ENTITY;

ENTITY security_classification_assignment
  ABSTRACT SUPERTYPE;
  assigned_security_classification : security_classification;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY security_classification_level;
  name : label;
END_ENTITY;

ENTITY selected_item
  SUBTYPE OF (class);
END_ENTITY;

ENTITY selected_item_assignment
  SUBTYPE OF (applied_classification_assignment);
  SELF\classification_assignment.assigned_class : selected_item;
  SELF\applied_classification_assignment.items  : SET [1 : 1] OF selected_item_select;
DERIVE
  item : SET [1 : 1] OF selected_item_select := SELF\applied_classification_assignment.items;
END_ENTITY;

ENTITY selected_items_assignment_in_context_group
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : selected_items_context_group;
  selected_item_assignment             : SET [1 : 1] OF selected_item_assignment;
END_ENTITY;

ENTITY selected_items_context_group
  SUBTYPE OF (group);
END_ENTITY;

ENTITY selected_items_context_group_to_context
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : selected_items_context_group;
  item_context                         : SET [1 : ?] OF selected_item_context_items;
END_ENTITY;

ENTITY selector_function
  SUBTYPE OF (maths_function, generic_literal);
  selector         : input_selector;
  source_of_domain : maths_space_or_function;
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
END_ENTITY;

ENTITY sequential_method
  SUBTYPE OF (serial_action_method);
  sequence_position : count_measure;
END_ENTITY;

ENTITY serial_action_method
  SUBTYPE OF (action_method_relationship);
END_ENTITY;

ENTITY serial_numbered_effectivity
  SUBTYPE OF (effectivity);
  effectivity_start_id : identifier;
  effectivity_end_id   : OPTIONAL identifier;
END_ENTITY;

ENTITY series_composed_function
  SUBTYPE OF (maths_function, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [2 : ?] OF maths_function;
WHERE
  WR1: composable_sequence(SELF\multiple_arity_generic_expression.operands);
END_ENTITY;

ENTITY shape_aspect
  SUPERTYPE OF (ONEOF(shape_aspect_occurrence) ANDOR constituent_shape_aspect);
  name                 : label;
  description          : OPTIONAL text;
  of_shape             : product_definition_shape;
  product_definitional : LOGICAL;
DERIVE
  id : identifier := get_id_value(SELF);
UNIQUE
  UR1: id, of_shape;
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY shape_aspect_occurrence
  SUBTYPE OF (shape_aspect);
  definition : shape_aspect_or_characterized_object;
WHERE
  WR1: acyclic_shape_aspect_occurrence(SELF, definition);
END_ENTITY;

ENTITY shape_aspect_relationship;
  name                  : label;
  description           : OPTIONAL text;
  relating_shape_aspect : shape_aspect;
  related_shape_aspect  : shape_aspect;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY shape_defining_relationship
  SUBTYPE OF (shape_aspect_relationship);
END_ENTITY;

ENTITY shape_definition_representation
  SUBTYPE OF (property_definition_representation);
  SELF\property_definition_representation.definition          : property_definition;
  SELF\property_definition_representation.used_representation : shape_representation;
WHERE
  WR1: ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(definition)) OR
       ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_DEFINITION' IN
        TYPEOF(definition\property_definition.definition));
END_ENTITY;

ENTITY shape_feature_definition
  SUBTYPE OF (feature_definition);
END_ENTITY;

ENTITY shape_feature_definition_element_relationship
  SUBTYPE OF (shape_aspect_relationship, characterized_object);
DERIVE
  SELF\characterized_object.name                                  : label := SELF\shape_aspect_relationship.name;
  SELF\characterized_object.description                           : text  := SELF\shape_aspect_relationship.description;
END_ENTITY;

ENTITY shape_feature_definition_relationship
  SUBTYPE OF (characterized_object_relationship, characterized_object);
  SELF\characterized_object_relationship.relating_object : shape_feature_definition;
  SELF\characterized_object_relationship.related_object  : shape_feature_definition;
DERIVE
  SELF\characterized_object.name                                  : label := SELF\characterized_object_relationship.name;
  SELF\characterized_object.description                           : text  := SELF\characterized_object_relationship.description;
END_ENTITY;

ENTITY shape_representation
  SUBTYPE OF (representation);
END_ENTITY;

ENTITY shape_representation_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_REPRESENTATION',
               'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_REPRESENTATION_REFERENCE'] *
              (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2))) >=
       1;
END_ENTITY;

ENTITY si_absorbed_dose_unit
  SUBTYPE OF (absorbed_dose_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.gray;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_capacitance_unit
  SUBTYPE OF (capacitance_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.farad;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_conductance_unit
  SUBTYPE OF (conductance_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.siemens;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_dose_equivalent_unit
  SUBTYPE OF (dose_equivalent_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.sievert;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_electric_charge_unit
  SUBTYPE OF (electric_charge_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.coulomb;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_electric_potential_unit
  SUBTYPE OF (electric_potential_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.volt;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_energy_unit
  SUBTYPE OF (energy_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.joule;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_force_unit
  SUBTYPE OF (force_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.newton;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_frequency_unit
  SUBTYPE OF (frequency_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.hertz;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_illuminance_unit
  SUBTYPE OF (illuminance_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.lux;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_inductance_unit
  SUBTYPE OF (inductance_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.henry;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_magnetic_flux_density_unit
  SUBTYPE OF (magnetic_flux_density_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.tesla;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_magnetic_flux_unit
  SUBTYPE OF (magnetic_flux_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.weber;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_power_unit
  SUBTYPE OF (power_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.watt;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_pressure_unit
  SUBTYPE OF (pressure_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.pascal;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_radioactivity_unit
  SUBTYPE OF (radioactivity_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.becquerel;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_resistance_unit
  SUBTYPE OF (resistance_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.ohm;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_unit
  SUBTYPE OF (named_unit);
  prefix : OPTIONAL si_prefix;
  name   : si_unit_name;
DERIVE
  SELF\named_unit.dimensions                 : dimensional_exponents := dimensions_for_si_unit(name);
WHERE
  WR1: NOT (('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MASS_UNIT' IN TYPEOF(SELF)) AND
            (SIZEOF(USEDIN(SELF, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DERIVED_UNIT_ELEMENT.UNIT')) > 0)) OR
           (prefix = si_prefix.kilo);
END_ENTITY;

ENTITY simple_boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(boolean_literal, boolean_variable))
  SUBTYPE OF (boolean_expression, simple_generic_expression);
END_ENTITY;

ENTITY simple_generic_expression
  ABSTRACT SUPERTYPE OF (ONEOF(generic_literal, generic_variable))
  SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY simple_numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(literal_number, numeric_variable))
  SUBTYPE OF (numeric_expression, simple_generic_expression);
END_ENTITY;

ENTITY simple_string_expression
  ABSTRACT SUPERTYPE OF (ONEOF(string_literal, string_variable))
  SUBTYPE OF (string_expression, simple_generic_expression);
END_ENTITY;

ENTITY simultaneous_task_element
  SUBTYPE OF (concurrent_task_element);
END_ENTITY;

ENTITY sin_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY single_property_is_definition
  SUBTYPE OF (property_definition);
  SELF\property_definition.definition : product_definition;
UNIQUE
  UR1: definition;
END_ENTITY;

ENTITY slash_expression
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY solid_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY solid_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY source_for_requirement
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_source;
  items                                : SET [1 : 1] OF requirement_source_item;
END_ENTITY;

ENTITY sourced_requirement
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_source;
  items                                : SET [1 : 1] OF product_definition;
END_ENTITY;

ENTITY specified_higher_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
  upper_usage : assembly_component_usage;
  next_usage  : next_assembly_usage_occurrence;
UNIQUE
  UR1: upper_usage, next_usage;
WHERE
  WR1: SELF :<>: upper_usage;
  WR2: SELF\product_definition_relationship.relating_product_definition :=: upper_usage.relating_product_definition;
  WR3: SELF\product_definition_relationship.related_product_definition :=: next_usage.related_product_definition;
  WR4: (upper_usage.related_product_definition :=: next_usage.relating_product_definition) OR
       (SIZEOF(QUERY(pdr
                     <* USEDIN(upper_usage.related_product_definition,
                               'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                     | pdr.relating_product_definition :=: next_usage.relating_product_definition)) =
        1);
  WR5: SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
               'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SPECIFIED_HIGHER_USAGE_OCCURRENCE'] *
              TYPEOF(upper_usage)) =
       1;
END_ENTITY;

ENTITY sql_mappable_defined_function
  ABSTRACT SUPERTYPE
  SUBTYPE OF (defined_function);
END_ENTITY;

ENTITY square_root_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY standard_table_function
  SUBTYPE OF (linearized_table_function);
  order : ordering_type;
WHERE
  WR1: extremal_position_check(SELF);
END_ENTITY;

ENTITY standard_uncertainty
  SUPERTYPE OF (expanded_uncertainty)
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : REAL;
END_ENTITY;

ENTITY start_task
  SUBTYPE OF (task_element);
END_ENTITY;

ENTITY state_definition_to_state_assignment_relationship
  SUBTYPE OF (ascribable_state_relationship);
  relation_type : STRING;
WHERE
  WR1: acyclic_state_definition_to_state_assignment_relationship(SELF,
                                                                 [SELF\ascribable_state_relationship.related_ascribable_state],
                                                                 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STATE_DEFINITION_TO_STATE_ASSIGNMENT_RELATIONSHIP');
END_ENTITY;

ENTITY state_observed;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY state_observed_assignment
  ABSTRACT SUPERTYPE;
  assigned_state_observed : state_observed;
  role                    : state_observed_role;
END_ENTITY;

ENTITY state_observed_relationship;
  name                    : label;
  description             : OPTIONAL text;
  relating_state_observed : SET [1 : ?] OF state_observed;
  related_state_observed  : SET [1 : ?] OF state_observed;
END_ENTITY;

ENTITY state_observed_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY state_predicted
  SUBTYPE OF (state_observed);
END_ENTITY;

ENTITY state_type;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY state_type_assignment
  ABSTRACT SUPERTYPE;
  assigned_state_type : state_type;
  role                : state_type_role;
END_ENTITY;

ENTITY state_type_relationship;
  name                : label;
  description         : OPTIONAL text;
  relating_state_type : SET [1 : ?] OF state_type;
  related_state_type  : SET [1 : ?] OF state_type;
END_ENTITY;

ENTITY state_type_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY statechar_applied_object
  SUBTYPE OF (characterized_object, state_observed_assignment);
END_ENTITY;

ENTITY statechar_object
  SUBTYPE OF (characterized_object, state_observed);
END_ENTITY;

ENTITY statechar_relationship_object
  SUBTYPE OF (characterized_object, state_observed_relationship);
END_ENTITY;

ENTITY statechar_type_applied_object
  SUBTYPE OF (characterized_object, state_type_assignment);
END_ENTITY;

ENTITY statechar_type_object
  SUBTYPE OF (characterized_object, state_type);
END_ENTITY;

ENTITY statechar_type_relationship_object
  SUBTYPE OF (characterized_object, state_type_relationship);
END_ENTITY;

ENTITY strict_triangular_matrix
  SUBTYPE OF (triangular_matrix);
  main_diagonal_value : maths_value;
END_ENTITY;

ENTITY string_defined_function
  ABSTRACT SUPERTYPE
  SUBTYPE OF (defined_function, string_expression);
END_ENTITY;

ENTITY string_expression
  ABSTRACT SUPERTYPE OF (ONEOF(simple_string_expression, index_expression, substring_expression, concat_expression,
                               format_function, string_defined_function))
  SUBTYPE OF (expression);
END_ENTITY;

ENTITY string_literal
  SUBTYPE OF (simple_string_expression, generic_literal);
  the_value : STRING;
END_ENTITY;

ENTITY string_variable
  SUBTYPE OF (simple_string_expression, variable);
END_ENTITY;

ENTITY structured_message
  SUBTYPE OF (product);
END_ENTITY;

ENTITY substring_expression
  SUBTYPE OF (string_expression, multiple_arity_generic_expression);
DERIVE
  operand : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
  index1  : generic_expression := SELF\multiple_arity_generic_expression.operands[2];
  index2  : generic_expression := SELF\multiple_arity_generic_expression.operands[3];
WHERE
  WR1: ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STRING_EXPRESSION' IN TYPEOF(operand)) AND
       ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(index1)) AND
       ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(index2));
  WR2: SIZEOF(SELF\multiple_arity_generic_expression.operands) = 3;
  WR3: is_int_expr(index1);
  WR4: is_int_expr(index2);
END_ENTITY;

ENTITY surface
  SUBTYPE OF (geometric_representation_item);
  -- IP1:
  -- IP2:
END_ENTITY;

ENTITY symmetric_banded_matrix
  SUBTYPE OF (symmetric_matrix);
  default_entry : maths_value;
  above         : nonnegative_integer;
WHERE
  WR1: member_of(default_entry, factor1(SELF\linearized_table_function.source.range));
END_ENTITY;

ENTITY symmetric_matrix
  SUBTYPE OF (linearized_table_function);
  symmetry : symmetry_type;
  triangle : lower_upper;
  order    : ordering_type;
WHERE
  WR1: SIZEOF(SELF\explicit_table_function.shape) = 2;
  WR2: SELF\explicit_table_function.shape[1] = SELF\explicit_table_function.shape[2];
  WR3: NOT (symmetry = symmetry_type.skew) OR
           ((space_dimension(SELF\linearized_table_function.source.range) = 1) AND
            subspace_of_es(factor1(SELF\linearized_table_function.source.range), es_numbers));
  WR4: NOT ((symmetry = symmetry_type.hermitian) OR (symmetry = symmetry_type.skew_hermitian)) OR
           ((space_dimension(SELF\linearized_table_function.source.range) = 1) AND
            subspace_of_es(factor1(SELF\linearized_table_function.source.range), es_complex_numbers));
END_ENTITY;

ENTITY system_breakdown_context
  SUBTYPE OF (breakdown_context);
END_ENTITY;

ENTITY system_element_usage
  SUBTYPE OF (breakdown_element_usage);
END_ENTITY;

ENTITY tan_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY task_element
  SUPERTYPE OF (ONEOF(concurrent_task_element, end_task, exit_loop, looping_element, task_element_sequence, task_step))
  SUBTYPE OF (action_method);
END_ENTITY;

ENTITY task_element_relationship
  SUBTYPE OF (action_method_relationship);
END_ENTITY;

ENTITY task_element_sequence
  SUBTYPE OF (task_element);
END_ENTITY;

ENTITY task_invocation
  SUBTYPE OF (task_element);
END_ENTITY;

ENTITY task_method
  SUBTYPE OF (action_method);
END_ENTITY;

ENTITY task_method_relationship
  SUBTYPE OF (action_method_relationship);
END_ENTITY;

ENTITY task_method_version
  SUBTYPE OF (action_method);
END_ENTITY;

ENTITY task_method_version_relationship
  SUBTYPE OF (action_method_relationship);
END_ENTITY;

ENTITY task_objective
  SUBTYPE OF (action_method);
END_ENTITY;

ENTITY task_step
  SUBTYPE OF (task_element);
END_ENTITY;

ENTITY thermodynamic_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY thermodynamic_temperature_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY time_interval;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_assignment
  ABSTRACT SUPERTYPE;
  assigned_time_interval : time_interval;
  role                   : time_interval_role;
END_ENTITY;

ENTITY time_interval_based_effectivity
  SUBTYPE OF (effectivity);
  effectivity_period : time_interval;
END_ENTITY;

ENTITY time_interval_relationship;
  name                   : label;
  description            : OPTIONAL text;
  relating_time_interval : time_interval;
  related_time_interval  : time_interval;
END_ENTITY;

ENTITY time_interval_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_with_bounds
  SUBTYPE OF (time_interval);
  primary_bound   : OPTIONAL date_time_or_event_occurrence;
  secondary_bound : OPTIONAL date_time_or_event_occurrence;
  duration        : OPTIONAL time_measure_with_unit;
WHERE
  WR1: EXISTS(primary_bound) OR EXISTS(secondary_bound);
  WR2: NOT (EXISTS(primary_bound) AND EXISTS(secondary_bound) AND EXISTS(duration));
  WR3: EXISTS(primary_bound) AND
       NOT EXISTS(secondary_bound) AND (NOT EXISTS(duration) OR duration_is_positive(duration));
  WR4: EXISTS(secondary_bound) AND NOT EXISTS(primary_bound) AND EXISTS(duration) AND duration_is_negative(duration);
END_ENTITY;

ENTITY time_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.TIME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY time_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 1.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY triangular_matrix
  SUBTYPE OF (linearized_table_function);
  default_entry : maths_value;
  lo_up         : lower_upper;
  order         : ordering_type;
WHERE
  WR1: SIZEOF(SELF\explicit_table_function.shape) = 2;
  WR2: member_of(default_entry, SELF\maths_function.range);
END_ENTITY;

ENTITY type_qualifier;
  name : label;
END_ENTITY;

ENTITY unary_boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(not_expression, odd_function))
  SUBTYPE OF (boolean_expression, unary_generic_expression);
END_ENTITY;

ENTITY unary_function_call
  ABSTRACT SUPERTYPE OF (ONEOF(abs_function, minus_function, sin_function, cos_function, tan_function, asin_function,
                               acos_function, exp_function, log_function, log2_function, log10_function,
                               square_root_function))
  SUBTYPE OF (unary_numeric_expression);
END_ENTITY;

ENTITY unary_generic_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (generic_expression);
  operand : generic_expression;
END_ENTITY;

ENTITY unary_numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(unary_function_call))
  SUBTYPE OF (numeric_expression, unary_generic_expression);
  SELF\unary_generic_expression.operand : numeric_expression;
END_ENTITY;

ENTITY uncertainty_assigned_representation
  SUBTYPE OF (representation);
  uncertainty : SET [1 : ?] OF uncertainty_measure_with_unit;
END_ENTITY;

ENTITY uncertainty_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  name        : label;
  description : OPTIONAL text;
WHERE
  WR1: valid_measure_value(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY uncertainty_qualifier
  SUPERTYPE OF (ONEOF(standard_uncertainty, qualitative_uncertainty));
  measure_name : label;
  description  : text;
END_ENTITY;

ENTITY uniform_product_space
  SUBTYPE OF (maths_space, generic_literal);
  base     : maths_space;
  exponent : positive_integer;
WHERE
  WR1: expression_is_constant(base);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: base <> the_empty_space;
END_ENTITY;

ENTITY usage_association
  SUBTYPE OF (action_method_relationship);
  SELF\action_method_relationship.relating_method : information_usage_right;
  SELF\action_method_relationship.related_method  : information_usage_right;
DERIVE
  related  : information_usage_right := SELF\action_method_relationship.related_method;
  relating : information_usage_right := SELF\action_method_relationship.relating_method;
END_ENTITY;

ENTITY validation
  SUBTYPE OF (group);
END_ENTITY;

ENTITY value_format_type_qualifier;
  format_type : value_format_type;
END_ENTITY;

ENTITY value_function
  SUPERTYPE OF (int_value_function)
  SUBTYPE OF (numeric_expression, unary_generic_expression);
  SELF\unary_generic_expression.operand : string_expression;
END_ENTITY;

ENTITY value_range
  SUBTYPE OF (compound_representation_item);
WHERE
  WR1: ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SET_REPRESENTATION_ITEM' IN TYPEOF(item_element)) AND
       value_range_wr1(item_element);
  WR2: value_range_wr2(item_element);
  WR3: value_range_wr3(item_element);
END_ENTITY;

ENTITY value_representation_item
  SUBTYPE OF (representation_item);
  value_component : measure_value;
WHERE
  WR1: SIZEOF(QUERY(rep
                    <* using_representations(SELF)
                    | NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN
                           TYPEOF(rep.context_of_items)))) =
       0;
END_ENTITY;

ENTITY variable
  ABSTRACT SUPERTYPE OF (ONEOF(numeric_variable, boolean_variable, string_variable))
  SUBTYPE OF (generic_variable);
END_ENTITY;

ENTITY variable_semantics
  ABSTRACT SUPERTYPE;
END_ENTITY;

ENTITY vector
  SUBTYPE OF (geometric_representation_item);
  orientation : direction;
  magnitude   : length_measure;
WHERE
  WR1: magnitude >= 0.0;
END_ENTITY;

ENTITY velocity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VELOCITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY velocity_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensional_exponents(1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0);
END_ENTITY;

ENTITY verification
  SUBTYPE OF (group);
END_ENTITY;

ENTITY verification_relationship
  SUBTYPE OF (group_relationship);
  SELF\group_relationship.relating_group : verification;
  SELF\group_relationship.related_group  : verification;
END_ENTITY;

ENTITY versioned_action_request;
  id          : identifier;
  version     : OPTIONAL label;
  purpose     : text;
  description : OPTIONAL text;
END_ENTITY;

ENTITY versioned_action_request_relationship;
  id                                : identifier;
  name                              : label;
  description                       : OPTIONAL text;
  relating_versioned_action_request : versioned_action_request;
  related_versioned_action_request  : versioned_action_request;
END_ENTITY;

ENTITY volume
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY volume_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VOLUME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY volume_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensional_exponents(3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
END_ENTITY;

ENTITY week_of_year_and_day_date
  SUBTYPE OF (date);
  week_component : week_in_year_number;
  day_component  : OPTIONAL day_in_week_number;
WHERE
  WR1: NOT (leap_year(SELF\date.year_component)) OR {1 <= (day_component + (7 * (week_component - 1))) <= 366};
  WR2: leap_year(SELF\date.year_component) OR {1 <= (day_component + (7 * (week_component - 1))) <= 365};
END_ENTITY;

ENTITY xor_expression
  SUBTYPE OF (binary_boolean_expression);
  SELF\binary_generic_expression.operands : LIST [2 : 2] OF boolean_expression;
END_ENTITY;

ENTITY year_month
  SUBTYPE OF (date);
  month_component : month_in_year_number;
END_ENTITY;

ENTITY zone_breakdown_context
  SUBTYPE OF (breakdown_context);
END_ENTITY;

ENTITY zone_element_usage
  SUBTYPE OF (breakdown_element_usage);
END_ENTITY;

FUNCTION acyclic(arg1 : generic_expression;
                 arg2 : SET OF generic_expression) : BOOLEAN;
LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SIMPLE_GENERIC_EXPRESSION' IN TYPEOF(arg1))
  THEN
    RETURN(TRUE);
  END_IF;
  IF arg1 IN arg2
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.UNARY_GENERIC_EXPRESSION' IN TYPEOF(arg1)
  THEN
    RETURN(acyclic(arg1\unary_generic_expression.operand, arg2 + [arg1]));
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BINARY_GENERIC_EXPRESSION' IN TYPEOF(arg1)
  THEN
    RETURN(acyclic(arg1\binary_generic_expression.operands[1], arg2 + [arg1]) AND
           acyclic(arg1\binary_generic_expression.operands[2], arg2 + [arg1]));
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION' IN TYPEOF(arg1)
  THEN
    result := TRUE;
    REPEAT i := 1 TO SIZEOF(arg1\multiple_arity_generic_expression.operands);
      result := result AND acyclic(arg1\multiple_arity_generic_expression.operands[i], arg2 + [arg1]);
    END_REPEAT;
    RETURN(result);
  END_IF;
  RETURN(result);
END_FUNCTION;

FUNCTION acyclic_action_directive_relationship(relation : action_directive_relationship;
                                               relatives : SET [1 : ?] OF action_directive;
                                               specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF action_directive_relationship;
END_LOCAL;
  IF relation.relating IN relatives
  THEN
    RETURN(FALSE);
  END_IF;
  x := QUERY(adr
             <* bag_to_set(USEDIN(relation.relating,
                                  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_DIRECTIVE_RELATIONSHIP.RELATED'))
             | specific_relation IN TYPEOF(adr));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_action_directive_relationship(x[i], relatives + relation.relating, specific_relation)
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION acyclic_assignment_object_relationship(relation : assignment_object_relationship;
                                                relatives : SET [1 : ?] OF assignment_object_select;
                                                specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF assignment_object_relationship;
END_LOCAL;
  IF relation.relating IN relatives
  THEN
    RETURN(FALSE);
  END_IF;
  x := QUERY(aor
             <* bag_to_set(USEDIN(relation.relating,
                                  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASSIGNMENT_OBJECT_RELATIONSHIP.RELATED'))
             | specific_relation IN TYPEOF(aor));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_assignment_object_relationship(x[i], relatives + relation.relating, specific_relation)
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION acyclic_classification_assignment_relationship(relation : classification_assignment_relationship;
                                                        relatives : SET [1 : ?] OF classification_assignment;
                                                        specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF classification_assignment_relationship;
END_LOCAL;
  IF relation.relating IN relatives
  THEN
    RETURN(FALSE);
  END_IF;
  x := QUERY(car
             <* bag_to_set(USEDIN(relation.relating,
                                  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CLASSIFICATION_ASSIGNMENT_RELATIONSHIP.RELATED'))
             | specific_relation IN TYPEOF(car));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_classification_assignment_relationship(x[i], relatives + relation.relating, specific_relation)
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION acyclic_description_text_assignment_relationship(relation : description_text_assignment_relationship;
                                                          relatives : SET [1 : ?] OF description_text_assignment;
                                                          specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF description_text_assignment_relationship;
END_LOCAL;
  IF relation.relating IN relatives
  THEN
    RETURN(FALSE);
  END_IF;
  x := QUERY(dtar
             <* bag_to_set(USEDIN(relation.relating,
                                  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_TEXT_ASSIGNMENT_RELATIONSHIP.RELATED'))
             | specific_relation IN TYPEOF(dtar));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_description_text_assignment_relationship(x[i], relatives + relation.relating, specific_relation)
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION acyclic_external_identification_assignment_relationship(relation : external_identification_assignment_relationship;
                                                                 relatives : SET [1 : ?] OF external_identification_assignment;
                                                                 specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF external_identification_assignment_relationship;
END_LOCAL;
  IF relation.relating IN relatives
  THEN
    RETURN(FALSE);
  END_IF;
  x := QUERY(eiar
             <* bag_to_set(USEDIN(relation.relating,
                                  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXTERNAL_IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.RELATED'))
             | specific_relation IN TYPEOF(eiar));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_external_identification_assignment_relationship(x[i], relatives + relation.relating,
                                                                   specific_relation)
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION acyclic_generic_property_relationship(relation : generic_property_relationship;
                                               relatives : SET [1 : ?] OF generic_property_definition_select;
                                               specific_relation : STRING) : LOGICAL;
LOCAL
  x : SET OF generic_property_relationship;
END_LOCAL;
  IF relation.relating IN relatives
  THEN
    RETURN(FALSE);
  END_IF;
  -- IN is based in instance equality
  x := QUERY(gpr
             <* bag_to_set(USEDIN(relation.relating,
                                  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GENERIC_PROPERTY_RELATIONSHIP.RELATED'))
             | specific_relation IN TYPEOF(gpr));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_generic_property_relationship(x[i], relatives + relation.relating, specific_relation)
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION acyclic_mapped_representation(mi : mapped_item) : BOOLEAN;
LOCAL
  rms : SET OF representation_map;
  mis : SET OF mapped_item;
  rs1 : SET OF representation;
  rs2 : SET OF representation;
END_LOCAL;
  rs1 := using_representations(mi);
  rs2 := [];
  -- loop as long as there are elements in rs1
  REPEAT WHILE SIZEOF(rs1) > 0;
    REPEAT i := 1 TO HIINDEX(rs1);
      rms := bag_to_set(USEDIN(rs1[i],
                               'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
      IF SIZEOF(rms) > 0
      THEN
        REPEAT j := 1 TO HIINDEX(rms);
          mis := bag_to_set(USEDIN(rms[i], 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MAPPED_ITEM.MAPPING_SOURCE'));
          IF SIZEOF(mis) > 0
          THEN
            REPEAT j := 1 TO HIINDEX(mis);
              IF mis[i] :=: mi
              THEN
                RETURN(FALSE);
              END_IF;
              rs2 := rs2 + using_representations(mis[i]);
            END_REPEAT;
          END_IF;
        END_REPEAT;
      END_IF;
    END_REPEAT;
    rs1 := rs2;
    rs2 := [];
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION acyclic_product_definition_relationship(relation : product_definition_relationship;
                                                 relatives : SET [1 : ?] OF product_definition_or_reference;
                                                 specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF product_definition_relationship;
END_LOCAL;
  IF relation.relating_product_definition IN relatives
  THEN
    RETURN(FALSE);
  END_IF;
  x := QUERY(pd
             <* bag_to_set(USEDIN(relation.relating_product_definition,
                                  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION'))
             | specific_relation IN TYPEOF(pd));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition,
                                                   specific_relation)
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION acyclic_product_definition_specified_occurrence(pdso : product_definition_specified_occurrence;
                                                         definition : product_definition_occurrence) : BOOLEAN;
  IF NOT (('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_SPECIFIED_OCCURRENCE') IN TYPEOF(definition))
  THEN
    RETURN(TRUE);
  END_IF;
  IF (definition :=: pdso)
  THEN
    RETURN(FALSE);
  ELSE
    RETURN(acyclic_product_definition_specified_occurrence(pdso, definition\product_definition_occurrence.definition));
  END_IF;
END_FUNCTION;

FUNCTION acyclic_representation_relationship(relation : representation_relationship;
                                             relatives : SET [1 : ?] OF representation;
                                             specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF representation_relationship;
END_LOCAL;
  IF relation.rep_1 IN relatives
  THEN
    RETURN(FALSE);
  END_IF;
  x := QUERY(r
             <* bag_to_set(USEDIN(relation.rep_1,
                                  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_RELATIONSHIP.REP_2'))
             | specific_relation IN TYPEOF(r));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_representation_relationship(x[i], relatives + relation.rep_1, specific_relation)
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION acyclic_shape_aspect_occurrence(sao : shape_aspect_occurrence;
                                         definition : shape_aspect_or_characterized_object) : BOOLEAN;
  IF NOT (('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_ASPECT_OCCURRENCE') IN TYPEOF(definition))
  THEN
    RETURN(TRUE);
  END_IF;
  IF (definition :=: sao)
  THEN
    RETURN(FALSE);
  ELSE
    RETURN(acyclic_shape_aspect_occurrence(sao, definition\shape_aspect_occurrence.definition));
  END_IF;
END_FUNCTION;

FUNCTION acyclic_state_definition_to_state_assignment_relationship(relation : state_definition_to_state_assignment_relationship;
                                                                   relatives : SET [1 : ?] OF ascribable_state;
                                                                   specific_relation : STRING) : LOGICAL;
LOCAL
  x : SET OF ascribable_state_relationship;
END_LOCAL;
  IF relation.relating_ascribable_state IN relatives
  THEN
    RETURN(FALSE);
  END_IF;
  -- IN is based in instance equality
  x := QUERY(sdtsar
             <* bag_to_set(USEDIN(relation.relating_ascribable_state,
                                  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASCRIBABLE_STATE_RELATIONSHIP.RELATED_ASCRIBABLE_STATE'))
             | specific_relation IN TYPEOF(sdtsar));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_state_definition_to_state_assignment_relationship(x[i],
                                                                     relatives + relation.relating_ascribable_state,
                                                                     specific_relation)
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION all_members_of_es(sv : SET OF maths_value;
                           es : elementary_space_enumerators) : LOGICAL;

CONSTANT
  base_types : SET OF STRING :=
               ['NUMBER',
                'COMPLEX_NUMBER_LITERAL',
                'REAL',
                'INTEGER',
                'LOGICAL',
                'BOOLEAN',
                'STRING',
                'BINARY',
                'MATHS_SPACE',
                'MATHS_FUNCTION',
                'LIST',
                'ELEMENTARY_SPACE_ENUMERATORS',
                'ORDERING_TYPE',
                'LOWER_UPPER',
                'SYMMETRY_TYPE',
                'ELEMENTARY_FUNCTION_ENUMERATORS',
                'OPEN_CLOSED',
                'SPACE_CONSTRAINT_TYPE',
                'REPACKAGE_OPTIONS',
                'EXTENSION_OPTIONS'];
END_CONSTANT;
LOCAL
  v        : maths_value;
  key_type : STRING             := '';
  types    : SET OF STRING;
  ge       : generic_expression;
  cum      : LOGICAL            := TRUE;
  vspc     : maths_space;
END_LOCAL;
  IF NOT EXISTS(sv) OR NOT EXISTS(es)
  THEN
    RETURN(FALSE);
  END_IF;
  CASE es OF
    es_numbers : key_type := 'NUMBER';
    es_complex_numbers : key_type := 'COMPLEX_NUMBER_LITERAL';
    es_reals : key_type := 'REAL';
    es_integers : key_type := 'INTEGER';
    es_logicals : key_type := 'LOGICAL';
    es_booleans : key_type := 'BOOLEAN';
    es_strings : key_type := 'STRING';
    es_binarys : key_type := 'BINARY';
    es_maths_spaces : key_type := 'MATHS_SPACE';
    es_maths_functions : key_type := 'MATHS_FUNCTION';
    es_generics : RETURN(TRUE);
  END_CASE;
  REPEAT i := 1 TO SIZEOF(sv);
    IF NOT EXISTS(sv[i])
    THEN
      RETURN(FALSE);
    END_IF;
    v := simplify_maths_value(sv[i]);
    types := stripped_typeof(v);
    IF key_type IN types
    THEN
      SKIP;
    END_IF;
    IF (es = es_numbers) AND ('COMPLEX_NUMBER_LITERAL' IN types)
    THEN
      SKIP;
    END_IF;
    IF SIZEOF(base_types * types) > 0
    THEN
      RETURN(FALSE);
    END_IF;
    ge := v;
    IF has_values_space(ge)
    THEN
      vspc := values_space_of(ge);
      IF NOT subspace_of_es(vspc, es)
      THEN
        IF NOT compatible_spaces(vspc, make_elementary_space(es))
        THEN
          RETURN(FALSE);
        END_IF;
        cum := UNKNOWN;
      END_IF;
    ELSE
      cum := UNKNOWN;
    END_IF;
    IF cum = FALSE
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(cum);
END_FUNCTION;

FUNCTION any_space_satisfies(sc : space_constraint_type;
                             spc : maths_space) : BOOLEAN;
LOCAL
  spc_id : elementary_space_enumerators;
END_LOCAL;
  IF (sc = sc_equal) OR NOT ('ELEMENTARY_SPACE' IN stripped_typeof(spc))
  THEN
    RETURN(FALSE);
  END_IF;
  spc_id := spc\elementary_space.space_id;
  IF sc = sc_subspace
  THEN
    RETURN(bool(spc_id = es_generics));
  END_IF;
  IF sc = sc_member
  THEN
    RETURN(bool((spc_id = es_generics) OR (spc_id = es_maths_spaces)));
  END_IF;
  -- Should be unreachable.
  RETURN(?);
END_FUNCTION;

FUNCTION assoc_product_space(ts1 : tuple_space;
                             ts2 : tuple_space) : tuple_space;
LOCAL
  types1  : SET OF STRING         := stripped_typeof(ts1);
  types2  : SET OF STRING         := stripped_typeof(ts2);
  up1     : uniform_product_space := make_uniform_product_space(the_reals, 1);
  up2     : uniform_product_space := make_uniform_product_space(the_reals, 1);
  lp1     : listed_product_space  := the_zero_tuple_space;
  lp2     : listed_product_space  := the_zero_tuple_space;
  lps     : listed_product_space  := the_zero_tuple_space;
  et1     : extended_tuple_space  := the_tuples;
  et2     : extended_tuple_space  := the_tuples;
  ets     : extended_tuple_space  := the_tuples;
  use_up1 : BOOLEAN;
  use_up2 : BOOLEAN;
  use_lp1 : BOOLEAN;
  use_lp2 : BOOLEAN;
  factors : LIST OF maths_space   := [];
  tspace  : tuple_space;
END_LOCAL;
  -- Identify type of first operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types1
  THEN
    up1 := ts1;
    use_up1 := TRUE;
    use_lp1 := FALSE;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types1
    THEN
      lp1 := ts1;
      use_up1 := FALSE;
      use_lp1 := TRUE;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types1)
      THEN
        RETURN(?);
      END_IF;
      et1 := ts1;
      use_up1 := FALSE;
      use_lp1 := FALSE;
    END_IF;
  END_IF;
  -- Identify type of second operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types2
  THEN
    up2 := ts2;
    use_up2 := TRUE;
    use_lp2 := FALSE;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types2
    THEN
      lp2 := ts2;
      use_up2 := FALSE;
      use_lp2 := TRUE;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types2)
      THEN
        RETURN(?);
      END_IF;
      et2 := ts2;
      use_up2 := FALSE;
      use_lp2 := FALSE;
    END_IF;
  END_IF;
  -- Construction for each combination of cases
  IF use_up1
  THEN
    IF use_up2
    THEN
      IF up1.base = up2.base
      THEN
        tspace := make_uniform_product_space(up1.base, up1.exponent + up2.exponent);
      ELSE
        factors := [up1.base:up1.exponent,up2.base:up2.exponent];
        tspace := make_listed_product_space(factors);
      END_IF;
    ELSE
      IF use_lp2
      THEN
        factors := [up1.base:up1.exponent];
        factors := factors + lp2.factors;
        tspace := make_listed_product_space(factors);
      ELSE
        tspace := assoc_product_space(up1, et2.base);
        tspace := make_extended_tuple_space(tspace, et2.extender);
      END_IF;
    END_IF;
  ELSE
    IF use_lp1
    THEN
      IF use_up2
      THEN
        factors := [up2.base:up2.exponent];
        factors := lp1.factors + factors;
        tspace := make_listed_product_space(factors);
      ELSE
        IF use_lp2
        THEN
          tspace := make_listed_product_space(lp1.factors + lp2.factors);
        ELSE
          tspace := assoc_product_space(lp1, et2.base);
          tspace := make_extended_tuple_space(tspace, et2.extender);
        END_IF;
      END_IF;
    ELSE
      IF use_up2
      THEN
        IF et1.extender = up2.base
        THEN
          tspace := assoc_product_space(et1.base, up2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          RETURN(?);
        END_IF;
      ELSE
        IF use_lp2
        THEN
          factors := lp2.factors;
          REPEAT i := 1 TO SIZEOF(factors);
            IF et1.extender <> factors[i]
            THEN
              RETURN(?);
            END_IF;
          END_REPEAT;
          tspace := assoc_product_space(et1.base, lp2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          IF et1.extender = et2.extender
          THEN
            tspace := assoc_product_space(et1, et2.base);
          ELSE
            RETURN(?);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(tspace);
END_FUNCTION;

FUNCTION atan2(y : REAL;
               x : REAL) : REAL;
LOCAL
  r : REAL;
END_LOCAL;
  IF (y = 0.0) AND (x = 0.0)
  THEN
    RETURN(?);
  END_IF;
  r := ATAN(y, x);
  IF x < 0.0
  THEN
    IF y < 0.0
    THEN
      r := r - PI;
    ELSE
      r := r + PI;
    END_IF;
  END_IF;
  RETURN(r);
END_FUNCTION;

FUNCTION bag_to_set(the_bag : BAG OF GENERIC : INTYPE) : SET OF GENERIC : INTYPE;
LOCAL
  the_set : SET OF GENERIC : INTYPE := [];
END_LOCAL;
  IF SIZEOF(the_bag) > 0
  THEN
    REPEAT i := 1 TO HIINDEX(the_bag);
      the_set := the_set + the_bag[i];
    END_REPEAT;
  END_IF;
  RETURN(the_set);
END_FUNCTION;

FUNCTION base_axis(dim : INTEGER;
                   axis1 : direction;
                   axis2 : direction;
                   axis3 : direction) : LIST [2 : 3] OF direction;
LOCAL
  u      : LIST [2 : 3] OF direction;
  factor : REAL;
  d1     : direction;
  d2     : direction;
END_LOCAL;
  IF (dim = 3)
  THEN
    d1 := NVL(normalise(axis3), dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1, axis1);
    u := [d2,second_proj_axis(d1, d2, axis2),d1];
  ELSE
    IF EXISTS(axis1)
    THEN
      d1 := normalise(axis1);
      u := [d1,orthogonal_complement(d1)];
      IF EXISTS(axis2)
      THEN
        factor := dot_product(axis2, u[2]);
        IF (factor < 0.0)
        THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2)
      THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1),d1];
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0,0.0]),dummy_gri || direction([0.0,1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);
END_FUNCTION;

FUNCTION bool(lgcl : LOGICAL) : BOOLEAN;
  IF NOT EXISTS(lgcl)
  THEN
    RETURN(FALSE);
  END_IF;
  IF lgcl <> TRUE
  THEN
    RETURN(FALSE);
  END_IF;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION build_2axes(ref_direction : direction) : LIST [2 : 2] OF direction;
LOCAL
  d : direction := NVL(normalise(ref_direction), dummy_gri || direction([1.0,0.0]));
END_LOCAL;
  RETURN([d,orthogonal_complement(d)]);
END_FUNCTION;

FUNCTION build_axes(axis : direction;
                    ref_direction : direction) : LIST [3 : 3] OF direction;
LOCAL
  d1 : direction;
  d2 : direction;
END_LOCAL;
  d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
  d2 := first_proj_axis(d1, ref_direction);
  RETURN([d2,normalise(cross_product(d1, d2))\vector.orientation,d1]);
END_FUNCTION;

FUNCTION categories_of_product(obj : product) : SET OF STRING;
LOCAL
  category_assignments : BAG OF product_category;
  categories           : SET OF STRING           := [];
END_LOCAL;
  category_assignments := USEDIN(obj,
                                 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
  REPEAT i := LOINDEX(category_assignments) TO HIINDEX(category_assignments) BY 1;
    categories := categories + category_assignments[i].name;
  END_REPEAT;
  RETURN(categories);
END_FUNCTION;

FUNCTION check_geometric_dimension(capt : SET [0 : ?] OF cartesian_point;
                                   dir : SET [0 : ?] OF direction;
                                   grc : SET [1 : ?] OF geometric_representation_context) : BOOLEAN;
LOCAL
  globaldim : INTEGER                       := 0;
  reps      : SET [0 : ?] OF representation := [];
  result    : BOOLEAN                       := TRUE;
END_LOCAL;
  globaldim := geometric_dimensionalities_in_contexts(grc);
  IF (globaldim > 0)
  THEN
    IF (SIZEOF(capt) > 0)
    THEN
      REPEAT i := 1 TO HIINDEX(capt);
        IF (HIINDEX(capt[i].coordinates) <> globaldim)
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    IF (SIZEOF(dir) > 0)
    THEN
      REPEAT i := 1 TO HIINDEX(dir);
        IF (HIINDEX(dir[i].direction_ratios) <> globaldim)
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(result);
  ELSE
    IF (SIZEOF(capt) > 0)
    THEN
      REPEAT i := 1 TO HIINDEX(capt);
        reps := using_representations(capt[i]);
        IF (SIZEOF(reps) > 0)
        THEN
          REPEAT j := 1 TO HIINDEX(reps);
            IF (HIINDEX(capt[i].coordinates) <>
                reps[j].context_of_items\geometric_representation_context.coordinate_space_dimension)
            THEN
              RETURN(FALSE);
            END_IF;
          END_REPEAT;
        ELSE
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    IF (SIZEOF(dir) > 0)
    THEN
      REPEAT i := 1 TO HIINDEX(dir);
        reps := using_representations(dir[i]);
        IF (SIZEOF(reps) > 0)
        THEN
          REPEAT j := 1 TO HIINDEX(reps);
            IF (HIINDEX(dir[i].direction_ratios) <>
                reps[j].context_of_items\geometric_representation_context.coordinate_space_dimension)
            THEN
              RETURN(FALSE);
            END_IF;
          END_REPEAT;
        ELSE
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN(result);
END_FUNCTION;

FUNCTION check_sparse_index_domain(idxdom : tuple_space;
                                   base : zero_or_one;
                                   shape : LIST [1 : ?] OF positive_integer;
                                   order : ordering_type) : BOOLEAN;
LOCAL
  mthspc   : maths_space;
  interval : finite_integer_interval;
  i        : INTEGER;
END_LOCAL;
  mthspc := factor1(idxdom);
  -- A consequence of WR1 of basic_sparse_matrix is that here we need only
  -- consider the case that mthspc is a finite integer interval and is the only
  -- factor space of idxdom.
  interval := mthspc;
  IF order = by_rows
  THEN
    i := 1;
  ELSE
    i := 2;
  END_IF;
  RETURN(bool((interval.min <= base) AND (interval.max >= base + shape[i])));
END_FUNCTION;

FUNCTION check_sparse_index_to_loc(index_range : tuple_space;
                                   loc_domain : tuple_space) : BOOLEAN;
LOCAL
  temp         : maths_space;
  idx_rng_itvl : finite_integer_interval;
  loc_dmn_itvl : finite_integer_interval;
END_LOCAL;
  temp := factor1(index_range);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF(temp)
  THEN
    temp := factor1(temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
  THEN
    RETURN(FALSE);
  END_IF;
  idx_rng_itvl := temp;
  temp := factor1(loc_domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF(temp)
  THEN
    temp := factor1(temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
  THEN
    RETURN(FALSE);
  END_IF;
  loc_dmn_itvl := temp;
  RETURN(bool((loc_dmn_itvl.min <= idx_rng_itvl.min) AND (idx_rng_itvl.max <= loc_dmn_itvl.max + 1)));
END_FUNCTION;

FUNCTION check_sparse_loc_range(locrng : tuple_space;
                                base : zero_or_one;
                                shape : LIST [1 : ?] OF positive_integer;
                                order : ordering_type) : BOOLEAN;
LOCAL
  mthspc   : maths_space;
  interval : finite_integer_interval;
  i        : INTEGER;
END_LOCAL;
  IF space_dimension(locrng) <> 1
  THEN
    RETURN(FALSE);
  END_IF;
  mthspc := factor1(locrng);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(mthspc))
  THEN
    RETURN(FALSE);
  END_IF;
  interval := mthspc;
  IF order = by_rows
  THEN
    i := 2;
  ELSE
    i := 1;
  END_IF;
  RETURN(bool((interval.min >= base) AND (interval.max <= base + shape[i] - 1)));
END_FUNCTION;

FUNCTION class_assignment_is_valid(aia : applied_classification_assignment) : BOOLEAN;
LOCAL
  item : classification_item;
  role : classification_role;
END_LOCAL;
  role := aia\classification_assignment.role;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CLASS_SYSTEM' IN TYPEOF(aia\classification_assignment.assigned_class))
  THEN
    IF (role\classification_role.name <> 'class system membership')
    THEN
      RETURN(FALSE);
    END_IF;
    REPEAT i := LOINDEX(aia\applied_classification_assignment.items) TO HIINDEX(aia\applied_classification_assignment.items);
      item := aia\applied_classification_assignment.items[i];
      IF (SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CHARACTERIZED_CLASS'] * TYPEOF(item)) = 0)
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CHARACTERIZED_CLASS' IN
      TYPEOF(aia\classification_assignment.assigned_class))
  THEN
    IF NOT (role\classification_role.name IN ['definitional','non-definitional',''])
    THEN
      RETURN(FALSE);
    END_IF;
    REPEAT i := LOINDEX(aia\applied_classification_assignment.items) TO HIINDEX(aia\applied_classification_assignment.items);
      item := aia\applied_classification_assignment.items[i];
      IF (SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CLASSIFIED_ITEM'] * TYPEOF(item)) = 0)
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  IF (role\classification_role.name = 'definitional')
  THEN
    IF NOT (SIZEOF(QUERY(it
                         <* aia\applied_classification_assignment.items
                         | NOT (SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT',
                                        'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_FORMATION',
                                        'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION'] *
                                       TYPEOF(it)) =
                                1))) =
            0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION compare_basis_and_coef(basis : LIST [1 : ?] OF b_spline_basis;
                                coef : maths_function) : BOOLEAN;
LOCAL
  shape : LIST OF positive_integer;
END_LOCAL;
  IF NOT EXISTS(basis) OR NOT EXISTS(coef)
  THEN
    RETURN(FALSE);
  END_IF;
  shape := shape_of_array(coef);
  IF NOT EXISTS(shape)
  THEN
    RETURN(FALSE);
  END_IF;
  IF SIZEOF(shape) < SIZEOF(basis)
  THEN
    RETURN(FALSE);
  END_IF;
  REPEAT i := 1 TO SIZEOF(basis);
    IF (basis[i].num_basis = shape[i]) <> TRUE
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION compatible_complex_number_regions(sp1 : maths_space;
                                           sp2 : maths_space) : BOOLEAN;
LOCAL
  typenames   : SET OF STRING                   := stripped_typeof(sp1);
  crgn1       : cartesian_complex_number_region;
  crgn2       : cartesian_complex_number_region;
  prgn1       : polar_complex_number_region;
  prgn2       : polar_complex_number_region;
  prgn1c2     : polar_complex_number_region;
  prgn2c1     : polar_complex_number_region;
  sp1_is_crgn : BOOLEAN;
  sp2_is_crgn : BOOLEAN;
END_LOCAL;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames
  THEN
    sp1_is_crgn := TRUE;
    crgn1 := sp1;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames
    THEN
      sp1_is_crgn := FALSE;
      prgn1 := sp1;
    ELSE
      RETURN(TRUE);
    END_IF;
  END_IF;
  typenames := stripped_typeof(sp2);
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames
  THEN
    sp2_is_crgn := TRUE;
    crgn2 := sp2;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames
    THEN
      sp2_is_crgn := FALSE;
      prgn2 := sp2;
    ELSE
      RETURN(TRUE);
    END_IF;
  END_IF;
  IF sp1_is_crgn AND sp2_is_crgn
  THEN
    RETURN(compatible_intervals(crgn1.real_constraint, crgn2.real_constraint) AND
           compatible_intervals(crgn1.imag_constraint, crgn2.imag_constraint));
  END_IF;
  IF NOT sp1_is_crgn AND
         NOT sp2_is_crgn AND (prgn1.centre.real_part = prgn2.centre.real_part) AND
             (prgn1.centre.imag_part = prgn2.centre.imag_part)
  THEN
    IF NOT compatible_intervals(prgn1.distance_constraint, prgn2.distance_constraint)
    THEN
      RETURN(FALSE);
    END_IF;
    IF compatible_intervals(prgn1.direction_constraint, prgn2.direction_constraint)
    THEN
      RETURN(TRUE);
    END_IF;
    IF (prgn1.direction_constraint.max > PI) AND (prgn2.direction_constraint.max < PI)
    THEN
      RETURN(compatible_intervals(prgn2.direction_constraint,
                                  make_finite_real_interval(-PI, open, prgn1.direction_constraint.max - 2.0 * PI,
                                                            prgn1.direction_constraint.max_closure)));
    END_IF;
    IF (prgn2.direction_constraint.max > PI) AND (prgn1.direction_constraint.max < PI)
    THEN
      RETURN(compatible_intervals(prgn1.direction_constraint,
                                  make_finite_real_interval(-PI, open, prgn2.direction_constraint.max - 2.0 * PI,
                                                            prgn2.direction_constraint.max_closure)));
    END_IF;
    RETURN(FALSE);
  END_IF;
  -- Make do with imperfect tests for remaining cases.
  IF sp1_is_crgn AND NOT sp2_is_crgn
  THEN
    crgn2 := enclose_pregion_in_cregion(prgn2);
    prgn1 := enclose_cregion_in_pregion(crgn1, prgn2.centre);
    RETURN(compatible_complex_number_regions(crgn1, crgn2) AND compatible_complex_number_regions(prgn1, prgn2));
  END_IF;
  IF NOT sp1_is_crgn AND sp2_is_crgn
  THEN
    crgn1 := enclose_pregion_in_cregion(prgn1);
    prgn2 := enclose_cregion_in_pregion(crgn2, prgn1.centre);
    RETURN(compatible_complex_number_regions(crgn1, crgn2) AND compatible_complex_number_regions(prgn1, prgn2));
  END_IF;
  -- Two polar regions with different centres
  prgn1c2 := enclose_pregion_in_pregion(prgn1, prgn2.centre);
  prgn2c1 := enclose_pregion_in_pregion(prgn2, prgn1.centre);
  RETURN(compatible_complex_number_regions(prgn1, prgn2c1) AND compatible_complex_number_regions(prgn1c2, prgn2));
END_FUNCTION;

FUNCTION compatible_es_values(esval1 : elementary_space_enumerators;
                              esval2 : elementary_space_enumerators) : BOOLEAN;
LOCAL
  esval1_is_numeric : LOGICAL;
  esval2_is_numeric : LOGICAL;
END_LOCAL;
  IF (esval1 = esval2) OR (esval1 = es_generics) OR (esval2 = es_generics)
  THEN
    RETURN(TRUE);
  END_IF;
  esval1_is_numeric := (esval1 >= es_numbers) AND (esval1 <= es_integers);
  esval2_is_numeric := (esval2 >= es_numbers) AND (esval2 <= es_integers);
  IF (esval1_is_numeric AND (esval2 = es_numbers)) OR (esval2_is_numeric AND (esval1 = es_numbers))
  THEN
    RETURN(TRUE);
  END_IF;
  IF esval1_is_numeric XOR esval2_is_numeric
  THEN
    RETURN(FALSE);
  END_IF;
  IF ((esval1 = es_logicals) AND (esval2 = es_booleans)) OR ((esval1 = es_booleans) AND (esval2 = es_logicals))
  THEN
    RETURN(TRUE);
  END_IF;
  -- All other cases are incompatible
  RETURN(FALSE);
END_FUNCTION;

FUNCTION compatible_intervals(sp1 : maths_space;
                              sp2 : maths_space) : BOOLEAN;
LOCAL
  amin : REAL;
  amax : REAL;
END_LOCAL;
  IF min_exists(sp1) AND max_exists(sp2)
  THEN
    amin := real_min(sp1);
    amax := real_max(sp2);
    IF amin > amax
    THEN
      RETURN(FALSE);
    END_IF;
    IF amin = amax
    THEN
      RETURN(min_included(sp1) AND max_included(sp2));
    END_IF;
  END_IF;
  IF min_exists(sp2) AND max_exists(sp1)
  THEN
    amin := real_min(sp2);
    amax := real_max(sp1);
    IF amin > amax
    THEN
      RETURN(FALSE);
    END_IF;
    IF amin = amax
    THEN
      RETURN(min_included(sp2) AND max_included(sp1));
    END_IF;
  END_IF;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION compatible_spaces(sp1 : maths_space;
                           sp2 : maths_space) : BOOLEAN;
LOCAL
  types1 : SET OF STRING := stripped_typeof(sp1);
  types2 : SET OF STRING := stripped_typeof(sp2);
  lgcl   : LOGICAL       := UNKNOWN;
  m      : INTEGER;
  n      : INTEGER;
  s1     : maths_space;
  s2     : maths_space;
END_LOCAL;
  IF 'FINITE_SPACE' IN types1
  THEN
    REPEAT i := 1 TO SIZEOF(sp1\finite_space.members);
      lgcl := member_of(sp1\finite_space.members[i], sp2);
      IF lgcl <> FALSE
      THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
    RETURN(FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types2
  THEN
    REPEAT i := 1 TO SIZEOF(sp2\finite_space.members);
      lgcl := member_of(sp2\finite_space.members[i], sp1);
      IF lgcl <> FALSE
      THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
    RETURN(FALSE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1
  THEN
    IF sp1\elementary_space.space_id = es_generics
    THEN
      RETURN(TRUE);
    END_IF;
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      RETURN(compatible_es_values(sp1\elementary_space.space_id, sp2\elementary_space.space_id));
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types2) OR ('INTEGER_INTERVAL_FROM_MIN' IN types2) OR
       ('INTEGER_INTERVAL_TO_MAX' IN types2)
    THEN
      RETURN(compatible_es_values(sp1\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR ('REAL_INTERVAL_FROM_MIN' IN types2) OR ('REAL_INTERVAL_TO_MAX' IN types2)
    THEN
      RETURN(compatible_es_values(sp1\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types2) OR ('POLAR_COMPLEX_NUMBER_REGION' IN types2)
    THEN
      RETURN(compatible_es_values(sp1\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2
    THEN
      RETURN(bool(sp1\elementary_space.space_id = es_maths_functions));
    END_IF;
    RETURN(TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types2
  THEN
    IF sp2\elementary_space.space_id = es_generics
    THEN
      RETURN(TRUE);
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types1) OR ('INTEGER_INTERVAL_FROM_MIN' IN types1) OR
       ('INTEGER_INTERVAL_TO_MAX' IN types1)
    THEN
      RETURN(compatible_es_values(sp2\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types1) OR ('REAL_INTERVAL_FROM_MIN' IN types1) OR ('REAL_INTERVAL_TO_MAX' IN types1)
    THEN
      RETURN(compatible_es_values(sp2\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types1) OR ('POLAR_COMPLEX_NUMBER_REGION' IN types1)
    THEN
      RETURN(compatible_es_values(sp2\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types1
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types1
    THEN
      RETURN(bool(sp2\elementary_space.space_id = es_maths_functions));
    END_IF;
    RETURN(TRUE);
  END_IF;
  IF subspace_of_es(sp1, es_integers)
  THEN
    IF subspace_of_es(sp2, es_integers)
    THEN
      RETURN(compatible_intervals(sp1, sp2));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF subspace_of_es(sp2, es_integers)
  THEN
    RETURN(FALSE);
  END_IF;
  IF subspace_of_es(sp1, es_reals)
  THEN
    IF subspace_of_es(sp2, es_reals)
    THEN
      RETURN(compatible_intervals(sp1, sp2));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF subspace_of_es(sp2, es_reals)
  THEN
    RETURN(FALSE);
  END_IF;
  IF subspace_of_es(sp1, es_complex_numbers)
  THEN
    IF subspace_of_es(sp2, es_complex_numbers)
    THEN
      RETURN(compatible_complex_number_regions(sp1, sp2));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF subspace_of_es(sp2, es_complex_numbers)
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN types1
  THEN
    IF 'UNIFORM_PRODUCT_SPACE' IN types2
    THEN
      IF sp1\uniform_product_space.exponent <> sp2\uniform_product_space.exponent
      THEN
        RETURN(FALSE);
      END_IF;
      RETURN(compatible_spaces(sp1\uniform_product_space.base, sp2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2
    THEN
      n := SIZEOF(sp2\listed_product_space.factors);
      IF sp1\uniform_product_space.exponent <> n
      THEN
        RETURN(FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\uniform_product_space.base, sp2\listed_product_space.factors[i])
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2
    THEN
      m := sp1\uniform_product_space.exponent;
      n := space_dimension(sp2\extended_tuple_space.base);
      IF m < n
      THEN
        RETURN(FALSE);
      END_IF;
      IF m = n
      THEN
        RETURN(compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN(compatible_spaces(sp1,
                               assoc_product_space(sp2\extended_tuple_space.base,
                                                   make_uniform_product_space(sp2\extended_tuple_space.extender,
                                                                              m - n))));
    END_IF;
    IF 'FUNCTION_SPACE' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    RETURN(TRUE);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types1
  THEN
    n := SIZEOF(sp1\listed_product_space.factors);
    IF 'UNIFORM_PRODUCT_SPACE' IN types2
    THEN
      IF n <> sp2\uniform_product_space.exponent
      THEN
        RETURN(FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp2\uniform_product_space.base, sp1\listed_product_space.factors[i])
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(TRUE);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2
    THEN
      IF n <> SIZEOF(sp2\listed_product_space.factors)
      THEN
        RETURN(FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\listed_product_space.factors[i], sp2\listed_product_space.factors[i])
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2
    THEN
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n < m
      THEN
        RETURN(FALSE);
      END_IF;
      IF n = m
      THEN
        RETURN(compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN(compatible_spaces(sp1,
                               assoc_product_space(sp2\extended_tuple_space.base,
                                                   make_uniform_product_space(sp2\extended_tuple_space.extender,
                                                                              n - m))));
    END_IF;
    IF (schema_prefix + 'FUNCTION_SPACE') IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    RETURN(TRUE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1
  THEN
    IF ('UNIFORM_PRODUCT_SPACE' IN types2) OR ('LISTED_PRODUCT_SPACE' IN types2)
    THEN
      RETURN(compatible_spaces(sp2, sp1));
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2
    THEN
      IF NOT compatible_spaces(sp1\extended_tuple_space.extender, sp2\extended_tuple_space.extender)
      THEN
        RETURN(FALSE);
      END_IF;
      n := space_dimension(sp1\extended_tuple_space.base);
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n < m
      THEN
        RETURN(compatible_spaces(assoc_product_space(sp1\extended_tuple_space.base,
                                                     make_uniform_product_space(sp1\extended_tuple_space.extender,
                                                                                m - n)),
                                 sp2\extended_tuple_space.base));
      END_IF;
      IF n = m
      THEN
        RETURN(compatible_spaces(sp1\extended_tuple_space.base, sp2\extended_tuple_space.base));
      END_IF;
      IF n > m
      THEN
        RETURN(compatible_spaces(sp1\extended_tuple_space.base,
                                 assoc_product_space(sp2\extended_tuple_space.base,
                                                     make_uniform_product_space(sp2\extended_tuple_space.extender,
                                                                                n - m))));
      END_IF;
    END_IF;
    IF 'FUNCTION_SPACE' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    RETURN(TRUE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1
  THEN
    IF 'FUNCTION_SPACE' IN types2
    THEN
      s1 := sp1\function_space.domain_argument;
      s2 := sp2\function_space.domain_argument;
      CASE sp1\function_space.domain_constraint OF
        sc_equal : BEGIN  
                          CASE sp2\function_space.domain_constraint OF
                            sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
                            sc_subspace : lgcl := subspace_of(s1, s2);
                            sc_member : lgcl := member_of(s1, s2);
                          END_CASE;
        END;
        sc_subspace : BEGIN  
                             CASE sp2\function_space.domain_constraint OF
                               sc_equal : lgcl := subspace_of(s2, s1);
                               sc_subspace : lgcl := compatible_spaces(s1, s2);
                               sc_member : lgcl := UNKNOWN;
                             END_CASE;
        END;
        sc_member : BEGIN  
                           CASE sp2\function_space.domain_constraint OF
                             sc_equal : lgcl := member_of(s2, s1);
                             sc_subspace : lgcl := UNKNOWN;
                             sc_member : lgcl := compatible_spaces(s1, s2);
                           END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE
      THEN
        RETURN(FALSE);
      END_IF;
      s1 := sp1\function_space.range_argument;
      s2 := sp2\function_space.range_argument;
      CASE sp1\function_space.range_constraint OF
        sc_equal : BEGIN  
                          CASE sp2\function_space.range_constraint OF
                            sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
                            sc_subspace : lgcl := subspace_of(s1, s2);
                            sc_member : lgcl := member_of(s1, s2);
                          END_CASE;
        END;
        sc_subspace : BEGIN  
                             CASE sp2\function_space.range_constraint OF
                               sc_equal : lgcl := subspace_of(s2, s1);
                               sc_subspace : lgcl := compatible_spaces(s1, s2);
                               sc_member : lgcl := UNKNOWN;
                             END_CASE;
        END;
        sc_member : BEGIN  
                           CASE sp2\function_space.range_constraint OF
                             sc_equal : lgcl := member_of(s2, s1);
                             sc_subspace : lgcl := UNKNOWN;
                             sc_member : lgcl := compatible_spaces(s1, s2);
                           END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE
      THEN
        RETURN(FALSE);
      END_IF;
      RETURN(TRUE);
    END_IF;
    RETURN(TRUE);
  END_IF;
  -- Should be unreachable.
  RETURN(TRUE);
END_FUNCTION;

FUNCTION composable_sequence(operands : LIST [2 : ?] OF maths_function) : BOOLEAN;
  REPEAT i := 1 TO SIZEOF(operands) - 1;
    IF NOT compatible_spaces(operands[i].range, operands[i + 1].domain)
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION convert_to_literal(val : maths_atom) : generic_literal;
LOCAL
  types : SET OF STRING := TYPEOF(val);
END_LOCAL;
  IF 'INTEGER' IN types
  THEN
    RETURN(make_int_literal(val));
  END_IF;
  IF 'REAL' IN types
  THEN
    RETURN(make_real_literal(val));
  END_IF;
  IF 'BOOLEAN' IN types
  THEN
    RETURN(make_boolean_literal(val));
  END_IF;
  IF 'STRING' IN types
  THEN
    RETURN(make_string_literal(val));
  END_IF;
  IF 'LOGICAL' IN types
  THEN
    RETURN(make_logical_literal(val));
  END_IF;
  IF 'BINARY' IN types
  THEN
    RETURN(make_binary_literal(val));
  END_IF;
  IF (schema_prefix + 'MATHS_ENUM_ATOM') IN types
  THEN
    RETURN(make_maths_enum_literal(val));
  END_IF;
  -- Should be unreachable
  RETURN(?);
END_FUNCTION;

FUNCTION convert_to_maths_function(func : maths_function_select) : maths_function;
LOCAL
  efenum : elementary_function_enumerators;
  mthfun : maths_function;
END_LOCAL;
  IF (schema_prefix + 'MATHS_FUNCTION') IN TYPEOF(func)
  THEN
    mthfun := func;
  ELSE
    efenum := func;
    mthfun := make_elementary_function(efenum);
  END_IF;
  RETURN(mthfun);
END_FUNCTION;

FUNCTION convert_to_maths_value(val : GENERIC : G) : maths_value;
LOCAL
  types : SET OF STRING := TYPEOF(val);
  ival  : maths_integer;
  rval  : maths_real;
  nval  : maths_number;
  tfval : maths_boolean;
  lval  : maths_logical;
  sval  : maths_string;
  bval  : maths_binary;
  tval  : maths_tuple   := the_empty_maths_tuple;
  mval  : maths_value;
END_LOCAL;
  IF (schema_prefix + 'MATHS_VALUE') IN types
  THEN
    RETURN(val);
  END_IF;
  IF 'INTEGER' IN types
  THEN
    ival := val;
    RETURN(ival);
  END_IF;
  IF 'REAL' IN types
  THEN
    rval := val;
    RETURN(rval);
  END_IF;
  IF 'NUMBER' IN types
  THEN
    nval := val;
    RETURN(nval);
  END_IF;
  IF 'BOOLEAN' IN types
  THEN
    tfval := val;
    RETURN(tfval);
  END_IF;
  IF 'LOGICAL' IN types
  THEN
    lval := val;
    RETURN(lval);
  END_IF;
  IF 'STRING' IN types
  THEN
    sval := val;
    RETURN(sval);
  END_IF;
  IF 'BINARY' IN types
  THEN
    bval := val;
    RETURN(bval);
  END_IF;
  IF 'LIST' IN types
  THEN
    REPEAT i := 1 TO SIZEOF(val);
      mval := convert_to_maths_value(val[i]);
      IF NOT EXISTS(mval)
      THEN
        RETURN(?);
      END_IF;
      INSERT(tval, mval, i - 1);
    END_REPEAT;
    RETURN(tval);
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION convert_to_operand(val : maths_value) : generic_expression;
LOCAL
  types : SET OF STRING := stripped_typeof(val);
END_LOCAL;
  -- Use intermediate variables of appropriate declared types to help the compilers.
  IF 'GENERIC_EXPRESSION' IN types
  THEN
    RETURN(val);
  END_IF;
  IF 'MATHS_ATOM' IN types
  THEN
    RETURN(convert_to_literal(val));
  END_IF;
  IF 'ATOM_BASED_VALUE' IN types
  THEN
    RETURN(make_atom_based_literal(val));
  END_IF;
  IF 'MATHS_TUPLE' IN types
  THEN
    RETURN(make_maths_tuple_literal(val));
  END_IF;
  -- Should be unreachable
  RETURN(?);
END_FUNCTION;

FUNCTION convert_to_operands(values : AGGREGATE OF maths_value) : LIST OF generic_expression;
LOCAL
  operands : LIST OF generic_expression := [];
  loc      : INTEGER                    := 0;
END_LOCAL;
  IF NOT EXISTS(values)
  THEN
    RETURN(?);
  END_IF;
  REPEAT i := LOINDEX(values) TO HIINDEX(values);
    INSERT(operands, convert_to_operand(values[i]), loc);
    loc := loc + 1;
  END_REPEAT;
  RETURN(operands);
END_FUNCTION;

FUNCTION convert_to_operands_prcmfn(srcdom : maths_space_or_function;
                                    prepfun : LIST OF maths_function;
                                    finfun : maths_function_select) : LIST [2 : ?] OF generic_expression;
LOCAL
  operands : LIST OF generic_expression := [];
END_LOCAL;
  INSERT(operands, srcdom, 0);
  REPEAT i := 1 TO SIZEOF(prepfun);
    INSERT(operands, prepfun[i], i);
  END_REPEAT;
  INSERT(operands, convert_to_maths_function(finfun), SIZEOF(prepfun) + 1);
  RETURN(operands);
END_FUNCTION;

FUNCTION cross_product(arg1 : direction;
                       arg2 : direction) : vector;
LOCAL
  mag    : REAL;
  res    : direction;
  v1     : LIST [3 : 3] OF REAL;
  v2     : LIST [3 : 3] OF REAL;
  result : vector;
END_LOCAL;
  IF (NOT EXISTS(arg1) OR (arg1.dim = 2)) OR (NOT EXISTS(arg2) OR (arg2.dim = 2))
  THEN
    RETURN(?);
  ELSE
    BEGIN  
           v1 := normalise(arg1).direction_ratios;
           v2 := normalise(arg2).direction_ratios;
           res := dummy_gri ||
                  direction([(v1[2] * v2[3] - v1[3] * v2[2]),
                             (v1[3] * v2[1] - v1[1] * v2[3]),
                             (v1[1] * v2[2] - v1[2] * v2[1])]);
           mag := 0.0;
           REPEAT i := 1 TO 3;
             mag := mag + res.direction_ratios[i] * res.direction_ratios[i];
           END_REPEAT;
           IF (mag > 0.0)
           THEN
             result := dummy_gri || vector(res, SQRT(mag));
           ELSE
             result := dummy_gri || vector(arg1, 0.0);
           END_IF;
           RETURN(result);
    END;
  END_IF;
END_FUNCTION;

FUNCTION definite_integral_check(domain : tuple_space;
                                 vrblint : input_selector;
                                 lowerinf : BOOLEAN;
                                 upperinf : BOOLEAN) : BOOLEAN;
LOCAL
  domn : tuple_space         := domain;
  fspc : maths_space;
  dim  : nonnegative_integer;
  k    : positive_integer;
END_LOCAL;
  IF (space_dimension(domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(domain)))
  THEN
    domn := factor1(domain);
  END_IF;
  dim := space_dimension(domn);
  k := vrblint;
  IF k > dim
  THEN
    RETURN(FALSE);
  END_IF;
  fspc := factor_space(domn, k);
  IF NOT ((schema_prefix + 'REAL_INTERVAL') IN TYPEOF(fspc))
  THEN
    RETURN(FALSE);
  END_IF;
  IF lowerinf AND min_exists(fspc)
  THEN
    RETURN(FALSE);
  END_IF;
  IF upperinf AND max_exists(fspc)
  THEN
    RETURN(FALSE);
  END_IF;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION definite_integral_expr_check(operands : LIST [2 : ?] OF generic_expression;
                                      lowerinf : BOOLEAN;
                                      upperinf : BOOLEAN) : BOOLEAN;
LOCAL
  nops : INTEGER             := 2;
  vspc : maths_space;
  dim  : nonnegative_integer;
  k    : positive_integer;
  bspc : maths_space;
END_LOCAL;
  IF NOT lowerinf
  THEN
    nops := nops + 1;
  END_IF;
  IF NOT upperinf
  THEN
    nops := nops + 1;
  END_IF;
  IF SIZEOF(operands) <> nops
  THEN
    RETURN(FALSE);
  END_IF;
  IF NOT ('GENERIC_VARIABLE' IN stripped_typeof(operands[2]))
  THEN
    RETURN(FALSE);
  END_IF;
  IF NOT has_values_space(operands[2])
  THEN
    RETURN(FALSE);
  END_IF;
  vspc := values_space_of(operands[2]);
  IF NOT ('REAL_INTERVAL' IN stripped_typeof(vspc))
  THEN
    RETURN(FALSE);
  END_IF;
  IF lowerinf
  THEN
    IF min_exists(vspc)
    THEN
      RETURN(FALSE);
    END_IF;
    k := 3;
  ELSE
    IF NOT has_values_space(operands[3])
    THEN
      RETURN(FALSE);
    END_IF;
    bspc := values_space_of(operands[3]);
    IF NOT compatible_spaces(bspc, vspc)
    THEN
      RETURN(FALSE);
    END_IF;
    k := 4;
  END_IF;
  IF upperinf
  THEN
    IF max_exists(vspc)
    THEN
      RETURN(FALSE);
    END_IF;
  ELSE
    IF NOT has_values_space(operands[k])
    THEN
      RETURN(FALSE);
    END_IF;
    bspc := values_space_of(operands[k]);
    IF NOT compatible_spaces(bspc, vspc)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION derive_definite_integral_domain(igrl : definite_integral_function) : tuple_space;
FUNCTION process_product_space(spc : product_space;
                               idx : INTEGER;
                               prefix : INTEGER;
                               vdomn : maths_space) : product_space;
LOCAL
  uspc    : uniform_product_space;
  expnt   : INTEGER;
  factors : LIST OF maths_space;
END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN TYPEOF(spc)
  THEN
    uspc := spc;
    expnt := uspc.exponent + prefix;
    IF idx <= uspc.exponent
    THEN
      expnt := expnt - 1;
    END_IF;
    IF expnt = 0
    THEN
      RETURN(make_listed_product_space([]));
    ELSE
      RETURN(make_uniform_product_space(uspc.base, expnt));
    END_IF;
  ELSE
    factors := spc\listed_product_space.factors;
    IF idx <= SIZEOF(factors)
    THEN
      REMOVE(factors, idx);
    END_IF;
    IF prefix > 0
    THEN
      INSERT(factors, vdomn, 0);
      IF prefix > 1
      THEN
        INSERT(factors, vdomn, 0);
      END_IF;
    END_IF;
    RETURN(make_listed_product_space(factors));
  END_IF;
END_FUNCTION;
LOCAL
  idomn  : tuple_space          := igrl.integrand.domain;
  types  : SET OF STRING        := TYPEOF(idomn);
  idx    : INTEGER              := igrl.variable_of_integration;
  tupled : BOOLEAN              := bool(((space_dimension(idomn) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN types)));
  prefix : INTEGER              := 0;
  espc   : extended_tuple_space;
  vdomn  : maths_space;
END_LOCAL;
  IF tupled
  THEN
    idomn := factor1(idomn);
    types := TYPEOF(idomn);
  END_IF;
  IF igrl.lower_limit_neg_infinity
  THEN
    prefix := prefix + 1;
  END_IF;
  IF igrl.upper_limit_pos_infinity
  THEN
    prefix := prefix + 1;
  END_IF;
  vdomn := factor_space(idomn, idx);
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types
  THEN
    espc := idomn;
    idomn := make_extended_tuple_space(process_product_space(espc.base, idx, prefix, vdomn), espc.extender);
  ELSE
    idomn := process_product_space(idomn, idx, prefix, vdomn);
  END_IF;
  IF tupled
  THEN
    RETURN(one_tuples_of(idomn));
  ELSE
    RETURN(idomn);
  END_IF;
END_FUNCTION;

FUNCTION derive_dimensional_exponents(x : unit) : dimensional_exponents;
LOCAL
  result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
END_LOCAL;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DERIVED_UNIT' IN TYPEOF(x)
  THEN
    REPEAT i := LOINDEX(x\derived_unit.elements) TO HIINDEX(x\derived_unit.elements);
      result.length_exponent := result.length_exponent +
                                (x\derived_unit.elements[i]\derived_unit_element.exponent *
                                 x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.length_exponent);
      result.mass_exponent := result.mass_exponent +
                              (x\derived_unit.elements[i]\derived_unit_element.exponent *
                               x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.mass_exponent);
      result.time_exponent := result.time_exponent +
                              (x\derived_unit.elements[i]\derived_unit_element.exponent *
                               x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.time_exponent);
      result.electric_current_exponent := result.electric_current_exponent +
                                          (x\derived_unit.elements[i]\derived_unit_element.exponent *
                                           x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.electric_current_exponent);
      result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent +
                                                   (x\derived_unit.elements[i]\derived_unit_element.exponent *
                                                    x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.thermodynamic_temperature_exponent);
      result.amount_of_substance_exponent := result.amount_of_substance_exponent +
                                             (x\derived_unit.elements[i]\derived_unit_element.exponent *
                                              x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.amount_of_substance_exponent);
      result.luminous_intensity_exponent := result.luminous_intensity_exponent +
                                            (x\derived_unit.elements[i]\derived_unit_element.exponent *
                                             x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.luminous_intensity_exponent);
    END_REPEAT;
  ELSE
    result := x\named_unit.dimensions;
  END_IF;
  RETURN(result);
END_FUNCTION;

FUNCTION derive_elementary_function_domain(ef_val : elementary_function_enumerators) : tuple_space;
  IF NOT EXISTS(ef_val)
  THEN
    RETURN(?);
  END_IF;
  CASE ef_val OF
    ef_and : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_logicals));
    ef_or : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_logicals));
    ef_not : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_xor : RETURN(make_uniform_product_space(the_logicals, 2));
    ef_negate_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_add_i : RETURN(the_integer_tuples);
    ef_subtract_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_multiply_i : RETURN(the_integer_tuples);
    ef_divide_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_mod_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_exponentiate_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_eq_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_ne_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_gt_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_lt_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_ge_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_le_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_abs_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_if_i : RETURN(make_listed_product_space([the_logicals,the_integers,the_integers]));
    ef_negate_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_reciprocal_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_add_r : RETURN(the_real_tuples);
    ef_subtract_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_multiply_r : RETURN(the_real_tuples);
    ef_divide_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_mod_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_exponentiate_r : RETURN(make_listed_product_space([the_nonnegative_reals,the_reals]));
    ef_exponentiate_ri : RETURN(make_listed_product_space([the_reals,the_integers]));
    ef_eq_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_ne_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_gt_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_lt_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_ge_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_le_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_abs_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_acos_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
    ef_asin_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
    ef_atan2_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_cos_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_exp_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_ln_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_log2_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_log10_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_sin_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_sqrt_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_tan_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_if_r : RETURN(make_listed_product_space([the_logicals,the_reals,the_reals]));
    ef_negate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_reciprocal_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_add_c : RETURN(the_complex_tuples);
    ef_subtract_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
    ef_multiply_c : RETURN(the_complex_tuples);
    ef_divide_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
    ef_exponentiate_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
    ef_exponentiate_ci : RETURN(make_listed_product_space([the_complex_numbers,the_integers]));
    ef_eq_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
    ef_ne_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
    ef_conjugate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_abs_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_arg_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_cos_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_exp_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_ln_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_sin_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_sqrt_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_tan_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_if_c : RETURN(make_listed_product_space([the_logicals,the_complex_numbers,the_complex_numbers]));
    ef_subscript_s : RETURN(make_listed_product_space([the_strings,the_integers]));
    ef_eq_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_ne_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_gt_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_lt_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_ge_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_le_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_subsequence_s : RETURN(make_listed_product_space([the_strings,the_integers,the_integers]));
    ef_concat_s : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_strings));
    ef_size_s : RETURN(make_uniform_product_space(the_strings, 1));
    ef_format : RETURN(make_listed_product_space([the_numbers,the_strings]));
    ef_value : RETURN(make_uniform_product_space(the_strings, 1));
    ef_like : RETURN(make_uniform_product_space(the_strings, 2));
    ef_if_s : RETURN(make_listed_product_space([the_logicals,the_strings,the_strings]));
    ef_subscript_b : RETURN(make_listed_product_space([the_binarys,the_integers]));
    ef_eq_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_ne_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_gt_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_lt_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_ge_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_le_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_subsequence_b : RETURN(make_listed_product_space([the_binarys,the_integers,the_integers]));
    ef_concat_b : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_binarys));
    ef_size_b : RETURN(make_uniform_product_space(the_binarys, 1));
    ef_if_b : RETURN(make_listed_product_space([the_logicals,the_binarys,the_binarys]));
    ef_subscript_t : RETURN(make_listed_product_space([the_tuples,the_integers]));
    ef_eq_t : RETURN(make_uniform_product_space(the_tuples, 2));
    ef_ne_t : RETURN(make_uniform_product_space(the_tuples, 2));
    ef_concat_t : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_tuples));
    ef_size_t : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_entuple : RETURN(the_tuples);
    ef_detuple : RETURN(make_uniform_product_space(the_generics, 1));
    ef_insert : RETURN(make_listed_product_space([the_tuples,the_generics,the_integers]));
    ef_remove : RETURN(make_listed_product_space([the_tuples,the_integers]));
    ef_if_t : RETURN(make_listed_product_space([the_logicals,the_tuples,the_tuples]));
    ef_sum_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
    ef_product_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
    ef_add_it : RETURN(make_extended_tuple_space(the_integer_tuples, the_integer_tuples));
    ef_subtract_it : RETURN(make_uniform_product_space(the_integer_tuples, 2));
    ef_scalar_mult_it : RETURN(make_listed_product_space([the_integers,the_integer_tuples]));
    ef_dot_prod_it : RETURN(make_uniform_product_space(the_integer_tuples, 2));
    ef_sum_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_product_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_add_rt : RETURN(make_extended_tuple_space(the_real_tuples, the_real_tuples));
    ef_subtract_rt : RETURN(make_uniform_product_space(the_real_tuples, 2));
    ef_scalar_mult_rt : RETURN(make_listed_product_space([the_reals,the_real_tuples]));
    ef_dot_prod_rt : RETURN(make_uniform_product_space(the_real_tuples, 2));
    ef_norm_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_sum_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_product_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_add_ct : RETURN(make_extended_tuple_space(the_complex_tuples, the_complex_tuples));
    ef_subtract_ct : RETURN(make_uniform_product_space(the_complex_tuples, 2));
    ef_scalar_mult_ct : RETURN(make_listed_product_space([the_complex_numbers,the_complex_tuples]));
    ef_dot_prod_ct : RETURN(make_uniform_product_space(the_complex_tuples, 2));
    ef_norm_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_if : RETURN(make_listed_product_space([the_logicals,the_generics,the_generics]));
    ef_ensemble : RETURN(the_tuples);
    ef_member_of : RETURN(make_listed_product_space([the_generics,the_maths_spaces]));
    OTHERWISE: RETURN(?);
  END_CASE;
END_FUNCTION;

FUNCTION derive_elementary_function_range(ef_val : elementary_function_enumerators) : tuple_space;
  IF NOT EXISTS(ef_val)
  THEN
    RETURN(?);
  END_IF;
  CASE ef_val OF
    ef_and : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_or : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_not : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_xor : RETURN(make_uniform_product_space(the_logicals, 2));
    ef_negate_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_add_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_subtract_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_multiply_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_divide_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_mod_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_exponentiate_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_eq_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_gt_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_lt_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ge_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_le_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_abs_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_if_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_negate_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_reciprocal_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_add_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_subtract_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_multiply_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_divide_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_mod_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_exponentiate_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_exponentiate_ri : RETURN(make_uniform_product_space(the_reals, 1));
    ef_eq_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_gt_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_lt_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ge_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_le_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_abs_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_acos_r : RETURN(make_uniform_product_space(the_zero_pi_interval, 1));
    ef_asin_r : RETURN(make_uniform_product_space(the_neghalfpi_halfpi_interval, 1));
    ef_atan2_r : RETURN(make_uniform_product_space(the_negpi_pi_interval, 1));
    ef_cos_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
    ef_exp_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_ln_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_log2_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_log10_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_sin_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
    ef_sqrt_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_tan_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_if_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_negate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_reciprocal_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_add_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_subtract_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_multiply_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_divide_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_exponentiate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_exponentiate_ci : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_eq_c : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_c : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_conjugate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_abs_c : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_arg_c : RETURN(make_uniform_product_space(the_negpi_pi_interval, 1));
    ef_cos_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_exp_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_ln_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_sin_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_sqrt_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_tan_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_if_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_subscript_s : RETURN(make_uniform_product_space(the_strings, 1));
    ef_eq_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_gt_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_lt_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ge_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_le_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_subsequence_s : RETURN(make_uniform_product_space(the_strings, 1));
    ef_concat_s : RETURN(make_uniform_product_space(the_strings, 1));
    ef_size_s : RETURN(make_uniform_product_space(the_integers, 1));
    ef_format : RETURN(make_uniform_product_space(the_strings, 1));
    ef_value : RETURN(make_uniform_product_space(the_reals, 1));
    ef_like : RETURN(make_uniform_product_space(the_booleans, 1));
    ef_if_s : RETURN(make_uniform_product_space(the_strings, 1));
    ef_subscript_b : RETURN(make_uniform_product_space(the_binarys, 1));
    ef_eq_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_gt_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_lt_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ge_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_le_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_subsequence_b : RETURN(make_uniform_product_space(the_binarys, 1));
    ef_concat_b : RETURN(make_uniform_product_space(the_binarys, 1));
    ef_size_b : RETURN(make_uniform_product_space(the_integers, 1));
    ef_if_b : RETURN(make_uniform_product_space(the_binarys, 1));
    ef_subscript_t : RETURN(make_uniform_product_space(the_generics, 1));
    ef_eq_t : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_t : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_concat_t : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_size_t : RETURN(make_uniform_product_space(the_integers, 1));
    ef_entuple : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_detuple : RETURN(the_tuples);
    ef_insert : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_remove : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_if_t : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_sum_it : RETURN(make_uniform_product_space(the_integers, 1));
    ef_product_it : RETURN(make_uniform_product_space(the_integers, 1));
    ef_add_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
    ef_subtract_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
    ef_scalar_mult_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
    ef_dot_prod_it : RETURN(make_uniform_product_space(the_integers, 1));
    ef_sum_rt : RETURN(make_uniform_product_space(the_reals, 1));
    ef_product_rt : RETURN(make_uniform_product_space(the_reals, 1));
    ef_add_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_subtract_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_scalar_mult_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_dot_prod_rt : RETURN(make_uniform_product_space(the_reals, 1));
    ef_norm_rt : RETURN(make_uniform_product_space(the_reals, 1));
    ef_sum_ct : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_product_ct : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_add_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_subtract_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_scalar_mult_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_dot_prod_ct : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_norm_ct : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_if : RETURN(make_uniform_product_space(the_generics, 1));
    ef_ensemble : RETURN(make_uniform_product_space(the_maths_spaces, 1));
    ef_member_of : RETURN(make_uniform_product_space(the_logicals, 1));
    OTHERWISE: RETURN(?);
  END_CASE;
END_FUNCTION;

FUNCTION derive_finite_function_domain(pairs : SET [1 : ?] OF LIST [2 : 2] OF maths_value) : tuple_space;
LOCAL
  result : SET OF maths_value := [];
END_LOCAL;
  -- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
  -- three lines ambiguous in those cases where an operand is simultaneously a member
  -- of the base type and the aggregate type.
  -- REPEAT i := 1 TO SIZEOF (pairs);
  -- result := result + pairs[i][1];
  -- END_REPEAT;
  -- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components(pairs, 1);
  RETURN(one_tuples_of(make_finite_space(result)));
END_FUNCTION;

FUNCTION derive_finite_function_range(pairs : SET [1 : ?] OF LIST [2 : 2] OF maths_value) : tuple_space;
LOCAL
  result : SET OF maths_value := [];
END_LOCAL;
  -- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
  -- three lines ambiguous in those cases where an operand is simultaneously a member
  -- of the base type and the aggregate type.
  -- REPEAT i := 1 TO SIZEOF (pairs);
  -- result := result + pairs[i][2];
  -- END_REPEAT;
  -- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components(pairs, 2);
  RETURN(one_tuples_of(make_finite_space(result)));
END_FUNCTION;

FUNCTION derive_function_domain(func : maths_function) : tuple_space;
LOCAL
  typenames  : SET OF STRING                   := stripped_typeof(func);
  tspace     : tuple_space                     := make_listed_product_space([]);
  shape      : LIST OF positive_integer;
  sidxs      : LIST OF INTEGER                 := [0];
  itvl       : finite_integer_interval;
  factors    : LIST OF finite_integer_interval := [];
  is_uniform : BOOLEAN                         := TRUE;
END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames
  THEN
    RETURN(derive_finite_function_domain(func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\selector_function.source_of_domain));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames
  THEN
    RETURN(derive_elementary_function_domain(func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames
  THEN
    IF func\repackaging_function.input_repack = ro_nochange
    THEN
      RETURN(func\repackaging_function.operand.domain);
    END_IF;
    IF func\repackaging_function.input_repack = ro_wrap_as_tuple
    THEN
      RETURN(factor1(func\repackaging_function.operand.domain));
    END_IF;
    IF func\repackaging_function.input_repack = ro_unwrap_tuple
    THEN
      RETURN(one_tuples_of(func\repackaging_function.operand.domain));
    END_IF;
    RETURN(?);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames
  THEN
    shape := shape_of_array(func\unary_generic_expression.operand);
    sidxs := func\reindexed_array_function.starting_indices;
    REPEAT i := 1 TO SIZEOF(shape);
      itvl := make_finite_integer_interval(sidxs[i], sidxs[i] + shape[i] - 1);
      INSERT(factors, itvl, i - 1);
      IF shape[i] <> shape[1]
      THEN
        is_uniform := FALSE;
      END_IF;
    END_REPEAT;
    IF is_uniform
    THEN
      RETURN(make_uniform_product_space(factors[1], SIZEOF(shape)));
    END_IF;
    RETURN(make_listed_product_space(factors));
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames
  THEN
    RETURN(func\series_composed_function.operands[1].domain);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\parallel_composed_function.source_of_domain));
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames
  THEN
    shape := func\explicit_table_function.shape;
    sidxs[1] := func\explicit_table_function.index_base;
    REPEAT i := 1 TO SIZEOF(shape);
      itvl := make_finite_integer_interval(sidxs[1], sidxs[1] + shape[i] - 1);
      INSERT(factors, itvl, i - 1);
      IF shape[i] <> shape[1]
      THEN
        is_uniform := FALSE;
      END_IF;
    END_REPEAT;
    IF is_uniform
    THEN
      RETURN(make_uniform_product_space(factors[1], SIZEOF(shape)));
    END_IF;
    RETURN(make_listed_product_space(factors));
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(make_uniform_product_space(factor1(func\homogeneous_linear_function.mat.range),
                                                    func\homogeneous_linear_function.mat\explicit_table_function.shape[func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(make_uniform_product_space(factor1(func\general_linear_function.mat.range),
                                                    func\general_linear_function.mat\explicit_table_function.shape[func\general_linear_function.sum_index] -
                                                    1)));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames
  THEN
    RETURN(one_tuples_of(make_finite_real_interval(func\b_spline_basis.repeated_knots[func\b_spline_basis.order],
                                                   closed,
                                                   func\b_spline_basis.repeated_knots[func\b_spline_basis.num_basis +
                                                                                      1],
                                                   closed)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames
  THEN
    REPEAT i := 1 TO SIZEOF(func\b_spline_function.basis);
      tspace := assoc_product_space(tspace, func\b_spline_function.basis[i].domain);
    END_REPEAT;
    RETURN(one_tuples_of(tspace));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames
  THEN
    RETURN(func\rationalize_function.fun.domain);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames
  THEN
    RETURN(func\partial_derivative_function.derivand.domain);
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames
  THEN
    RETURN(derive_definite_integral_domain(func));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames
  THEN
    REPEAT i := 1 TO SIZEOF(func\abstracted_expression_function.variables);
      tspace := assoc_product_space(tspace,
                                    one_tuples_of(values_space_of(func\abstracted_expression_function.variables[i])));
    END_REPEAT;
    RETURN(tspace);
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames
  THEN
    RETURN(values_space_of(func\expression_denoted_function.expr)\function_space.domain_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(make_listed_product_space([])));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames
  THEN
    RETURN(func\imported_curve_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames
  THEN
    RETURN(func\imported_surface_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames
  THEN
    RETURN(func\imported_volume_function.parametric_domain);
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames
  THEN
    RETURN(func\application_defined_function.explicit_domain);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN(?);
END_FUNCTION;

FUNCTION derive_function_range(func : maths_function) : tuple_space;
LOCAL
  typenames : SET OF STRING       := stripped_typeof(func);
  tspace    : tuple_space         := make_listed_product_space([]);
  m         : nonnegative_integer := 0;
  n         : nonnegative_integer := 0;
  temp      : INTEGER             := 0;
END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames
  THEN
    RETURN(derive_finite_function_range(func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(make_finite_space([func\constant_function.sole_output])));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames
  THEN
    tspace := func.domain;
    IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(tspace))
    THEN
      tspace := factor1(tspace);
    END_IF;
    RETURN(one_tuples_of(factor_space(tspace, func\selector_function.selector)));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames
  THEN
    RETURN(derive_elementary_function_range(func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames
  THEN
    tspace := func\repackaging_function.operand.range;
    IF func\repackaging_function.output_repack = ro_wrap_as_tuple
    THEN
      tspace := one_tuples_of(tspace);
    END_IF;
    IF func\repackaging_function.output_repack = ro_unwrap_tuple
    THEN
      tspace := factor1(tspace);
    END_IF;
    IF func\repackaging_function.selected_output > 0
    THEN
      tspace := one_tuples_of(factor_space(tspace, func\repackaging_function.selected_output));
    END_IF;
    RETURN(tspace);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames
  THEN
    RETURN(func\unary_generic_expression.operand\maths_function.range);
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames
  THEN
    RETURN(func\series_composed_function.operands[SIZEOF(func\series_composed_function.operands)].range);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames
  THEN
    RETURN(func\parallel_composed_function.final_function.range);
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames
  THEN
    IF 'LISTED_REAL_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(the_reals));
    END_IF;
    IF 'LISTED_INTEGER_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(the_integers));
    END_IF;
    IF 'LISTED_LOGICAL_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(the_logicals));
    END_IF;
    IF 'LISTED_STRING_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(the_strings));
    END_IF;
    IF 'LISTED_COMPLEX_NUMBER_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(the_complex_numbers));
    END_IF;
    IF 'LISTED_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(func\listed_data.value_range));
    END_IF;
    IF 'EXTERNALLY_LISTED_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(func\externally_listed_data.value_range));
    END_IF;
    IF 'LINEARIZED_TABLE_FUNCTION' IN typenames
    THEN
      RETURN(func\linearized_table_function.source.range);
    END_IF;
    IF 'BASIC_SPARSE_MATRIX' IN typenames
    THEN
      RETURN(func\basic_sparse_matrix.val.range);
    END_IF;
    RETURN(?);
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(make_uniform_product_space(factor1(func\homogeneous_linear_function.mat.range),
                                                    func\homogeneous_linear_function.mat\explicit_table_function.shape[3 -
                                                                                                                       func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(make_uniform_product_space(factor1(func\general_linear_function.mat.range),
                                                    func\general_linear_function.mat\explicit_table_function.shape[3 -
                                                                                                                   func\general_linear_function.sum_index])));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames
  THEN
    RETURN(one_tuples_of(make_uniform_product_space(the_reals, func\b_spline_basis.num_basis)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames
  THEN
    tspace := factor1(func\b_spline_function.coef.domain);
    m := SIZEOF(func\b_spline_function.basis);
    n := space_dimension(tspace);
    IF m = n
    THEN
      RETURN(one_tuples_of(the_reals));
    END_IF;
    IF m = n - 1
    THEN
      RETURN(one_tuples_of(make_uniform_product_space(the_reals,
                                                      factor_space(tspace, n)\finite_integer_interval.size)));
    END_IF;
    tspace := extract_factors(tspace, m + 1, n);
    RETURN(one_tuples_of(make_function_space(sc_equal, tspace, sc_subspace,
                                             number_superspace_of(func\b_spline_function.coef.range))));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames
  THEN
    tspace := factor1(func\rationalize_function.fun.range);
    n := space_dimension(tspace);
    RETURN(one_tuples_of(make_uniform_product_space(number_superspace_of(factor1(tspace)), n - 1)));
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames
  THEN
    RETURN(drop_numeric_constraints(func\partial_derivative_function.derivand.range));
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames
  THEN
    RETURN(drop_numeric_constraints(func\definite_integral_function.integrand.range));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(values_space_of(func\abstracted_expression_function.expr)));
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames
  THEN
    RETURN(values_space_of(func\expression_denoted_function.expr)\function_space.range_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames
  THEN
    temp := dimension_of(func\imported_point_function.geometry);
    RETURN(one_tuples_of(make_uniform_product_space(the_reals, temp)));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames
  THEN
    temp := dimension_of(func\imported_curve_function.geometry);
    RETURN(one_tuples_of(make_uniform_product_space(the_reals, temp)));
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames
  THEN
    temp := dimension_of(func\imported_surface_function.geometry);
    RETURN(one_tuples_of(make_uniform_product_space(the_reals, temp)));
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames
  THEN
    temp := dimension_of(func\imported_volume_function.geometry);
    RETURN(one_tuples_of(make_uniform_product_space(the_reals, temp)));
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames
  THEN
    RETURN(func\application_defined_function.explicit_range);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN(?);
END_FUNCTION;

FUNCTION dimension_of(item : geometric_representation_item) : dimension_count;
LOCAL
  x   : SET OF representation;
  y   : representation_context;
  dim : dimension_count;
END_LOCAL;
  -- For cartesian_point, direction, or vector dimension is determined by
  -- counting components.
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CARTESIAN_POINT' IN TYPEOF(item)
  THEN
    dim := SIZEOF(item\cartesian_point.coordinates);
    RETURN(dim);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DIRECTION' IN TYPEOF(item)
  THEN
    dim := SIZEOF(item\direction.direction_ratios);
    RETURN(dim);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VECTOR' IN TYPEOF(item)
  THEN
    dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
    RETURN(dim);
  END_IF;
  -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 
  x := using_representations(item);
  -- Determines the dimension_count of the 
  -- geometric_representation_context.
  -- The SET x is non-empty for legal instances since this is required by WR1 of
  -- representation_item.
  IF (SIZEOF(x) > 0)
  THEN
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN(dim);
  ELSE
    RETURN(?);
  END_IF;
END_FUNCTION;

FUNCTION dimensions_for_si_unit(n : si_unit_name) : dimensional_exponents;
  CASE n OF
    metre : RETURN(dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    gram : RETURN(dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    second : RETURN(dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
    ampere : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
    kelvin : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    mole : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
    candela : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    radian : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    steradian : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    hertz : RETURN(dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    newton : RETURN(dimensional_exponents(1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    pascal : RETURN(dimensional_exponents(-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    joule : RETURN(dimensional_exponents(2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    watt : RETURN(dimensional_exponents(2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
    coulomb : RETURN(dimensional_exponents(0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
    volt : RETURN(dimensional_exponents(2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
    farad : RETURN(dimensional_exponents(-2.0, -1.0, 4.0, 2.0, 0.0, 0.0, 0.0));
    ohm : RETURN(dimensional_exponents(2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
    siemens : RETURN(dimensional_exponents(-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
    weber : RETURN(dimensional_exponents(2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    tesla : RETURN(dimensional_exponents(0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    henry : RETURN(dimensional_exponents(2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
    degree_celsius : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    lumen : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    lux : RETURN(dimensional_exponents(-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    becquerel : RETURN(dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    gray : RETURN(dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    sievert : RETURN(dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    OTHERWISE: RETURN(?);
  END_CASE;
END_FUNCTION;

FUNCTION domain_from(ref : maths_space_or_function) : tuple_space;
LOCAL
  typenames : SET OF STRING  := stripped_typeof(ref);
  func      : maths_function;
END_LOCAL;
  IF NOT EXISTS(ref)
  THEN
    RETURN(?);
  END_IF;
  IF 'TUPLE_SPACE' IN typenames
  THEN
    RETURN(ref);
  END_IF;
  IF 'MATHS_SPACE' IN typenames
  THEN
    RETURN(one_tuples_of(ref));
  END_IF;
  func := ref;
  IF 'CONSTANT_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\selector_function.source_of_domain));
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\parallel_composed_function.source_of_domain));
  END_IF;
  RETURN(func.domain);
END_FUNCTION;

FUNCTION dot_count(str : STRING) : INTEGER;
LOCAL
  n : INTEGER := 0;
END_LOCAL;
  REPEAT i := 1 TO LENGTH(str);
    IF str[i] = '.'
    THEN
      n := n + 1;
    END_IF;
  END_REPEAT;
  RETURN(n);
END_FUNCTION;

FUNCTION dot_product(arg1 : direction;
                     arg2 : direction) : REAL;
LOCAL
  scalar : REAL;
  vec1   : direction;
  vec2   : direction;
  ndim   : INTEGER;
END_LOCAL;
  IF NOT EXISTS(arg1) OR NOT EXISTS(arg2)
  THEN
    scalar := ?;
  ELSE
    IF (arg1.dim <> arg2.dim)
    THEN
      scalar := ?;
    ELSE
      BEGIN  
             vec1 := normalise(arg1);
             vec2 := normalise(arg2);
             ndim := arg1.dim;
             scalar := 0.0;
             REPEAT i := 1 TO ndim;
               scalar := scalar + vec1.direction_ratios[i] * vec2.direction_ratios[i];
             END_REPEAT;
      END;
    END_IF;
  END_IF;
  RETURN(scalar);
END_FUNCTION;

FUNCTION dotted_identifiers_syntax(str : STRING) : BOOLEAN;
LOCAL
  k : positive_integer;
  m : positive_integer;
END_LOCAL;
  IF NOT EXISTS(str)
  THEN
    RETURN(FALSE);
  END_IF;
  k := parse_express_identifier(str, 1);
  IF k = 1
  THEN
    RETURN(FALSE);
  END_IF;
  REPEAT WHILE k <= LENGTH(str);
    IF (str[k] <> '.') OR (k = LENGTH(str))
    THEN
      RETURN(FALSE);
    END_IF;
    m := parse_express_identifier(str, k + 1);
    IF m = k + 1
    THEN
      RETURN(FALSE);
    END_IF;
    k := m;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION drop_numeric_constraints(spc : maths_space) : maths_space;
LOCAL
  typenames : SET OF STRING        := stripped_typeof(spc);
  tspc      : listed_product_space;
  factors   : LIST OF maths_space  := [];
  xspc      : extended_tuple_space;
END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN typenames
  THEN
    RETURN(make_uniform_product_space(drop_numeric_constraints(spc\uniform_product_space.base),
                                      spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN typenames
  THEN
    tspc := spc;
    REPEAT i := 1 TO SIZEOF(tspc.factors);
      INSERT(factors, drop_numeric_constraints(tspc.factors[i]), i - 1);
    END_REPEAT;
    RETURN(make_listed_product_space(factors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN typenames
  THEN
    xspc := spc;
    RETURN(make_extended_tuple_space(drop_numeric_constraints(xspc.base), drop_numeric_constraints(xspc.extender)));
  END_IF;
  IF subspace_of_es(spc, es_numbers)
  THEN
    RETURN(number_superspace_of(spc));
  END_IF;
  RETURN(spc);
END_FUNCTION;

FUNCTION duration_is_negative(duration : time_measure_with_unit) : BOOLEAN;
  IF (duration\measure_with_unit.value_component < 0.0)
  THEN
    RETURN(TRUE);
  ELSE
    RETURN(FALSE);
  END_IF;
END_FUNCTION;

FUNCTION duration_is_positive(duration : time_measure_with_unit) : BOOLEAN;
  IF (duration\measure_with_unit.value_component > 0.0)
  THEN
    RETURN(TRUE);
  ELSE
    RETURN(FALSE);
  END_IF;
END_FUNCTION;

FUNCTION enclose_cregion_in_pregion(crgn : cartesian_complex_number_region;
                                    centre : complex_number_literal) : polar_complex_number_region;
FUNCTION angle(a : REAL) : REAL;
  REPEAT WHILE a > PI;
    a := a - 2.0 * PI;
  END_REPEAT;
  REPEAT WHILE a <= -PI;
    a := a + 2.0 * PI;
  END_REPEAT;
  RETURN(a);
END_FUNCTION;
FUNCTION strictly_in(z : REAL;
                     zitv : real_interval) : LOGICAL;
  RETURN((NOT min_exists(zitv) OR (z > real_min(zitv))) AND (NOT max_exists(zitv) OR (z < real_max(zitv))));
END_FUNCTION;
PROCEDURE angle_minmax(ab : REAL; a : REAL; a_in : BOOLEAN; VAR amin : REAL; VAR amax : REAL; VAR amin_in : BOOLEAN;
                       VAR amax_in : BOOLEAN);
  a := angle(a - ab);
  IF amin = a
  THEN
    amin_in := amin_in OR a_in;
  END_IF;
  IF amin > a
  THEN
    amin := a;
    amin_in := a_in;
  END_IF;
  IF amax = a
  THEN
    amax_in := amax_in OR a_in;
  END_IF;
  IF amax < a
  THEN
    amax := a;
    amax_in := a_in;
  END_IF;
END_PROCEDURE;
PROCEDURE range_max(r : REAL; incl : BOOLEAN; VAR rmax : REAL; VAR rmax_in : BOOLEAN);
  IF rmax = r
  THEN
    rmax_in := rmax_in OR incl;
  END_IF;
  IF rmax < r
  THEN
    rmax := r;
    rmax_in := incl;
  END_IF;
END_PROCEDURE;
PROCEDURE range_min(r : REAL; incl : BOOLEAN; VAR rmin : REAL; VAR rmin_in : BOOLEAN);
  IF rmin = r
  THEN
    rmin_in := rmin_in OR incl;
  END_IF;
  IF (rmin < 0.0) OR (rmin > r)
  THEN
    rmin := r;
    rmin_in := incl;
  END_IF;
END_PROCEDURE;
LOCAL
  xitv        : real_interval;
  yitv        : real_interval;
  is_xmin     : BOOLEAN;
  is_xmax     : BOOLEAN;
  is_ymin     : BOOLEAN;
  is_ymax     : BOOLEAN;
  xmin        : REAL                 := 0.0;
  xmax        : REAL                 := 0.0;
  ymin        : REAL                 := 0.0;
  ymax        : REAL                 := 0.0;
  xc          : REAL                 := 0.0;
  yc          : REAL                 := 0.0;
  xmin_in     : BOOLEAN              := FALSE;
  xmax_in     : BOOLEAN              := FALSE;
  ymin_in     : BOOLEAN              := FALSE;
  ymax_in     : BOOLEAN              := FALSE;
  rmin        : REAL                 := -1.0;
  rmax        : REAL                 := -1.0;
  amin        : REAL                 := 4.0;
  amax        : REAL                 := -4.0;
  rmax_exists : BOOLEAN              := TRUE;
  outside     : BOOLEAN              := TRUE;
  rmin_in     : BOOLEAN              := FALSE;
  rmax_in     : BOOLEAN              := FALSE;
  amin_in     : BOOLEAN              := FALSE;
  amax_in     : BOOLEAN              := FALSE;
  ab          : REAL                 := 0.0;
  a           : REAL                 := 0.0;
  r           : REAL                 := 0.0;
  incl        : BOOLEAN;
  ritv        : real_interval;
  aitv        : finite_real_interval;
  minclo      : open_closed          := open;
  maxclo      : open_closed          := open;
END_LOCAL;
  IF NOT EXISTS(crgn) OR NOT EXISTS(centre)
  THEN
    RETURN(?);
  END_IF;
  -- Extract elementary input information
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  is_xmin := min_exists(xitv);
  is_xmax := max_exists(xitv);
  is_ymin := min_exists(yitv);
  is_ymax := max_exists(yitv);
  IF is_xmin
  THEN
    xmin := real_min(xitv);
    xmin_in := min_included(xitv);
  END_IF;
  IF is_xmax
  THEN
    xmax := real_max(xitv);
    xmax_in := max_included(xitv);
  END_IF;
  IF is_ymin
  THEN
    ymin := real_min(yitv);
    ymin_in := min_included(yitv);
  END_IF;
  IF is_ymax
  THEN
    ymax := real_max(yitv);
    ymax_in := max_included(yitv);
  END_IF;
  rmax_exists := is_xmin AND is_xmax AND is_ymin AND is_ymax;
  -- Identify base direction with respect to which all relevant directions lie
  -- within +/- 0.5*PI, or that the centre lies properly inside crgn.
  IF is_xmin AND (xc <= xmin)
  THEN
    ab := 0.0;
  ELSE
    IF is_ymin AND (yc <= ymin)
    THEN
      ab := 0.5 * PI;
    ELSE
      IF is_ymax AND (yc >= ymax)
      THEN
        ab := -0.5 * PI;
      ELSE
        IF is_xmax AND (xc >= xmax)
        THEN
          ab := PI;
        ELSE
          outside := FALSE;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  IF NOT outside AND NOT rmax_exists
  THEN
    RETURN(?);
  END_IF;
  -- Identify any closest point on a side but not a corner.
  IF is_xmin AND (xc <= xmin) AND strictly_in(yc, yitv)
  THEN
    rmin := xmin - xc;
    rmin_in := xmin_in;
  ELSE
    IF is_ymin AND (yc <= ymin) AND strictly_in(xc, xitv)
    THEN
      rmin := ymin - yc;
      rmin_in := ymin_in;
    ELSE
      IF is_ymax AND (yc >= ymax) AND strictly_in(xc, xitv)
      THEN
        rmin := yc - ymax;
        rmin_in := ymax_in;
      ELSE
        IF is_xmax AND (xc >= xmax) AND strictly_in(yc, yitv)
        THEN
          rmin := xc - xmax;
          rmin_in := xmax_in;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  IF is_xmin
  THEN
    IF is_ymin
    THEN
      r := SQRT((xmin - xc) ** 2 + (ymin - yc) ** 2);
      incl := xmin_in AND ymin_in;
      IF rmax_exists
      THEN
        range_max(r, incl, rmax, rmax_in);
      END_IF;
      IF outside
      THEN
        IF r > 0.0
        THEN
          range_min(r, incl, rmin, rmin_in);
          a := angle(atan2(ymin - yc, xmin - xc) - ab);
          IF xc = xmin
          THEN
            incl := xmin_in;
          END_IF;
          IF yc = ymin
          THEN
            incl := ymin_in;
          END_IF;
          angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
        ELSE
          rmin := 0.0;
          rmin_in := xmin_in AND ymin_in;
          amin := angle(0.0 - ab);
          amin_in := ymin_in;
          amax := angle(0.5 * PI - ab);
          amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE
      IF xc <= xmin
      THEN
        angle_minmax(ab, -0.5 * PI, (xc = xmin) AND xmin_in, amin, amax, amin_in, amax_in);
      END_IF;
    END_IF;
    IF NOT is_ymax AND (xc <= xmin)
    THEN
      angle_minmax(ab, 0.5 * PI, (xc = xmin) AND xmin_in, amin, amax, amin_in, amax_in);
    END_IF;
  END_IF;
  IF is_ymin
  THEN
    IF is_xmax
    THEN
      r := SQRT((xmax - xc) ** 2 + (ymin - yc) ** 2);
      incl := xmax_in AND ymin_in;
      IF rmax_exists
      THEN
        range_max(r, incl, rmax, rmax_in);
      END_IF;
      IF outside
      THEN
        IF r > 0.0
        THEN
          range_min(r, incl, rmin, rmin_in);
          a := angle(atan2(ymin - yc, xmax - xc) - ab);
          IF xc = xmax
          THEN
            incl := xmax_in;
          END_IF;
          IF yc = ymin
          THEN
            incl := ymin_in;
          END_IF;
          angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
        ELSE
          rmin := 0.0;
          rmin_in := xmax_in AND ymin_in;
          amin := angle(0.5 * PI - ab);
          amin_in := ymin_in;
          amax := angle(PI - ab);
          amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE
      IF yc <= ymin
      THEN
        angle_minmax(ab, 0.0, (yc = ymin) AND ymin_in, amin, amax, amin_in, amax_in);
      END_IF;
    END_IF;
    IF NOT is_xmin AND (yc <= ymin)
    THEN
      angle_minmax(ab, PI, (yc = ymin) AND ymin_in, amin, amax, amin_in, amax_in);
    END_IF;
  END_IF;
  IF is_xmax
  THEN
    IF is_ymax
    THEN
      r := SQRT((xmax - xc) ** 2 + (ymax - yc) ** 2);
      incl := xmax_in AND ymax_in;
      IF rmax_exists
      THEN
        range_max(r, incl, rmax, rmax_in);
      END_IF;
      IF outside
      THEN
        IF r > 0.0
        THEN
          range_min(r, incl, rmin, rmin_in);
          a := angle(atan2(ymax - yc, xmax - xc) - ab);
          IF xc = xmax
          THEN
            incl := xmax_in;
          END_IF;
          IF yc = ymax
          THEN
            incl := ymax_in;
          END_IF;
          angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
        ELSE
          rmin := 0.0;
          rmin_in := xmax_in AND ymax_in;
          amin := angle(-PI - ab);
          amin_in := ymax_in;
          amax := angle(-0.5 * PI - ab);
          amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE
      IF xc >= xmax
      THEN
        angle_minmax(ab, 0.5 * PI, (xc = xmax) AND xmax_in, amin, amax, amin_in, amax_in);
      END_IF;
    END_IF;
    IF NOT is_ymin AND (xc >= xmax)
    THEN
      angle_minmax(ab, -0.5 * PI, (xc = xmax) AND xmax_in, amin, amax, amin_in, amax_in);
    END_IF;
  END_IF;
  IF is_ymax
  THEN
    IF is_xmin
    THEN
      r := SQRT((xmin - xc) ** 2 + (ymax - yc) ** 2);
      incl := xmin_in AND ymax_in;
      IF rmax_exists
      THEN
        range_max(r, incl, rmax, rmax_in);
      END_IF;
      IF outside
      THEN
        IF r > 0.0
        THEN
          range_min(r, incl, rmin, rmin_in);
          a := angle(atan2(ymax - yc, xmin - xc) - ab);
          IF xc = xmin
          THEN
            incl := xmin_in;
          END_IF;
          IF yc = ymax
          THEN
            incl := ymax_in;
          END_IF;
          angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
        ELSE
          rmin := 0.0;
          rmin_in := xmin_in AND ymax_in;
          amin := angle(0.5 * PI - ab);
          amin_in := ymax_in;
          amax := angle(PI - ab);
          amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE
      IF yc >= ymax
      THEN
        angle_minmax(ab, PI, (yc = ymax) AND ymax_in, amin, amax, amin_in, amax_in);
      END_IF;
    END_IF;
    IF NOT is_xmax AND (yc >= ymax)
    THEN
      angle_minmax(ab, 0.0, (yc = ymax) AND ymax_in, amin, amax, amin_in, amax_in);
    END_IF;
  END_IF;
  IF outside
  THEN
    amin := angle(amin + ab);
    IF amin = PI
    THEN
      amin := -PI;
    END_IF;
    amax := angle(amax + ab);
    IF amax <= amin
    THEN
      amax := amax + 2.0 * PI;
    END_IF;
  ELSE
    amin := -PI;
    amin_in := FALSE;
    amax := PI;
    amax_in := FALSE;
  END_IF;
  IF amin_in
  THEN
    minclo := closed;
  END_IF;
  IF amax_in
  THEN
    maxclo := closed;
  END_IF;
  aitv := make_finite_real_interval(amin, minclo, amax, maxclo);
  minclo := open;
  IF rmin_in
  THEN
    minclo := closed;
  END_IF;
  IF rmax_exists
  THEN
    maxclo := open;
    IF rmax_in
    THEN
      maxclo := closed;
    END_IF;
    ritv := make_finite_real_interval(rmin, minclo, rmax, maxclo);
  ELSE
    ritv := make_real_interval_from_min(rmin, minclo);
  END_IF;
  RETURN(make_polar_complex_number_region(centre, ritv, aitv));
END_FUNCTION;

FUNCTION enclose_pregion_in_cregion(prgn : polar_complex_number_region) : cartesian_complex_number_region;
PROCEDURE nearest_good_direction(acart : REAL; aitv : finite_real_interval; VAR a : REAL; VAR a_in : BOOLEAN);
  a := acart;
  a_in := TRUE;
  IF a < aitv.min
  THEN
    IF a + 2.0 * PI < aitv.max
    THEN
      RETURN;
    END_IF;
    IF a + 2.0 * PI = aitv.max
    THEN
      a_in := max_included(aitv);
      RETURN;
    END_IF;
  ELSE
    IF a = aitv.min
    THEN
      a_in := min_included(aitv);
      RETURN;
    ELSE
      IF a < aitv.max
      THEN
        RETURN;
      ELSE
        IF a = aitv.max
        THEN
          a_in := max_included(aitv);
          RETURN;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  IF COS(acart - aitv.max) >= COS(acart - aitv.min)
  THEN
    a := aitv.max;
    a_in := max_included(aitv);
  ELSE
    a := aitv.min;
    a_in := min_included(aitv);
  END_IF;
END_PROCEDURE;
LOCAL
  xc          : REAL                 := 0.0;
  yc          : REAL                 := 0.0;
  xmin        : REAL                 := 0.0;
  xmax        : REAL                 := 0.0;
  ymin        : REAL                 := 0.0;
  ymax        : REAL                 := 0.0;
  ritv        : real_interval;
  xitv        : real_interval;
  yitv        : real_interval;
  aitv        : finite_real_interval;
  xmin_exists : BOOLEAN;
  xmax_exists : BOOLEAN;
  ymin_exists : BOOLEAN;
  ymax_exists : BOOLEAN;
  xmin_in     : BOOLEAN              := FALSE;
  xmax_in     : BOOLEAN              := FALSE;
  ymin_in     : BOOLEAN              := FALSE;
  ymax_in     : BOOLEAN              := FALSE;
  a           : REAL                 := 0.0;
  r           : REAL                 := 0.0;
  a_in        : BOOLEAN              := FALSE;
  min_clo     : open_closed          := open;
  max_clo     : open_closed          := open;
END_LOCAL;
  IF NOT EXISTS(prgn)
  THEN
    RETURN(?);
  END_IF;
  -- Extract elementary input data
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  ritv := prgn.distance_constraint;
  aitv := prgn.direction_constraint;
  -- Determine xmin data
  nearest_good_direction(PI, aitv, a, a_in);
  IF COS(a) >= 0.0
  THEN
    xmin_exists := TRUE;
    xmin := xc + real_min(ritv) * COS(a);
    xmin_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv)
    THEN
      xmin_exists := TRUE;
      xmin := xc + real_max(ritv) * COS(a);
      xmin_in := a_in AND max_included(ritv);
    ELSE
      xmin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine xmax data
  nearest_good_direction(0.0, aitv, a, a_in);
  IF COS(a) <= 0.0
  THEN
    xmax_exists := TRUE;
    xmax := xc + real_min(ritv) * COS(a);
    xmax_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv)
    THEN
      xmax_exists := TRUE;
      xmax := xc + real_max(ritv) * COS(a);
      xmax_in := a_in AND max_included(ritv);
    ELSE
      xmax_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymin data
  nearest_good_direction(-0.5 * PI, aitv, a, a_in);
  IF SIN(a) >= 0.0
  THEN
    ymin_exists := TRUE;
    ymin := yc + real_min(ritv) * SIN(a);
    ymin_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv)
    THEN
      ymin_exists := TRUE;
      ymin := yc + real_max(ritv) * SIN(a);
      ymin_in := a_in AND max_included(ritv);
    ELSE
      ymin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymax data
  nearest_good_direction(0.5 * PI, aitv, a, a_in);
  IF SIN(a) <= 0.0
  THEN
    ymax_exists := TRUE;
    ymax := yc + real_min(ritv) * SIN(a);
    ymax_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv)
    THEN
      ymax_exists := TRUE;
      ymax := yc + real_max(ritv) * SIN(a);
      ymax_in := a_in AND max_included(ritv);
    ELSE
      ymax_exists := FALSE;
    END_IF;
  END_IF;
  -- Construct result
  IF NOT (xmin_exists OR xmax_exists OR ymin_exists OR ymax_exists)
  THEN
    RETURN(?);
  END_IF;
  -- Construct real_constraint
  IF xmin_exists
  THEN
    IF xmin_in
    THEN
      min_clo := closed;
    ELSE
      min_clo := open;
    END_IF;
    IF xmax_exists
    THEN
      IF xmax_in
      THEN
        max_clo := closed;
      ELSE
        max_clo := open;
      END_IF;
      xitv := make_finite_real_interval(xmin, min_clo, xmax, max_clo);
    ELSE
      xitv := make_real_interval_from_min(xmin, min_clo);
    END_IF;
  ELSE
    IF xmax_exists
    THEN
      IF xmax_in
      THEN
        max_clo := closed;
      ELSE
        max_clo := open;
      END_IF;
      xitv := make_real_interval_to_max(xmax, max_clo);
    ELSE
      xitv := the_reals;
    END_IF;
  END_IF;
  -- Construct imag_constraint
  IF ymin_exists
  THEN
    IF ymin_in
    THEN
      min_clo := closed;
    ELSE
      min_clo := open;
    END_IF;
    IF ymax_exists
    THEN
      IF ymax_in
      THEN
        max_clo := closed;
      ELSE
        max_clo := open;
      END_IF;
      yitv := make_finite_real_interval(ymin, min_clo, ymax, max_clo);
    ELSE
      yitv := make_real_interval_from_min(ymin, min_clo);
    END_IF;
  ELSE
    IF ymax_exists
    THEN
      IF ymax_in
      THEN
        max_clo := closed;
      ELSE
        max_clo := open;
      END_IF;
      yitv := make_real_interval_to_max(ymax, max_clo);
    ELSE
      yitv := the_reals;
    END_IF;
  END_IF;
  -- Construct cartesian region
  RETURN(make_cartesian_complex_number_region(xitv, yitv));
END_FUNCTION;

FUNCTION enclose_pregion_in_pregion(prgn : polar_complex_number_region;
                                    centre : complex_number_literal) : polar_complex_number_region;
FUNCTION angle(a : REAL) : REAL;
  REPEAT WHILE a > PI;
    a := a - 2.0 * PI;
  END_REPEAT;
  REPEAT WHILE a <= -PI;
    a := a + 2.0 * PI;
  END_REPEAT;
  RETURN(a);
END_FUNCTION;
PROCEDURE angle_range(VAR amin : REAL; VAR amax : REAL);
  amin := angle(amin);
  IF amin = PI
  THEN
    amin := -PI;
  END_IF;
  amax := angle(amax);
  IF amax <= amin
  THEN
    amax := amax + 2.0 * PI;
  END_IF;
END_PROCEDURE;
FUNCTION strictly_in(a : REAL;
                     aitv : finite_real_interval) : LOGICAL;
  a := angle(a);
  RETURN({aitv.min < a < aitv.max} OR {aitv.min < a + 2.0 * PI < aitv.max});
END_FUNCTION;
PROCEDURE find_aminmax(ab : REAL; a0 : REAL; a1 : REAL; a2 : REAL; a3 : REAL; in0 : BOOLEAN; in1 : BOOLEAN;
                       in2 : BOOLEAN; in3 : BOOLEAN; VAR amin : REAL; VAR amax : REAL; VAR amin_in : BOOLEAN;
                       VAR amax_in : BOOLEAN);
 LOCAL  
        a : REAL;
 END_LOCAL;
  amin := angle(a0 - ab);
  amin_in := in0;
  amax := amin;
  amax_in := in0;
  a := angle(a1 - ab);
  IF a = amin
  THEN
    amin_in := amin_in OR in1;
  END_IF;
  IF a < amin
  THEN
    amin := a;
    amin_in := in1;
  END_IF;
  IF a = amax
  THEN
    amax_in := amax_in OR in1;
  END_IF;
  IF a > amax
  THEN
    amax := a;
    amax_in := in1;
  END_IF;
  a := angle(a2 - ab);
  IF a = amin
  THEN
    amin_in := amin_in OR in2;
  END_IF;
  IF a < amin
  THEN
    amin := a;
    amin_in := in2;
  END_IF;
  IF a = amax
  THEN
    amax_in := amax_in OR in2;
  END_IF;
  IF a > amax
  THEN
    amax := a;
    amax_in := in2;
  END_IF;
  a := angle(a3 - ab);
  IF a = amin
  THEN
    amin_in := amin_in OR in3;
  END_IF;
  IF a < amin
  THEN
    amin := a;
    amin_in := in3;
  END_IF;
  IF a = amax
  THEN
    amax_in := amax_in OR in3;
  END_IF;
  IF a > amax
  THEN
    amax := a;
    amax_in := in3;
  END_IF;
  amin := amin + ab;
  amax := amax + ab;
  angle_range(amin, amax);
END_PROCEDURE;
LOCAL
  ritp    : real_interval;
  ritv    : real_interval;
  aitp    : finite_real_interval;
  aitv    : finite_real_interval;
  xp      : REAL                 := 0.0;
  yp      : REAL                 := 0.0;
  xc      : REAL                 := 0.0;
  yc      : REAL                 := 0.0;
  rmax    : REAL                 := 0.0;
  rmin    : REAL                 := 0.0;
  amin    : REAL                 := 0.0;
  amax    : REAL                 := 0.0;
  rc      : REAL                 := 0.0;
  acp     : REAL                 := 0.0;
  apc     : REAL                 := 0.0;
  rmax_in : BOOLEAN              := FALSE;
  rmin_in : BOOLEAN              := FALSE;
  amin_in : BOOLEAN              := FALSE;
  amax_in : BOOLEAN              := FALSE;
  rmxp    : REAL                 := 0.0;
  rmnp    : REAL                 := 0.0;
  x       : REAL                 := 0.0;
  y       : REAL                 := 0.0;
  r       : REAL                 := 0.0;
  a       : REAL                 := 0.0;
  ab      : REAL                 := 0.0;
  r0      : REAL                 := 0.0;
  a0      : REAL                 := 0.0;
  r1      : REAL                 := 0.0;
  a1      : REAL                 := 0.0;
  r2      : REAL                 := 0.0;
  a2      : REAL                 := 0.0;
  r3      : REAL                 := 0.0;
  a3      : REAL                 := 0.0;
  in0     : BOOLEAN              := FALSE;
  in1     : BOOLEAN              := FALSE;
  in2     : BOOLEAN              := FALSE;
  in3     : BOOLEAN              := FALSE;
  inn     : BOOLEAN              := FALSE;
  minclo  : open_closed          := open;
  maxclo  : open_closed          := open;
END_LOCAL;
  -- Extract elementary input information
  IF NOT EXISTS(prgn) OR NOT EXISTS(centre)
  THEN
    RETURN(?);
  END_IF;
  xp := prgn.centre.real_part;
  yp := prgn.centre.imag_part;
  ritp := prgn.distance_constraint;
  aitp := prgn.direction_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  IF (xc = xp) AND (yc = yp)
  THEN
    RETURN(prgn);
  END_IF;
  rc := SQRT((xp - xc) ** 2 + (yp - yc) ** 2);
  acp := atan2(yp - yc, xp - xc);
  apc := atan2(yc - yp, xc - xp);
  rmnp := real_min(ritp);
  -- Analyse cases by existence of max distance and direction limits
  IF max_exists(ritp)
  THEN
    rmxp := real_max(ritp);
    IF aitp.max - aitp.min = 2.0 * PI
    THEN
      inn := NOT max_included(aitp);
      a := angle(aitp.min);
      rmax := rc + rmxp;
      rmax_in := max_included(ritp);
      IF inn AND (acp = a)
      THEN
        rmax_in := FALSE;
      END_IF;
      IF rc > rmxp
      THEN
        a0 := ASIN(rmxp / rc);
        amin := angle(acp - a0);
        amin_in := max_included(ritp);
        IF amin = PI
        THEN
          amin := -PI;
        END_IF;
        amax := angle(acp + a0);
        amax_in := amin_in;
        IF amax < amin
        THEN
          amax := amax + 2.0 * PI;
        END_IF;
        rmin := rc - rmxp;
        rmin_in := amin_in;
        IF inn
        THEN
          IF apc = a
          THEN
            rmin_in := FALSE;
          END_IF;
          IF angle(amin + 0.5 * PI) = a
          THEN
            amin_in := FALSE;
          END_IF;
          IF angle(amax - 0.5 * PI) = a
          THEN
            amax_in := FALSE;
          END_IF;
        END_IF;
      ELSE
        IF rc = rmxp
        THEN
          amin := angle(acp - 0.5 * PI);
          amin_in := FALSE;
          IF amin = PI
          THEN
            amin := -PI;
          END_IF;
          amax := angle(acp + 0.5 * PI);
          amax_in := FALSE;
          IF amax < amin
          THEN
            amax := amax + 2.0 * PI;
          END_IF;
          rmin := 0.0;
          rmin_in := max_included(ritp);
          IF inn AND (apc = a)
          THEN
            rmin_in := FALSE;
          END_IF;
        ELSE
          IF rc > rmnp
          THEN
            IF inn AND (apc = a)
            THEN
              rmin := 0.0;
              rmin_in := FALSE;
              amin := aitp.min;
              amin_in := FALSE;
              amax := aitp.max;
              amax_in := FALSE;
            ELSE
              rmin := 0.0;
              rmin_in := TRUE;
              amin := -PI;
              amin_in := FALSE;
              amax := PI;
              amax_in := TRUE;
            END_IF;
          ELSE
            rmin := rmnp - rc;
            rmin_in := min_included(ritp);
            amin := -PI;
            amin_in := FALSE;
            amax := PI;
            amax_in := TRUE;
            IF inn
            THEN
              IF apc = a
              THEN
                rmin_in := FALSE;
                amin := aitp.min;
                amin_in := FALSE;
                amax := aitp.max;
                amax_in := FALSE;
              ELSE
                IF acp = a
                THEN
                  amin := aitp.min;
                  amin_in := FALSE;
                  amax := aitp.max;
                  amax_in := FALSE;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    ELSE
      x := xp + rmxp * COS(aitp.min) - xc;
      y := yp + rmxp * SIN(aitp.min) - yc;
      r0 := SQRT(x ** 2 + y ** 2);
      in0 := max_included(ritp) AND min_included(aitp);
      IF r0 <> 0.0
      THEN
        a0 := atan2(y, x);
      END_IF;
      x := xp + rmxp * COS(aitp.max) - xc;
      y := yp + rmxp * SIN(aitp.max) - yc;
      r1 := SQRT(x ** 2 + y ** 2);
      in1 := max_included(ritp) AND max_included(aitp);
      IF r1 <> 0.0
      THEN
        a1 := atan2(y, x);
      END_IF;
      x := xp + rmnp * COS(aitp.max) - xc;
      y := yp + rmnp * SIN(aitp.max) - yc;
      r2 := SQRT(x ** 2 + y ** 2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 <> 0.0
      THEN
        a2 := atan2(y, x);
      ELSE
        a2 := a1;
        in2 := in1;
      END_IF;
      IF r1 = 0.0
      THEN
        a1 := a2;
        in1 := in2;
      END_IF;
      x := xp + rmnp * COS(aitp.min) - xc;
      y := yp + rmnp * SIN(aitp.min) - yc;
      r3 := SQRT(x ** 2 + y ** 2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 <> 0.0
      THEN
        a3 := atan2(y, x);
      ELSE
        a3 := a0;
        in3 := in0;
      END_IF;
      IF r0 = 0.0
      THEN
        a0 := a3;
        in0 := in3;
      END_IF;
      IF rmnp = 0.0
      THEN
        in2 := min_included(ritp);
        in3 := in2;
      END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min))
      THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE
        IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max))
        THEN
          in1 := max_included(aitp);
          in2 := in1;
        END_IF;
      END_IF;
      IF strictly_in(acp, aitp)
      THEN
        rmax := rc + rmxp;
        rmax_in := max_included(ritp);
      ELSE
        rmax := r0;
        rmax_in := in0;
        IF rmax = r1
        THEN
          rmax_in := rmax_in OR in1;
        END_IF;
        IF rmax < r1
        THEN
          rmax := r1;
          rmax_in := in1;
        END_IF;
        IF rmax = r2
        THEN
          rmax_in := rmax_in OR in2;
        END_IF;
        IF rmax < r2
        THEN
          rmax := r2;
          rmax_in := in2;
        END_IF;
        IF rmax = r3
        THEN
          rmax_in := rmax_in OR in3;
        END_IF;
        IF rmax < r3
        THEN
          rmax := r3;
          rmax_in := in3;
        END_IF;
      END_IF;
      IF strictly_in(apc, aitp)
      THEN
        IF rc >= rmxp
        THEN
          rmin := rc - rmxp;
          rmin_in := max_included(ritp);
        ELSE
          IF rc <= rmnp
          THEN
            rmin := rmnp - rc;
            rmin_in := min_included(ritp);
          ELSE
            rmin := 0.0;
            rmin_in := TRUE;
          END_IF;
        END_IF;
      ELSE
        rmin := r0;
        rmin_in := in0;
        a := apc - aitp.min;
        r := rc * COS(a);
        IF {rmnp < r < rmxp}
        THEN
          rmin := rc * SIN(ABS(a));
          rmin_in := min_included(aitp);
        END_IF;
        a := apc - aitp.max;
        r := rc * COS(a);
        IF {rmnp < r < rmxp}
        THEN
          r := rc * SIN(ABS(a));
          inn := max_included(aitp);
          IF r = rmin
          THEN
            rmin_in := rmin_in OR inn;
          END_IF;
          IF r < rmin
          THEN
            rmin := r;
            rmin_in := inn;
          END_IF;
        END_IF;
        IF r1 = rmin
        THEN
          rmin_in := rmin_in OR in1;
        END_IF;
        IF r1 < rmin
        THEN
          rmin := r1;
          rmin_in := in1;
        END_IF;
        IF r2 = rmin
        THEN
          rmin_in := rmin_in OR in2;
        END_IF;
        IF r2 < rmin
        THEN
          rmin := r2;
          rmin_in := in2;
        END_IF;
        IF r3 = rmin
        THEN
          rmin_in := rmin_in OR in3;
        END_IF;
        IF r3 < rmin
        THEN
          rmin := r3;
          rmin_in := in3;
        END_IF;
      END_IF;
      IF rc >= rmxp
      THEN
        ab := acp;
        find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
        a := ACOS(rmxp / rc);
        IF strictly_in(apc - a, aitp)
        THEN
          amin := ab - ASIN(rmxp / rc);
          amin_in := max_included(ritp);
        END_IF;
        IF strictly_in(apc + a, aitp)
        THEN
          amax := ab + ASIN(rmxp / rc);
          amax_in := max_included(ritp);
        END_IF;
        angle_range(amin, amax);
      ELSE
        IF rc > rmnp
        THEN
          ab := angle(0.5 * (aitp.min + aitp.max));
          find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
        ELSE
          ab := angle(0.5 * (aitp.min + aitp.max));
          a0 := angle(a0 - ab);
          a1 := angle(a1 - ab);
          a2 := angle(a2 - ab);
          a3 := angle(a3 - ab);
          IF a3 > a2
          THEN
            a2 := a2 + 2.0 * PI;
          END_IF;
          IF a0 > a1
          THEN
            a0 := a0 + 2.0 * PI;
          END_IF;
          IF a3 < a0
          THEN
            amin := a3;
            amin_in := in3;
          ELSE
            amin := a0;
            amin_in := in0;
          END_IF;
          IF a2 > a1
          THEN
            amax := a2;
            amax_in := in2;
          ELSE
            amax := a1;
            amax_in := in1;
          END_IF;
          IF (amax - amin > 2.0 * PI) OR ((amax - amin = 2.0 * PI) AND (amin_in OR amax_in))
          THEN
            amin := -PI;
            amin_in := FALSE;
            amax := PI;
            amax_in := TRUE;
          ELSE
            amin := amin + ab;
            amax := amax + ab;
            angle_range(amin, amax);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    IF rmin_in
    THEN
      minclo := closed;
    END_IF;
    IF rmax_in
    THEN
      maxclo := closed;
    END_IF;
    ritv := make_finite_real_interval(rmin, minclo, rmax, maxclo);
  ELSE
    IF (rc > rmnp) AND strictly_in(apc, aitp)
    THEN
      RETURN(?);
    END_IF;
    IF aitp.max - aitp.min = 2.0 * PI
    THEN
      a := angle(aitp.min);
      IF rc > rmnp
      THEN
        IF max_included(aitp)
        THEN
          RETURN(?);
        END_IF;
        rmin := 0.0;
        rmin_in := FALSE;
        amin := aitp.min;
        amin_in := FALSE;
        amax := aitp.max;
        amax_in := FALSE;
      ELSE
        rmin := rmnp - rc;
        rmin_in := min_included(ritp);
        amin := -PI;
        amin_in := FALSE;
        amax := PI;
        amax_in := TRUE;
        IF NOT max_included(aitp)
        THEN
          IF apc = a
          THEN
            rmin_in := FALSE;
            amin := aitp.min;
            amin_in := FALSE;
            amax := aitp.max;
            amax_in := FALSE;
          ELSE
            IF acp = a
            THEN
              amin := aitp.min;
              amin_in := FALSE;
              amax := aitp.max;
              amax_in := FALSE;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    ELSE
      a0 := angle(aitp.min);
      in0 := FALSE;
      a1 := angle(aitp.max);
      in1 := FALSE;
      x := xp + rmnp * COS(aitp.max) - xc;
      y := yp + rmnp * SIN(aitp.max) - yc;
      r2 := SQRT(x ** 2 + y ** 2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 <> 0.0
      THEN
        a2 := atan2(y, x);
      ELSE
        a2 := a1;
        in2 := in1;
      END_IF;
      x := xp + rmnp * COS(aitp.min) - xc;
      y := yp + rmnp * SIN(aitp.min) - yc;
      r3 := SQRT(x ** 2 + y ** 2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 <> 0.0
      THEN
        a3 := atan2(y, x);
      ELSE
        a3 := a0;
        in3 := in0;
      END_IF;
      IF rmnp = 0.0
      THEN
        in2 := min_included(ritp);
        in3 := in2;
      END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min))
      THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE
        IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max))
        THEN
          in1 := max_included(aitp);
          in2 := in1;
        END_IF;
      END_IF;
      IF strictly_in(apc, aitp)
      THEN
        rmin := rmnp - rc;
        rmin_in := min_included(ritp);
      ELSE
        rmin := r2;
        rmin_in := in2;
        a := apc - aitp.min;
        r := rc * COS(a);
        IF rmnp < r
        THEN
          rmin := rc * SIN(ABS(a));
          rmin_in := min_included(aitp);
        END_IF;
        a := apc - aitp.max;
        r := rc * COS(a);
        IF rmnp < r
        THEN
          r := rc * SIN(ABS(a));
          inn := max_included(aitp);
          IF r = rmin
          THEN
            rmin_in := rmin_in OR inn;
          END_IF;
          IF r < rmin
          THEN
            rmin := r;
            rmin_in := inn;
          END_IF;
        END_IF;
        IF r3 = rmin
        THEN
          rmin_in := rmin_in OR in3;
        END_IF;
        IF r3 < rmin
        THEN
          rmin := r3;
          rmin_in := in3;
        END_IF;
      END_IF;
      ab := angle(0.5 * (aitp.min + aitp.max));
      IF rc > rmnp
      THEN
        find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
      ELSE
        a0 := angle(a0 - ab);
        a1 := angle(a1 - ab);
        a2 := angle(a2 - ab);
        a3 := angle(a3 - ab);
        IF a3 > a2
        THEN
          a2 := a2 + 2.0 * PI;
        END_IF;
        IF a0 > a1
        THEN
          a0 := a0 + 2.0 * PI;
        END_IF;
        IF a3 < a0
        THEN
          amin := a3;
          amin_in := in3;
        ELSE
          amin := a0;
          amin_in := in0;
        END_IF;
        IF a2 > a1
        THEN
          amax := a2;
          amax_in := in2;
        ELSE
          amax := a1;
          amax_in := in1;
        END_IF;
        IF (amax - amin > 2.0 * PI) OR ((amax - amin = 2.0 * PI) AND (amin_in OR amax_in))
        THEN
          amin := -PI;
          amin_in := FALSE;
          amax := PI;
          amax_in := TRUE;
          IF (rmin = 0.0) AND rmin_in
          THEN
            RETURN(?);
          END_IF;
        ELSE
          amin := amin + ab;
          amax := amax + ab;
          angle_range(amin, amax);
        END_IF;
      END_IF;
    END_IF;
    IF rmin_in
    THEN
      minclo := closed;
    END_IF;
    ritv := make_real_interval_from_min(rmin, minclo);
  END_IF;
  minclo := open;
  maxclo := open;
  IF amin_in
  THEN
    minclo := closed;
  END_IF;
  IF amax_in
  THEN
    maxclo := closed;
  END_IF;
  aitv := make_finite_real_interval(amin, minclo, amax, maxclo);
  -- Construct polar region
  RETURN(make_polar_complex_number_region(centre, ritv, aitv));
END_FUNCTION;

FUNCTION equal_cregion_pregion(crgn : cartesian_complex_number_region;
                               prgn : polar_complex_number_region) : LOGICAL;
LOCAL
  arng : REAL;
  amin : REAL;
  xc   : REAL;
  yc   : REAL;
  aitv : real_interval;
  xitv : real_interval;
  yitv : real_interval;
  c_in : BOOLEAN;
END_LOCAL;
  IF NOT EXISTS(crgn) OR NOT EXISTS(prgn)
  THEN
    RETURN(FALSE);
  END_IF;
  IF max_exists(prgn.distance_constraint)
  THEN
    RETURN(FALSE);
  END_IF;
  IF real_min(prgn.distance_constraint) <> 0.0
  THEN
    RETURN(FALSE);
  END_IF;
  c_in := min_included(prgn.distance_constraint);
  aitv := prgn.direction_constraint;
  amin := aitv.min;
  arng := aitv.max - amin;
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  IF arng = 0.5 * PI
  THEN
    IF amin = 0.0
    THEN
      RETURN(NOT max_exists(xitv) AND
                 NOT max_exists(yitv) AND min_exists(xitv) AND min_exists(yitv) AND (real_min(xitv) = xc) AND
                     (real_min(yitv) = yc) AND
                     ((c_in AND min_included(aitv) AND max_included(aitv) AND min_included(xitv) AND
                       min_included(yitv)) OR
                      (NOT c_in AND
                           NOT min_included(aitv) AND max_included(aitv) AND min_included(xitv) AND
                               NOT min_included(yitv)) OR
                      (NOT c_in AND min_included(aitv) AND
                           NOT max_included(aitv) AND NOT min_included(xitv) AND min_included(yitv)) OR
                      (NOT c_in AND
                           NOT min_included(aitv) AND
                               NOT max_included(aitv) AND NOT min_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5 * PI
    THEN
      RETURN(max_exists(xitv) AND
             NOT max_exists(yitv) AND
                 NOT min_exists(xitv) AND min_exists(yitv) AND (real_max(xitv) = xc) AND (real_min(yitv) = yc) AND
                     ((c_in AND min_included(aitv) AND max_included(aitv) AND max_included(xitv) AND
                       min_included(yitv)) OR
                      (NOT c_in AND
                           NOT min_included(aitv) AND max_included(aitv) AND max_included(xitv) AND
                               NOT min_included(yitv)) OR
                      (NOT c_in AND min_included(aitv) AND
                           NOT max_included(aitv) AND NOT max_included(xitv) AND min_included(yitv)) OR
                      (NOT c_in AND
                           NOT min_included(aitv) AND
                               NOT max_included(aitv) AND NOT max_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = -PI
    THEN
      RETURN(max_exists(xitv) AND max_exists(yitv) AND
             NOT min_exists(xitv) AND
                 NOT min_exists(yitv) AND (real_max(xitv) = xc) AND (real_max(yitv) = yc) AND
                     ((c_in AND min_included(aitv) AND max_included(aitv) AND max_included(xitv) AND
                       max_included(yitv)) OR
                      (NOT c_in AND
                           NOT min_included(aitv) AND max_included(aitv) AND max_included(xitv) AND
                               NOT max_included(yitv)) OR
                      (NOT c_in AND min_included(aitv) AND
                           NOT max_included(aitv) AND NOT max_included(xitv) AND max_included(yitv)) OR
                      (NOT c_in AND
                           NOT min_included(aitv) AND
                               NOT max_included(aitv) AND NOT max_included(xitv) AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5 * PI
    THEN
      RETURN(NOT max_exists(xitv) AND max_exists(yitv) AND min_exists(xitv) AND
                 NOT min_exists(yitv) AND (real_min(xitv) = xc) AND (real_max(yitv) = yc) AND
                     ((c_in AND min_included(aitv) AND max_included(aitv) AND min_included(xitv) AND
                       max_included(yitv)) OR
                      (NOT c_in AND
                           NOT min_included(aitv) AND max_included(aitv) AND min_included(xitv) AND
                               NOT max_included(yitv)) OR
                      (NOT c_in AND min_included(aitv) AND
                           NOT max_included(aitv) AND NOT min_included(xitv) AND max_included(yitv)) OR
                      (NOT c_in AND
                           NOT min_included(aitv) AND
                               NOT max_included(aitv) AND NOT min_included(xitv) AND NOT max_included(yitv))));
    END_IF;
  END_IF;
  IF arng = PI
  THEN
    IF amin = 0.0
    THEN
      RETURN(NOT max_exists(xitv) AND
                 NOT max_exists(yitv) AND
                     NOT min_exists(xitv) AND min_exists(yitv) AND (real_min(yitv) = yc) AND
                         ((c_in AND min_included(aitv) AND max_included(aitv) AND min_included(yitv)) OR
                          (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5 * PI
    THEN
      RETURN(max_exists(xitv) AND
             NOT max_exists(yitv) AND
                 NOT min_exists(xitv) AND
                     NOT min_exists(yitv) AND (real_max(xitv) = xc) AND
                         ((c_in AND min_included(aitv) AND max_included(aitv) AND max_included(xitv)) OR
                          (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT max_included(xitv))));
    END_IF;
    IF amin = -PI
    THEN
      RETURN(NOT max_exists(xitv) AND max_exists(yitv) AND
                 NOT min_exists(xitv) AND
                     NOT min_exists(yitv) AND (real_max(yitv) = yc) AND
                         ((c_in AND min_included(aitv) AND max_included(aitv) AND max_included(yitv)) OR
                          (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5 * PI
    THEN
      RETURN(NOT max_exists(xitv) AND
                 NOT max_exists(yitv) AND min_exists(xitv) AND
                     NOT min_exists(yitv) AND (real_min(xitv) = xc) AND
                         ((c_in AND min_included(aitv) AND max_included(aitv) AND min_included(xitv)) OR
                          (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT min_included(xitv))));
    END_IF;
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

FUNCTION equal_maths_functions(fun1 : maths_function;
                               fun2 : maths_function) : LOGICAL;
LOCAL
  cum : LOGICAL;
END_LOCAL;
  IF fun1 = fun2
  THEN
    RETURN(TRUE);
  END_IF;
  cum := equal_maths_spaces(fun1.domain, fun2.domain);
  IF cum = FALSE
  THEN
    RETURN(FALSE);
  END_IF;
  cum := cum AND equal_maths_spaces(fun1.range, fun2.range);
  IF cum = FALSE
  THEN
    RETURN(FALSE);
  END_IF;
  -- A lot of further analysis is possible, but not required.
  RETURN(UNKNOWN);
END_FUNCTION;

FUNCTION equal_maths_spaces(spc1 : maths_space;
                            spc2 : maths_space) : LOGICAL;
LOCAL
  spc1types : SET OF STRING       := stripped_typeof(spc1);
  spc2types : SET OF STRING       := stripped_typeof(spc2);
  set1      : SET OF maths_value;
  set2      : SET OF maths_value;
  cum       : LOGICAL             := TRUE;
  base      : maths_space;
  expnt     : INTEGER;
  factors   : LIST OF maths_space;
  factors2  : LIST OF maths_space;
  fs1       : function_space;
  fs2       : function_space;
  cum2      : LOGICAL;
END_LOCAL;
  IF spc1 = spc2
  THEN
    RETURN(TRUE);
  END_IF;
  -- Consider cases where it is not yet certain that spc1 <> spc2.
  IF 'FINITE_SPACE' IN spc1types
  THEN
    set1 := spc1\finite_space.members;
    IF 'FINITE_SPACE' IN spc2types
    THEN
      set2 := spc2\finite_space.members;
      REPEAT i := 1 TO SIZEOF(set1);
        cum := cum AND member_of(set1[i], spc2);
        IF cum = FALSE
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      IF cum = TRUE
      THEN
        REPEAT i := 1 TO SIZEOF(set2);
          cum := cum AND member_of(set2[i], spc1);
          IF cum = FALSE
          THEN
            RETURN(FALSE);
          END_IF;
        END_REPEAT;
      END_IF;
      RETURN(cum);
    END_IF;
    IF 'FINITE_INTEGER_INTERVAL' IN spc2types
    THEN
      set2 := [];
      REPEAT i := spc2\finite_integer_interval.min TO spc2\finite_integer_interval.max;
        set2 := set2 + [i];
      END_REPEAT;
      RETURN(equal_maths_spaces(spc1, make_finite_space(set2)));
    END_IF;
  END_IF;
  IF ('FINITE_INTEGER_INTERVAL' IN spc1types) AND ('FINITE_SPACE' IN spc2types)
  THEN
    set1 := [];
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      set1 := set1 + [i];
    END_REPEAT;
    RETURN(equal_maths_spaces(make_finite_space(set1), spc2));
  END_IF;
  IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc1types) AND ('POLAR_COMPLEX_NUMBER_REGION' IN spc2types)
  THEN
    RETURN(equal_cregion_pregion(spc1, spc2));
  END_IF;
  IF ('POLAR_COMPLEX_NUMBER_REGION' IN spc1types) AND ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc2types)
  THEN
    RETURN(equal_cregion_pregion(spc2, spc1));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN spc1types
  THEN
    base := spc1\uniform_product_space.base;
    expnt := spc1\uniform_product_space.exponent;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types
    THEN
      IF expnt <> spc2\uniform_product_space.exponent
      THEN
        RETURN(FALSE);
      END_IF;
      RETURN(equal_maths_spaces(base, spc2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types
    THEN
      factors := spc2\listed_product_space.factors;
      IF expnt <> SIZEOF(factors)
      THEN
        RETURN(FALSE);
      END_IF;
      REPEAT i := 1 TO SIZEOF(factors);
        cum := cum AND equal_maths_spaces(base, factors[i]);
        IF cum = FALSE
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(cum);
    END_IF;
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN spc1types
  THEN
    factors := spc1\listed_product_space.factors;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types
    THEN
      IF spc2\uniform_product_space.exponent <> SIZEOF(factors)
      THEN
        RETURN(FALSE);
      END_IF;
      base := spc2\uniform_product_space.base;
      REPEAT i := 1 TO SIZEOF(factors);
        cum := cum AND equal_maths_spaces(base, factors[i]);
        IF cum = FALSE
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(cum);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types
    THEN
      factors2 := spc2\listed_product_space.factors;
      IF SIZEOF(factors) <> SIZEOF(factors2)
      THEN
        RETURN(FALSE);
      END_IF;
      REPEAT i := 1 TO SIZEOF(factors);
        cum := cum AND equal_maths_spaces(factors[i], factors2[i]);
        IF cum = FALSE
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(cum);
    END_IF;
  END_IF;
  IF ('EXTENDED_TUPLE_SPACE' IN spc1types) AND ('EXTENDED_TUPLE_SPACE' IN spc2types)
  THEN
    RETURN(equal_maths_spaces(spc1\extended_tuple_space.extender, spc2\extended_tuple_space.extender) AND
           equal_maths_spaces(spc1\extended_tuple_space.base, spc2\extended_tuple_space.base));
  END_IF;
  IF ('FUNCTION_SPACE' IN spc1types) AND ('FUNCTION_SPACE' IN spc2types)
  THEN
    fs1 := spc1;
    fs2 := spc2;
    IF fs1.domain_constraint <> fs2.domain_constraint
    THEN
      IF (fs1.domain_constraint = sc_equal) OR (fs2.domain_constraint = sc_equal)
      THEN
        RETURN(FALSE);
      END_IF;
      IF (fs1.domain_constraint <> sc_subspace)
      THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.domain_constraint <> sc_subspace) OR (fs2.domain_constraint <> sc_member)
      THEN
        RETURN(UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.domain_constraint, fs1.domain_argument) <>
         any_space_satisfies(fs2.domain_constraint, fs2.domain_argument)
      THEN
        RETURN(FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.domain_argument))
      THEN
        RETURN(FALSE);
      END_IF;
      IF SIZEOF(['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] * stripped_typeof(fs1.domain_argument)) = 0
      THEN
        RETURN(FALSE);
      END_IF;
      RETURN(UNKNOWN);
    END_IF;
    cum := equal_maths_spaces(fs1.domain_argument, fs2.domain_argument);
    IF cum = FALSE
    THEN
      RETURN(FALSE);
    END_IF;
    IF fs1.range_constraint <> fs2.range_constraint
    THEN
      IF (fs1.range_constraint = sc_equal) OR (fs2.range_constraint = sc_equal)
      THEN
        RETURN(FALSE);
      END_IF;
      IF (fs1.range_constraint <> sc_subspace)
      THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.range_constraint <> sc_subspace) OR (fs2.range_constraint <> sc_member)
      THEN
        RETURN(UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.range_constraint, fs1.range_argument) <>
         any_space_satisfies(fs2.range_constraint, fs2.range_argument)
      THEN
        RETURN(FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.range_argument))
      THEN
        RETURN(FALSE);
      END_IF;
      IF SIZEOF(['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] * stripped_typeof(fs1.range_argument)) = 0
      THEN
        RETURN(FALSE);
      END_IF;
      RETURN(UNKNOWN);
    END_IF;
    cum := cum AND equal_maths_spaces(fs1.range_argument, fs2.range_argument);
    RETURN(cum);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

FUNCTION equal_maths_values(val1 : maths_value;
                            val2 : maths_value) : LOGICAL;
FUNCTION mem_of_vs(val1 : maths_value;
                   val2 : maths_value) : LOGICAL;
  IF NOT has_values_space(val2)
  THEN
    RETURN(UNKNOWN);
  END_IF;
  IF NOT member_of(val1, values_space_of(val2))
  THEN
    RETURN(FALSE);
  END_IF;
  RETURN(UNKNOWN);
END_FUNCTION;
LOCAL
  types1 : SET OF STRING;
  types2 : SET OF STRING;
  list1  : LIST OF maths_value;
  list2  : LIST OF maths_value;
  cum    : LOGICAL             := TRUE;
END_LOCAL;
  IF NOT EXISTS(val1) OR NOT EXISTS(val2)
  THEN
    RETURN(FALSE);
  END_IF;
  IF val1 = val2
  THEN
    RETURN(TRUE);
  END_IF;
  types1 := stripped_typeof(val1);
  types2 := stripped_typeof(val2);
  IF ('MATHS_ATOM' IN types1) OR ('COMPLEX_NUMBER_LITERAL' IN types1)
  THEN
    IF 'MATHS_ATOM' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'COMPLEX_NUMBER_LITERAL' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'LIST' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'MATHS_SPACE' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'MATHS_FUNCTION' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2
    THEN
      RETURN(mem_of_vs(val1, val2));
    END_IF;
    RETURN(UNKNOWN);
  END_IF;
  IF ('MATHS_ATOM' IN types2) OR ('COMPLEX_NUMBER_LITERAL' IN types2)
  THEN
    RETURN(equal_maths_values(val2, val1));
  END_IF;
  IF 'LIST' IN types1
  THEN
    IF 'LIST' IN types2
    THEN
      list1 := val1;
      list2 := val2;
      IF SIZEOF(list1) <> SIZEOF(list2)
      THEN
        RETURN(FALSE);
      END_IF;
      REPEAT i := 1 TO SIZEOF(list1);
        cum := cum AND equal_maths_values(list1[i], list2[i]);
        IF cum = FALSE
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(cum);
    END_IF;
    IF 'MATHS_SPACE' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'MATHS_FUNCTION' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2
    THEN
      RETURN(mem_of_vs(val1, val2));
    END_IF;
    RETURN(UNKNOWN);
  END_IF;
  IF 'LIST' IN types2
  THEN
    RETURN(equal_maths_values(val2, val1));
  END_IF;
  IF 'MATHS_SPACE' IN types1
  THEN
    IF 'MATHS_SPACE' IN types2
    THEN
      RETURN(equal_maths_spaces(val1, val2));
    END_IF;
    IF 'MATHS_FUNCTION' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2
    THEN
      RETURN(mem_of_vs(val1, val2));
    END_IF;
    RETURN(UNKNOWN);
  END_IF;
  IF 'MATHS_SPACE' IN types2
  THEN
    RETURN(equal_maths_values(val2, val1));
  END_IF;
  IF 'MATHS_FUNCTION' IN types1
  THEN
    IF 'MATHS_FUNCTION' IN types2
    THEN
      RETURN(equal_maths_functions(val1, val2));
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2
    THEN
      RETURN(mem_of_vs(val1, val2));
    END_IF;
    RETURN(UNKNOWN);
  END_IF;
  IF 'MATHS_FUNCTION' IN types2
  THEN
    RETURN(equal_maths_values(val2, val1));
  END_IF;
  IF ('GENERIC_EXPRESSION' IN types1) AND ('GENERIC_EXPRESSION' IN types2)
  THEN
    IF NOT has_values_space(val1) OR NOT has_values_space(val2)
    THEN
      RETURN(UNKNOWN);
    END_IF;
    IF NOT compatible_spaces(values_space_of(val1), values_space_of(val2))
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  RETURN(UNKNOWN);
END_FUNCTION;

FUNCTION es_subspace_of_es(es1 : elementary_space_enumerators;
                           es2 : elementary_space_enumerators) : BOOLEAN;
  IF NOT EXISTS(es1) OR NOT EXISTS(es2)
  THEN
    RETURN(FALSE);
  END_IF;
  IF es1 = es2
  THEN
    RETURN(TRUE);
  END_IF;
  IF es2 = es_generics
  THEN
    RETURN(TRUE);
  END_IF;
  IF (es1 = es_booleans) AND (es2 = es_logicals)
  THEN
    RETURN(TRUE);
  END_IF;
  IF (es2 = es_numbers) AND ((es1 = es_complex_numbers) OR (es1 = es_reals) OR (es1 = es_integers))
  THEN
    RETURN(TRUE);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

FUNCTION expression_is_constant(expr : generic_expression) : BOOLEAN;
  RETURN(bool(SIZEOF(free_variables_of(expr)) = 0));
END_FUNCTION;

FUNCTION external_version_assignment_is_valid(aia : applied_external_identification_assignment) : BOOLEAN;
LOCAL
  item : external_identification_item;
  role : identification_role;
END_LOCAL;
  role := aia.role;
  IF role.name = 'version'
  THEN
    REPEAT i := LOINDEX(aia\applied_external_identification_assignment.items) TO HIINDEX(aia\applied_external_identification_assignment.items);
      item := aia\applied_external_identification_assignment.items[i];
      IF (SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXTERNALLY_DEFINED_GENERAL_PROPERTY'] * TYPEOF(item)) = 0)
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);
  ELSE
    RETURN(TRUE);
  END_IF;
END_FUNCTION;

FUNCTION extract_factors(tspace : tuple_space;
                         m : INTEGER;
                         n : INTEGER) : tuple_space;
LOCAL
  tsp : tuple_space := the_zero_tuple_space;
END_LOCAL;
  REPEAT i := m TO n;
    tsp := assoc_product_space(tsp, factor_space(tspace, i));
  END_REPEAT;
  RETURN(tsp);
END_FUNCTION;

FUNCTION extremal_position_check(fun : linearized_table_function) : BOOLEAN;
LOCAL
  source_domain   : maths_space;
  source_interval : finite_integer_interval;
  index           : INTEGER                  := 1;
  base            : INTEGER;
  shape           : LIST OF positive_integer;
  ndim            : positive_integer;
  slo             : INTEGER;
  shi             : INTEGER;
  sublo           : LIST OF INTEGER          := [];
  subhi           : LIST OF INTEGER          := [];
END_LOCAL;
  IF NOT EXISTS(fun)
  THEN
    RETURN(FALSE);
  END_IF;
  source_domain := factor1(fun.source.domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF(source_domain)
  THEN
    source_domain := factor1(source_domain);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(source_domain))
  THEN
    RETURN(FALSE);
  END_IF;
  source_interval := source_domain;
  base := fun\explicit_table_function.index_base;
  shape := fun\explicit_table_function.shape;
  IF (schema_prefix + 'STANDARD_TABLE_FUNCTION') IN TYPEOF(fun)
  THEN
    REPEAT j := 1 TO SIZEOF(shape);
      index := index * shape[j];
    END_REPEAT;
    index := fun.first + index - 1;
    RETURN(bool({source_interval.min <= index <= source_interval.max}));
  END_IF;
  IF (schema_prefix + 'REGULAR_TABLE_FUNCTION') IN TYPEOF(fun)
  THEN
    ndim := SIZEOF(fun\explicit_table_function.shape);
    REPEAT j := 1 TO ndim;
      slo := base;
      shi := base + shape[j] - 1;
      IF fun\regular_table_function.increments[j] >= 0
      THEN
        INSERT(sublo, slo, j - 1);
        INSERT(subhi, shi, j - 1);
      ELSE
        INSERT(sublo, shi, j - 1);
        INSERT(subhi, slo, j - 1);
      END_IF;
    END_REPEAT;
    index := regular_indexing(sublo, base, shape, fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min <= index <= source_interval.max})
    THEN
      RETURN(FALSE);
    END_IF;
    index := regular_indexing(subhi, base, shape, fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min <= index <= source_interval.max})
    THEN
      RETURN(FALSE);
    END_IF;
    RETURN(TRUE);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

FUNCTION factor_space(tspace : tuple_space;
                      idx : positive_integer) : maths_space;
LOCAL
  typenames : SET OF STRING := TYPEOF(tspace);
END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames
  THEN
    IF idx <= tspace\uniform_product_space.exponent
    THEN
      RETURN(tspace\uniform_product_space.base);
    END_IF;
    RETURN(?);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames
  THEN
    IF idx <= SIZEOF(tspace\listed_product_space.factors)
    THEN
      RETURN(tspace\listed_product_space.factors[idx]);
    END_IF;
    RETURN(?);
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames
  THEN
    IF idx <= space_dimension(tspace\extended_tuple_space.base)
    THEN
      RETURN(factor_space(tspace\extended_tuple_space.base, idx));
    END_IF;
    RETURN(tspace\extended_tuple_space.extender);
  END_IF;
  -- Should not be reachable.
  RETURN(?);
END_FUNCTION;

FUNCTION factor1(tspace : tuple_space) : maths_space;
LOCAL
  typenames : SET OF STRING := TYPEOF(tspace);
END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames
  THEN
    RETURN(tspace\uniform_product_space.base);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames
  THEN
    RETURN(tspace\listed_product_space.factors[1]);
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames
  THEN
    RETURN(factor1(tspace\extended_tuple_space.base));
  END_IF;
  -- Should not be reachable.
  RETURN(?);
END_FUNCTION;

FUNCTION first_proj_axis(z_axis : direction;
                         arg : direction) : direction;
LOCAL
  x_axis : direction;
  v      : direction;
  z      : direction;
  x_vec  : vector;
END_LOCAL;
  IF (NOT EXISTS(z_axis))
  THEN
    RETURN(?);
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg)
    THEN
      IF ((z.direction_ratios <> [1.0,0.0,0.0]) AND (z.direction_ratios <> [-1.0,0.0,0.0]))
      THEN
        v := dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF (arg.dim <> 3)
      THEN
        RETURN(?);
      END_IF;
      IF ((cross_product(arg, z).magnitude) = 0.0)
      THEN
        RETURN(?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);
END_FUNCTION;

FUNCTION free_variables_of(expr : generic_expression) : SET OF generic_variable;
LOCAL
  typenames : SET OF STRING              := stripped_typeof(expr);
  result    : SET OF generic_variable    := [];
  exprs     : LIST OF generic_expression := [];
END_LOCAL;
  IF 'GENERIC_LITERAL' IN typenames
  THEN
    RETURN(result);
  END_IF;
  IF 'GENERIC_VARIABLE' IN typenames
  THEN
    result := result + expr;
    RETURN(result);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN typenames
  THEN
    exprs := QUERY(ge
                   <* expr\multiple_arity_generic_expression.operands
                   | NOT (ge IN expr\quantifier_expression.variables));
    REPEAT i := 1 TO SIZEOF(exprs);
      result := result + free_variables_of(exprs[i]);
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(expr\quantifier_expression.variables);
      result := result - expr\quantifier_expression.variables[i];
    END_REPEAT;
    RETURN(result);
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN typenames
  THEN
    RETURN(free_variables_of(expr\unary_generic_expression.operand));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN typenames
  THEN
    result := free_variables_of(expr\binary_generic_expression.operands[1]);
    RETURN(result + free_variables_of(expr\binary_generic_expression.operands[2]));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN typenames
  THEN
    REPEAT i := 1 TO SIZEOF(expr\multiple_arity_generic_expression.operands);
      result := result + free_variables_of(expr\multiple_arity_generic_expression.operands[i]);
    END_REPEAT;
    RETURN(result);
  END_IF;
  -- In this case the subtype shall not contain any variable (see IP1 in
  -- generic_expression).
  RETURN(result);
END_FUNCTION;

FUNCTION function_applicability(func : maths_function_select;
                                arguments : LIST [1 : ?] OF maths_value) : BOOLEAN;
LOCAL
  domain       : tuple_space        := convert_to_maths_function(func).domain;
  domain_types : SET OF STRING      := TYPEOF(domain);
  narg         : positive_integer   := SIZEOF(arguments);
  arg          : generic_expression;
END_LOCAL;
  IF (schema_prefix + 'PRODUCT_SPACE') IN domain_types
  THEN
    IF space_dimension(domain) <> narg
    THEN
      RETURN(FALSE);
    END_IF;
  ELSE
    IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN domain_types
    THEN
      IF space_dimension(domain) > narg
      THEN
        RETURN(FALSE);
      END_IF;
    ELSE
      RETURN(FALSE);
    END_IF;
  END_IF;
  REPEAT i := 1 TO narg;
    arg := convert_to_operand(arguments[i]);
    IF NOT has_values_space(arg)
    THEN
      RETURN(FALSE);
    END_IF;
    IF NOT compatible_spaces(factor_space(domain, i), values_space_of(arg))
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION function_is_1d_array(func : maths_function) : BOOLEAN;
LOCAL
  temp : maths_space;
END_LOCAL;
  IF NOT EXISTS(func)
  THEN
    RETURN(FALSE);
  END_IF;
  IF space_dimension(func.domain) <> 1
  THEN
    RETURN(FALSE);
  END_IF;
  temp := factor1(func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF(temp)
  THEN
    IF space_dimension(temp) <> 1
    THEN
      RETURN(FALSE);
    END_IF;
    temp := factor1(temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp)
  THEN
    RETURN(TRUE);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

FUNCTION function_is_1d_table(func : maths_function) : BOOLEAN;
LOCAL
  temp : maths_space;
  itvl : finite_integer_interval;
END_LOCAL;
  IF NOT EXISTS(func)
  THEN
    RETURN(FALSE);
  END_IF;
  IF space_dimension(func.domain) <> 1
  THEN
    RETURN(FALSE);
  END_IF;
  temp := factor1(func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF(temp)
  THEN
    IF space_dimension(temp) <> 1
    THEN
      RETURN(FALSE);
    END_IF;
    temp := factor1(temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp)
  THEN
    itvl := temp;
    RETURN(bool((itvl.min = 0) OR (itvl.min = 1)));
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

FUNCTION function_is_2d_table(func : maths_function) : BOOLEAN;
LOCAL
  temp   : maths_space;
  pspace : product_space;
  itvl1  : finite_integer_interval;
  itvl2  : finite_integer_interval;
END_LOCAL;
  IF NOT EXISTS(func)
  THEN
    RETURN(FALSE);
  END_IF;
  IF space_dimension(func.domain) <> 1
  THEN
    RETURN(FALSE);
  END_IF;
  temp := factor1(func.domain);
  IF NOT ('PRODUCT_SPACE' IN stripped_typeof(temp))
  THEN
    RETURN(FALSE);
  END_IF;
  pspace := temp;
  IF space_dimension(pspace) <> 2
  THEN
    RETURN(FALSE);
  END_IF;
  temp := factor1(pspace);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp))
  THEN
    RETURN(FALSE);
  END_IF;
  itvl1 := temp;
  temp := factor_space(pspace, 2);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp))
  THEN
    RETURN(FALSE);
  END_IF;
  itvl2 := temp;
  RETURN(bool((itvl1.min = itvl2.min) AND ((itvl1.min = 0) OR (itvl1.min = 1))));
END_FUNCTION;

FUNCTION function_is_array(func : maths_function) : BOOLEAN;
LOCAL
  tspace : tuple_space;
  temp   : maths_space;
END_LOCAL;
  IF NOT EXISTS(func)
  THEN
    RETURN(FALSE);
  END_IF;
  tspace := func.domain;
  IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(tspace)))
  THEN
    tspace := factor1(tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF(tspace))
  THEN
    RETURN(FALSE);
  END_IF;
  REPEAT i := 1 TO space_dimension(tspace);
    temp := factor_space(tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION function_is_table(func : maths_function) : BOOLEAN;
LOCAL
  tspace : tuple_space;
  temp   : maths_space;
  base   : INTEGER;
END_LOCAL;
  IF NOT EXISTS(func)
  THEN
    RETURN(FALSE);
  END_IF;
  tspace := func.domain;
  IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(tspace)))
  THEN
    tspace := factor1(tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF(tspace))
  THEN
    RETURN(FALSE);
  END_IF;
  temp := factor1(tspace);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
  THEN
    RETURN(FALSE);
  END_IF;
  base := temp\finite_integer_interval.min;
  IF (base <> 0) AND (base <> 1)
  THEN
    RETURN(FALSE);
  END_IF;
  REPEAT i := 2 TO space_dimension(tspace);
    temp := factor_space(tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
    THEN
      RETURN(FALSE);
    END_IF;
    IF temp\finite_integer_interval.min <> base
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION geometric_dimensionalities_in_contexts(grcs : SET [1 : ?] OF geometric_representation_context) : INTEGER;
LOCAL
  grcs_1d : INTEGER := 0;
  grcs_2d : INTEGER := 0;
  grcs_3d : INTEGER := 0;
END_LOCAL;
  IF (SIZEOF(grcs) = 1)
  THEN
    RETURN(grcs[1]\geometric_representation_context.coordinate_space_dimension);
  ELSE
    REPEAT i := 1 TO HIINDEX(grcs);
      IF (grcs[i]\geometric_representation_context.coordinate_space_dimension = 1)
      THEN
        grcs_1d := grcs_1d + 1;
      ELSE
        IF (grcs[i]\geometric_representation_context.coordinate_space_dimension = 2)
        THEN
          grcs_2d := grcs_2d + 1;
        ELSE
          IF (grcs[i]\geometric_representation_context.coordinate_space_dimension = 3)
          THEN
            grcs_3d := grcs_3d + 1;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
  END_IF;
  IF (grcs_1d + grcs_2d = 0)
  THEN
    RETURN(3);
  ELSE
    IF (grcs_1d + grcs_3d = 0)
    THEN
      RETURN(2);
    ELSE
      IF (grcs_2d + grcs_3d = 0)
      THEN
        RETURN(1);
      ELSE
        RETURN(0);
      END_IF;
    END_IF;
  END_IF;
END_FUNCTION;

FUNCTION get_descendant_occurrences(input : product_definition_occurrence) : SET [0 : ?] OF product_definition_specified_occurrence;
LOCAL
  result : SET OF product_definition_specified_occurrence := input.child_occurrences;
END_LOCAL;
  REPEAT i := 1 TO HIINDEX(input.child_occurrences) BY 1;
    result := result + get_descendant_occurrences(input.child_occurrences[i]);
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

FUNCTION get_description_value(obj : description_attribute_select) : text;
LOCAL
  description_bag : BAG OF description_attribute := (USEDIN(obj,
                                                            'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'));
END_LOCAL;
  IF SIZEOF(description_bag) = 1
  THEN
    RETURN(description_bag[1].attribute_value);
  ELSE
    RETURN(?);
  END_IF;
END_FUNCTION;

FUNCTION get_directed_link(nodes : LIST OF representation;
                           undirected_link : LIST OF chained_representation_link) : LIST OF representation_relationship;
LOCAL
  directed_link : LIST OF representation_relationship := [];
END_LOCAL;
  IF (SIZEOF(nodes) <> SIZEOF(undirected_link) + 1) OR (VALUE_UNIQUE(nodes) = FALSE)
  THEN
    RETURN(?);
  END_IF;
  REPEAT i := 1 TO SIZEOF(undirected_link);
    CASE TRUE OF
      ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_CONTEXT' IN TYPEOF(undirected_link[i])) : BEGIN  
                                                                                                                IF ((nodes[i]\representation.context_of_items :=:
                                                                                                                     undirected_link[i]) AND
                                                                                                                    (nodes[i +
                                                                                                                           1]\representation.context_of_items :=:
                                                                                                                     undirected_link[i]))
                                                                                                                THEN
                                                                                                                  INSERT(directed_link,
                                                                                                                         representation_relationship('',
                                                                                                                                                     '',
                                                                                                                                                     nodes[i +
                                                                                                                                                           1],
                                                                                                                                                     nodes[i]),
                                                                                                                         (i -
                                                                                                                          1));
                                                                                                                ELSE
                                                                                                                  RETURN(?);
                                                                                                                END_IF;
      END;
      ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_RELATIONSHIP' IN TYPEOF(undirected_link[i])) : BEGIN  
                                                                                                                     IF (((nodes[i] :=:
                                                                                                                           undirected_link[i]\representation_relationship.rep_1) AND
                                                                                                                          (nodes[i +
                                                                                                                                 1] :=:
                                                                                                                           undirected_link[i]\representation_relationship.rep_2)) OR
                                                                                                                         ((nodes[i] :=:
                                                                                                                           undirected_link[i]\representation_relationship.rep_2) AND
                                                                                                                          (nodes[i +
                                                                                                                                 1] :=:
                                                                                                                           undirected_link[i]\representation_relationship.rep_1)))
                                                                                                                     THEN
                                                                                                                       INSERT(directed_link,
                                                                                                                              representation_relationship('',
                                                                                                                                                          '',
                                                                                                                                                          nodes[i +
                                                                                                                                                                1],
                                                                                                                                                          nodes[i]),
                                                                                                                              (i -
                                                                                                                               1));
                                                                                                                     ELSE
                                                                                                                       RETURN(?);
                                                                                                                     END_IF;
      END;
      ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MAPPED_ITEM' IN TYPEOF(undirected_link[i])) : BEGIN  
                                                                                                     IF ((nodes[i] IN
                                                                                                          using_representations(undirected_link[i])) AND
                                                                                                         (nodes[i +
                                                                                                                1] :=:
                                                                                                          undirected_link[i]\mapped_item.mapping_source\representation_map.mapped_representation))
                                                                                                     THEN
                                                                                                       INSERT(directed_link,
                                                                                                              representation_relationship('',
                                                                                                                                          '',
                                                                                                                                          nodes[i +
                                                                                                                                                1],
                                                                                                                                          nodes[i]),
                                                                                                              (i - 1));
                                                                                                     ELSE
                                                                                                       RETURN(?);
                                                                                                     END_IF;
      END;
      OTHERWISE: RETURN(?);
    END_CASE;
  END_REPEAT;
  IF (VALUE_UNIQUE(directed_link) = FALSE)
  THEN
    RETURN(?);
  END_IF;
  RETURN(directed_link);
END_FUNCTION;

FUNCTION get_id_value(obj : id_attribute_select) : identifier;
LOCAL
  id_bag : BAG OF id_attribute := (USEDIN(obj, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM'));
END_LOCAL;
  IF SIZEOF(id_bag) = 1
  THEN
    RETURN(id_bag[1].attribute_value);
  ELSE
    RETURN(?);
  END_IF;
END_FUNCTION;

FUNCTION get_name_value(obj : name_attribute_select) : label;
LOCAL
  name_bag : BAG OF name_attribute := (USEDIN(obj,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM'));
END_LOCAL;
  IF SIZEOF(name_bag) = 1
  THEN
    RETURN(name_bag[1].attribute_value);
  ELSE
    RETURN(?);
  END_IF;
END_FUNCTION;

FUNCTION get_product_definition_shape(current : constituent_shape_aspect) : product_definition_shape;
  REPEAT WHILE ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONSTITUENT_SHAPE_ASPECT' IN TYPEOF(current.parent));
    current := current.parent;
  END_REPEAT;
  RETURN(current.parent\shape_aspect.of_shape);
END_FUNCTION;

FUNCTION get_property_definition_representations(c_def_instance : characterized_definition) : SET OF property_definition_representation;
LOCAL
  pd_set  : SET OF property_definition                := [];
  pdr_set : SET OF property_definition_representation := [];
END_LOCAL;
  pd_set := bag_to_set(USEDIN(c_def_instance,
                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION.DEFINITION'));
  IF (SIZEOF(pd_set) < 1)
  THEN
    RETURN(pdr_set);
  END_IF;
  REPEAT i := 1 TO HIINDEX(pd_set);
    pdr_set := pdr_set +
               bag_to_set(USEDIN(pd_set[i],
                                 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
  END_REPEAT;
  RETURN(pdr_set);
END_FUNCTION;

FUNCTION get_role(obj : role_select) : object_role;
LOCAL
  role_bag : BAG OF role_association := (USEDIN(obj,
                                                'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE'));
END_LOCAL;
  IF SIZEOF(role_bag) = 1
  THEN
    RETURN(role_bag[1].role);
  ELSE
    RETURN(?);
  END_IF;
END_FUNCTION;

FUNCTION get_shape_aspects(c_def_instance : characterized_definition) : SET OF shape_aspect;
LOCAL
  pd_set  : SET OF product_definition_shape := [];
  pdr_set : SET OF shape_aspect             := [];
END_LOCAL;
  pd_set := bag_to_set(QUERY(pd
                             <* USEDIN(c_def_instance,
                                       'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION.DEFINITION')
                             | 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)));
  IF (SIZEOF(pd_set) < 1)
  THEN
    RETURN(pdr_set);
  END_IF;
  REPEAT i := 1 TO HIINDEX(pd_set);
    pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_ASPECT.OF_SHAPE'));
  END_REPEAT;
  RETURN(pdr_set);
END_FUNCTION;

FUNCTION has_values_space(expr : generic_expression) : BOOLEAN;
LOCAL
  typenames : SET OF STRING := stripped_typeof(expr);
END_LOCAL;
  IF 'EXPRESSION' IN typenames
  THEN
    RETURN(bool(('NUMERIC_EXPRESSION' IN typenames) OR ('STRING_EXPRESSION' IN typenames) OR
                ('BOOLEAN_EXPRESSION' IN typenames)));
  END_IF;
  IF 'MATHS_FUNCTION' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'FUNCTION_APPLICATION' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'MATHS_SPACE' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'MATHS_VARIABLE' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'DEPENDENT_VARIABLE_DEFINITION' IN typenames
  THEN
    RETURN(has_values_space(expr\unary_generic_expression.operand));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'LOGICAL_LITERAL' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'BINARY_LITERAL' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_EXPRESSION' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'DEFINITE_INTEGRAL_EXPRESSION' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

FUNCTION is_acyclic(arg : generic_expression) : BOOLEAN;
  RETURN(acyclic(arg, []));
END_FUNCTION;

FUNCTION is_int_expr(arg : numeric_expression) : BOOLEAN;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INT_LITERAL' IN TYPEOF(arg)
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REAL_LITERAL' IN TYPEOF(arg)
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INT_NUMERIC_VARIABLE' IN TYPEOF(arg)
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REAL_NUMERIC_VARIABLE' IN TYPEOF(arg)
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ABS_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(is_int_expr(arg\unary_numeric_expression.operand));
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MINUS_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(is_int_expr(arg\unary_numeric_expression.operand));
  END_IF;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SIN_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COS_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.TAN_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASIN_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACOS_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ATAN_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXP_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LOG_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LOG2_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LOG10_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SQUARE_ROOT_FUNCTION' IN TYPEOF(arg))
  THEN
    RETURN(FALSE);
  END_IF;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PLUS_EXPRESSION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MULT_EXPRESSION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MAXIMUM_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MINIMUM_FUNCTION' IN TYPEOF(arg))
  THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_numeric_expression.operands);
      IF NOT is_int_expr(arg\multiple_arity_numeric_expression.operands[i])
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);
  END_IF;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MINUS_EXPRESSION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POWER_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(is_int_expr(arg\binary_numeric_expression.operands[1]) AND
           is_int_expr(arg\binary_numeric_expression.operands[2]));
  END_IF;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DIV_EXPRESSION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MOD_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SLASH_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LENGTH_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VALUE_FUNCTION' IN TYPEOF(arg)
  THEN
    IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INT_VALUE_FUNCTION' IN TYPEOF(arg)
    THEN
      RETURN(TRUE);
    ELSE
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTEGER_DEFINED_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REAL_DEFINED_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BOOLEAN_DEFINED_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STRING_DEFINED_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(FALSE);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

FUNCTION is_sql_mappable(arg : expression) : BOOLEAN;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SIMPLE_NUMERIC_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SQL_MAPPABLE_DEFINED_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MINUS_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(is_sql_mappable(arg\unary_numeric_expression.operand));
  END_IF;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ABS_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SIN_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COS_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.TAN_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ASIN_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACOS_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ATAN_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXP_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LOG_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LOG2_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LOG10_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SQUARE_ROOT_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VALUE_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LENGTH_FUNCTION' IN TYPEOF(arg))
  THEN
    RETURN(FALSE);
  END_IF;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PLUS_EXPRESSION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MULT_EXPRESSION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MAXIMUM_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MINIMUM_FUNCTION' IN TYPEOF(arg))
  THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_numeric_expression.operands);
      IF NOT is_sql_mappable(arg\multiple_arity_numeric_expression.operands[i])
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);
  END_IF;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MINUS_EXPRESSION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SLASH_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(is_sql_mappable(arg\binary_numeric_expression.operands[1]) AND
           is_sql_mappable(arg\binary_numeric_expression.operands[2]));
  END_IF;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DIV_EXPRESSION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MOD_EXPRESSION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POWER_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SIMPLE_BOOLEAN_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NOT_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(is_sql_mappable(arg\unary_generic_expression.operand));
  END_IF;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ODD_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.XOR_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(FALSE);
  END_IF;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.AND_EXPRESSION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OR_EXPRESSION' IN TYPEOF(arg))
  THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_boolean_expression.operands);
      IF NOT is_sql_mappable(arg\multiple_arity_boolean_expression.operands[i])
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EQUALS_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(is_sql_mappable(arg\binary_generic_expression.operands[1]) AND
           is_sql_mappable(arg\binary_generic_expression.operands[2]));
  END_IF;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COMPARISON_EQUAL' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COMPARISON_GREATER' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COMPARISON_GREATER_EQUAL' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COMPARISON_LESS' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COMPARISON_LESS_EQUAL' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COMPARISON_NOT_EQUAL' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LIKE_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(is_sql_mappable(arg\comparison_expression.operands[1]) AND
           is_sql_mappable(arg\comparison_expression.operands[2]));
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INTERVAL_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(is_sql_mappable(arg\interval_expression.interval_low) AND
           is_sql_mappable(arg\interval_expression.interval_high) AND
           is_sql_mappable(arg\interval_expression.interval_item));
  END_IF;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NUMERIC_DEFINED_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BOOLEAN_DEFINED_FUNCTION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STRING_DEFINED_FUNCTION' IN TYPEOF(arg))
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SIMPLE_STRING_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(TRUE);
  END_IF;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INDEX_EXPRESSION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SUBSTRING_EXPRESSION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONCAT_EXPRESSION' IN TYPEOF(arg)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.FORMAT_FUNCTION' IN TYPEOF(arg))
  THEN
    RETURN(FALSE);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

FUNCTION item_in_context(item : representation_item;
                         cntxt : representation_context) : BOOLEAN;
LOCAL
  y : BAG OF representation_item;
END_LOCAL;
  -- If there is one or more representation using both the item
  -- and cntxt return true.
  IF SIZEOF(USEDIN(item, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION.ITEMS') *
            cntxt.representations_in_context) >
     0
  THEN
    RETURN(TRUE);
  ELSE
    y := QUERY(z <* USEDIN(item, '') | 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
    IF SIZEOF(y) > 0
    THEN
      REPEAT i := 1 TO HIINDEX(y);
        IF item_in_context(y[i], cntxt)
        THEN
          RETURN(TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  -- Return false when all possible branches have been checked
  -- with no success.
  RETURN(FALSE);
END_FUNCTION;

FUNCTION leap_year(year : year_number) : BOOLEAN;
  IF ((((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) = 0))
  THEN
    RETURN(TRUE);
  ELSE
    RETURN(FALSE);
  END_IF;
END_FUNCTION;

FUNCTION list_selected_components(aggr : AGGREGATE OF LIST OF maths_value;
                                  k : positive_integer) : LIST OF maths_value;
LOCAL
  result : LIST OF maths_value := [];
  j      : INTEGER             := 0;
END_LOCAL;
  REPEAT i := LOINDEX(aggr) TO HIINDEX(aggr);
    IF k <= SIZEOF(aggr[i])
    THEN
      INSERT(result, aggr[i][k], j);
      j := j + 1;
    END_IF;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

FUNCTION make_atom_based_literal(lit_value : atom_based_value) : atom_based_literal;
  RETURN(atom_based_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
END_FUNCTION;

FUNCTION make_binary_literal(lit_value : BINARY) : binary_literal;
  RETURN(binary_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
END_FUNCTION;

FUNCTION make_boolean_literal(lit_value : BOOLEAN) : boolean_literal;
  RETURN(boolean_literal(lit_value) || simple_boolean_expression() || boolean_expression() || expression() ||
         generic_expression() || simple_generic_expression() || generic_literal());
END_FUNCTION;

FUNCTION make_cartesian_complex_number_region(real_constraint : real_interval;
                                              imag_constraint : real_interval) : cartesian_complex_number_region;
  RETURN(cartesian_complex_number_region(real_constraint, imag_constraint) || maths_space() || generic_expression() ||
         generic_literal() || simple_generic_expression());
END_FUNCTION;

FUNCTION make_complex_number_literal(rpart : REAL;
                                     ipart : REAL) : complex_number_literal;
  RETURN(complex_number_literal(rpart, ipart) || generic_literal() || simple_generic_expression() ||
         generic_expression());
END_FUNCTION;

FUNCTION make_elementary_function(func_id : elementary_function_enumerators) : elementary_function;
  RETURN(elementary_function(func_id) || maths_function() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_elementary_space(space_id : elementary_space_enumerators) : elementary_space;
  RETURN(elementary_space(space_id) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_extended_tuple_space(base : tuple_space;
                                   extender : maths_space) : extended_tuple_space;
  RETURN(extended_tuple_space(base, extender) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_finite_integer_interval(min : INTEGER;
                                      max : INTEGER) : finite_integer_interval;
  RETURN(finite_integer_interval(min, max) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_finite_real_interval(min : REAL;
                                   minclo : open_closed;
                                   max : REAL;
                                   maxclo : open_closed) : finite_real_interval;
  RETURN(finite_real_interval(min, minclo, max, maxclo) || maths_space() || generic_expression() ||
         generic_literal() || simple_generic_expression());
END_FUNCTION;

FUNCTION make_finite_space(members : SET OF maths_value) : finite_space;
  RETURN(finite_space(members) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_function_application(afunction : maths_function_select;
                                   arguments : LIST [1 : ?] OF maths_value) : function_application;
  RETURN(function_application(afunction, arguments) ||
         multiple_arity_generic_expression(convert_to_maths_function(afunction) + convert_to_operands(arguments)) ||
         generic_expression());
END_FUNCTION;

FUNCTION make_function_space(domain_constraint : space_constraint_type;
                             domain_argument : maths_space;
                             range_constraint : space_constraint_type;
                             range_argument : maths_space) : function_space;
  RETURN(function_space(domain_constraint, domain_argument, range_constraint, range_argument) || maths_space() ||
         generic_expression() || generic_literal() || simple_generic_expression());
END_FUNCTION;

FUNCTION make_int_literal(lit_value : INTEGER) : int_literal;
  RETURN(int_literal() || literal_number(lit_value) || simple_numeric_expression() || numeric_expression() ||
         expression() || generic_expression() || simple_generic_expression() || generic_literal());
END_FUNCTION;

FUNCTION make_listed_product_space(factors : LIST OF maths_space) : listed_product_space;
  RETURN(listed_product_space(factors) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_logical_literal(lit_value : LOGICAL) : logical_literal;
  RETURN(logical_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
END_FUNCTION;

FUNCTION make_maths_enum_literal(lit_value : maths_enum_atom) : maths_enum_literal;
  RETURN(maths_enum_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
END_FUNCTION;

FUNCTION make_maths_tuple_literal(lit_value : LIST OF maths_value) : maths_tuple_literal;
  RETURN(maths_tuple_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
END_FUNCTION;

FUNCTION make_parallel_composed_function(srcdom : maths_space_or_function;
                                         prepfuncs : LIST [2 : ?] OF maths_function;
                                         finfunc : maths_function_select) : parallel_composed_function;
  RETURN(parallel_composed_function(srcdom, prepfuncs, finfunc) || maths_function() || generic_expression() ||
         multiple_arity_generic_expression(convert_to_operands_prcmfn(srcdom, prepfuncs, finfunc)));
END_FUNCTION;

FUNCTION make_polar_complex_number_region(centre : complex_number_literal;
                                          dis_constraint : real_interval;
                                          dir_constraint : finite_real_interval) : polar_complex_number_region;
  RETURN(polar_complex_number_region(centre, dis_constraint, dir_constraint) || maths_space() ||
         generic_expression() || generic_literal() || simple_generic_expression());
END_FUNCTION;

FUNCTION make_real_interval_from_min(min : REAL;
                                     minclo : open_closed) : real_interval_from_min;
  RETURN(real_interval_from_min(min, minclo) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_real_interval_to_max(max : REAL;
                                   maxclo : open_closed) : real_interval_to_max;
  RETURN(real_interval_to_max(max, maxclo) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_real_literal(lit_value : REAL) : real_literal;
  RETURN(real_literal() || literal_number(lit_value) || simple_numeric_expression() || numeric_expression() ||
         expression() || generic_expression() || simple_generic_expression() || generic_literal());
END_FUNCTION;

FUNCTION make_string_literal(lit_value : STRING) : string_literal;
  RETURN(string_literal(lit_value) || simple_string_expression() || string_expression() || expression() ||
         generic_expression() || simple_generic_expression() || generic_literal());
END_FUNCTION;

FUNCTION make_uniform_product_space(base : maths_space;
                                    exponent : positive_integer) : uniform_product_space;
  RETURN(uniform_product_space(base, exponent) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION max_exists(spc : maths_space) : BOOLEAN;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  RETURN(bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
              ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) OR
              ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
              ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types)));
END_FUNCTION;

FUNCTION max_included(spc : maths_space) : BOOLEAN;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types)
  THEN
    RETURN(TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types)
  THEN
    RETURN(bool(spc\finite_real_interval.max_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types)
  THEN
    RETURN(bool(spc\real_interval_to_max.max_closure = closed));
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

FUNCTION member_of(val : GENERIC : G;
                   spc : maths_space) : LOGICAL;
FUNCTION fedex(val : AGGREGATE OF GENERIC : X;
               i : INTEGER) : GENERIC : X;
  RETURN(val[i]);
END_FUNCTION;
LOCAL
  v         : maths_value            := simplify_maths_value(convert_to_maths_value(val));
  vtypes    : SET OF STRING          := stripped_typeof(v);
  s         : maths_space            := simplify_maths_space(spc);
  stypes    : SET OF STRING          := stripped_typeof(s);
  tmp_int   : INTEGER;
  tmp_real  : REAL;
  tmp_cmplx : complex_number_literal;
  lgcl      : LOGICAL;
  cum       : LOGICAL;
  vspc      : maths_space;
  sspc      : maths_space;
  smem      : SET OF maths_value;
  factors   : LIST OF maths_space;
END_LOCAL;
  IF NOT EXISTS(s)
  THEN
    RETURN(FALSE);
  END_IF;
  IF NOT EXISTS(v)
  THEN
    RETURN(s = the_generics);
  END_IF;
  IF ('GENERIC_EXPRESSION' IN vtypes) AND
     NOT ('MATHS_SPACE' IN vtypes) AND NOT ('MATHS_FUNCTION' IN vtypes) AND NOT ('COMPLEX_NUMBER_LITERAL' IN vtypes)
  THEN
    IF has_values_space(v)
    THEN
      vspc := values_space_of(v);
      IF subspace_of(vspc, s)
      THEN
        RETURN(TRUE);
      END_IF;
      IF NOT compatible_spaces(vspc, s)
      THEN
        RETURN(FALSE);
      END_IF;
      RETURN(UNKNOWN);
    END_IF;
    RETURN(UNKNOWN);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN stypes
  THEN
    CASE s\elementary_space.space_id OF
      es_numbers : RETURN(('NUMBER' IN vtypes) OR ('COMPLEX_NUMBER_LITERAL' IN vtypes));
      es_complex_numbers : RETURN('COMPLEX_NUMBER_LITERAL' IN vtypes);
      es_reals : RETURN(('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes));
      es_integers : RETURN('INTEGER' IN vtypes);
      es_logicals : RETURN('LOGICAL' IN vtypes);
      es_booleans : RETURN('BOOLEAN' IN vtypes);
      es_strings : RETURN('STRING' IN vtypes);
      es_binarys : RETURN('BINARY' IN vtypes);
      es_maths_spaces : RETURN('MATHS_SPACE' IN vtypes);
      es_maths_functions : RETURN('MATHS_FUNCTION' IN vtypes);
      es_generics : RETURN(TRUE);
    END_CASE;
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN stypes
  THEN
    IF 'INTEGER' IN vtypes
    THEN
      tmp_int := v;
      RETURN({s\finite_integer_interval.min <= tmp_int <= s\finite_integer_interval.max});
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN stypes
  THEN
    IF 'INTEGER' IN vtypes
    THEN
      tmp_int := v;
      RETURN(s\integer_interval_from_min.min <= tmp_int);
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN stypes
  THEN
    IF 'INTEGER' IN vtypes
    THEN
      tmp_int := v;
      RETURN(tmp_int <= s\integer_interval_to_max.max);
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN stypes
  THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes)
    THEN
      tmp_real := v;
      IF s\finite_real_interval.min_closure = closed
      THEN
        IF s\finite_real_interval.max_closure = closed
        THEN
          RETURN({s\finite_real_interval.min <= tmp_real <= s\finite_real_interval.max});
        ELSE
          RETURN({s\finite_real_interval.min <= tmp_real < s\finite_real_interval.max});
        END_IF;
      ELSE
        IF s\finite_real_interval.max_closure = closed
        THEN
          RETURN({s\finite_real_interval.min < tmp_real <= s\finite_real_interval.max});
        ELSE
          RETURN({s\finite_real_interval.min < tmp_real < s\finite_real_interval.max});
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN stypes
  THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes)
    THEN
      tmp_real := v;
      IF s\real_interval_from_min.min_closure = closed
      THEN
        RETURN(s\real_interval_from_min.min <= tmp_real);
      ELSE
        RETURN(s\real_interval_from_min.min < tmp_real);
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN stypes
  THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes)
    THEN
      tmp_real := v;
      IF s\real_interval_to_max.max_closure = closed
      THEN
        RETURN(tmp_real <= s\real_interval_to_max.max);
      ELSE
        RETURN(tmp_real < s\real_interval_to_max.max);
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN stypes
  THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes
    THEN
      RETURN(member_of(v\complex_number_literal.real_part, s\cartesian_complex_number_region.real_constraint) AND
             member_of(v\complex_number_literal.imag_part, s\cartesian_complex_number_region.imag_constraint));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN stypes
  THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes
    THEN
      tmp_cmplx := v;
      tmp_cmplx.real_part := tmp_cmplx.real_part - s\polar_complex_number_region.centre.real_part;
      tmp_cmplx.imag_part := tmp_cmplx.imag_part - s\polar_complex_number_region.centre.imag_part;
      tmp_real := SQRT(tmp_cmplx.real_part ** 2 + tmp_cmplx.imag_part ** 2);
      IF NOT member_of(tmp_real, s\polar_complex_number_region.distance_constraint)
      THEN
        RETURN(FALSE);
      END_IF;
      IF tmp_real = 0.0
      THEN
        RETURN(TRUE);
      END_IF;
      tmp_real := atan2(tmp_cmplx.imag_part, tmp_cmplx.real_part);
      RETURN(member_of(tmp_real, s\polar_complex_number_region.direction_constraint) OR
             member_of(tmp_real + 2.0 * PI, s\polar_complex_number_region.direction_constraint));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN stypes
  THEN
    smem := s\finite_space.members;
    cum := FALSE;
    REPEAT i := 1 TO SIZEOF(smem);
      cum := cum OR equal_maths_values(v, smem[i]);
      IF cum = TRUE
      THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
    RETURN(cum);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes
  THEN
    IF 'LIST' IN vtypes
    THEN
      IF SIZEOF(v) = s\uniform_product_space.exponent
      THEN
        sspc := s\uniform_product_space.base;
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF(v);
          cum := cum AND member_of(v[i], sspc);
          IF cum = FALSE
          THEN
            RETURN(FALSE);
          END_IF;
        END_REPEAT;
        RETURN(cum);
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes
  THEN
    IF 'LIST' IN vtypes
    THEN
      factors := s\listed_product_space.factors;
      IF SIZEOF(v) = SIZEOF(factors)
      THEN
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF(v);
          cum := cum AND member_of(v[i], factors[i]);
          IF cum = FALSE
          THEN
            RETURN(FALSE);
          END_IF;
        END_REPEAT;
        RETURN(cum);
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes
  THEN
    IF 'LIST' IN vtypes
    THEN
      sspc := s\extended_tuple_space.base;
      tmp_int := space_dimension(sspc);
      IF SIZEOF(v) >= tmp_int
      THEN
        cum := TRUE;
        REPEAT i := 1 TO tmp_int;
          cum := cum AND member_of(v[i], factor_space(sspc, i));
          IF cum = FALSE
          THEN
            RETURN(FALSE);
          END_IF;
        END_REPEAT;
        sspc := s\extended_tuple_space.extender;
        REPEAT i := tmp_int + 1 TO SIZEOF(v);
          cum := cum AND member_of(v[i], sspc);
          IF cum = FALSE
          THEN
            RETURN(FALSE);
          END_IF;
        END_REPEAT;
        RETURN(cum);
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes
  THEN
    IF 'MATHS_FUNCTION' IN vtypes
    THEN
      vspc := v\maths_function.domain;
      sspc := s\function_space.domain_argument;
      CASE s\function_space.domain_constraint OF
        sc_equal : cum := equal_maths_spaces(vspc, sspc);
        sc_subspace : cum := subspace_of(vspc, sspc);
        sc_member : cum := member_of(vspc, sspc);
      END_CASE;
      IF cum = FALSE
      THEN
        RETURN(FALSE);
      END_IF;
      vspc := v\maths_function.range;
      sspc := s\function_space.range_argument;
      CASE s\function_space.range_constraint OF
        sc_equal : cum := cum AND equal_maths_spaces(vspc, sspc);
        sc_subspace : cum := cum AND subspace_of(vspc, sspc);
        sc_member : cum := cum AND member_of(vspc, sspc);
      END_CASE;
      RETURN(cum);
    END_IF;
    RETURN(FALSE);
  END_IF;
  -- Should be unreachable
  RETURN(UNKNOWN);
END_FUNCTION;

FUNCTION min_exists(spc : maths_space) : BOOLEAN;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  RETURN(bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
              ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) OR
              ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
              ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types)));
END_FUNCTION;

FUNCTION min_included(spc : maths_space) : BOOLEAN;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types)
  THEN
    RETURN(TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types)
  THEN
    RETURN(bool(spc\finite_real_interval.min_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types)
  THEN
    RETURN(bool(spc\real_interval_from_min.min_closure = closed));
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

FUNCTION no_cyclic_domain_reference(ref : maths_space_or_function;
                                    used : SET OF maths_function) : BOOLEAN;
LOCAL
  typenames : SET OF STRING  := TYPEOF(ref);
  func      : maths_function;
END_LOCAL;
  IF (NOT EXISTS(ref)) OR (NOT EXISTS(used))
  THEN
    RETURN(FALSE);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  func := ref;
  IF func IN used
  THEN
    RETURN(FALSE);
  END_IF;
  IF (schema_prefix + 'CONSTANT_FUNCTION') IN typenames
  THEN
    RETURN(no_cyclic_domain_reference(func\constant_function.source_of_domain, used + [func]));
  END_IF;
  IF (schema_prefix + 'SELECTOR_FUNCTION') IN typenames
  THEN
    RETURN(no_cyclic_domain_reference(func\selector_function.source_of_domain, used + [func]));
  END_IF;
  IF (schema_prefix + 'PARALLEL_COMPOSED_FUNCTION') IN typenames
  THEN
    RETURN(no_cyclic_domain_reference(func\parallel_composed_function.source_of_domain, used + [func]));
  END_IF;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION no_cyclic_space_reference(spc : maths_space;
                                   refs : SET OF maths_space) : BOOLEAN;
LOCAL
  types     : SET OF STRING;
  refs_plus : SET OF maths_space;
END_LOCAL;
  IF (spc IN refs)
  THEN
    RETURN(FALSE);
  END_IF;
  types := TYPEOF(spc);
  refs_plus := refs + spc;
  IF (schema_prefix + 'FINITE_SPACE') IN types
  THEN
    RETURN(bool(SIZEOF(QUERY(sp
                             <* QUERY(mem <* spc\finite_space.members | (schema_prefix + 'MATHS_SPACE') IN TYPEOF(mem))
                             | NOT no_cyclic_space_reference(sp, refs_plus))) =
                0));
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types
  THEN
    RETURN(no_cyclic_space_reference(spc\uniform_product_space.base, refs_plus));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types
  THEN
    RETURN(bool(SIZEOF(QUERY(fac
                             <* spc\listed_product_space.factors
                             | NOT no_cyclic_space_reference(fac, refs_plus))) =
                0));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types
  THEN
    RETURN(no_cyclic_space_reference(spc\extended_tuple_space.base, refs_plus) AND
           no_cyclic_space_reference(spc\extended_tuple_space.extender, refs_plus));
  END_IF;
  -- spc contains no references to other spaces
  RETURN(TRUE);
END_FUNCTION;

FUNCTION nondecreasing(lr : LIST OF REAL) : BOOLEAN;
  IF NOT EXISTS(lr)
  THEN
    RETURN(FALSE);
  END_IF;
  REPEAT j := 2 TO SIZEOF(lr);
    IF lr[j] < lr[j - 1]
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION normalise(arg : vector_or_direction) : vector_or_direction;
LOCAL
  ndim   : INTEGER;
  v      : direction           := dummy_gri || direction([1.0,0.0,0.0]);
  result : vector_or_direction;
  vec    : vector              := dummy_gri || vector(v, 1.0);
  mag    : REAL;
END_LOCAL;
  IF NOT EXISTS(arg)
  THEN
    result := ?;
  ELSE
    ndim := arg.dim;
    IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VECTOR' IN TYPEOF(arg)
    THEN
      BEGIN  
             v := dummy_gri || direction(arg\vector.orientation.direction_ratios);
             IF arg\vector.magnitude = 0.0
             THEN
               RETURN(?);
             ELSE
               vec := dummy_gri || vector(v, 1.0);
             END_IF;
      END;
    ELSE
      v := dummy_gri || direction(arg.direction_ratios);
    END_IF;
    mag := 0.0;
    REPEAT i := 1 TO ndim;
      mag := mag + v.direction_ratios[i] * v.direction_ratios[i];
    END_REPEAT;
    IF mag > 0.0
    THEN
      mag := SQRT(mag);
      REPEAT i := 1 TO ndim;
        v.direction_ratios[i] := v.direction_ratios[i] / mag;
      END_REPEAT;
      IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VECTOR' IN TYPEOF(arg)
      THEN
        vec.orientation := v;
        result := vec;
      ELSE
        result := v;
      END_IF;
    ELSE
      RETURN(?);
    END_IF;
  END_IF;
  RETURN(result);
END_FUNCTION;

FUNCTION number_superspace_of(spc : maths_space) : elementary_space;
  IF subspace_of_es(spc, es_integers)
  THEN
    RETURN(the_integers);
  END_IF;
  IF subspace_of_es(spc, es_reals)
  THEN
    RETURN(the_reals);
  END_IF;
  IF subspace_of_es(spc, es_complex_numbers)
  THEN
    RETURN(the_complex_numbers);
  END_IF;
  IF subspace_of_es(spc, es_numbers)
  THEN
    RETURN(the_numbers);
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION number_tuple_subspace_check(spc : maths_space) : LOGICAL;
LOCAL
  types   : SET OF STRING       := stripped_typeof(spc);
  factors : LIST OF maths_space;
  cum     : LOGICAL             := TRUE;
END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN types
  THEN
    RETURN(subspace_of_es(spc\uniform_product_space.base, es_numbers));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types
  THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF(factors);
      cum := cum AND subspace_of_es(factors[i], es_numbers);
    END_REPEAT;
    RETURN(cum);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types
  THEN
    cum := subspace_of_es(spc\extended_tuple_space.extender, es_numbers);
    cum := cum AND number_tuple_subspace_check(spc\extended_tuple_space.base);
    RETURN(cum);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

FUNCTION one_tuples_of(spc : maths_space) : tuple_space;
  RETURN(make_uniform_product_space(spc, 1));
END_FUNCTION;

FUNCTION orthogonal_complement(vec : direction) : direction;
LOCAL
  result : direction;
END_LOCAL;
  IF (vec.dim <> 2) OR NOT EXISTS(vec)
  THEN
    RETURN(?);
  ELSE
    result := dummy_gri || direction([-vec.direction_ratios[2],vec.direction_ratios[1]]);
    RETURN(result);
  END_IF;
END_FUNCTION;

FUNCTION parallel_composed_function_composability_check(funcs : LIST OF maths_function;
                                                        final : maths_function_select) : BOOLEAN;
LOCAL
  tplsp  : tuple_space    := the_zero_tuple_space;
  finfun : maths_function := convert_to_maths_function(final);
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(funcs);
    tplsp := assoc_product_space(tplsp, funcs[i].range);
  END_REPEAT;
  RETURN(compatible_spaces(tplsp, finfun.domain));
END_FUNCTION;

FUNCTION parallel_composed_function_domain_check(comdom : tuple_space;
                                                 funcs : LIST OF maths_function) : BOOLEAN;
  REPEAT i := 1 TO SIZEOF(funcs);
    IF NOT (compatible_spaces(comdom, funcs[i].domain))
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION parse_express_identifier(s : STRING;
                                  i : positive_integer) : positive_integer;
LOCAL
  k : positive_integer;
END_LOCAL;
  k := i;
  IF i <= LENGTH(s)
  THEN
    IF (s[i] LIKE '@')
    THEN
      REPEAT UNTIL (k > LENGTH(s)) OR ((s[k] <> '_') AND NOT (s[k] LIKE '@') AND NOT (s[k] LIKE '#'));
        k := k + 1;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN(k);
END_FUNCTION;

FUNCTION partial_derivative_check(domain : tuple_space;
                                  d_vars : LIST [1 : ?] OF input_selector) : BOOLEAN;
LOCAL
  domn : tuple_space := domain;
  fspc : maths_space;
  dim  : INTEGER;
  k    : INTEGER;
END_LOCAL;
  IF (space_dimension(domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(domain)))
  THEN
    domn := factor1(domain);
  END_IF;
  dim := space_dimension(domn);
  REPEAT i := 1 TO SIZEOF(d_vars);
    k := d_vars[i];
    IF k > dim
    THEN
      RETURN(FALSE);
    END_IF;
    fspc := factor_space(domn, k);
    IF (NOT subspace_of_es(fspc, es_reals)) AND (NOT subspace_of_es(fspc, es_complex_numbers))
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION real_max(spc : maths_space) : REAL;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types)
  THEN
    RETURN(spc\finite_integer_interval.max);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types)
  THEN
    RETURN(spc\integer_interval_to_max.max);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types)
  THEN
    RETURN(spc\finite_real_interval.max);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types)
  THEN
    RETURN(spc\real_interval_to_max.max);
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION real_min(spc : maths_space) : REAL;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types)
  THEN
    RETURN(spc\finite_integer_interval.min);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types)
  THEN
    RETURN(spc\integer_interval_from_min.min);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types)
  THEN
    RETURN(spc\finite_real_interval.min);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types)
  THEN
    RETURN(spc\real_interval_from_min.min);
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION regular_indexing(sub : LIST OF INTEGER;
                          base : zero_or_one;
                          shape : LIST [1 : ?] OF positive_integer;
                          inc : LIST [1 : ?] OF INTEGER;
                          first : INTEGER) : INTEGER;
LOCAL
  k     : INTEGER;
  index : INTEGER;
END_LOCAL;
  IF NOT EXISTS(sub) OR NOT EXISTS(base) OR NOT EXISTS(shape) OR NOT EXISTS(inc) OR NOT EXISTS(first)
  THEN
    RETURN(?);
  END_IF;
  IF (SIZEOF(sub) <> SIZEOF(inc)) OR (SIZEOF(sub) <> SIZEOF(shape))
  THEN
    RETURN(?);
  END_IF;
  index := first;
  REPEAT j := 1 TO SIZEOF(sub);
    IF NOT EXISTS(sub[j]) OR NOT EXISTS(inc[j])
    THEN
      RETURN(?);
    END_IF;
    k := sub[j] - base;
    IF NOT ({0 <= k < shape[j]})
    THEN
      RETURN(?);
    END_IF;
    index := index + k * inc[j];
  END_REPEAT;
  RETURN(index);
END_FUNCTION;

FUNCTION remove_first(alist : LIST OF GENERIC : GEN) : LIST OF GENERIC : GEN;
LOCAL
  blist : LIST OF GENERIC : GEN := alist;
END_LOCAL;
  IF SIZEOF(blist) > 0
  THEN
    REMOVE(blist, 1);
  END_IF;
  RETURN(blist);
END_FUNCTION;

FUNCTION repackage(tspace : tuple_space;
                   repckg : repackage_options) : tuple_space;
  CASE repckg OF
    ro_nochange : RETURN(tspace);
    ro_wrap_as_tuple : RETURN(one_tuples_of(tspace));
    ro_unwrap_tuple : RETURN(factor1(tspace));
    OTHERWISE: RETURN(?);
  END_CASE;
END_FUNCTION;

FUNCTION scalar_times_vector(scalar : REAL;
                             vec : vector_or_direction) : vector;
LOCAL
  v      : direction;
  mag    : REAL;
  result : vector;
END_LOCAL;
  IF NOT EXISTS(scalar) OR NOT EXISTS(vec)
  THEN
    RETURN(?);
  ELSE
    IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VECTOR' IN TYPEOF(vec)
    THEN
      v := dummy_gri || direction(vec\vector.orientation.direction_ratios);
      mag := scalar * vec\vector.magnitude;
    ELSE
      v := dummy_gri || direction(vec.direction_ratios);
      mag := scalar;
    END_IF;
    IF (mag < 0.0)
    THEN
      REPEAT i := 1 TO SIZEOF(v.direction_ratios);
        v.direction_ratios[i] := -v.direction_ratios[i];
      END_REPEAT;
      mag := -mag;
    END_IF;
    result := dummy_gri || vector(normalise(v), mag);
  END_IF;
  RETURN(result);
END_FUNCTION;

FUNCTION second_proj_axis(z_axis : direction;
                          x_axis : direction;
                          arg : direction) : direction;
LOCAL
  y_axis : vector;
  v      : direction;
  temp   : vector;
END_LOCAL;
  IF NOT EXISTS(arg)
  THEN
    v := dummy_gri || direction([0.0,1.0,0.0]);
  ELSE
    v := arg;
  END_IF;
  temp := scalar_times_vector(dot_product(v, z_axis), z_axis);
  y_axis := vector_difference(v, temp);
  temp := scalar_times_vector(dot_product(v, x_axis), x_axis);
  y_axis := vector_difference(y_axis, temp);
  y_axis := normalise(y_axis);
  RETURN(y_axis.orientation);
END_FUNCTION;

FUNCTION shape_of_array(func : maths_function) : LIST OF positive_integer;
LOCAL
  tspace : tuple_space;
  temp   : maths_space;
  result : LIST OF positive_integer := [];
END_LOCAL;
  IF (schema_prefix + 'EXPLICIT_TABLE_FUNCTION') IN TYPEOF(func)
  THEN
    RETURN(func\explicit_table_function.shape);
  END_IF;
  tspace := func.domain;
  IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(tspace)))
  THEN
    tspace := factor1(tspace);
  END_IF;
  REPEAT i := 1 TO space_dimension(tspace);
    temp := factor_space(tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
    THEN
      RETURN(?);
    END_IF;
    INSERT(result, temp\finite_integer_interval.size, i - 1);
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

FUNCTION simplify_function_application(expr : function_application) : maths_value;
FUNCTION ctmv(x : GENERIC : G) : maths_value;
  RETURN(convert_to_maths_value(x));
END_FUNCTION;
PROCEDURE parts(c : complex_number_literal; VAR x : REAL; VAR y : REAL);
  x := c.real_part;
  y := c.imag_part;
END_PROCEDURE;
FUNCTION makec(x : REAL;
               y : REAL) : complex_number_literal;
  RETURN(make_complex_number_literal(x, y));
END_FUNCTION;
FUNCTION good_t(v : maths_value;
                tn : STRING) : BOOLEAN;
LOCAL
  tpl : LIST OF maths_value;
END_LOCAL;
  IF 'LIST' IN TYPEOF(v)
  THEN
    tpl := v;
    REPEAT i := 1 TO SIZEOF(tpl);
      IF NOT (tn IN TYPEOF(tpl[i]))
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

CONSTANT
  cnlit : STRING := schema_prefix + 'COMPLEX_NUMBER_LITERAL';
END_CONSTANT;
LOCAL
  types         : SET OF STRING                              := stripped_typeof(expr.func);
  ef_val        : elementary_function_enumerators;
  is_elementary : BOOLEAN                                    := FALSE;
  v             : maths_value;
  v1            : maths_value;
  v2            : maths_value;
  v3            : maths_value;
  vlist         : LIST OF maths_value                        := [];
  gexpr         : generic_expression;
  pairs         : SET [1 : ?] OF LIST [2 : 2] OF maths_value;
  boo           : BOOLEAN;
  lgc           : LOGICAL;
  cum           : LOGICAL;
  j             : INTEGER;
  k             : INTEGER;
  n             : INTEGER;
  p             : REAL;
  q             : REAL;
  r             : REAL;
  s             : REAL;
  t             : REAL;
  u             : REAL;
  str           : STRING;
  st2           : STRING;
  bin           : BINARY;
  bi2           : BINARY;
  tpl           : LIST OF maths_value;
  tp2           : LIST OF maths_value;
  mem           : SET OF maths_value                         := [];
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(expr.arguments);
    v := simplify_maths_value(expr.arguments[i]);
    INSERT(vlist, v, i - 1);
  END_REPEAT;
  IF SIZEOF(vlist) >= 1
  THEN
    v1 := vlist[1];
  END_IF;
  IF SIZEOF(vlist) >= 2
  THEN
    v2 := vlist[2];
  END_IF;
  IF SIZEOF(vlist) >= 3
  THEN
    v3 := vlist[3];
  END_IF;
  IF 'ELEMENTARY_FUNCTION_ENUMERATORS' IN types
  THEN
    ef_val := expr.func;
    is_elementary := TRUE;
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN types
  THEN
    ef_val := expr.func\elementary_function.func_id;
    is_elementary := TRUE;
  END_IF;
  IF is_elementary
  THEN
    CASE ef_val OF
      ef_and : BEGIN  
                      cum := TRUE;
                      REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF 'LOGICAL' IN TYPEOF(vlist[i])
                        THEN
                          lgc := vlist[i];
                          cum := cum AND lgc;
                          IF lgc = FALSE
                          THEN
                            RETURN(ctmv(FALSE));
                          END_IF;
                          REMOVE(vlist, i);
                        END_IF;
                      END_REPEAT;
                      IF SIZEOF(vlist) = 0
                      THEN
                        RETURN(ctmv(cum));
                      END_IF;
                      IF cum <> TRUE
                      THEN
                        INSERT(vlist, ctmv(cum), 0);
                      END_IF;
                      IF SIZEOF(vlist) = 1
                      THEN
                        RETURN(vlist[1]);
                      END_IF;
      END;
      ef_or : BEGIN  
                     cum := FALSE;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                       IF 'LOGICAL' IN TYPEOF(vlist[i])
                       THEN
                         lgc := vlist[i];
                         cum := cum OR lgc;
                         IF lgc = TRUE
                         THEN
                           RETURN(ctmv(TRUE));
                         END_IF;
                         REMOVE(vlist, i);
                       END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0
                     THEN
                       RETURN(ctmv(cum));
                     END_IF;
                     IF cum <> FALSE
                     THEN
                       INSERT(vlist, ctmv(cum), 0);
                     END_IF;
                     IF SIZEOF(vlist) = 1
                     THEN
                       RETURN(vlist[1]);
                     END_IF;
      END;
      ef_not : IF 'LOGICAL' IN TYPEOF(v1)
      THEN
        lgc := v1;
        RETURN(ctmv(NOT lgc));
      END_IF;
      ef_xor : BEGIN  
                      IF 'LOGICAL' IN TYPEOF(v1)
                      THEN
                        lgc := v1;
                        IF 'LOGICAL' IN TYPEOF(v2)
                        THEN
                          cum := v2;
                          RETURN(ctmv(lgc XOR cum));
                        ELSE
                          IF lgc = FALSE
                          THEN
                            RETURN(ctmv(v2));
                          ELSE
                            IF lgc = UNKNOWN
                            THEN
                              RETURN(ctmv(UNKNOWN));
                            ELSE
                              RETURN(make_function_application(ef_not, [v2]));
                            END_IF;
                          END_IF;
                        END_IF;
                      ELSE
                        IF 'LOGICAL' IN TYPEOF(v2)
                        THEN
                          lgc := v2;
                          IF lgc = FALSE
                          THEN
                            RETURN(ctmv(v1));
                          ELSE
                            IF lgc = UNKNOWN
                            THEN
                              RETURN(ctmv(UNKNOWN));
                            ELSE
                              RETURN(make_function_application(ef_not, [v1]));
                            END_IF;
                          END_IF;
                        END_IF;
                      END_IF;
      END;
      ef_negate_i : IF 'INTEGER' IN TYPEOF(v1)
      THEN
        j := v1;
        RETURN(ctmv(-j));
      END_IF;
      ef_add_i : BEGIN  
                        j := 0;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'INTEGER' IN TYPEOF(vlist[i])
                          THEN
                            k := vlist[i];
                            j := j + k;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(j));
                        END_IF;
                        IF j <> 0
                        THEN
                          INSERT(vlist, ctmv(j), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_subtract_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j - k));
      END_IF;
      ef_multiply_i : BEGIN  
                             j := 1;
                             REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                               IF 'INTEGER' IN TYPEOF(vlist[i])
                               THEN
                                 k := vlist[i];
                                 j := j * k;
                                 REMOVE(vlist, i);
                               END_IF;
                             END_REPEAT;
                             IF SIZEOF(vlist) = 0
                             THEN
                               RETURN(ctmv(j));
                             END_IF;
                             IF j <> 1
                             THEN
                               INSERT(vlist, ctmv(j), 0);
                             END_IF;
                             IF SIZEOF(vlist) = 1
                             THEN
                               RETURN(vlist[1]);
                             END_IF;
      END;
      ef_divide_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j DIV k));
      END_IF;
      ef_mod_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j MOD k));
      END_IF;
      ef_exponentiate_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        n := 1;
        REPEAT i := 1 TO ABS(k);
          n := n * j;
        END_REPEAT;
        IF k < 0
        THEN
          n := 1 DIV n;
        END_IF;
        RETURN(ctmv(n));
      END_IF;
      ef_eq_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j = k));
      END_IF;
      ef_ne_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j <> k));
      END_IF;
      ef_gt_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j > k));
      END_IF;
      ef_lt_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j < k));
      END_IF;
      ef_ge_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j >= k));
      END_IF;
      ef_le_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j <= k));
      END_IF;
      ef_abs_i : IF 'INTEGER' IN TYPEOF(v1)
      THEN
        j := v1;
        RETURN(ctmv(ABS(j)));
      END_IF;
      ef_max_i : BEGIN  
                        boo := FALSE;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'INTEGER' IN TYPEOF(vlist[i])
                          THEN
                            IF boo
                            THEN
                              k := vlist[i];
                              IF k > j
                              THEN
                                j := k;
                              END_IF;
                            ELSE
                              j := vlist[i];
                              boo := TRUE;
                            END_IF;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(j));
                        END_IF;
                        IF boo
                        THEN
                          INSERT(vlist, ctmv(j), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_min_i : BEGIN  
                        boo := FALSE;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'INTEGER' IN TYPEOF(vlist[i])
                          THEN
                            IF boo
                            THEN
                              k := vlist[i];
                              IF k < j
                              THEN
                                j := k;
                              END_IF;
                            ELSE
                              j := vlist[i];
                              boo := TRUE;
                            END_IF;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(j));
                        END_IF;
                        IF boo
                        THEN
                          INSERT(vlist, ctmv(j), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_negate_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(-r));
      END_IF;
      ef_reciprocal_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(1.0 / r));
      END_IF;
      ef_add_r : BEGIN  
                        r := 0.0;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'REAL' IN TYPEOF(vlist[i])
                          THEN
                            s := vlist[i];
                            r := r + s;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(r));
                        END_IF;
                        IF r <> 0.0
                        THEN
                          INSERT(vlist, ctmv(r), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_subtract_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r - s));
      END_IF;
      ef_multiply_r : BEGIN  
                             r := 1.0;
                             REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                               IF 'REAL' IN TYPEOF(vlist[i])
                               THEN
                                 s := vlist[i];
                                 r := r * s;
                                 REMOVE(vlist, i);
                               END_IF;
                             END_REPEAT;
                             IF SIZEOF(vlist) = 0
                             THEN
                               RETURN(ctmv(r));
                             END_IF;
                             IF r <> 1.0
                             THEN
                               INSERT(vlist, ctmv(r), 0);
                             END_IF;
                             IF SIZEOF(vlist) = 1
                             THEN
                               RETURN(vlist[1]);
                             END_IF;
      END;
      ef_divide_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r / s));
      END_IF;
      ef_mod_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        t := r / s;
        j := t DIV 1;
        IF (t < 0.0) AND (j <> t)
        THEN
          j := j - 1;
        END_IF;
        RETURN(ctmv(r - j * s));
      END_IF;
      ef_exponentiate_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r ** s));
      END_IF;
      ef_exponentiate_ri : IF ('REAL' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        r := v1;
        k := v2;
        t := 1.0;
        REPEAT i := 1 TO ABS(k);
          t := t * r;
        END_REPEAT;
        IF k < 0
        THEN
          t := 1.0 / t;
        END_IF;
        RETURN(ctmv(t));
      END_IF;
      ef_eq_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r = s));
      END_IF;
      ef_ne_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r <> s));
      END_IF;
      ef_gt_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r > s));
      END_IF;
      ef_lt_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r < s));
      END_IF;
      ef_ge_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r >= s));
      END_IF;
      ef_le_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r <= s));
      END_IF;
      ef_abs_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(ABS(r)));
      END_IF;
      ef_max_r : BEGIN  
                        boo := FALSE;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'REAL' IN TYPEOF(vlist[i])
                          THEN
                            IF boo
                            THEN
                              s := vlist[i];
                              IF s > r
                              THEN
                                r := s;
                              END_IF;
                            ELSE
                              r := vlist[i];
                              boo := TRUE;
                            END_IF;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(r));
                        END_IF;
                        IF boo
                        THEN
                          INSERT(vlist, ctmv(r), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_min_r : BEGIN  
                        boo := FALSE;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'REAL' IN TYPEOF(vlist[i])
                          THEN
                            IF boo
                            THEN
                              s := vlist[i];
                              IF s < r
                              THEN
                                r := s;
                              END_IF;
                            ELSE
                              r := vlist[i];
                              boo := TRUE;
                            END_IF;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(r));
                        END_IF;
                        IF boo
                        THEN
                          INSERT(vlist, ctmv(r), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_acos_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(ACOS(r)));
      END_IF;
      ef_asin_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(ASIN(r)));
      END_IF;
      ef_atan2_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(atan2(r, s)));
      END_IF;
      ef_cos_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(COS(r)));
      END_IF;
      ef_exp_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(EXP(r)));
      END_IF;
      ef_ln_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(LOG(r)));
      END_IF;
      ef_log2_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(LOG2(r)));
      END_IF;
      ef_log10_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(LOG10(r)));
      END_IF;
      ef_sin_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(SIN(r)));
      END_IF;
      ef_sqrt_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(SQRT(r)));
      END_IF;
      ef_tan_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(TAN(r)));
      END_IF;
      ef_form_c : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(makec(r, s));
      END_IF;
      ef_rpart_c : IF cnlit IN TYPEOF(v1)
      THEN
        RETURN(ctmv(v1\complex_number_literal.real_part));
      END_IF;
      ef_ipart_c : IF cnlit IN TYPEOF(v1)
      THEN
        RETURN(ctmv(v1\complex_number_literal.imag_part));
      END_IF;
      ef_negate_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(makec(-p, -q));
      END_IF;
      ef_reciprocal_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        t := p * p + q * q;
        RETURN(makec(p / t, -q / t));
      END_IF;
      ef_add_c : BEGIN  
                        p := 0.0;
                        q := 0.0;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF cnlit IN TYPEOF(vlist[i])
                          THEN
                            parts(vlist[i], r, s);
                            p := p + r;
                            q := q + s;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(makec(p, q));
                        END_IF;
                        IF p * p + q * q <> 0.0
                        THEN
                          INSERT(vlist, makec(p, q), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_subtract_c : IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        parts(v2, r, s);
        RETURN(makec(p - r, q - s));
      END_IF;
      ef_multiply_c : BEGIN  
                             p := 1.0;
                             q := 0.0;
                             REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                               IF cnlit IN TYPEOF(vlist[i])
                               THEN
                                 parts(vlist[i], r, s);
                                 p := p * r - q * s;
                                 q := p * s + q * r;
                                 REMOVE(vlist, i);
                               END_IF;
                             END_REPEAT;
                             IF SIZEOF(vlist) = 0
                             THEN
                               RETURN(makec(p, q));
                             END_IF;
                             IF (p <> 1.0) OR (q <> 0.0)
                             THEN
                               INSERT(vlist, makec(p, q), 0);
                             END_IF;
                             IF SIZEOF(vlist) = 1
                             THEN
                               RETURN(vlist[1]);
                             END_IF;
      END;
      ef_divide_c : IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        parts(v2, r, s);
        t := r * r + s * s;
        RETURN(makec((p * r + q * s) / t, (q * r - p * s) / t));
      END_IF;
      ef_exponentiate_c : IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        parts(v2, r, s);
        t := 0.5 * LOG(p * p + q * q);
        u := atan2(q, p);
        p := r * t - s * u;
        q := r * u + s * t;
        r := EXP(p);
        RETURN(makec(r * COS(q), r * SIN(q)));
      END_IF;
      ef_exponentiate_ci : IF (cnlit IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        k := v2;
        r := 1.0;
        s := 0.0;
        REPEAT i := 1 TO ABS(k);
          r := p * r - q * s;
          s := p * s + q * r;
        END_REPEAT;
        IF k < 0
        THEN
          t := r * r + s * s;
          r := r / t;
          s := -s / t;
        END_IF;
        RETURN(makec(r, s));
      END_IF;
      ef_eq_c : IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        parts(v2, r, s);
        RETURN(ctmv((p = r) AND (q = s)));
      END_IF;
      ef_ne_c : IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        parts(v2, r, s);
        RETURN(ctmv((p <> r) OR (q <> s)));
      END_IF;
      ef_conjugate_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(makec(p, -q));
      END_IF;
      ef_abs_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(ctmv(SQRT(p * p + q * q)));
      END_IF;
      ef_arg_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(ctmv(atan2(q, p)));
      END_IF;
      ef_cos_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        t := 0.5 * EXP(-q);
        u := 0.5 * EXP(q);
        RETURN(makec((t + u) * COS(p), (t - u) * SIN(p)));
      END_IF;
      ef_exp_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(makec(EXP(p) * COS(q), EXP(p) * SIN(q)));
      END_IF;
      ef_ln_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(makec(0.5 * LOG(p * p + q * q), atan2(q, p)));
      END_IF;
      ef_sin_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        t := 0.5 * EXP(-q);
        u := 0.5 * EXP(q);
        RETURN(makec((t + u) * SIN(p), (u - t) * COS(p)));
      END_IF;
      ef_sqrt_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        t := SQRT(SQRT(p * p + q * q));
        u := 0.5 * atan2(q, p);
        RETURN(makec(t * COS(u), t * SIN(u)));
      END_IF;
      ef_tan_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        t := EXP(2.0 * q) + EXP(-2.0 * q) + 2.0 * COS(2.0 * p);
        RETURN(makec(2.0 * SIN(2.0 * p) / t, (EXP(-2.0 * q) - EXP(2.0 * q)) / t));
      END_IF;
      ef_subscript_s : IF ('STRING' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        str := v1;
        k := v2;
        RETURN(ctmv(str[k]));
      END_IF;
      ef_eq_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str = st2));
      END_IF;
      ef_ne_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str <> st2));
      END_IF;
      ef_gt_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str > st2));
      END_IF;
      ef_lt_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str < st2));
      END_IF;
      ef_ge_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str >= st2));
      END_IF;
      ef_le_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str <= st2));
      END_IF;
      ef_subsequence_s : IF ('STRING' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) AND ('INTEGER' IN TYPEOF(v3))
      THEN
        str := v1;
        j := v2;
        k := v3;
        RETURN(ctmv(str[j:k]));
      END_IF;
      ef_concat_s : BEGIN  
                           str := '';
                           REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                             IF 'STRING' IN TYPEOF(vlist[i])
                             THEN
                               st2 := vlist[i];
                               str := str + st2;
                               REMOVE(vlist, i);
                             ELSE
                               IF str <> ''
                               THEN
                                 INSERT(vlist, ctmv(str), i);
                                 str := '';
                               END_IF;
                             END_IF;
                           END_REPEAT;
                           IF SIZEOF(vlist) = 0
                           THEN
                             RETURN(ctmv(str));
                           END_IF;
                           IF str <> ''
                           THEN
                             INSERT(vlist, ctmv(str), 0);
                           END_IF;
                           IF SIZEOF(vlist) = 1
                           THEN
                             RETURN(vlist[1]);
                           END_IF;
      END;
      ef_size_s : IF 'STRING' IN TYPEOF(v1)
      THEN
        str := v1;
        RETURN(ctmv(LENGTH(str)));
      END_IF;
      ef_format : IF ('NUMBER' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        RETURN(ctmv(FORMAT(v1, v2)));
      END_IF;
      ef_value : IF 'STRING' IN TYPEOF(v1)
      THEN
        str := v1;
        RETURN(ctmv(VALUE(str)));
      END_IF;
      ef_like : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        RETURN(ctmv(v1 LIKE v2));
      END_IF;
      ef_subscript_b : IF ('BINARY' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        bin := v1;
        k := v2;
        RETURN(ctmv(bin[k]));
      END_IF;
      ef_eq_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin = bi2));
      END_IF;
      ef_ne_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin <> bi2));
      END_IF;
      ef_gt_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin > bi2));
      END_IF;
      ef_lt_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin < bi2));
      END_IF;
      ef_ge_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin >= bi2));
      END_IF;
      ef_le_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin <= bi2));
      END_IF;
      ef_subsequence_b : IF ('BINARY' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) AND ('INTEGER' IN TYPEOF(v3))
      THEN
        bin := v1;
        j := v2;
        k := v3;
        RETURN(ctmv(bin[j:k]));
      END_IF;
      ef_concat_b : BEGIN  
                           boo := FALSE;
                           REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                             IF 'BINARY' IN TYPEOF(vlist[i])
                             THEN
                               IF boo
                               THEN
                                 bi2 := vlist[i];
                                 bin := bin + bi2;
                               ELSE
                                 bin := vlist[i];
                                 boo := TRUE;
                               END_IF;
                               REMOVE(vlist, i);
                             ELSE
                               IF boo
                               THEN
                                 INSERT(vlist, ctmv(bin), i);
                                 boo := FALSE;
                               END_IF;
                             END_IF;
                           END_REPEAT;
                           IF SIZEOF(vlist) = 0
                           THEN
                             RETURN(ctmv(bin));
                           END_IF;
                           IF boo
                           THEN
                             INSERT(vlist, ctmv(bin), 0);
                           END_IF;
                           IF SIZEOF(vlist) = 1
                           THEN
                             RETURN(vlist[1]);
                           END_IF;
      END;
      ef_size_b : IF 'BINARY' IN TYPEOF(v1)
      THEN
        bin := v1;
        RETURN(ctmv(BLENGTH(bin)));
      END_IF;
      ef_subscript_t : IF ('LIST' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        tpl := v1;
        k := v2;
        RETURN(ctmv(tpl[k]));
      END_IF;
      ef_eq_t : IF ('LIST' IN TYPEOF(v1)) AND ('LIST' IN TYPEOF(v2))
      THEN
        lgc := equal_maths_values(v1, v2);
        IF lgc <> UNKNOWN
        THEN
          RETURN(ctmv(lgc));
        END_IF;
      END_IF;
      ef_ne_t : IF ('LIST' IN TYPEOF(v1)) AND ('LIST' IN TYPEOF(v2))
      THEN
        lgc := equal_maths_values(v1, v2);
        IF lgc <> UNKNOWN
        THEN
          RETURN(ctmv(NOT lgc));
        END_IF;
      END_IF;
      ef_concat_t : BEGIN  
                           tpl := [];
                           REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                             IF 'STRING' IN TYPEOF(vlist[i])
                             THEN
                               tp2 := vlist[i];
                               tpl := tpl + tp2;
                               REMOVE(vlist, i);
                             ELSE
                               IF SIZEOF(tpl) <> 0
                               THEN
                                 INSERT(vlist, ctmv(tpl), i);
                                 tpl := [];
                               END_IF;
                             END_IF;
                           END_REPEAT;
                           IF SIZEOF(vlist) = 0
                           THEN
                             RETURN(ctmv(tpl));
                           END_IF;
                           IF SIZEOF(tpl) <> 0
                           THEN
                             INSERT(vlist, ctmv(tpl), 0);
                           END_IF;
                           IF SIZEOF(vlist) = 1
                           THEN
                             RETURN(vlist[1]);
                           END_IF;
      END;
      ef_size_t : IF 'LIST' IN TYPEOF(v1)
      THEN
        tpl := v1;
        RETURN(ctmv(SIZEOF(tpl)));
      END_IF;
      ef_entuple : RETURN(ctmv(vlist));
      ef_detuple : IF 'LIST' IN TYPEOF(v1)
      THEN
        tpl := v1;
        RETURN(ctmv(tpl[1]));
      END_IF;
      ef_insert : IF ('LIST' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v3))
      THEN
        tpl := v1;
        k := v3;
        INSERT(tpl, v2, k);
        RETURN(ctmv(tpl));
      END_IF;
      ef_remove : IF ('LIST' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        tpl := v1;
        k := v2;
        REMOVE(tpl, k);
        RETURN(ctmv(tpl));
      END_IF;
      ef_sum_it : IF good_t(v1, 'INTEGER')
      THEN
        tpl := v1;
        j := 0;
        REPEAT i := 1 TO SIZEOF(tpl);
          j := j + tpl[i];
        END_REPEAT;
        RETURN(ctmv(j));
      END_IF;
      ef_product_it : IF good_t(v1, 'INTEGER')
      THEN
        tpl := v1;
        j := 1;
        REPEAT i := 1 TO SIZEOF(tpl);
          j := j * tpl[i];
        END_REPEAT;
        RETURN(ctmv(j));
      END_IF;
      ef_add_it : BEGIN  
                         boo := FALSE;
                         REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                           IF good_t(vlist[i], 'INTEGER')
                           THEN
                             IF NOT boo
                             THEN
                               tpl := vlist[i];
                               boo := TRUE;
                             ELSE
                               tp2 := vlist[i];
                               IF SIZEOF(tpl) <> SIZEOF(tp2)
                               THEN
                                 RETURN(?);
                               END_IF;
                               REPEAT l := 1 TO SIZEOF(tpl);
                                 tpl[j] := tpl[j] + tp2[j];
                               END_REPEAT;
                             END_IF;
                             REMOVE(vlist, i);
                           END_IF;
                         END_REPEAT;
                         IF SIZEOF(vlist) = 0
                         THEN
                           RETURN(ctmv(tpl));
                         END_IF;
                         IF boo
                         THEN
                           INSERT(vlist, ctmv(tpl), 0);
                         END_IF;
                         IF SIZEOF(vlist) = 1
                         THEN
                           RETURN(vlist[1]);
                         END_IF;
      END;
      ef_subtract_it : IF good_t(v1, 'INTEGER') AND good_t(v2, 'INTEGER')
      THEN
        tpl := v1;
        tp2 := v2;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          tpl[i] := tpl[i] - tp2[i];
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_scalar_mult_it : IF ('INTEGER' IN TYPEOF(v1)) AND good_t(v2, 'INTEGER')
      THEN
        j := v1;
        tpl := v2;
        REPEAT i := 1 TO SIZEOF(tpl);
          tpl[i] := j * tpl[i];
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_dot_prod_it : IF good_t(v1, 'INTEGER') AND good_t(v2, 'INTEGER')
      THEN
        tpl := v1;
        tp2 := v2;
        j := 0;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          j := j + tpl[i] * tp2[i];
        END_REPEAT;
        RETURN(ctmv(j));
      END_IF;
      ef_sum_rt : IF good_t(v1, 'REAL')
      THEN
        tpl := v1;
        r := 0.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          r := r + tpl[i];
        END_REPEAT;
        RETURN(ctmv(r));
      END_IF;
      ef_product_rt : IF good_t(v1, 'REAL')
      THEN
        tpl := v1;
        r := 1.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          r := r * tpl[i];
        END_REPEAT;
        RETURN(ctmv(r));
      END_IF;
      ef_add_rt : BEGIN  
                         boo := FALSE;
                         REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                           IF good_t(vlist[i], 'REAL')
                           THEN
                             IF NOT boo
                             THEN
                               tpl := vlist[i];
                               boo := TRUE;
                             ELSE
                               tp2 := vlist[i];
                               IF SIZEOF(tpl) <> SIZEOF(tp2)
                               THEN
                                 RETURN(?);
                               END_IF;
                               REPEAT l := 1 TO SIZEOF(tpl);
                                 tpl[j] := tpl[j] + tp2[j];
                               END_REPEAT;
                             END_IF;
                             REMOVE(vlist, i);
                           END_IF;
                         END_REPEAT;
                         IF SIZEOF(vlist) = 0
                         THEN
                           RETURN(ctmv(tpl));
                         END_IF;
                         IF boo
                         THEN
                           INSERT(vlist, ctmv(tpl), 0);
                         END_IF;
                         IF SIZEOF(vlist) = 1
                         THEN
                           RETURN(vlist[1]);
                         END_IF;
      END;
      ef_subtract_rt : IF good_t(v1, 'REAL') AND good_t(v2, 'REAL')
      THEN
        tpl := v1;
        tp2 := v2;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          tpl[i] := tpl[i] - tp2[i];
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_scalar_mult_rt : IF ('REAL' IN TYPEOF(v1)) AND good_t(v2, 'REAL')
      THEN
        r := v1;
        tpl := v2;
        REPEAT i := 1 TO SIZEOF(tpl);
          tpl[i] := r * tpl[i];
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_dot_prod_rt : IF good_t(v1, 'REAL') AND good_t(v2, 'REAL')
      THEN
        tpl := v1;
        tp2 := v2;
        r := 0;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          r := r + tpl[i] * tp2[i];
        END_REPEAT;
        RETURN(ctmv(r));
      END_IF;
      ef_norm_rt : IF good_t(v1, 'REAL')
      THEN
        tpl := v1;
        r := 0.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          r := r + tpl[i] * tpl[i];
        END_REPEAT;
        RETURN(ctmv(SQRT(r)));
      END_IF;
      ef_sum_ct : IF good_t(v1, cnlit)
      THEN
        tpl := v1;
        p := 0.0;
        q := 0.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], r, s);
          p := p + r;
          q := q + s;
        END_REPEAT;
        RETURN(makec(p, q));
      END_IF;
      ef_product_ct : IF good_t(v1, cnlit)
      THEN
        tpl := v1;
        p := 1.0;
        q := 0.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], r, s);
          p := p * r - q * s;
          q := p * s + q * r;
        END_REPEAT;
        RETURN(makec(p, q));
      END_IF;
      ef_add_ct : BEGIN  
                         boo := FALSE;
                         REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                           IF good_t(vlist[i], cnlit)
                           THEN
                             IF NOT boo
                             THEN
                               tpl := vlist[i];
                               boo := TRUE;
                             ELSE
                               tp2 := vlist[i];
                               IF SIZEOF(tpl) <> SIZEOF(tp2)
                               THEN
                                 RETURN(?);
                               END_IF;
                               REPEAT l := 1 TO SIZEOF(tpl);
                                 parts(tpl[j], p, q);
                                 parts(tp2[j], r, s);
                                 tpl[j] := makec(p + r, q + s);
                               END_REPEAT;
                             END_IF;
                             REMOVE(vlist, i);
                           END_IF;
                         END_REPEAT;
                         IF SIZEOF(vlist) = 0
                         THEN
                           RETURN(ctmv(tpl));
                         END_IF;
                         IF boo
                         THEN
                           INSERT(vlist, ctmv(tpl), 0);
                         END_IF;
                         IF SIZEOF(vlist) = 1
                         THEN
                           RETURN(vlist[1]);
                         END_IF;
      END;
      ef_subtract_ct : IF good_t(v1, cnlit) AND good_t(v2, cnlit)
      THEN
        tpl := v1;
        tp2 := v2;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], p, q);
          parts(tp2[i], r, s);
          tpl[i] := makec(p - r, q - s);
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_scalar_mult_ct : IF (cnlit IN TYPEOF(v1)) AND good_t(v2, cnlit)
      THEN
        parts(v1, p, q);
        tpl := v2;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], r, s);
          tpl[i] := makec(p * r - q * s, p * s + q * r);
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_dot_prod_ct : IF good_t(v1, cnlit) AND good_t(v2, cnlit)
      THEN
        tpl := v1;
        tp2 := v2;
        t := 0.0;
        u := 0.0;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], p, q);
          parts(tp2[i], r, s);
          t := t + p * r + q * s;
          u := u + q * r - p * s;
        END_REPEAT;
        RETURN(makec(t, u));
      END_IF;
      ef_norm_ct : IF good_t(v1, cnlit)
      THEN
        tpl := v1;
        r := 0.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], p, q);
          r := r + p * p + q * q;
        END_REPEAT;
        RETURN(ctmv(SQRT(r)));
      END_IF;
      ef_if, ef_if_i, ef_if_r, ef_if_c, ef_if_s, ef_if_b, ef_if_t : IF 'LOGICAL' IN TYPEOF(v1)
      THEN
        lgc := v1;
        IF lgc
        THEN
          RETURN(v2);
        ELSE
          RETURN(v3);
        END_IF;
      END_IF;
      ef_ensemble : RETURN(make_finite_space(mem + vlist));
      ef_member_of : IF (schema_prefix + 'MATHS_SPACE') IN TYPEOF(v2)
      THEN
        lgc := member_of(v1, v2);
        IF lgc <> UNKNOWN
        THEN
          RETURN(ctmv(lgc));
        END_IF;
      END_IF;
    END_CASE;
    RETURN(make_function_application(expr.func, vlist));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN types
  THEN
    gexpr := substitute(expr.func\abstracted_expression_function.expr, expr.func\quantifier_expression.variables,
                        vlist);
    RETURN(simplify_generic_expression(gexpr));
  END_IF;
  IF 'FINITE_FUNCTION' IN types
  THEN
    pairs := expr.func\finite_function.pairs;
    REPEAT i := 1 TO SIZEOF(pairs);
      IF equal_maths_values(vlist[1], pairs[i][1])
      THEN
        RETURN(simplify_maths_value(pairs[i][2]));
      END_IF;
    END_REPEAT;
    RETURN(make_function_application(expr.func, vlist));
  END_IF;
  RETURN(expr);
END_FUNCTION;

FUNCTION simplify_generic_expression(expr : generic_expression) : maths_value;
FUNCTION restore_unary(expr : unary_generic_expression;
                       opnd : generic_expression) : generic_expression;
  expr.operand := opnd;
  RETURN(expr);
END_FUNCTION;
FUNCTION restore_binary(expr : binary_generic_expression;
                        opd1 : generic_expression;
                        opd2 : generic_expression) : generic_expression;
  expr.operands[1] := opd1;
  expr.operands[2] := opd2;
  RETURN(expr);
END_FUNCTION;
FUNCTION restore_mulary(expr : multiple_arity_generic_expression;
                        ops : LIST OF generic_expression) : generic_expression;
  expr.operands := ops;
  RETURN(expr);
END_FUNCTION;
FUNCTION make_number_literal(nmb : NUMBER) : generic_literal;
  IF 'INTEGER' IN TYPEOF(nmb)
  THEN
    RETURN(make_int_literal(nmb));
  END_IF;
  RETURN(make_real_literal(nmb));
END_FUNCTION;
LOCAL
  types  : SET OF STRING                      := stripped_typeof(expr);
  v1     : maths_value;
  v2     : maths_value;
  vlist  : LIST OF maths_value                := [];
  op1    : generic_expression;
  op2    : generic_expression;
  oplist : LIST OF generic_expression         := [];
  opnds  : LIST [2 : ?] OF generic_expression;
  n      : INTEGER;
  m      : INTEGER;
  finfun : maths_function_select;
  boo    : BOOLEAN;
  str    : STRING;
  nmb    : NUMBER;
END_LOCAL;
  -- Unwrap the elementary kinds of literals
  IF 'INT_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\int_literal.the_value));
  END_IF;
  IF 'REAL_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\real_literal.the_value));
  END_IF;
  IF 'BOOLEAN_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\boolean_literal.the_value));
  END_IF;
  IF 'STRING_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\string_literal.the_value));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN types
  THEN
    RETURN(expr);
  END_IF;
  IF 'LOGICAL_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\logical_literal.lit_value));
  END_IF;
  IF 'BINARY_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\binary_literal.lit_value));
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN types
  THEN
    RETURN(expr\maths_enum_literal.lit_value);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\real_tuple_literal.lit_value));
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\integer_tuple_literal.lit_value));
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN types
  THEN
    RETURN(expr\atom_based_literal.lit_value);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\maths_tuple_literal.lit_value));
  END_IF;
  -- Simplify one special class of literals
  IF 'MATHS_SPACE' IN types
  THEN
    RETURN(simplify_maths_space(expr));
  END_IF;
  -- Simplify one special kind of expression
  IF 'FUNCTION_APPLICATION' IN types
  THEN
    RETURN(simplify_function_application(expr));
  END_IF;
  -- Separate and simplify the operands
  IF 'UNARY_GENERIC_EXPRESSION' IN types
  THEN
    v1 := simplify_generic_expression(expr\unary_generic_expression.operand);
    op1 := convert_to_operand(v1);
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types
  THEN
    v1 := simplify_generic_expression(expr\binary_generic_expression.operands[1]);
    op1 := convert_to_operand(v1);
    v2 := simplify_generic_expression(expr\binary_generic_expression.operands[2]);
    op2 := convert_to_operand(v2);
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types
  THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF(opnds);
      v1 := simplify_generic_expression(opnds[i]);
      INSERT(vlist, v1, i - 1);
      INSERT(oplist, convert_to_operand(v1), i - 1);
    END_REPEAT;
  END_IF;
  -- Simplify the one kind of maths_function which derives its operands.
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types
  THEN
    v1 := vlist[1];
    n := SIZEOF(vlist);
    finfun := vlist[n];
    REMOVE(vlist, n);
    REMOVE(vlist, 1);
    RETURN(make_parallel_composed_function(v1, vlist, finfun));
  END_IF;
  -- Simplify individual kinds of expressions.  It is not necessary to cover all cases.
  IF ('ABS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(ABS(v1)));
  END_IF;
  IF ('ACOS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(ACOS(v1)));
  END_IF;
  IF 'AND_EXPRESSION' IN types
  THEN
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF(vlist[i])
      THEN
        boo := vlist[i];
        IF NOT boo
        THEN
          RETURN(convert_to_maths_value(FALSE));
        END_IF;
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(TRUE));
    END_IF;
    IF SIZEOF(oplist) = 1
    THEN
      RETURN(oplist[1]);
    END_IF;
  END_IF;
  IF ('ASIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(ASIN(v1)));
  END_IF;
  IF ('ATAN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(ATAN(v1, v2)));
  END_IF;
  IF ('COMPARISON_EXPRESSION' IN types) AND
     ((('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))) OR
      (('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))) OR
      (('BOOLEAN' IN TYPEOF(v1)) AND ('BOOLEAN' IN TYPEOF(v2))))
  THEN
    IF 'COMPARISON_EQUAL' IN types
    THEN
      boo := bool(v1 = v2);
    ELSE
      IF 'COMPARISON_GREATER' IN types
      THEN
        boo := bool(v1 > v2);
      ELSE
        IF 'COMPARISON_GREATER_EQUAL' IN types
        THEN
          boo := bool(v1 >= v2);
        ELSE
          IF 'COMPARISON_LESS' IN types
          THEN
            boo := bool(v1 < v2);
          ELSE
            IF 'COMPARISON_LESS_EQUAL' IN types
            THEN
              boo := bool(v1 <= v2);
            ELSE
              IF 'COMPARISON_NOT_EQUAL' IN types
              THEN
                boo := bool(v1 <> v2);
              ELSE
                IF 'LIKE_EXPRESSION' IN types
                THEN
                  boo := bool(v1 LIKE v2);
                ELSE
                  RETURN(?);
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(convert_to_maths_value(boo));
  END_IF;
  IF 'CONCAT_EXPRESSION' IN types
  THEN
    str := '';
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'STRING' IN TYPEOF(vlist[i])
      THEN
        str := vlist[i] + str;
        REMOVE(oplist, i);
      ELSE
        IF LENGTH(str) > 0
        THEN
          INSERT(oplist, make_string_literal(str), i);
          str := '';
        END_IF;
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(str));
    END_IF;
    IF LENGTH(str) > 0
    THEN
      INSERT(oplist, make_string_literal(str), 0);
    END_IF;
    IF SIZEOF(oplist) = 1
    THEN
      RETURN(oplist[1]);
    END_IF;
  END_IF;
  IF ('COS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(COS(v1)));
  END_IF;
  IF ('DIV_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 DIV v2));
  END_IF;
  IF 'EQUALS_EXPRESSION' IN types
  THEN
    opnds := expr\binary_generic_expression.operands;
    RETURN(convert_to_maths_value(opnds[1] :=: opnds[2]));
  END_IF;
  IF ('EXP_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(EXP(v1)));
  END_IF;
  IF ('FORMAT_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(FORMAT(v1, v2)));
  END_IF;
  IF ('INDEX_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    str := v1;
    n := v2;
    RETURN(convert_to_maths_value(str[n]));
  END_IF;
  IF ('INT_VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(VALUE(v1)));
  END_IF;
  IF 'INTERVAL_EXPRESSION' IN types
  THEN
    str := '';
    IF 'NUMBER' IN TYPEOF(vlist[1])
    THEN
      str := 'NUMBER';
    END_IF;
    IF 'STRING' IN TYPEOF(vlist[1])
    THEN
      str := 'STRING';
    END_IF;
    IF 'BOOLEAN' IN TYPEOF(vlist[1])
    THEN
      str := 'BOOLEAN';
    END_IF;
    IF (LENGTH(str) > 0) AND (str IN TYPEOF(vlist[2])) AND (str IN TYPEOF(vlist[3]))
    THEN
      RETURN(convert_to_maths_value({vlist[1] <= vlist[2] <= vlist[3]}));
    END_IF;
  END_IF;
  IF ('LENGTH_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(LENGTH(v1)));
  END_IF;
  IF ('LOG_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(LOG(v1)));
  END_IF;
  IF ('LOG10_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(LOG10(v1)));
  END_IF;
  IF ('LOG2_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(LOG2(v1)));
  END_IF;
  IF 'MAXIMUM_EXPRESSION' IN types
  THEN
    boo := FALSE;
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF(vlist[i])
      THEN
        IF boo
        THEN
          IF nmb < vlist[i]
          THEN
            nmb := vlist[i];
          END_IF;
        ELSE
          nmb := vlist[i];
          boo := TRUE;
        END_IF;
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(nmb));
    END_IF;
    IF boo
    THEN
      INSERT(oplist, make_number_literal(nmb), 0);
    END_IF;
  END_IF;
  IF 'MINIMUM_EXPRESSION' IN types
  THEN
    boo := FALSE;
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF(vlist[i])
      THEN
        IF boo
        THEN
          IF nmb > vlist[i]
          THEN
            nmb := vlist[i];
          END_IF;
        ELSE
          nmb := vlist[i];
          boo := TRUE;
        END_IF;
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(nmb));
    END_IF;
    IF boo
    THEN
      INSERT(oplist, make_number_literal(nmb), 0);
    END_IF;
  END_IF;
  IF ('MINUS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 - v2));
  END_IF;
  IF ('MOD_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 MOD v2));
  END_IF;
  IF 'MULT_EXPRESSION' IN types
  THEN
    nmb := 1;
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF(vlist[i])
      THEN
        nmb := nmb * vlist[i];
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(nmb));
    END_IF;
    IF nmb <> 1
    THEN
      INSERT(oplist, make_number_literal(nmb), 0);
    END_IF;
    IF SIZEOF(oplist) = 1
    THEN
      RETURN(oplist[1]);
    END_IF;
  END_IF;
  IF ('NOT_EXPRESSION' IN types) AND ('BOOLEAN' IN TYPEOF(v1))
  THEN
    boo := v1;
    RETURN(convert_to_maths_value(NOT (boo)));
  END_IF;
  IF ('ODD_EXPRESSION' IN types) AND ('INTEGER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(ODD(v1)));
  END_IF;
  IF 'OR_EXPRESSION' IN types
  THEN
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF(vlist[i])
      THEN
        boo := vlist[i];
        IF boo
        THEN
          RETURN(convert_to_maths_value(TRUE));
        END_IF;
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(FALSE));
    END_IF;
    IF SIZEOF(oplist) = 1
    THEN
      RETURN(oplist[1]);
    END_IF;
  END_IF;
  IF 'PLUS_EXPRESSION' IN types
  THEN
    nmb := 0;
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF(vlist[i])
      THEN
        nmb := nmb + vlist[i];
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(nmb));
    END_IF;
    IF nmb <> 0
    THEN
      INSERT(oplist, make_number_literal(nmb), 0);
    END_IF;
    IF SIZEOF(oplist) = 1
    THEN
      RETURN(oplist[1]);
    END_IF;
  END_IF;
  IF ('POWER_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 ** v2));
  END_IF;
  IF ('SIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(SIN(v1)));
  END_IF;
  IF ('SLASH_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 / v2));
  END_IF;
  IF ('SQUARE_ROOT_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(SQRT(v1)));
  END_IF;
  IF ('SUBSTRING_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(vlist[1])) AND ('NUMBER' IN TYPEOF(vlist[2])) AND
     ('NUMBER' IN TYPEOF(vlist[3]))
  THEN
    str := vlist[1];
    n := vlist[2];
    m := vlist[3];
    RETURN(convert_to_maths_value(str[n:m]));
  END_IF;
  IF ('TAN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(TAN(v1)));
  END_IF;
  IF ('UNARY_MINUS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    nmb := v1;
    RETURN(convert_to_maths_value(-nmb));
  END_IF;
  IF ('VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(VALUE(v1)));
  END_IF;
  IF ('XOR_EXPRESSION' IN types) AND ('BOOLEAN' IN TYPEOF(v1)) AND ('BOOLEAN' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 XOR v2));
  END_IF;
  -- No special simplification defined, return same with simplified operands.
  IF 'UNARY_GENERIC_EXPRESSION' IN types
  THEN
    RETURN(restore_unary(expr, op1));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types
  THEN
    RETURN(restore_binary(expr, op1, op2));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types
  THEN
    RETURN(restore_mulary(expr, oplist));
  END_IF;
  -- Should be unreachable, but for safety, return unsimplified expression.
  RETURN(expr);
END_FUNCTION;

FUNCTION simplify_maths_space(spc : maths_space) : maths_space;
LOCAL
  stypes   : SET OF STRING       := stripped_typeof(spc);
  sset     : SET OF maths_value;
  zset     : SET OF maths_value  := [];
  zval     : maths_value;
  zspc     : maths_space;
  zallint  : BOOLEAN             := TRUE;
  zint     : INTEGER;
  zmin     : INTEGER;
  zmax     : INTEGER;
  factors  : LIST OF maths_space;
  zfactors : LIST OF maths_space := [];
  rspc     : maths_space;
END_LOCAL;
  IF 'FINITE_SPACE' IN stypes
  THEN
    sset := spc\finite_space.members;
    REPEAT i := 1 TO SIZEOF(sset);
      zval := simplify_maths_value(sset[i]);
      zset := zset + [zval];
      IF zallint AND ('INTEGER' IN TYPEOF(zval))
      THEN
        zint := zval;
        IF i = 1
        THEN
          zmin := zint;
          zmax := zint;
        ELSE
          IF zint < zmin
          THEN
            zmin := zint;
          END_IF;
          IF zint > zmax
          THEN
            zmax := zint;
          END_IF;
        END_IF;
      ELSE
        zallint := FALSE;
      END_IF;
    END_REPEAT;
    IF zallint AND (SIZEOF(zset) = zmax - zmin + 1)
    THEN
      RETURN(make_finite_integer_interval(zmin, zmax));
    END_IF;
    RETURN(make_finite_space(zset));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes
  THEN
    zspc := simplify_maths_space(spc\uniform_product_space.base);
    RETURN(make_uniform_product_space(zspc, spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes
  THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF(factors);
      INSERT(zfactors, simplify_maths_space(factors[i]), i - 1);
    END_REPEAT;
    RETURN(make_listed_product_space(zfactors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes
  THEN
    zspc := simplify_maths_space(spc\extended_tuple_space.base);
    rspc := simplify_maths_space(spc\extended_tuple_space.extender);
    RETURN(make_extended_tuple_space(zspc, rspc));
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes
  THEN
    zspc := simplify_maths_space(spc\function_space.domain_argument);
    rspc := simplify_maths_space(spc\function_space.range_argument);
    RETURN(make_function_space(spc\function_space.domain_constraint, zspc, spc\function_space.range_constraint, rspc));
  END_IF;
  RETURN(spc);
END_FUNCTION;

FUNCTION simplify_maths_value(val : maths_value) : maths_value;
LOCAL
  vtypes : SET OF STRING       := stripped_typeof(val);
  vlist  : LIST OF maths_value;
  nlist  : LIST OF maths_value := [];
END_LOCAL;
  IF 'GENERIC_EXPRESSION' IN vtypes
  THEN
    RETURN(simplify_generic_expression(val));
  END_IF;
  IF 'LIST' IN vtypes
  THEN
    vlist := val;
    REPEAT i := 1 TO SIZEOF(vlist);
      INSERT(nlist, simplify_maths_value(vlist[i]), i - 1);
    END_REPEAT;
    RETURN(convert_to_maths_value(nlist));
  END_IF;
  RETURN(val);
END_FUNCTION;

FUNCTION singleton_member_of(spc : maths_space) : maths_value;
LOCAL
  types : SET OF STRING := stripped_typeof(spc);
END_LOCAL;
  IF 'FINITE_SPACE' IN types
  THEN
    IF SIZEOF(spc\finite_space.members) = 1
    THEN
      RETURN(spc\finite_space.members[1]);
    END_IF;
    RETURN(?);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types
  THEN
    IF spc\finite_integer_interval.size = 1
    THEN
      RETURN(spc\finite_integer_interval.min);
    END_IF;
    RETURN(?);
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION space_dimension(tspace : tuple_space) : nonnegative_integer;
LOCAL
  types : SET OF STRING := TYPEOF(tspace);
END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types
  THEN
    RETURN(tspace\uniform_product_space.exponent);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types
  THEN
    RETURN(SIZEOF(tspace\listed_product_space.factors));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types
  THEN
    RETURN(space_dimension(tspace\extended_tuple_space.base));
  END_IF;
  -- Should be unreachable
  RETURN(?);
END_FUNCTION;

FUNCTION space_is_continuum(space : maths_space) : BOOLEAN;
LOCAL
  typenames : SET OF STRING       := TYPEOF(space);
  factors   : LIST OF maths_space;
END_LOCAL;
  IF NOT EXISTS(space)
  THEN
    RETURN(FALSE);
  END_IF;
  IF subspace_of_es(space, es_reals) OR subspace_of_es(space, es_complex_numbers)
  THEN
    RETURN(TRUE);
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames
  THEN
    RETURN(space_is_continuum(space\uniform_product_space.base));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames
  THEN
    factors := space\listed_product_space.factors;
    IF SIZEOF(factors) = 0
    THEN
      RETURN(FALSE);
    END_IF;
    REPEAT i := 1 TO SIZEOF(factors);
      IF NOT space_is_continuum(factors[i])
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

FUNCTION space_is_singleton(spc : maths_space) : BOOLEAN;
LOCAL
  types : SET OF STRING := stripped_typeof(spc);
END_LOCAL;
  IF 'FINITE_SPACE' IN types
  THEN
    RETURN(bool(SIZEOF(spc\finite_space.members) = 1));
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types
  THEN
    RETURN(bool(spc\finite_integer_interval.size = 1));
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

FUNCTION stripped_typeof(arg : GENERIC : G) : SET OF STRING;
LOCAL
  types  : SET OF STRING := TYPEOF(arg);
  stypes : SET OF STRING := [];
  n      : INTEGER       := LENGTH(schema_prefix);
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(types);
    IF types[i][1:n] = schema_prefix
    THEN
      stypes := stypes + types[i][n + 1:LENGTH(types[i])];
    ELSE
      stypes := stypes + types[i];
    END_IF;
  END_REPEAT;
  RETURN(stypes);
END_FUNCTION;

FUNCTION subspace_of(space1 : maths_space;
                     space2 : maths_space) : LOGICAL;
LOCAL
  spc1   : maths_space                  := simplify_maths_space(space1);
  spc2   : maths_space                  := simplify_maths_space(space2);
  types1 : SET OF STRING                := stripped_typeof(spc1);
  types2 : SET OF STRING                := stripped_typeof(spc2);
  lgcl   : LOGICAL;
  cum    : LOGICAL;
  es_val : elementary_space_enumerators;
  bnd1   : REAL;
  bnd2   : REAL;
  n      : INTEGER;
  sp1    : maths_space;
  sp2    : maths_space;
  prgn1  : polar_complex_number_region;
  prgn2  : polar_complex_number_region;
  aitv   : finite_real_interval;
END_LOCAL;
  IF NOT EXISTS(spc1) OR NOT EXISTS(spc2)
  THEN
    RETURN(FALSE);
  END_IF;
  IF spc2 = the_generics
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1
  THEN
    IF NOT ('ELEMENTARY_SPACE' IN types2)
    THEN
      RETURN(FALSE);
    END_IF;
    es_val := spc2\elementary_space.space_id;
    IF spc1\elementary_space.space_id = es_val
    THEN
      RETURN(TRUE);
    END_IF;
    CASE spc1\elementary_space.space_id OF
      es_numbers : RETURN(FALSE);
      es_complex_numbers : RETURN(es_val = es_numbers);
      es_reals : RETURN(es_val = es_numbers);
      es_integers : RETURN(es_val = es_numbers);
      es_logicals : RETURN(FALSE);
      es_booleans : RETURN(es_val = es_logicals);
      es_strings : RETURN(FALSE);
      es_binarys : RETURN(FALSE);
      es_maths_spaces : RETURN(FALSE);
      es_maths_functions : RETURN(FALSE);
      es_generics : RETURN(FALSE);
    END_CASE;
    RETURN(UNKNOWN);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types1
  THEN
    cum := TRUE;
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      cum := cum AND member_of(i, spc2);
      IF cum = FALSE
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(cum);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_FROM_MIN' IN types2
    THEN
      RETURN(spc1\integer_interval_from_min.min >= spc2\integer_interval_from_min.min);
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_TO_MAX' IN types2
    THEN
      RETURN(spc1\integer_interval_to_max.max <= spc2\integer_interval_to_max.max);
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR ('REAL_INTERVAL_FROM_MIN' IN types2) OR ('REAL_INTERVAL_TO_MAX' IN types2)
    THEN
      IF min_exists(spc2)
      THEN
        bnd1 := spc1\finite_real_interval.min;
        bnd2 := real_min(spc2);
        IF (bnd1 < bnd2) OR ((bnd1 = bnd2) AND min_included(spc1) AND NOT min_included(spc2))
        THEN
          RETURN(FALSE);
        END_IF;
      END_IF;
      IF max_exists(spc2)
      THEN
        bnd1 := spc1\finite_real_interval.max;
        bnd2 := real_max(spc2);
        IF (bnd1 > bnd2) OR ((bnd1 = bnd2) AND max_included(spc1) AND NOT max_included(spc2))
        THEN
          RETURN(FALSE);
        END_IF;
      END_IF;
      RETURN(TRUE);
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_FROM_MIN' IN types2
    THEN
      bnd1 := spc1\real_interval_from_min.min;
      bnd2 := spc2\real_interval_from_min.min;
      RETURN((bnd2 < bnd1) OR ((bnd2 = bnd1) AND (min_included(spc2) OR NOT min_included(spc1))));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_TO_MAX' IN types2
    THEN
      bnd1 := spc1\real_interval_to_max.max;
      bnd2 := spc2\real_interval_to_max.max;
      RETURN((bnd2 > bnd1) OR ((bnd2 = bnd1) AND (max_included(spc2) OR NOT max_included(spc1))));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2
    THEN
      RETURN(subspace_of(spc1\cartesian_complex_number_region.real_constraint,
                         spc2\cartesian_complex_number_region.real_constraint) AND
             subspace_of(spc1\cartesian_complex_number_region.imag_constraint,
                         spc2\cartesian_complex_number_region.imag_constraint));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2
    THEN
      RETURN(subspace_of(enclose_cregion_in_pregion(spc1, spc2\polar_complex_number_region.centre), spc2));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2
    THEN
      RETURN(subspace_of(enclose_pregion_in_cregion(spc1), spc2));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2
    THEN
      prgn1 := spc1;
      prgn2 := spc2;
      IF prgn1.centre = prgn2.centre
      THEN
        IF prgn2.direction_constraint.max > PI
        THEN
          aitv := make_finite_real_interval(-PI, open, prgn2.direction_constraint.max - 2.0 * PI,
                                            prgn2.direction_constraint.max_closure);
          RETURN(subspace_of(prgn1.distance_constraint, prgn2.distance_constraint) AND
                 (subspace_of(prgn1.direction_constraint, prgn2.direction_constraint) OR
                  subspace_of(prgn1.direction_constraint, aitv)));
        ELSE
          RETURN(subspace_of(prgn1.distance_constraint, prgn2.distance_constraint) AND
                 subspace_of(prgn1.direction_constraint, prgn2.direction_constraint));
        END_IF;
      END_IF;
      RETURN(subspace_of(enclose_pregion_in_pregion(prgn1, prgn2.centre), prgn2));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types1
  THEN
    cum := TRUE;
    REPEAT i := 1 TO SIZEOF(spc1\finite_space.members);
      cum := cum AND member_of(spc1\finite_space.members[i], spc2);
      IF cum = FALSE
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(cum);
  END_IF;
  IF 'PRODUCT_SPACE' IN types1
  THEN
    IF 'PRODUCT_SPACE' IN types2
    THEN
      IF space_dimension(spc1) = space_dimension(spc2)
      THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension(spc1);
          cum := cum AND subspace_of(factor_space(spc1, i), factor_space(spc2, i));
          IF cum = FALSE
          THEN
            RETURN(FALSE);
          END_IF;
        END_REPEAT;
        RETURN(cum);
      END_IF;
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2
    THEN
      IF space_dimension(spc1) >= space_dimension(spc2)
      THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension(spc1);
          cum := cum AND subspace_of(factor_space(spc1, i), factor_space(spc2, i));
          IF cum = FALSE
          THEN
            RETURN(FALSE);
          END_IF;
        END_REPEAT;
        RETURN(cum);
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1
  THEN
    IF 'EXTENDED_TUPLE_SPACE' IN types2
    THEN
      n := space_dimension(spc1);
      IF n < space_dimension(spc2)
      THEN
        n := space_dimension(spc2);
      END_IF;
      cum := TRUE;
      REPEAT i := 1 TO n + 1;
        cum := cum AND subspace_of(factor_space(spc1, i), factor_space(spc2, i));
        IF cum = FALSE
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(cum);
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      RETURN(spc2\elementary_space.space_id = es_maths_functions);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2
    THEN
      cum := TRUE;
      sp1 := spc1\function_space.domain_argument;
      sp2 := spc2\function_space.domain_argument;
      CASE spc1\function_space.domain_constraint OF
        sc_equal : BEGIN  
                          CASE spc2\function_space.domain_constraint OF
                            sc_equal : cum := cum AND equal_maths_spaces(sp1, sp2);
                            sc_subspace : cum := cum AND subspace_of(sp1, sp2);
                            sc_member : cum := cum AND member_of(sp1, sp2);
                          END_CASE;
        END;
        sc_subspace : BEGIN  
                             CASE spc2\function_space.domain_constraint OF
                               sc_equal : RETURN(FALSE);
                               sc_subspace : cum := cum AND subspace_of(sp1, sp2);
                               sc_member : BEGIN  
                                                  IF NOT member_of(sp1, sp2)
                                                  THEN
                                                    RETURN(FALSE);
                                                  END_IF;
                                                  cum := UNKNOWN;
                               END;
                             END_CASE;
        END;
        sc_member : BEGIN  
                           CASE spc2\function_space.domain_constraint OF
                             sc_equal : cum := cum AND space_is_singleton(sp1) AND
                                               equal_maths_spaces(singleton_member_of(sp1), sp2);
                             sc_subspace : BEGIN  
                                                  IF NOT member_of(sp2, sp1)
                                                  THEN
                                                    RETURN(FALSE);
                                                  END_IF;
                                                  cum := UNKNOWN;
                             END;
                             sc_member : cum := cum AND (subspace_of(sp1, sp2));
                           END_CASE;
        END;
      END_CASE;
      IF cum = FALSE
      THEN
        RETURN(FALSE);
      END_IF;
      sp1 := spc1\function_space.range_argument;
      sp2 := spc2\function_space.range_argument;
      CASE spc1\function_space.range_constraint OF
        sc_equal : BEGIN  
                          CASE spc2\function_space.range_constraint OF
                            sc_equal : cum := cum AND equal_maths_spaces(sp1, sp2);
                            sc_subspace : cum := cum AND subspace_of(sp1, sp2);
                            sc_member : cum := cum AND member_of(sp1, sp2);
                          END_CASE;
        END;
        sc_subspace : BEGIN  
                             CASE spc2\function_space.domain_constraint OF
                               sc_equal : RETURN(FALSE);
                               sc_subspace : cum := cum AND subspace_of(sp1, sp2);
                               sc_member : BEGIN  
                                                  IF NOT member_of(sp1, sp2)
                                                  THEN
                                                    RETURN(FALSE);
                                                  END_IF;
                                                  cum := UNKNOWN;
                               END;
                             END_CASE;
        END;
        sc_member : BEGIN  
                           CASE spc2\function_space.domain_constraint OF
                             sc_equal : cum := cum AND space_is_singleton(sp1) AND
                                               equal_maths_spaces(singleton_member_of(sp1), sp2);
                             sc_subspace : BEGIN  
                                                  IF NOT member_of(sp2, sp1)
                                                  THEN
                                                    RETURN(FALSE);
                                                  END_IF;
                                                  cum := UNKNOWN;
                             END;
                             sc_member : cum := cum AND subspace_of(sp1, sp2);
                           END_CASE;
        END;
      END_CASE;
      RETURN(cum);
    END_IF;
    RETURN(FALSE);
  END_IF;
  -- Should be unreachable
  RETURN(UNKNOWN);
END_FUNCTION;

FUNCTION subspace_of_es(spc : maths_space;
                        es : elementary_space_enumerators) : LOGICAL;
LOCAL
  types : SET OF STRING := stripped_typeof(spc);
END_LOCAL;
  IF NOT EXISTS(spc) OR NOT EXISTS(es)
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types
  THEN
    RETURN(es_subspace_of_es(spc\elementary_space.space_id, es));
  END_IF;
  IF 'FINITE_SPACE' IN types
  THEN
    RETURN(all_members_of_es(spc\finite_space.members, es));
  END_IF;
  CASE es OF
    es_numbers : RETURN(('FINITE_INTEGER_INTERVAL' IN types) OR ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
                        ('INTEGER_INTERVAL_TO_MAX' IN types) OR ('FINITE_REAL_INTERVAL' IN types) OR
                        ('REAL_INTERVAL_FROM_MIN' IN types) OR ('REAL_INTERVAL_TO_MAX' IN types) OR
                        ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR ('POLAR_COMPLEX_NUMBER_REGION' IN types));
    es_complex_numbers : RETURN(('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR
                                ('POLAR_COMPLEX_NUMBER_REGION' IN types));
    es_reals : RETURN(('FINITE_REAL_INTERVAL' IN types) OR ('REAL_INTERVAL_FROM_MIN' IN types) OR
                      ('REAL_INTERVAL_TO_MAX' IN types));
    es_integers : RETURN(('FINITE_INTEGER_INTERVAL' IN types) OR ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
                         ('INTEGER_INTERVAL_TO_MAX' IN types));
    es_logicals : RETURN(FALSE);
    es_booleans : RETURN(FALSE);
    es_strings : RETURN(FALSE);
    es_binarys : RETURN(FALSE);
    es_maths_spaces : RETURN(FALSE);
    es_maths_functions : RETURN('FUNCTION_SPACE' IN types);
    es_generics : RETURN(TRUE);
  END_CASE;
  RETURN(UNKNOWN);
END_FUNCTION;

FUNCTION substitute(expr : generic_expression;
                    vars : LIST [1 : ?] OF generic_variable;
                    vals : LIST [1 : ?] OF maths_value) : generic_expression;
LOCAL
  types  : SET OF STRING                  := stripped_typeof(expr);
  opnds  : LIST OF generic_expression;
  op1    : generic_expression;
  op2    : generic_expression;
  qvars  : LIST OF generic_variable;
  srcdom : maths_space_or_function;
  prpfun : LIST [1 : ?] OF maths_function;
  finfun : maths_function_select;
END_LOCAL;
  IF SIZEOF(vars) <> SIZEOF(vals)
  THEN
    RETURN(?);
  END_IF;
  IF 'GENERIC_LITERAL' IN types
  THEN
    RETURN(expr);
  END_IF;
  IF 'GENERIC_VARIABLE' IN types
  THEN
    REPEAT i := 1 TO SIZEOF(vars);
      IF expr :=: vars[i]
      THEN
        RETURN(vals[i]);
      END_IF;
    END_REPEAT;
    RETURN(expr);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN types
  THEN
    qvars := expr\quantifier_expression.variables;
    REPEAT i := SIZEOF(vars) TO 1 BY -1;
      IF vars[i] IN qvars
      THEN
        REMOVE(vars, i);
        REMOVE(vals, i);
      END_IF;
    END_REPEAT;
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF(opnds);
      IF NOT (opnds[i] IN qvars)
      THEN
        expr\multiple_arity_generic_expression.operands[i] := substitute(opnds[i], vars, vals);
      END_IF;
    END_REPEAT;
    RETURN(expr);
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN types
  THEN
    op1 := expr\unary_generic_expression.operand;
    expr\unary_generic_expression.operand := substitute(op1, vars, vals);
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types
  THEN
    op1 := expr\binary_generic_expression.operands[1];
    expr\binary_generic_expression.operands[1] := substitute(op1, vars, vals);
    op2 := expr\binary_generic_expression.operands[2];
    expr\binary_generic_expression.operands[2] := substitute(op2, vars, vals);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types
  THEN
    srcdom := expr\parallel_composed_function.source_of_domain;
    prpfun := expr\parallel_composed_function.prep_functions;
    finfun := expr\parallel_composed_function.final_function;
    srcdom := substitute(srcdom, vars, vals);
    REPEAT i := 1 TO SIZEOF(prpfun);
      prpfun[i] := substitute(prpfun[i], vars, vals);
    END_REPEAT;
    IF 'MATHS_FUNCTION' IN stripped_typeof(finfun)
    THEN
      finfun := substitute(finfun, vars, vals);
    END_IF;
    RETURN(make_parallel_composed_function(srcdom, prpfun, finfun));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types
  THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF(opnds);
      expr\multiple_arity_generic_expression.operands[i] := substitute(opnds[i], vars, vals);
    END_REPEAT;
  END_IF;
  RETURN(expr);
END_FUNCTION;

FUNCTION type_check_function(the_type : GENERIC;
                             sub_names : SET OF STRING;
                             criterion : INTEGER) : LOGICAL;
  IF ((NOT EXISTS(the_type)) OR (SIZEOF(sub_names) = 0))
  THEN
    RETURN(UNKNOWN);
  ELSE
    CASE criterion OF
      0 : RETURN(SIZEOF(sub_names * TYPEOF(the_type)) > 0);
      1 : RETURN(SIZEOF(sub_names * TYPEOF(the_type)) = 0);
      2 : RETURN(SIZEOF(sub_names * TYPEOF(the_type)) = 1);
      3 : RETURN(SIZEOF(sub_names * TYPEOF(the_type)) <= 1);
      OTHERWISE: RETURN(UNKNOWN);
    END_CASE;
  END_IF;
END_FUNCTION;

FUNCTION unambiguously_specified_multi_level_reference_designator(links : LIST [1 : ?] OF next_assembly_usage_occurrence) : BOOLEAN;
  REPEAT i := 1 TO SIZEOF(links) - 1;
    CASE TRUE OF
      ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION' IN
       TYPEOF(links[i]\product_definition_relationship.relating_product_definition)) AND
      ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION' IN
       TYPEOF(links[i]\product_definition_relationship.related_product_definition)) AND
      ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION' IN
       TYPEOF(links[i + 1]\product_definition_relationship.relating_product_definition)) : BEGIN  
                                                                                                  IF NOT ((links[i]\product_definition_relationship.related_product_definition :=:
                                                                                                           links[i +
                                                                                                                 1]\product_definition_relationship.relating_product_definition) OR
                                                                                                          ((SIZEOF(QUERY(pdr
                                                                                                                         <* USEDIN(links[i]\product_definition_relationship.related_product_definition,
                                                                                                                                   'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                                                                                                                         | pdr\product_definition_relationship.relating_product_definition :=:
                                                                                                                           links[i +
                                                                                                                                 1]\product_definition_relationship.relating_product_definition)) =
                                                                                                            1) AND
                                                                                                           (links[i]\product_definition_relationship.related_product_definition\product_definition.formation\product_definition_formation.of_product :=:
                                                                                                            links[i +
                                                                                                                  1]\product_definition_relationship.relating_product_definition\product_definition.formation\product_definition_formation.of_product)))
                                                                                                  THEN
                                                                                                    RETURN(FALSE);
                                                                                                  END_IF;
      END;
      ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_REFERENCE' IN
       TYPEOF(links[i]\product_definition_relationship.related_product_definition)) AND
      ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_REFERENCE' IN
       TYPEOF(links[i + 1]\product_definition_relationship.relating_product_definition)) : BEGIN  
                                                                                                  IF NOT ((links[i]\product_definition_relationship.related_product_definition :=:
                                                                                                           links[i +
                                                                                                                 1]\product_definition_relationship.relating_product_definition) OR
                                                                                                          ((SIZEOF(QUERY(pdr
                                                                                                                         <* USEDIN(links[i]\product_definition_relationship.related_product_definition,
                                                                                                                                   'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                                                                                                                         | pdr\product_definition_relationship.relating_product_definition :=:
                                                                                                                           links[i +
                                                                                                                                 1]\product_definition_relationship.relating_product_definition)) =
                                                                                                            1) AND
                                                                                                           (links[i]\product_definition_relationship.related_product_definition\product_definition_reference.product_id =
                                                                                                            links[i +
                                                                                                                  1]\product_definition_relationship.relating_product_definition\product_definition_reference.product_id) AND
                                                                                                           (links[i]\product_definition_relationship.related_product_definition\product_definition_reference.id_owning_organization_name =
                                                                                                            links[i +
                                                                                                                  1]\product_definition_relationship.relating_product_definition\product_definition_reference.id_owning_organization_name) AND
                                                                                                           (links[i]\product_definition_relationship.related_product_definition\product_definition_reference.product_definition_id <>
                                                                                                            links[i +
                                                                                                                  1]\product_definition_relationship.relating_product_definition\product_definition_reference.product_definition_id)))
                                                                                                  THEN
                                                                                                    RETURN(FALSE);
                                                                                                  END_IF;
      END;
      ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_REFERENCE' IN
       TYPEOF(links[i]\product_definition_relationship.relating_product_definition)) AND
      ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION' IN
       TYPEOF(links[i]\product_definition_relationship.related_product_definition)) : RETURN(FALSE);
      OTHERWISE: RETURN(FALSE);
    END_CASE;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION using_items(item : founded_item_select;
                     checked_items : SET OF founded_item_select) : SET OF founded_item_select;
LOCAL
  new_check_items : SET OF founded_item_select;
  result_items    : SET OF founded_item_select;
  next_items      : SET OF founded_item_select;
END_LOCAL;
  result_items := [];
  new_check_items := checked_items + item;
  -- Find the set of representation_items or founded_items
  -- in which item is used directly.
  next_items := QUERY(z
                      <* bag_to_set(USEDIN(item, ''))
                      | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
                        ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.FOUNDED_ITEM' IN TYPEOF(z)));
  -- If the set of next_items is not empty;
  IF SIZEOF(next_items) > 0
  THEN
    REPEAT i := 1 TO HIINDEX(next_items);
      IF NOT (next_items[i] IN new_check_items)
      THEN
        result_items := result_items + next_items[i] + using_items(next_items[i], new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  -- return the set of representation_items or founded_items
  -- in which the input item is used directly and indirectly.
  RETURN(result_items);
END_FUNCTION;

FUNCTION using_representations(item : founded_item_select) : SET OF representation;
LOCAL
  results            : SET OF representation;
  result_bag         : BAG OF representation;
  intermediate_items : SET OF founded_item_select;
END_LOCAL;
  -- Find the representations in which the item is used and add to the
  -- results set.
  results := [];
  result_bag := USEDIN(item, 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION.ITEMS');
  IF SIZEOF(result_bag) > 0
  THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  -- Find all representation_items or founded_items
  -- by which item is referenced directly or indirectly.
  intermediate_items := using_items(item, []);
  -- If the set of intermediate items is not empty;
  IF SIZEOF(intermediate_items) > 0
  THEN
    REPEAT i := 1 TO HIINDEX(intermediate_items);
      result_bag := USEDIN(intermediate_items[i], 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION.ITEMS');
      IF SIZEOF(result_bag) > 0
      THEN
        REPEAT j := 1 TO HIINDEX(result_bag);
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return the set of representation in which the input item is
  -- used directly and indirectly (through intervening
  -- representation_items or founded items).
  RETURN(results);
END_FUNCTION;

FUNCTION valid_calendar_date(date : calendar_date) : LOGICAL;
  CASE date.month_component OF
    1 : RETURN({1 <= date.day_component <= 31});
    2 : BEGIN  
               IF (leap_year(date.year_component))
               THEN
                 RETURN({1 <= date.day_component <= 29});
               ELSE
                 RETURN({1 <= date.day_component <= 28});
               END_IF;
    END;
    3 : RETURN({1 <= date.day_component <= 31});
    4 : RETURN({1 <= date.day_component <= 30});
    5 : RETURN({1 <= date.day_component <= 31});
    6 : RETURN({1 <= date.day_component <= 30});
    7 : RETURN({1 <= date.day_component <= 31});
    8 : RETURN({1 <= date.day_component <= 31});
    9 : RETURN({1 <= date.day_component <= 30});
    10 : RETURN({1 <= date.day_component <= 31});
    11 : RETURN({1 <= date.day_component <= 30});
    12 : RETURN({1 <= date.day_component <= 31});
  END_CASE;
  RETURN(FALSE);
END_FUNCTION;

FUNCTION valid_identified_item_in_representation(identified_item : item_identified_representation_usage_select;
                                                 used_representation : representation) : BOOLEAN;
LOCAL
  i : INTEGER := 1;
END_LOCAL;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(identified_item)
  THEN
    RETURN(used_representation IN using_representations(identified_item));
  END_IF;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LIST_REPRESENTATION_ITEM' IN TYPEOF(identified_item)) OR
     ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SET_REPRESENTATION_ITEM' IN TYPEOF(identified_item))
  THEN
    REPEAT WHILE (EXISTS(identified_item[i]));
      IF NOT (used_representation IN using_representations(identified_item[i]))
      THEN
        RETURN(FALSE);
      END_IF;
      i := i + 1;
    END_REPEAT;
    RETURN(TRUE);
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION valid_measure_value(m : measure_value) : BOOLEAN;
  IF ('REAL' IN TYPEOF(m))
  THEN
    RETURN(m > 0.0);
  ELSE
    IF ('INTEGER' IN TYPEOF(m))
    THEN
      RETURN(m > 0);
    ELSE
      RETURN(TRUE);
    END_IF;
  END_IF;
END_FUNCTION;

FUNCTION valid_selected_instance_representation(pd : product_definition_or_assembly_relationship) : LOGICAL;
LOCAL
  properties                          : SET OF property_definition                := bag_to_set(QUERY(prd
                                                                                                      <* USEDIN(pd,
                                                                                                                'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION.DEFINITION')
                                                                                                      | (prd.name =
                                                                                                         'occurrence selection')));
  property_definition_representations : SET OF property_definition_representation := bag_to_set(QUERY(pdr
                                                                                                      <* USEDIN(properties[1],
                                                                                                                'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')
                                                                                                      | (pdr.used_representation.name =
                                                                                                         'selection criteria')));
  selected_representation             : representation;
END_LOCAL;
  IF (SIZEOF(properties) <> 1)
  THEN
    RETURN(FALSE);
  END_IF;
  IF (SIZEOF(property_definition_representations) <> 1)
  THEN
    RETURN(FALSE);
  END_IF;
  selected_representation := property_definition_representations[1]\property_definition_representation.used_representation;
  IF (SIZEOF(selected_representation\representation.items) < 1) OR
     (SIZEOF(selected_representation\representation.items) > 2)
  THEN
    RETURN(FALSE);
  END_IF;
  IF (SIZEOF(QUERY(i
                   <* selected_representation\representation.items
                   | (SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MEASURE_REPRESENTATION_ITEM',
                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VALUE_RANGE'] *
                             TYPEOF(i)) =
                      1) AND
                     (i.name = 'selection quantity'))) <>
      1)
  THEN
    RETURN(FALSE);
  END_IF;
  IF (SIZEOF(QUERY(i
                   <* selected_representation\representation.items
                   | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND
                     (i.name = 'selection control'))) >
      1)
  THEN
    RETURN(FALSE);
  END_IF;
  -- the selection control is not specified then the quantity shall be a qualified_representation_item or a value_range
  IF (SIZEOF(QUERY(i
                   <* selected_representation\representation.items
                   | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND
                     (i.name = 'selection control'))) =
      0) AND
     (SIZEOF(QUERY(i
                   <* selected_representation\representation.items
                   | (i.name = 'selection quantity') AND
                     (SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.QUALIFIED_REPRESENTATION_ITEM',
                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VALUE_RANGE'] *
                             TYPEOF(i)) =
                      0))) >
      0)
  THEN
    RETURN(FALSE);
  END_IF;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION valid_time(time : local_time) : BOOLEAN;
  IF EXISTS(time.second_component)
  THEN
    RETURN(EXISTS(time.minute_component));
  ELSE
    RETURN(TRUE);
  END_IF;
END_FUNCTION;

FUNCTION valid_units(m : measure_with_unit) : BOOLEAN;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LENGTH_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MASS_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.TIME_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CELSIUS_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SOLID_ANGLE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.AREA_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VOLUME_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RATIO_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACCELERATION_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CAPACITANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(-2.0, -1.0, 4.0, 2.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ELECTRIC_CHARGE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONDUCTANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ELECTRIC_POTENTIAL_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ENERGY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.FORCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.FREQUENCY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ILLUMINANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INDUCTANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LUMINOUS_FLUX_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MAGNETIC_FLUX_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MAGNETIC_FLUX_DENSITY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POWER_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRESSURE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RESISTANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VELOCITY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RADIOACTIVITY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ABSORBED_DOSE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DOSE_EQUIVALENT_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION value_range_wr1(agg : compound_item_definition) : BOOLEAN;
  BEGIN  
         IF (SIZEOF(agg) = 2) AND
            ((SIZEOF(QUERY(i1
                           <* agg
                           | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i1)))) =
              2) OR
             (SIZEOF(QUERY(i2
                           <* agg
                           | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VALUE_REPRESENTATION_ITEM' IN TYPEOF(i2)))) =
              2))
         THEN
           RETURN(TRUE);
         ELSE
           RETURN(FALSE);
         END_IF;
  END;
END_FUNCTION;

FUNCTION value_range_wr2(agg : compound_item_definition) : BOOLEAN;
  BEGIN  
         IF ((SIZEOF(QUERY(i <* agg | (i\representation_item.name = 'upper limit'))) = 1) AND
             (SIZEOF(QUERY(i <* agg | (i\representation_item.name = 'lower limit'))) = 1))
         THEN
           RETURN(TRUE);
         ELSE
           RETURN(FALSE);
         END_IF;
  END;
END_FUNCTION;

FUNCTION value_range_wr3(agg : compound_item_definition) : BOOLEAN;
  BEGIN  
         IF (SIZEOF(QUERY(i1
                          <* agg
                          | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i1)) AND
                            (SIZEOF(QUERY(i2
                                          <* agg
                                          | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN
                                             TYPEOF(i2)) AND
                                            (i1 :<>: i2) AND
                                            (i1\measure_with_unit.unit_component :=:
                                             i2\measure_with_unit.unit_component))) =
                             1))) =
             2)
         THEN
           RETURN(TRUE);
         ELSE
           RETURN(FALSE);
         END_IF;
  END;
END_FUNCTION;

FUNCTION values_space_of(expr : generic_expression) : maths_space;
LOCAL
  e_prefix  : STRING        := 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.';
  typenames : SET OF STRING := TYPEOF(expr);
END_LOCAL;
  IF (schema_prefix + 'MATHS_VARIABLE') IN typenames
  THEN
    RETURN(expr\maths_variable.values_space);
  END_IF;
  IF (e_prefix + 'EXPRESSION') IN typenames
  THEN
    IF (e_prefix + 'NUMERIC_EXPRESSION') IN typenames
    THEN
      IF expr\numeric_expression.is_int
      THEN
        IF (e_prefix + 'INT_LITERAL') IN typenames
        THEN
          RETURN(make_finite_space([expr\int_literal.the_value]));
        ELSE
          RETURN(the_integers);
        END_IF;
      ELSE
        IF (e_prefix + 'REAL_LITERAL') IN typenames
        THEN
          RETURN(make_finite_space([expr\real_literal.the_value]));
        ELSE
          RETURN(the_reals);
        END_IF;
      END_IF;
    END_IF;
    IF (e_prefix + 'BOOLEAN_EXPRESSION') IN typenames
    THEN
      IF (e_prefix + 'BOOLEAN_LITERAL') IN typenames
      THEN
        RETURN(make_finite_space([expr\boolean_literal.the_value]));
      ELSE
        RETURN(the_booleans);
      END_IF;
    END_IF;
    IF (e_prefix + 'STRING_EXPRESSION') IN typenames
    THEN
      IF (e_prefix + 'STRING_LITERAL') IN typenames
      THEN
        RETURN(make_finite_space([expr\string_literal.the_value]));
      ELSE
        RETURN(the_strings);
      END_IF;
    END_IF;
    RETURN(?);
  END_IF;
  IF (schema_prefix + 'MATHS_FUNCTION') IN typenames
  THEN
    IF expression_is_constant(expr)
    THEN
      RETURN(make_finite_space([expr]));
    ELSE
      RETURN(make_function_space(sc_equal, expr\maths_function.domain, sc_equal, expr\maths_function.range));
    END_IF;
  END_IF;
  IF (schema_prefix + 'FUNCTION_APPLICATION') IN typenames
  THEN
    RETURN(expr\function_application.func.range);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames
  THEN
    IF expression_is_constant(expr)
    THEN
      RETURN(make_finite_space([expr]));
    ELSE
      RETURN(make_elementary_space(es_maths_spaces));
    END_IF;
  END_IF;
  IF (schema_prefix + 'DEPENDENT_VARIABLE_DEFINITION') IN typenames
  THEN
    RETURN(values_space_of(expr\unary_generic_expression.operand));
  END_IF;
  IF (schema_prefix + 'COMPLEX_NUMBER_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr]));
  END_IF;
  IF (schema_prefix + 'LOGICAL_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\logical_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'BINARY_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\binary_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_ENUM_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\maths_enum_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'REAL_TUPLE_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\real_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'INTEGER_TUPLE_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\integer_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'ATOM_BASED_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\atom_based_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_TUPLE_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\maths_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'PARTIAL_DERIVATIVE_EXPRESSION') IN typenames
  THEN
    RETURN(drop_numeric_constraints(values_space_of(expr\partial_derivative_expression.derivand)));
  END_IF;
  IF (schema_prefix + 'DEFINITE_INTEGRAL_EXPRESSION') IN typenames
  THEN
    RETURN(drop_numeric_constraints(values_space_of(expr\definite_integral_expression.integrand)));
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION vector_difference(arg1 : vector_or_direction;
                           arg2 : vector_or_direction) : vector;
LOCAL
  result : vector;
  res    : direction;
  vec1   : direction;
  vec2   : direction;
  mag    : REAL;
  mag1   : REAL;
  mag2   : REAL;
  ndim   : INTEGER;
END_LOCAL;
  IF ((NOT EXISTS(arg1)) OR (NOT EXISTS(arg2))) OR (arg1.dim <> arg2.dim)
  THEN
    RETURN(?);
  ELSE
    BEGIN  
           IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VECTOR' IN TYPEOF(arg1)
           THEN
             mag1 := arg1\vector.magnitude;
             vec1 := arg1\vector.orientation;
           ELSE
             mag1 := 1.0;
             vec1 := arg1;
           END_IF;
           IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VECTOR' IN TYPEOF(arg2)
           THEN
             mag2 := arg2\vector.magnitude;
             vec2 := arg2\vector.orientation;
           ELSE
             mag2 := 1.0;
             vec2 := arg2;
           END_IF;
           vec1 := normalise(vec1);
           vec2 := normalise(vec2);
           ndim := SIZEOF(vec1.direction_ratios);
           mag := 0.0;
           res := dummy_gri || direction(vec1.direction_ratios);
           REPEAT i := 1 TO ndim;
             res.direction_ratios[i] := mag1 * vec1.direction_ratios[i] - mag2 * vec2.direction_ratios[i];
             mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
           END_REPEAT;
           IF (mag > 0.0)
           THEN
             result := dummy_gri || vector(res, SQRT(mag));
           ELSE
             result := dummy_gri || vector(vec1, 0.0);
           END_IF;
    END;
  END_IF;
  RETURN(result);
END_FUNCTION;

RULE alternative_solution_requires_solution_definition FOR (product_definition_formation);
LOCAL
  solution_versions : SET OF product_definition_formation := [];
END_LOCAL;
  solution_versions := QUERY(pdf
                             <* product_definition_formation
                             | SIZEOF(QUERY(prpc
                                            <* USEDIN(pdf.of_product,
                                                      'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                                            | prpc.name = 'alternative solution')) =
                               1);
WHERE
  WR1: SIZEOF(QUERY(pdf
                    <* solution_versions
                    | SIZEOF(QUERY(pd
                                   <* USEDIN(pdf,
                                             'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION.FORMATION')
                                   | pd.frame_of_reference.name = 'alternative definition')) <>
                      1)) =
       0;
END_RULE;

RULE ap239_prdi_restrict_product_category_for_product FOR (product);
WHERE
  WR1: SIZEOF(QUERY(p
                    <* product
                    | SIZEOF(QUERY(prpc
                                   <* USEDIN(p,
                                             'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                                   | prpc.name IN
                                     ['assembly',
                                      'attachment slot',
                                      'breakdown',
                                      'breakdown element',
                                      'conceptual product',
                                      'detail',
                                      'document',
                                      'envelope',
                                      'functional breakdown',
                                      'functionality',
                                      'interface connector',
                                      'interface specification',
                                      'justification',
                                      'message',
                                      'part',
                                      'physical breakdown',
                                      'physically realized product',
                                      'prototype part',
                                      'raw material',
                                      'requirement',
                                      'spare part',
                                      'standard',
                                      'system breakdown',
                                      'system element',
                                      'tool',
                                      'zone breakdown',
                                      'zone element'])) <>
                      1)) =
       0;
END_RULE;

RULE application_protocol_definition_required FOR (application_context);
WHERE
  WR1: SIZEOF(QUERY(ac
                    <* application_context
                    | (SIZEOF(QUERY(apd
                                    <* USEDIN(ac,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLICATION_PROTOCOL_DEFINITION.APPLICATION')
                                    | apd.application_interpreted_model_schema_name =
                                      'ap239_product_life_cycle_support')) >
                       0))) >
       0;
END_RULE;

RULE breakdown_element_requires_product_definition FOR (product_definition_formation);
WHERE
  WR1: SIZEOF(QUERY(pdf
                    <* product_definition_formation
                    | (SIZEOF(QUERY(prpc
                                    <* USEDIN(pdf.of_product,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                                    | prpc.name = 'functionality')) =
                       1) AND
                      (SIZEOF(QUERY(pd
                                    <* USEDIN(pdf,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION.FORMATION')
                                    | pd.frame_of_reference.name = 'functional definition')) <
                       1))) =
       0;
  WR2: SIZEOF(QUERY(pdf
                    <* product_definition_formation
                    | (SIZEOF(QUERY(prpc
                                    <* USEDIN(pdf.of_product,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                                    | prpc.name = 'conceptual design')) =
                       1) AND
                      (SIZEOF(QUERY(pd
                                    <* USEDIN(pdf,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION.FORMATION')
                                    | pd.frame_of_reference.name = 'conceptual definition')) <
                       1))) =
       0;
END_RULE;

RULE compatible_dimension FOR (cartesian_point, direction, geometric_representation_context);
WHERE
  WR1: ((SIZEOF(cartesian_point) = 0) AND (SIZEOF(direction) = 0) AND
        (SIZEOF(geometric_representation_context) = 0)) OR
       check_geometric_dimension(cartesian_point, direction, geometric_representation_context);
END_RULE;

RULE consistent_uncertainty FOR (global_uncertainty_assigned_context,
                                 qualified_representation_item,
                                 uncertainty_assigned_representation);
WHERE
  WR1: SIZEOF(QUERY(guac
                    <* global_uncertainty_assigned_context
                    | SIZEOF(QUERY(u1
                                   <* guac.uncertainty
                                   | SIZEOF(QUERY(u2 <* guac.uncertainty | u2.name = u1.name)) > 1)) >
                      0)) =
       0;
  WR2: SIZEOF(QUERY(uar
                    <* uncertainty_assigned_representation
                    | SIZEOF(QUERY(u1
                                   <* uar.uncertainty
                                   | SIZEOF(QUERY(u2 <* uar.uncertainty | u2.name = u1.name)) > 1)) >
                      0)) =
       0;
  WR3: SIZEOF(QUERY(qri
                    <* qualified_representation_item
                    | SIZEOF(QUERY(u1
                                   <* qri.qualifiers
                                   | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.UNCERTAINTY_QUALIFIER' IN
                                      TYPEOF(u1)) AND
                                     (SIZEOF(QUERY(u2
                                                   <* qri.qualifiers
                                                   | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.UNCERTAINTY_QUALIFIER' IN
                                                      TYPEOF(u2)) AND
                                                     (u2\uncertainty_qualifier.measure_name =
                                                      u1\uncertainty_qualifier.measure_name))) >
                                      1))) >
                      0)) =
       0;
END_RULE;

RULE constraint_definition_requires_constraint_category FOR (product_definition);
LOCAL
  constraint_definitions : SET OF product_definition := [];
END_LOCAL;
  constraint_definitions := QUERY(pd
                                  <* product_definition
                                  | (pd.frame_of_reference.name = 'design constraint definition'));
WHERE
  WR1: SIZEOF(QUERY(pd
                    <* constraint_definitions
                    | (SIZEOF(QUERY(prpc
                                    <* USEDIN(pd.formation.of_product,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                                    | prpc.name = 'requirement')) =
                       0))) =
       0;
END_RULE;

RULE design_constraint_requires_product_definition FOR (product_definition_formation);
WHERE
  WR1: SIZEOF(QUERY(pdf
                    <* product_definition_formation
                    | (SIZEOF(QUERY(prpc
                                    <* USEDIN(pdf.of_product,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                                    | prpc.name = 'requirement')) >
                       0) AND
                      (SIZEOF(QUERY(pd
                                    <* USEDIN(pdf,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION.FORMATION')
                                    | pd.frame_of_reference.name = 'design constraint definition')) <
                       1))) =
       0;
END_RULE;

RULE external_version_assignments_are_valid FOR (applied_external_identification_assignment);
WHERE
  WR1: SIZEOF(QUERY(aia
                    <* applied_external_identification_assignment
                    | NOT external_version_assignment_is_valid(aia))) =
       0;
END_RULE;

RULE machining_feature_definition_constraints FOR (feature_definition);
LOCAL
  mfds : SET OF feature_definition := [];
END_LOCAL;
  mfds := QUERY(temp
                <* feature_definition
                | 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MACHINING_FEATURE_DEFINITION' IN TYPEOF(temp));
WHERE
  WR1: SIZEOF(QUERY(mfd
                    <* mfds
                    | NOT (SIZEOF(QUERY(pdr
                                        <* get_property_definition_representations(mfd)
                                        | 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN
                                          TYPEOF(pdr.used_representation))) <=
                           1))) =
       0;
  WR2: SIZEOF(QUERY(mfd
                    <* mfds
                    | NOT (SIZEOF(QUERY(pd
                                        <* USEDIN(mfd,
                                                  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION.DEFINITION')
                                        | NOT (SIZEOF(QUERY(impl_rep
                                                            <* QUERY(pdr
                                                                     <* USEDIN(pd,
                                                                               'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')
                                                                     | 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN
                                                                       TYPEOF(pdr.used_representation))
                                                            | NOT (SIZEOF(QUERY(it
                                                                                <* impl_rep.used_representation.items
                                                                                | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PLACEMENT' IN
                                                                                   TYPEOF(it)) AND
                                                                                  (it.name = 'orientation'))) =
                                                                   1))) =
                                               0))) =
                           0))) =
       0;
  WR3: SIZEOF(QUERY(mfd
                    <* mfds
                    | NOT ((NOT (SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROUND_HOLE',
                                         'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BOSS',
                                         'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OUTSIDE_PROFILE',
                                         'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REMOVAL_VOLUME',
                                         'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.FLAT_FACE',
                                         'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POCKET',
                                         'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROTRUSION',
                                         'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RIB_TOP',
                                         'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROUNDED_END',
                                         'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SLOT',
                                         'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.STEP'] *
                                        TYPEOF(mfds)) =
                                 1)) OR
                           ((SIZEOF(QUERY(pdr
                                          <* get_property_definition_representations(mfd)
                                          | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PLANAR_SHAPE_REPRESENTATION' IN
                                             TYPEOF(pdr.used_representation)) AND
                                            (pdr.used_representation.name = 'maximum feature limit'))) >=
                             0))))) =
       0;
END_RULE;

RULE plib_property_reference_requires_name_scope FOR (externally_defined_general_property);
LOCAL
  known_sourced_properties : SET OF externally_defined_general_property;
END_LOCAL;
  known_sourced_properties := QUERY(edc
                                    <* externally_defined_general_property
                                    | 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.KNOWN_SOURCE' IN TYPEOF(edc.source));
WHERE
  WR1: SIZEOF(QUERY(edgp
                    <* known_sourced_properties
                    | (SIZEOF(QUERY(edir
                                    <* USEDIN(edgp,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.RELATING_ITEM')
                                    | (edir.name = 'name scope') AND
                                      ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXTERNALLY_DEFINED_CLASS' IN
                                       TYPEOF(edir.related_item)) AND
                                      ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.KNOWN_SOURCE' IN
                                       TYPEOF(edir.related_item.source)))) <>
                       1))) =
       0;
END_RULE;

RULE plib_property_reference_requires_version FOR (externally_defined_general_property);
LOCAL
  plib_properties : SET OF externally_defined_general_property := [];
END_LOCAL;
  plib_properties := QUERY(edgp
                           <* externally_defined_general_property
                           | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.KNOWN_SOURCE' IN TYPEOF(edgp.source)) AND
                             ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.KNOWN_SOURCE.NAME' = 'ISO 13584 library'));
WHERE
  WR1: SIZEOF(QUERY(edgp
                    <* plib_properties
                    | (SIZEOF(QUERY(edir
                                    <* USEDIN(edgp,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS')
                                    | (edir.role.name = 'version'))) <>
                       1))) =
       0;
END_RULE;

RULE product_concept_feature_requires_category FOR (product_concept_feature);
WHERE
  WR1: SIZEOF(QUERY(pcf
                    <* product_concept_feature
                    | (SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INCLUSION_PRODUCT_CONCEPT_FEATURE',
                               'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONDITIONAL_CONCEPT_FEATURE'] *
                              TYPEOF(pcf)) =
                       0) AND
                      (SIZEOF(QUERY(aga
                                    <* USEDIN(pcf,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_GROUP_ASSIGNMENT.ITEMS')
                                    | (aga\group_assignment.role\object_role.name =
                                       'specification category member') AND
                                      ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN
                                       TYPEOF(aga.assigned_group)))) <>
                       1))) =
       0;
END_RULE;

RULE product_definition_replacement_requires_effectivity_assignment FOR (product_definition_relationship);
WHERE
  WR1: SIZEOF(QUERY(pdr
                    <* product_definition_relationship
                    | (pdr.name = 'definition replacement') AND
                      (SIZEOF(USEDIN(pdr,
                                     'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_EFFECTIVITY_ASSIGNMENT.ITEMS')) =
                       0))) =
       0;
END_RULE;

RULE restrict_alternative_definition FOR (product_definition);
LOCAL
  solution_definitions : SET OF product_definition := [];
END_LOCAL;
  solution_definitions := QUERY(pd <* product_definition | (pd.frame_of_reference.name = 'alternative definition'));
WHERE
  WR1: SIZEOF(QUERY(pd
                    <* solution_definitions
                    | (SIZEOF(QUERY(pdr
                                    <* USEDIN(pd,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                                    | pdr.name = 'solution alternative definition')) <>
                       1))) =
       0;
  WR2: SIZEOF(QUERY(pd <* solution_definitions | NOT (pd.name IN ['technical','supplier','technical supplier','']))) =
       0;
  WR3: SIZEOF(QUERY(pd
                    <* solution_definitions
                    | (pd.name IN ['supplier','technical supplier']) AND
                      (SIZEOF(QUERY(aoa
                                    <* USEDIN(pd.formation,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')
                                    | aoa.role.name = 'supplier')) <>
                       1))) =
       0;
END_RULE;

RULE restrict_assembly_category FOR (product_definition);
LOCAL
  assembly_definitions : SET OF product_definition := [];
END_LOCAL;
  assembly_definitions := QUERY(pd
                                <* product_definition
                                | SIZEOF(QUERY(pdca
                                               <* USEDIN(pd,
                                                         'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION')
                                               | pdca.frame_of_reference.name = 'assembly definition')) >
                                  0);
WHERE
  WR1: SIZEOF(QUERY(pd <* assembly_definitions | NOT ('assembly' IN categories_of_product(pd.formation.of_product)))) =
       0;
END_RULE;

RULE restrict_classification_assignments FOR (applied_classification_assignment);
WHERE
  WR1: SIZEOF(QUERY(aia <* applied_classification_assignment | NOT class_assignment_is_valid(aia))) = 0;
END_RULE;

RULE restrict_collection_category FOR (product_definition);
LOCAL
  collection_definitions : SET OF product_definition := [];
END_LOCAL;
  collection_definitions := QUERY(pd
                                  <* product_definition
                                  | SIZEOF(QUERY(pdca
                                                 <* USEDIN(pd,
                                                           'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION')
                                                 | pdca.frame_of_reference.name = 'collection definition')) >
                                    0);
WHERE
  WR1: SIZEOF(QUERY(pd
                    <* collection_definitions
                    | NOT ('collection' IN categories_of_product(pd.formation.of_product)))) =
       0;
END_RULE;

RULE restrict_concept_feature_operator FOR (concept_feature_operator);
WHERE
  WR1: SIZEOF(QUERY(cfo <* concept_feature_operator | NOT (cfo.name IN ['and','or','oneof','not','implication']))) = 0;
  WR2: SIZEOF(QUERY(cfo
                    <* concept_feature_operator
                    | (cfo.name = 'implication') AND
                      (SIZEOF(QUERY(cfrwc
                                    <* USEDIN(cfo,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.CONDITIONAL_OPERATOR')
                                    | SIZEOF(QUERY(ccf
                                                   <* USEDIN(cfrwc,
                                                             'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONDITIONAL_CONCEPT_FEATURE.CONDITION')
                                                   | NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.INCLUSION_PRODUCT_CONCEPT_FEATURE' IN
                                                          TYPEOF(ccf)))) >
                                      0)) >
                       0))) =
       0;
  WR3: SIZEOF(QUERY(cfo
                    <* concept_feature_operator
                    | (cfo.name = 'not') AND
                      (SIZEOF(QUERY(cfrwc
                                    <* USEDIN(cfo,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.CONDITIONAL_OPERATOR')
                                    | cfrwc.related_product_concept_feature :<>:
                                      cfrwc.relating_product_concept_feature)) >
                       0))) =
       0;
END_RULE;

RULE restrict_configuration_design_for_class_breakdown_association FOR (configuration_design);
WHERE
  WR1: SIZEOF(QUERY(cd
                    <* configuration_design
                    | (cd.name = 'functionality') AND
                      (NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(cd.design)) OR
                           (cd.design\product_definition.frame_of_reference.name <> 'functional definition')))) =
       0;
  WR2: SIZEOF(QUERY(cd
                    <* configuration_design
                    | (cd.name = 'realization') AND
                      (NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(cd.design)) OR
                           (cd.design\product_definition.frame_of_reference.name <> 'conceptual definition')))) =
       0;
  WR3: SIZEOF(QUERY(cd
                    <* configuration_design
                    | (cd.name IN ['functionality','realization']) AND
                      (NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CLASS' IN
                            TYPEOF(cd.configuration.item_concept))))) =
       0;
END_RULE;

RULE restrict_configuration_design_for_design_constraint FOR (configuration_design);
WHERE
  WR1: SIZEOF(QUERY(cd
                    <* configuration_design
                    | (cd.name = 'design constraint usage') AND
                      (NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(cd.design)) OR
                           (cd.design\product_definition.frame_of_reference.name <>
                            'design constraint definition')))) =
       0;
END_RULE;

RULE restrict_group_relationship_for_classification_hierarchy FOR (group_relationship);
WHERE
  WR1: SIZEOF(QUERY(gr
                    <* group_relationship
                    | (gr\group_relationship.name = 'class hierarchy') AND
                      (NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CLASS' IN
                            TYPEOF(gr\group_relationship.related_group)) OR
                           NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CLASS' IN
                                TYPEOF(gr\group_relationship.relating_group))))) =
       0;
END_RULE;

RULE restrict_group_relationship_for_specification_category FOR (group_relationship);
WHERE
  WR1: SIZEOF(QUERY(gr
                    <* group_relationship
                    | (gr.name = 'specification category hierarchy') AND
                      (NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN
                            TYPEOF(gr.related_group)) OR
                           NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN
                                TYPEOF(gr.relating_group))))) =
       0;
END_RULE;

RULE restrict_language_assignment_per_attribute FOR (attribute_language_assignment);
WHERE
  WR1: SIZEOF(QUERY(ala1
                    <* attribute_language_assignment
                    | SIZEOF(QUERY(it
                                   <* ala1.items
                                   | SIZEOF(QUERY(ala2
                                                  <* USEDIN(it,
                                                            'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS')
                                                  | (ala1\attribute_classification_assignment.attribute_name =
                                                     ala2\attribute_classification_assignment.attribute_name) AND
                                                    (ala1\attribute_classification_assignment.assigned_class :=:
                                                     ala2\attribute_classification_assignment.assigned_class))) >
                                     1)) >
                      0)) =
       0;
END_RULE;

RULE restrict_part_occurrence FOR (product_definition);
LOCAL
  part_occurrences : SET OF product_definition := QUERY(pd
                                                        <* product_definition
                                                        | (pd.frame_of_reference.name = 'part occurrence'));
END_LOCAL;
WHERE
  WR1: SIZEOF(QUERY(pd
                    <* part_occurrences
                    | (NOT (pd.name IN
                            ['single instance','selected instance','quantified instance','specified instance'])))) =
       0;
  WR2: SIZEOF(QUERY(pd
                    <* part_occurrences
                    | (SIZEOF(QUERY(pdr
                                    <* USEDIN(pd,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                                    | pdr.name = 'definition usage')) <>
                       1) AND
                      (SIZEOF(QUERY(cd
                                    <* USEDIN(pd,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONFIGURATION_DESIGN.DESIGN')
                                    | (cd.name = 'occurrence usage definition') AND
                                      (NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_IDENTIFICATION' IN
                                            TYPEOF(cd.configuration))))) <>
                       1))) =
       0;
  WR3: SIZEOF(QUERY(pd
                    <* part_occurrences
                    | (SIZEOF(QUERY(cd
                                    <* USEDIN(pd,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                                    | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_USAGE' IN
                                       TYPEOF(cd)))) =
                       0) AND
                      (SIZEOF(USEDIN(pd,
                                     'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE')) =
                       0))) =
       0;
  WR4: SIZEOF(QUERY(pd
                    <* part_occurrences
                    | (pd.name = 'selected instance') AND NOT valid_selected_instance_representation(pd))) =
       0;
  WR5: SIZEOF(QUERY(pd
                    <* part_occurrences
                    | (pd.name = 'quantified instance') AND
                      (SIZEOF(QUERY(ppd
                                    <* USEDIN(pd,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION.DEFINITION')
                                    | (ppd.name = 'occurrence quantity') AND
                                      (SIZEOF(QUERY(pdr
                                                    <* USEDIN(ppd,
                                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')
                                                    | (pdr.used_representation.name = 'quantity') AND
                                                      (SIZEOF(pdr.used_representation.items) = 1) AND
                                                      (SIZEOF(QUERY(i
                                                                    <* pdr.used_representation.items
                                                                    | ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN
                                                                       TYPEOF(i)) AND
                                                                      (i.name = 'quantity measure'))) =
                                                       1))) =
                                       1))) =
                       0))) =
       0;
  WR6: SIZEOF(QUERY(pd
                    <* part_occurrences
                    | (pd.name = 'specified instance') AND
                      (SIZEOF(QUERY(pdor
                                    <* USEDIN(pd,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE')
                                    | 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN
                                      TYPEOF(pdor.occurrence_usage))) =
                       0))) =
       0;
END_RULE;

RULE restrict_part_occurrence_category FOR (product_definition);
LOCAL
  part_occurrences : SET OF product_definition := QUERY(pd
                                                        <* product_definition
                                                        | (pd.frame_of_reference.name = 'part occurrence'));
END_LOCAL;
WHERE
  WR1: SIZEOF(QUERY(pd
                    <* part_occurrences
                    | (SIZEOF(QUERY(prpc
                                    <* USEDIN(pd.formation.of_product,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                                    | prpc.name IN ['part','raw material','tool'])) =
                       0))) =
       0;
END_RULE;

RULE restrict_product_definitions_for_base_element FOR (product_definition_relationship);
WHERE
  WR1: SIZEOF(QUERY(pdr
                    <* product_definition_relationship
                    | (pdr.name = 'solution alternative definition') AND
                      (NOT (pdr.relating_product_definition.frame_of_reference.name IN
                            ['alternative definition','functional definition','conceptual definition']) OR
                           (pdr.related_product_definition.frame_of_reference.name <> 'alternative definition')))) =
       0;
END_RULE;

RULE restrict_product_definitions_for_collection FOR (product_definition_relationship);
WHERE
  WR1: SIZEOF(QUERY(pdr
                    <* product_definition_relationship
                    | (pdr.name = 'collection membership') AND
                      ((pdr.relating_product_definition.frame_of_reference.name <> 'part definition') OR
                       (pdr.related_product_definition.frame_of_reference.name <> 'part occurrence') OR
                       (SIZEOF(QUERY(pdca
                                     <* USEDIN(pdr.relating_product_definition,
                                               'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION')
                                     | (pdca.role.name = 'part definition type') AND
                                       (pdca.frame_of_reference.name = 'collection definition'))) =
                        0)))) =
       0;
END_RULE;

RULE restrict_product_definitions_for_definition_usage FOR (product_definition_relationship);
WHERE
  WR1: SIZEOF(QUERY(pdr
                    <* product_definition_relationship
                    | (pdr.name = 'definition usage') AND
                      ((pdr.relating_product_definition.frame_of_reference.name <> 'part definition') OR
                       (pdr.related_product_definition.frame_of_reference.name <> 'part occurrence')))) =
       0;
END_RULE;

RULE restrict_product_definitions_for_design_constraint_association FOR (product_definition_relationship);
WHERE
  WR1: SIZEOF(QUERY(pdr
                    <* product_definition_relationship
                    | (pdr.name = 'design constraint association') AND
                      ((pdr.relating_product_definition.frame_of_reference.name <> 'design constraint definition') OR
                       NOT (pdr.related_product_definition.frame_of_reference.name IN
                            ['alternative definition','functional definition','conceptual definition'])))) =
       0;
END_RULE;

RULE restrict_product_definitions_for_part_definition_relationship FOR (product_definition_relationship);
WHERE
  WR1: SIZEOF(QUERY(pdr
                    <* product_definition_relationship
                    | (pdr.name IN ['geometrical relationship','definition replacement']) AND
                      ((pdr.relating_product_definition.frame_of_reference.name <> 'part definition') OR
                       (pdr.related_product_definition.frame_of_reference.name <> 'part definition')))) =
       0;
END_RULE;

RULE selected_instance_usage_requires_representation FOR (assembly_component_usage);
LOCAL
  selected_instance_usages : SET OF assembly_component_usage := QUERY(acr
                                                                      <* assembly_component_usage
                                                                      | (acr.name = 'selected instance usage'));
END_LOCAL;
WHERE
  WR1: SIZEOF(QUERY(acr <* selected_instance_usages | NOT valid_selected_instance_representation(acr))) = 0;
END_RULE;

RULE solution_definition_requires_solution_category FOR (product_definition);
LOCAL
  solution_definitions : SET OF product_definition := [];
END_LOCAL;
  solution_definitions := QUERY(pd <* product_definition | (pd.frame_of_reference.name = 'alternative definition'));
WHERE
  WR1: SIZEOF(QUERY(pd
                    <* solution_definitions
                    | (SIZEOF(QUERY(prpc
                                    <* USEDIN(pd.formation.of_product,
                                              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                                    | prpc.name = 'alternative solution')) =
                       0))) =
       0;
END_RULE;

RULE subtype_exclusiveness_representation_item FOR (representation_item);
WHERE
  WR1: SIZEOF(QUERY(cri
                    <* representation_item
                    | NOT (type_check_function(cri,
                                               ['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MEASURE_REPRESENTATION_ITEM',
                                                'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VALUE_REPRESENTATION_ITEM',
                                                'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COMPOUND_REPRESENTATION_ITEM'],
                                               3)))) =
       0;
END_RULE;
END_SCHEMA;
