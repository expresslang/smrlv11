-- -*- Mode: EXPRESS; Base: 10 -*-

(* Shortform to Longform Conversion
   Express Engine
     5.1.9 (GIT eeng-5.1.4-30-gc9dd96c)
     Steel Bank CL 2.2.5 (Unknown Bits)
*)

(* 142 Schemata Processed:
   (action_schema activity_method_mim activity_mim advanced_boundary_representation_mim aic_advanced_brep aic_csg
    aic_curve_swept_solid aic_edge_based_wireframe aic_faceted_brep aic_geometrically_bounded_surface
    aic_geometrically_bounded_wireframe aic_manifold_surface aic_shell_based_wireframe
    aic_topologically_bounded_surface appearance_assignment_mim application_context_schema approval_mim approval_schema
    assembly_structure_mim associative_text_mim basic_attribute_schema basic_curve_mim basic_data_representation_mim
    basic_geometric_topology_mim basic_geometry_mim b_spline_geometry_mim characteristic_mim
    classification_assignment_mim classification_schema class_mim colour_mim composite_constituent_shape_mim
    configuration_item_mim configuration_management_schema construction_geometry_mim constructive_solid_geometry_3d_mim
    curve_appearance_mim curve_swept_solid_mim date_time_assignment_mim date_time_mim date_time_schema
    description_assignment_mim document_and_version_identification_mim document_assignment_mim document_definition_mim
    document_schema draughting_element_mim draughting_element_schema edge_based_wireframe_mim
    elemental_geometric_shape_mim elemental_topology_mim elementary_boundary_representation_mim elementary_function_mim
    expression_mim extended_date_mim extended_measure_representation_mim external_class_mim
    external_item_identification_assignment_mim external_library_mim external_model_mim external_properties_mim
    external_reference_schema external_source_mim faceted_boundary_representation_mim file_identification_mim
    foundation_representation_mim generic_expression_mim generic_material_aspects_mim geometrically_bounded_surface_mim
    geometrically_bounded_wireframe_mim geometric_model_relationship_mim geometric_model_schema geometry_schema
    group_mim group_schema identification_assignment_mim independent_property_mim
    independent_property_representation_mim iso13584_expressions_schema iso13584_generic_expressions_schema
    language_schema limited_length_or_area_indicator_assignment_mim management_resources_schema manifold_surface_mim
    material_property_definition_schema material_property_representation_schema mathematical_functions_schema
    maths_value_mim measure_representation_mim measure_schema mechanical_design_schema multi_linguism_mim
    name_assignment_mim numeric_expression_mim numeric_function_mim parametric_representation_mim
    part_and_version_identification_mim part_and_zone_laminate_tables_mim part_view_definition_mim
    person_organization_assignment_mim person_organization_mim person_organization_schema plib_class_reference_mim
    ply_orientation_specification_mim presentation_appearance_schema presentation_definition_schema
    presentation_organization_schema presentation_resource_schema primitive_solids_mim product_class_mim
    product_concept_identification_mim product_concept_schema product_definition_schema product_identification_mim
    product_property_definition_schema product_property_representation_schema product_structure_schema
    product_version_mim product_view_definition_mim product_view_definition_reference_mim
    product_view_definition_relationship_mim property_assignment_mim qualified_measure_mim qualified_measure_schema
    representation_schema shape_dimension_schema shape_property_assignment_mim shell_based_wireframe_mim
    solid_model_mim specification_document_mim stock_material_mim styled_curve_mim support_resource_mim
    support_resource_schema systems_engineering_representation_schema tagged_text_representation_mim
    tessellated_geometry_mim text_appearance_mim topologically_bounded_surface_mim topology_schema
    value_with_unit_extension_mim value_with_unit_mim)
*)

(*  Interfaces:                 0 *)
(*  Constants:                 29 *)
(*  Types:                    220 *)
(*  Entities:                 831 *)
(*  Subtype_Constraints:        0 *)
(*  Functions:                215 *)
(*  Rules:                     16 *)
(*  Procedures:                 0 *)

-- Schema limited_length_or_area_indicator_assignment_mim_lf;
SCHEMA Limited_length_or_area_indicator_assignment_mim_lf;

CONSTANT
  dummy_gri                     : geometric_representation_item   :=
                                  representation_item('') || geometric_representation_item();
  dummy_tri                     : topological_representation_item :=
                                  representation_item('') || topological_representation_item();
  schema_prefix                 : STRING                          :=
                                  'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.';
  the_binarys                   : elementary_space                := make_elementary_space(es_binarys);
  the_booleans                  : elementary_space                := make_elementary_space(es_booleans);
  the_complex_numbers           : elementary_space                := make_elementary_space(es_complex_numbers);
  the_complex_tuples            : extended_tuple_space            :=
                                  make_extended_tuple_space(the_zero_tuple_space, the_complex_numbers);
  the_empty_atom_based_tuple    : atom_based_tuple                := [];
  the_empty_atom_based_value    : atom_based_value                := the_empty_atom_based_tuple;
  the_empty_maths_tuple         : maths_tuple                     := [];
  the_empty_maths_value         : maths_value                     := the_empty_maths_tuple;
  the_empty_space               : finite_space                    := make_finite_space([]);
  the_generics                  : elementary_space                := make_elementary_space(es_generics);
  the_integer_tuples            : extended_tuple_space            :=
                                  make_extended_tuple_space(the_zero_tuple_space, the_integers);
  the_integers                  : elementary_space                := make_elementary_space(es_integers);
  the_logicals                  : elementary_space                := make_elementary_space(es_logicals);
  the_maths_spaces              : elementary_space                := make_elementary_space(es_maths_spaces);
  the_neg1_one_interval         : finite_real_interval            :=
                                  make_finite_real_interval(-1.0, closed, 1.0, closed);
  the_neghalfpi_halfpi_interval : finite_real_interval            :=
                                  make_finite_real_interval(-0.5 * PI, closed, 0.5 * PI, closed);
  the_negpi_pi_interval         : finite_real_interval            := make_finite_real_interval(-PI, open, PI, closed);
  the_nonnegative_reals         : real_interval_from_min          := make_real_interval_from_min(0.0, closed);
  the_numbers                   : elementary_space                := make_elementary_space(es_numbers);
  the_real_tuples               : extended_tuple_space            :=
                                  make_extended_tuple_space(the_zero_tuple_space, the_reals);
  the_reals                     : elementary_space                := make_elementary_space(es_reals);
  the_strings                   : elementary_space                := make_elementary_space(es_strings);
  the_tuples                    : extended_tuple_space            :=
                                  make_extended_tuple_space(the_zero_tuple_space, the_generics);
  the_zero_one_interval         : finite_real_interval            :=
                                  make_finite_real_interval(0.0, closed, 1.0, closed);
  the_zero_pi_interval          : finite_real_interval            := make_finite_real_interval(0.0, closed, PI, closed);
  the_zero_tuple_space          : listed_product_space            := make_listed_product_space([]);
END_CONSTANT;

(* "unique_datum_system"
             Pruning RULE unique_datum_system: it is missing one of its Entity-Refs
              *)

(* Pruned unused TYPE rs_description_attribute_select *)

(* Pruned unused TYPE rs_id_attribute_select *)

(* Pruned unused TYPE s_name_attribute_select *)

(* Pruned unused TYPE representation_identification_item *)

(* Pruned unused TYPE bc_external_identification_item *)

(* Pruned unused TYPE fi_action_items *)

(* Pruned unused TYPE file_identification_item *)

(* Pruned unused TYPE file_location_select *)

(* Pruned unused TYPE appearance_representation_identification_item *)

(* "annotation_representation_select"
             Pruned TYPE annotation_representation_select = SELECT for lack of SELECT Items
              *)

(* "description_item"
             Pruned TYPE description_item = SELECT for lack of SELECT Items
              *)

(* "multi_language_attribute_item"
             Pruned TYPE multi_language_attribute_item = SELECT for lack of SELECT Items
              *)

(* Pruned unused TYPE pie_external_identification_item *)

(* Pruned unused TYPE pa_action_items *)

(* Pruned unused TYPE apps_description_attribute_select *)

(* Pruned unused TYPE apps_role_select *)

(* "approval_scope_item"
             Pruned TYPE approval_scope_item = SELECT for lack of SELECT Items
              *)

(* Pruned unused TYPE date_and_time_item_approval *)

(* Pruned unused TYPE date_item_approval *)

(* Pruned unused TYPE document_location_select *)

(* Pruned unused TYPE ers_description_attribute_select *)

(* Pruned unused TYPE external_class_name_item *)

(* "person_and_organization_item"
             Pruned TYPE person_and_organization_item = SELECT for lack of SELECT Items
              *)

(* Pruned unused TYPE plib_class_identification_item *)

(* Pruned unused TYPE plib_class_organization_item *)

(* Pruned unused TYPE el_external_identification_item *)

(* Pruned unused TYPE external_identification_for_plib_property *)

(* Pruned unused TYPE c_document_reference_item *)

(* Pruned unused TYPE sd_document_reference_item *)

(* Pruned unused TYPE sm_approval_item *)

(* "classification_item"
             Pruned TYPE classification_item = SELECT for lack of SELECT Items
              *)

(* Pruned unused TYPE id_for_class *)

(* Pruned unused TYPE specification_for_category *)

(* "surface_side_style_select"
             Pruned TYPE surface_side_style_select = SELECT for lack of SELECT Items
              *)

(* "annotation_symbol_occurrence_item"
             Pruned TYPE annotation_symbol_occurrence_item = SELECT for lack of SELECT Items
              *)

(* "absorbed_dose_measure" USE from SCHEMA measure_schema *)
(* "absorbed_dose_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE absorbed_dose_measure = REAL;
END_TYPE;

(* "acceleration_measure" USE from SCHEMA measure_schema *)
(* "acceleration_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE acceleration_measure = REAL;
END_TYPE;

(* "action_items" USE from SCHEMA activity_mim *)
(* "action_items" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,EXTERNAL_MODEL_MIM,ACTIVITY_MIM *)
TYPE action_items = SELECT
  (document_type,
   property_definition_relationship);
END_TYPE;

(* "advanced_brep_shape_representation_items_select" IMPLICIT from SCHEMA geometric_model_schema *)
TYPE advanced_brep_shape_representation_items_select = SELECT
  (axis2_placement_3d,
   manifold_solid_brep,
   mapped_item);
END_TYPE;

(* "advanced_face_geometry_select" IMPLICIT from SCHEMA topology_schema *)
TYPE advanced_face_geometry_select = SELECT
  (b_spline_surface,
   elementary_surface,
   swept_surface);
END_TYPE;

(* "ahead_or_behind" IMPLICIT from SCHEMA date_time_schema *)
TYPE ahead_or_behind = ENUMERATION OF
  (ahead,
   exact,
   behind);
END_TYPE;

(* "amount_of_substance_measure" USE from SCHEMA measure_schema *)
(* "amount_of_substance_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE amount_of_substance_measure = REAL;
END_TYPE;

(* "angular_deviation" USE from SCHEMA geometric_model_schema *)
(* "angular_deviation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
TYPE angular_deviation = positive_plane_angle_measure;
END_TYPE;

(* "annotation_placeholder_occurrence_role" IMPLICIT from SCHEMA mechanical_design_schema *)
TYPE annotation_placeholder_occurrence_role = ENUMERATION OF
  (annotation_text,
   gps_data);
END_TYPE;

(* "annotation_plane_element" IMPLICIT from SCHEMA draughting_element_schema *)
TYPE annotation_plane_element = SELECT
  (draughting_callout,
   styled_item);
END_TYPE;

(* "annotation_text_occurrence_item" IMPLICIT from SCHEMA presentation_definition_schema *)
TYPE annotation_text_occurrence_item = SELECT
  ((* Pruned: annotation_text_character *)
   annotation_text,
   composite_text,
   defined_character_glyph,
   text_literal);
END_TYPE;

(* "approval_item" USE from SCHEMA approval_mim *)
(* "approval_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,APPROVAL_MIM *)
TYPE approval_item = SELECT
  (product_definition);
END_TYPE;

(* "area_measure" USE from SCHEMA measure_schema *)
(* "area_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE area_measure = REAL;
END_TYPE;

(* "atom_based_tuple" USE from SCHEMA mathematical_functions_schema *)
(* "atom_based_tuple" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE atom_based_tuple = LIST OF atom_based_value;
END_TYPE;

(* "atom_based_value" USE from SCHEMA mathematical_functions_schema *)
(* "atom_based_value" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE atom_based_value = SELECT
  (atom_based_tuple,
   maths_atom);
END_TYPE;

(* "attribute_language_item" USE from SCHEMA multi_linguism_mim *)
(* "attribute_language_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,MULTI_LINGUISM_MIM *)
TYPE attribute_language_item = SELECT
  (attribute_value_assignment,
   multi_language_attribute_assignment);
END_TYPE;

(* "attribute_type" IMPLICIT from SCHEMA management_resources_schema *)
TYPE attribute_type = SELECT
  (label,
   text);
END_TYPE;

(* "axis2_placement" IMPLICIT from SCHEMA geometry_schema *)
TYPE axis2_placement = SELECT
  (axis2_placement_2d,
   axis2_placement_3d);
END_TYPE;

(* "b_spline_curve_form" IMPLICIT from SCHEMA geometry_schema *)
TYPE b_spline_curve_form = ENUMERATION OF
  (polyline_form,
   circular_arc,
   elliptic_arc,
   parabolic_arc,
   hyperbolic_arc,
   unspecified);
END_TYPE;

(* "b_spline_surface_form" IMPLICIT from SCHEMA geometry_schema *)
TYPE b_spline_surface_form = ENUMERATION OF
  (plane_surf,
   cylindrical_surf,
   conical_surf,
   spherical_surf,
   toroidal_surf,
   surf_of_revolution,
   ruled_surf,
   generalised_cone,
   quadric_surf,
   surf_of_linear_extrusion,
   unspecified);
END_TYPE;

(* "basis_11_direction_member" USE from SCHEMA ply_orientation_specification_mim *)
(* "basis_11_direction_member" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PLY_ORIENTATION_SPECIFICATION_MIM *)
TYPE basis_11_direction_member = SELECT
  (cartesian_11,
   curve_11,
   cylindrical_11,
   point_array,
   polar_11,
   user_defined_11);
END_TYPE;

(* "boolean_operand" USE from SCHEMA geometric_model_schema *)
(* "boolean_operand" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
TYPE boolean_operand = SELECT
  ((* Pruned: half_space_2d *)
   boolean_result,
   csg_primitive,
   half_space_solid,
   solid_model);
END_TYPE;

(* "boolean_operator" USE from SCHEMA geometric_model_schema *)
(* "boolean_operator" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
TYPE boolean_operator = ENUMERATION OF
  (union,
   intersection,
   difference);
END_TYPE;

(* "box_characteristic_select" IMPLICIT from SCHEMA presentation_appearance_schema *)
TYPE box_characteristic_select = SELECT
  (box_height,
   box_rotate_angle,
   box_slant_angle,
   box_width);
END_TYPE;

(* "box_height" USE from SCHEMA presentation_appearance_schema *)
(* "box_height" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
TYPE box_height = positive_ratio_measure;
END_TYPE;

(* "box_rotate_angle" USE from SCHEMA presentation_appearance_schema *)
(* "box_rotate_angle" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
TYPE box_rotate_angle = plane_angle_measure;
END_TYPE;

(* "box_slant_angle" USE from SCHEMA presentation_appearance_schema *)
(* "box_slant_angle" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
TYPE box_slant_angle = plane_angle_measure;
END_TYPE;

(* "box_width" USE from SCHEMA presentation_appearance_schema *)
(* "box_width" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
TYPE box_width = positive_ratio_measure;
END_TYPE;

(* "capacitance_measure" USE from SCHEMA measure_schema *)
(* "capacitance_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE capacitance_measure = REAL;
END_TYPE;

(* "category_usage_item" USE from SCHEMA product_class_mim *)
(* "category_usage_item" Path: PRODUCT_CLASS_MIM *)
TYPE category_usage_item = SELECT
  (product_class);
END_TYPE;

(* "celsius_temperature_measure" USE from SCHEMA measure_schema *)
(* "celsius_temperature_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE celsius_temperature_measure = REAL;
END_TYPE;

(* "chained_representation_link" IMPLICIT from SCHEMA product_property_representation_schema *)
TYPE chained_representation_link = SELECT
  (mapped_item,
   representation_context,
   representation_relationship);
END_TYPE;

(* "character_spacing_select" IMPLICIT from SCHEMA presentation_appearance_schema *)
TYPE character_spacing_select = SELECT
  ((* Pruned: pre_defined_character_spacing *)
   descriptive_measure,
   length_measure,
   measure_with_unit,
   ratio_measure);
END_TYPE;

(* "character_style_select" IMPLICIT from SCHEMA presentation_appearance_schema *)
TYPE character_style_select = SELECT
  (character_glyph_style_outline,
   character_glyph_style_stroke,
   text_style_for_defined_font);
END_TYPE;

(* "characterized_definition" IMPLICIT from SCHEMA product_property_definition_schema *)
TYPE characterized_definition = SELECT
  ((* Pruned: shape_definition *)
   characterized_item,
   characterized_object,
   characterized_product_definition);
END_TYPE;

(* "characterized_item" USE from SCHEMA product_property_definition_schema *)
(* "characterized_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PRODUCT_PROPERTY_DEFINITION_SCHEMA *)
TYPE characterized_item = SELECT
  ((* Pruned: geometric_tolerance *)
   dimensional_size,
   item_identified_representation_usage);
END_TYPE;

(* "characterized_material_property" IMPLICIT from SCHEMA material_property_definition_schema *)
TYPE characterized_material_property = SELECT
  ((* Pruned: product_material_composition_relationship *)
   material_property_representation);
END_TYPE;

(* "characterized_product_definition" USE from SCHEMA product_property_definition_schema *)
(* "characterized_product_definition" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PRODUCT_PROPERTY_DEFINITION_SCHEMA *)
TYPE characterized_product_definition = SELECT
  ((* Pruned: product_definition_relationship_relationship *)
   product_definition,
   product_definition_occurrence,
   product_definition_relationship);
END_TYPE;

(* "characterized_property_representation" IMPLICIT from SCHEMA material_property_representation_schema *)
TYPE characterized_property_representation = SELECT
  ((* Pruned: action_property_representation *)
   (* Pruned: dimensional_characteristic_representation *)
   (* Pruned: resource_property_representation *)
   property_definition_representation);
END_TYPE;

(* "chordal_deviation" USE from SCHEMA geometric_model_schema *)
(* "chordal_deviation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
TYPE chordal_deviation = positive_length_measure;
END_TYPE;

(* "compound_item_definition" USE from SCHEMA representation_schema *)
(* "compound_item_definition" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,REPRESENTATION_SCHEMA *)
TYPE compound_item_definition = SELECT
  (list_representation_item,
   set_representation_item);
END_TYPE;

(* "conductance_measure" USE from SCHEMA measure_schema *)
(* "conductance_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE conductance_measure = REAL;
END_TYPE;

(* "configuration_design_item" IMPLICIT from SCHEMA configuration_management_schema *)
TYPE configuration_design_item = SELECT
  (product_definition,
   product_definition_formation,
   product_definition_occurrence);
END_TYPE;

(* "constructive_geometry_representation_or_shape_representation" USE from SCHEMA construction_geometry_mim *)
(* "constructive_geometry_representation_or_shape_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,CONSTRUCTION_GEOMETRY_MIM *)
TYPE constructive_geometry_representation_or_shape_representation = SELECT
  (constructive_geometry_representation,
   shape_representation);
END_TYPE;

(* "context_dependent_measure" USE from SCHEMA measure_schema *)
(* "context_dependent_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE context_dependent_measure = REAL;
END_TYPE;

(* "count_measure" USE from SCHEMA measure_schema *)
(* "count_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE count_measure = NUMBER;
END_TYPE;

(* "csg_primitive" USE from SCHEMA geometric_model_schema *)
(* "csg_primitive" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
TYPE csg_primitive = SELECT
  ((* Pruned: bounded_primitive_2d *)
   block,
   cyclide_segment_solid,
   eccentric_cone,
   ellipsoid,
   faceted_primitive,
   rectangular_pyramid,
   right_angular_wedge,
   right_circular_cone,
   right_circular_cylinder,
   sphere,
   torus);
END_TYPE;

(* "csg_select" USE from SCHEMA geometric_model_schema *)
(* "csg_select" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
TYPE csg_select = SELECT
  (boolean_result,
   csg_primitive);
END_TYPE;

(* "curve_font_or_scaled_curve_font_select" IMPLICIT from SCHEMA presentation_appearance_schema *)
TYPE curve_font_or_scaled_curve_font_select = SELECT
  (curve_style_font_and_scaling,
   curve_style_font_select);
END_TYPE;

(* "curve_on_surface" IMPLICIT from SCHEMA nil *)
TYPE curve_on_surface = SELECT
  (composite_curve_on_surface,
   pcurve,
   surface_curve);
END_TYPE;

(* "curve_or_curve_set" IMPLICIT from SCHEMA presentation_definition_schema *)
TYPE curve_or_curve_set = SELECT
  (curve,
   geometric_curve_set);
END_TYPE;

(* "curve_style_font_select" IMPLICIT from SCHEMA presentation_appearance_schema *)
TYPE curve_style_font_select = SELECT
  (curve_style_font,
   externally_defined_curve_font,
   pre_defined_curve_font);
END_TYPE;

(* "date_and_time_item" USE from SCHEMA date_time_assignment_mim *)
(* "date_and_time_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,DATE_TIME_ASSIGNMENT_MIM *)
TYPE date_and_time_item = SELECT
  (approval_person_organization);
END_TYPE;

(* "date_item" USE from SCHEMA date_time_assignment_mim *)
(* "date_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,DATE_TIME_ASSIGNMENT_MIM *)
TYPE date_item = SELECT
  (approval_person_organization);
END_TYPE;

(* "date_time_select" IMPLICIT from SCHEMA date_time_schema *)
TYPE date_time_select = SELECT
  (date,
   date_and_time,
   local_time);
END_TYPE;

(* "day_in_month_number" USE from SCHEMA date_time_schema *)
(* "day_in_month_number" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_MIM,DATE_TIME_ASSIGNMENT_MIM,DATE_TIME_SCHEMA *)
TYPE day_in_month_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 31};
END_TYPE;

(* "day_in_week_number" IMPLICIT from SCHEMA date_time_schema *)
TYPE day_in_week_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 7};
END_TYPE;

(* "day_in_year_number" IMPLICIT from SCHEMA date_time_schema *)
TYPE day_in_year_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 366};
END_TYPE;

(* "defined_glyph_select" IMPLICIT from SCHEMA presentation_definition_schema *)
TYPE defined_glyph_select = SELECT
  (externally_defined_character_glyph,
   pre_defined_character_glyph);
END_TYPE;

(* "derived_property_select" IMPLICIT from SCHEMA product_property_definition_schema *)
TYPE derived_property_select = SELECT
  ((* Pruned: action_property *)
   (* Pruned: geometric_tolerance *)
   (* Pruned: resource_property *)
   dimensional_location,
   dimensional_size,
   property_definition);
END_TYPE;

(* "des_apll_point_select" USE from SCHEMA draughting_element_schema *)
(* "des_apll_point_select" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_SCHEMA *)
TYPE des_apll_point_select = SELECT
  (apll_point,
   apll_point_with_surface);
END_TYPE;

(* "des_apll_point_symbol" IMPLICIT from SCHEMA draughting_element_schema *)
TYPE des_apll_point_symbol = ENUMERATION OF
  (circle,
   dot,
   internal_pair_forward_arrowhead,
   internal_pair_reverse_arrowhead,
   none,
   positive_arrowhead,
   triangle);
END_TYPE;

(* "description_attribute_select" USE from SCHEMA basic_attribute_schema *)
(* "description_attribute_select" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,BASIC_ATTRIBUTE_SCHEMA *)
TYPE description_attribute_select = SELECT
  (approval_role,
   external_source,
   representation);
END_TYPE;

(* "descriptive_measure" USE from SCHEMA measure_schema *)
(* "descriptive_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE descriptive_measure = STRING;
END_TYPE;

(* "dimension_count" IMPLICIT from SCHEMA geometry_schema *)
TYPE dimension_count = INTEGER;
WHERE
  WR1: SELF > 0;
END_TYPE;

(* "dimension_extent_usage" IMPLICIT from SCHEMA draughting_element_schema *)
TYPE dimension_extent_usage = ENUMERATION OF
  (origin,
   target);
END_TYPE;

(* "document_identifier_assigned_item" USE from SCHEMA specification_document_mim *)
(* "document_identifier_assigned_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SPECIFICATION_DOCUMENT_MIM *)
TYPE document_identifier_assigned_item = SELECT
  (document);
END_TYPE;

(* "document_reference_item" USE from SCHEMA document_assignment_mim *)
(* "document_reference_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,DOCUMENT_ASSIGNMENT_MIM *)
TYPE document_reference_item = SELECT
  (configuration_item,
   product,
   product_definition,
   product_definition_formation,
   representation);
END_TYPE;

(* "dose_equivalent_measure" USE from SCHEMA measure_schema *)
(* "dose_equivalent_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE dose_equivalent_measure = REAL;
END_TYPE;

(* "dotted_express_identifier" USE from SCHEMA mathematical_functions_schema *)
(* "dotted_express_identifier" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE dotted_express_identifier = STRING;
WHERE
  SYNTAX: dotted_identifiers_syntax(SELF);
END_TYPE;

(* "draughting_callout_element" IMPLICIT from SCHEMA draughting_element_schema *)
TYPE draughting_callout_element = SELECT
  (annotation_curve_occurrence,
   annotation_fill_area_occurrence,
   annotation_symbol_occurrence,
   annotation_text_occurrence,
   tessellated_annotation_occurrence);
END_TYPE;

(* "draughting_model_item_association_select" IMPLICIT from SCHEMA draughting_element_schema *)
TYPE draughting_model_item_association_select = SELECT
  (annotation_occurrence,
   draughting_callout);
END_TYPE;

(* "draughting_model_item_definition" IMPLICIT from SCHEMA draughting_element_schema *)
TYPE draughting_model_item_definition = SELECT
  (product_definition_shape,
   property_definition,
   shape_aspect,
   shape_aspect_relationship);
END_TYPE;

(* "draughting_model_item_select" IMPLICIT from SCHEMA draughting_element_schema *)
TYPE draughting_model_item_select = SELECT
  ((* Pruned: camera_model *)
   axis2_placement,
   draughting_callout,
   mapped_item,
   styled_item);
END_TYPE;

(* "edge_or_curve" USE from SCHEMA geometric_model_schema *)
(* "edge_or_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
TYPE edge_or_curve = SELECT
  (curve,
   edge_curve);
END_TYPE;

(* "electric_charge_measure" USE from SCHEMA measure_schema *)
(* "electric_charge_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE electric_charge_measure = REAL;
END_TYPE;

(* "electric_current_measure" USE from SCHEMA measure_schema *)
(* "electric_current_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE electric_current_measure = REAL;
END_TYPE;

(* "electric_potential_measure" USE from SCHEMA measure_schema *)
(* "electric_potential_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE electric_potential_measure = REAL;
END_TYPE;

(* "elementary_function_enumerators" USE from SCHEMA mathematical_functions_schema *)
(* "elementary_function_enumerators" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE elementary_function_enumerators = ENUMERATION OF
  (ef_and,
   ef_or,
   ef_not,
   ef_xor,
   ef_negate_i,
   ef_add_i,
   ef_subtract_i,
   ef_multiply_i,
   ef_divide_i,
   ef_mod_i,
   ef_exponentiate_i,
   ef_eq_i,
   ef_ne_i,
   ef_gt_i,
   ef_lt_i,
   ef_ge_i,
   ef_le_i,
   ef_abs_i,
   ef_max_i,
   ef_min_i,
   ef_if_i,
   ef_negate_r,
   ef_reciprocal_r,
   ef_add_r,
   ef_subtract_r,
   ef_multiply_r,
   ef_divide_r,
   ef_mod_r,
   ef_exponentiate_r,
   ef_exponentiate_ri,
   ef_eq_r,
   ef_ne_r,
   ef_gt_r,
   ef_lt_r,
   ef_ge_r,
   ef_le_r,
   ef_abs_r,
   ef_max_r,
   ef_min_r,
   ef_acos_r,
   ef_asin_r,
   ef_atan2_r,
   ef_cos_r,
   ef_exp_r,
   ef_ln_r,
   ef_log2_r,
   ef_log10_r,
   ef_sin_r,
   ef_sqrt_r,
   ef_tan_r,
   ef_if_r,
   ef_form_c,
   ef_rpart_c,
   ef_ipart_c,
   ef_negate_c,
   ef_reciprocal_c,
   ef_add_c,
   ef_subtract_c,
   ef_multiply_c,
   ef_divide_c,
   ef_exponentiate_c,
   ef_exponentiate_ci,
   ef_eq_c,
   ef_ne_c,
   ef_conjugate_c,
   ef_abs_c,
   ef_arg_c,
   ef_cos_c,
   ef_exp_c,
   ef_ln_c,
   ef_sin_c,
   ef_sqrt_c,
   ef_tan_c,
   ef_if_c,
   ef_subscript_s,
   ef_eq_s,
   ef_ne_s,
   ef_gt_s,
   ef_lt_s,
   ef_ge_s,
   ef_le_s,
   ef_subsequence_s,
   ef_concat_s,
   ef_size_s,
   ef_format,
   ef_value,
   ef_like,
   ef_if_s,
   ef_subscript_b,
   ef_eq_b,
   ef_ne_b,
   ef_gt_b,
   ef_lt_b,
   ef_ge_b,
   ef_le_b,
   ef_subsequence_b,
   ef_concat_b,
   ef_size_b,
   ef_if_b,
   ef_subscript_t,
   ef_eq_t,
   ef_ne_t,
   ef_concat_t,
   ef_size_t,
   ef_entuple,
   ef_detuple,
   ef_insert,
   ef_remove,
   ef_if_t,
   ef_sum_it,
   ef_product_it,
   ef_add_it,
   ef_subtract_it,
   ef_scalar_mult_it,
   ef_dot_prod_it,
   ef_sum_rt,
   ef_product_rt,
   ef_add_rt,
   ef_subtract_rt,
   ef_scalar_mult_rt,
   ef_dot_prod_rt,
   ef_norm_rt,
   ef_sum_ct,
   ef_product_ct,
   ef_add_ct,
   ef_subtract_ct,
   ef_scalar_mult_ct,
   ef_dot_prod_ct,
   ef_norm_ct,
   ef_if,
   ef_ensemble,
   ef_member_of);
END_TYPE;

(* "elementary_space_enumerators" USE from SCHEMA mathematical_functions_schema *)
(* "elementary_space_enumerators" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE elementary_space_enumerators = ENUMERATION OF
  (es_numbers,
   es_complex_numbers,
   es_reals,
   es_integers,
   es_logicals,
   es_booleans,
   es_strings,
   es_binarys,
   es_maths_spaces,
   es_maths_functions,
   es_generics);
END_TYPE;

(* "energy_measure" USE from SCHEMA measure_schema *)
(* "energy_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE energy_measure = REAL;
END_TYPE;

(* "express_identifier" USE from SCHEMA mathematical_functions_schema *)
(* "express_identifier" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE express_identifier = dotted_express_identifier;
WHERE
  SYNTAX: dot_count(SELF) = 0;
END_TYPE;

(* "extension_options" USE from SCHEMA mathematical_functions_schema *)
(* "extension_options" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE extension_options = ENUMERATION OF
  (eo_none,
   eo_cont,
   eo_cont_right,
   eo_cont_left);
END_TYPE;

(* "external_identification_item" USE from SCHEMA external_item_identification_assignment_mim *)
(* "external_identification_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTION_GEOMETRY_MIM,EXTERNAL_ITEM_IDENTIFICATION_ASSIGNMENT_MIM *)
TYPE external_identification_item = SELECT
  (applied_external_identification_assignment,
   document_file,
   external_source,
   externally_defined_class,
   externally_defined_general_property,
   generic_product_definition_reference,
   product_definition,
   trimmed_curve);
END_TYPE;

(* "face_or_surface" USE from SCHEMA geometric_model_schema *)
(* "face_or_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
TYPE face_or_surface = SELECT
  (face_surface,
   surface);
END_TYPE;

(* "font_select" USE from SCHEMA presentation_resource_schema *)
(* "font_select" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_RESOURCE_SCHEMA *)
TYPE font_select = SELECT
  ((* Pruned: text_font *)
   externally_defined_text_font,
   pre_defined_text_font);
END_TYPE;

(* "force_measure" USE from SCHEMA measure_schema *)
(* "force_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE force_measure = REAL;
END_TYPE;

(* "founded_item_select" IMPLICIT from SCHEMA nil *)
TYPE founded_item_select = SELECT
  (founded_item,
   representation_item);
END_TYPE;

(* "frequency_measure" USE from SCHEMA measure_schema *)
(* "frequency_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE frequency_measure = REAL;
END_TYPE;

(* "geometric_item_specific_usage_select" USE from SCHEMA shape_property_assignment_mim *)
(* "geometric_item_specific_usage_select" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM *)
TYPE geometric_item_specific_usage_select = SELECT
  (shape_aspect,
   shape_aspect_relationship);
END_TYPE;

(* "geometric_model_item" USE from SCHEMA shape_property_assignment_mim *)
(* "geometric_model_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM *)
TYPE geometric_model_item = SELECT
  (geometric_representation_item);
END_TYPE;

(* "geometric_set_select" IMPLICIT from SCHEMA geometric_model_schema *)
TYPE geometric_set_select = SELECT
  (curve,
   point,
   surface);
END_TYPE;

(* "groupable_item" USE from SCHEMA group_mim *)
(* "groupable_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,GROUP_MIM *)
TYPE groupable_item = SELECT
  (package_product_concept_feature,
   product_concept_feature);
WHERE
  WR1: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GROUP' IN TYPEOF(SELF));
END_TYPE;

(* "hour_in_day" IMPLICIT from SCHEMA date_time_schema *)
TYPE hour_in_day = INTEGER;
WHERE
  WR1: {0 <= SELF < 24};
END_TYPE;

(* "id_attribute_select" USE from SCHEMA basic_attribute_schema *)
(* "id_attribute_select" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,BASIC_ATTRIBUTE_SCHEMA *)
TYPE id_attribute_select = SELECT
  (representation);
END_TYPE;

(* "identification_item" USE from SCHEMA identification_assignment_mim *)
(* "identification_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,IDENTIFICATION_ASSIGNMENT_MIM *)
TYPE identification_item = SELECT
  (document_file,
   product_class,
   product_concept_feature,
   representation,
   shape_representation);
END_TYPE;

(* "identifier" USE from SCHEMA support_resource_schema *)
(* "identifier" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,SUPPORT_RESOURCE_SCHEMA *)
TYPE identifier = STRING;
END_TYPE;

(* "illuminance_measure" USE from SCHEMA measure_schema *)
(* "illuminance_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE illuminance_measure = REAL;
END_TYPE;

(* "inductance_measure" USE from SCHEMA measure_schema *)
(* "inductance_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE inductance_measure = REAL;
END_TYPE;

(* "input_selector" USE from SCHEMA mathematical_functions_schema *)
(* "input_selector" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE input_selector = positive_integer;
END_TYPE;

(* "invisible_item" IMPLICIT from SCHEMA presentation_appearance_schema *)
TYPE invisible_item = SELECT
  ((* Pruned: presentation_layer_assignment *)
   representation,
   styled_item);
END_TYPE;

(* "item_identified_representation_usage_definition" IMPLICIT from SCHEMA product_property_representation_schema *)
TYPE item_identified_representation_usage_definition = SELECT
  (represented_definition);
END_TYPE;

(* "item_identified_representation_usage_select" IMPLICIT from SCHEMA product_property_representation_schema *)
TYPE item_identified_representation_usage_select = SELECT
  (list_representation_item,
   representation_item,
   set_representation_item);
END_TYPE;

(* "knot_type" IMPLICIT from SCHEMA geometry_schema *)
TYPE knot_type = ENUMERATION OF
  (uniform_knots,
   quasi_uniform_knots,
   piecewise_bezier_knots,
   unspecified);
END_TYPE;

(* "label" USE from SCHEMA support_resource_schema *)
(* "label" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,SUPPORT_RESOURCE_SCHEMA *)
TYPE label = STRING;
END_TYPE;

(* "length_measure" USE from SCHEMA measure_schema *)
(* "length_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE length_measure = REAL;
END_TYPE;

(* "length_to_height_ratio" USE from SCHEMA geometric_model_schema *)
(* "length_to_height_ratio" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
TYPE length_to_height_ratio = ratio_measure;
END_TYPE;

(* "list_of_reversible_topology_item" IMPLICIT from SCHEMA nil *)
TYPE list_of_reversible_topology_item = LIST [0 : ?] OF reversible_topology_item;
END_TYPE;

(* "list_representation_item" USE from SCHEMA representation_schema *)
(* "list_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,REPRESENTATION_SCHEMA *)
TYPE list_representation_item = LIST [1 : ?] OF representation_item;
END_TYPE;

(* "lower_upper" USE from SCHEMA mathematical_functions_schema *)
(* "lower_upper" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE lower_upper = ENUMERATION OF
  (lower,
   upper);
END_TYPE;

(* "luminous_flux_measure" USE from SCHEMA measure_schema *)
(* "luminous_flux_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE luminous_flux_measure = REAL;
END_TYPE;

(* "luminous_intensity_measure" USE from SCHEMA measure_schema *)
(* "luminous_intensity_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE luminous_intensity_measure = REAL;
END_TYPE;

(* "magnetic_flux_density_measure" USE from SCHEMA measure_schema *)
(* "magnetic_flux_density_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE magnetic_flux_density_measure = REAL;
END_TYPE;

(* "magnetic_flux_measure" USE from SCHEMA measure_schema *)
(* "magnetic_flux_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE magnetic_flux_measure = REAL;
END_TYPE;

(* "marker_select" USE from SCHEMA presentation_appearance_schema *)
(* "marker_select" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
TYPE marker_select = SELECT
  (marker_type,
   pre_defined_marker);
END_TYPE;

(* "marker_type" USE from SCHEMA presentation_appearance_schema *)
(* "marker_type" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
TYPE marker_type = ENUMERATION OF
  (dot,
   x,
   plus,
   asterisk,
   ring,
   square,
   triangle);
END_TYPE;

(* "mass_measure" USE from SCHEMA measure_schema *)
(* "mass_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE mass_measure = REAL;
END_TYPE;

(* "maths_atom" USE from SCHEMA mathematical_functions_schema *)
(* "maths_atom" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE maths_atom = SELECT
  (maths_enum_atom,
   maths_simple_atom);
END_TYPE;

(* "maths_binary" USE from SCHEMA mathematical_functions_schema *)
(* "maths_binary" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE maths_binary = BINARY;
END_TYPE;

(* "maths_boolean" USE from SCHEMA mathematical_functions_schema *)
(* "maths_boolean" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE maths_boolean = BOOLEAN;
END_TYPE;

(* "maths_enum_atom" USE from SCHEMA mathematical_functions_schema *)
(* "maths_enum_atom" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE maths_enum_atom = SELECT
  (elementary_function_enumerators,
   elementary_space_enumerators,
   extension_options,
   lower_upper,
   open_closed,
   ordering_type,
   repackage_options,
   space_constraint_type,
   symmetry_type);
END_TYPE;

(* "maths_expression" USE from SCHEMA mathematical_functions_schema *)
(* "maths_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE maths_expression = SELECT
  (atom_based_value,
   generic_expression,
   maths_tuple);
END_TYPE;

(* "maths_function_select" USE from SCHEMA mathematical_functions_schema *)
(* "maths_function_select" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE maths_function_select = SELECT
  (elementary_function_enumerators,
   maths_function);
END_TYPE;

(* "maths_integer" USE from SCHEMA mathematical_functions_schema *)
(* "maths_integer" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE maths_integer = INTEGER;
END_TYPE;

(* "maths_logical" USE from SCHEMA mathematical_functions_schema *)
(* "maths_logical" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE maths_logical = LOGICAL;
END_TYPE;

(* "maths_number" USE from SCHEMA mathematical_functions_schema *)
(* "maths_number" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE maths_number = NUMBER;
END_TYPE;

(* "maths_real" USE from SCHEMA mathematical_functions_schema *)
(* "maths_real" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE maths_real = REAL;
END_TYPE;

(* "maths_simple_atom" USE from SCHEMA mathematical_functions_schema *)
(* "maths_simple_atom" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE maths_simple_atom = SELECT
  (maths_binary,
   maths_boolean,
   maths_integer,
   maths_logical,
   maths_number,
   maths_real,
   maths_string);
END_TYPE;

(* "maths_space_or_function" USE from SCHEMA mathematical_functions_schema *)
(* "maths_space_or_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE maths_space_or_function = SELECT
  (maths_function,
   maths_space);
END_TYPE;

(* "maths_string" USE from SCHEMA mathematical_functions_schema *)
(* "maths_string" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE maths_string = STRING;
END_TYPE;

(* "maths_tuple" USE from SCHEMA mathematical_functions_schema *)
(* "maths_tuple" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE maths_tuple = LIST [0 : ?] OF maths_value;
END_TYPE;

(* "maths_value" USE from SCHEMA mathematical_functions_schema *)
(* "maths_value" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE maths_value = SELECT
  (atom_based_value,
   generic_expression,
   maths_tuple);
WHERE
  CONSTANCY: NOT ('GENERIC_EXPRESSION' IN stripped_typeof(SELF)) OR expression_is_constant(SELF);
END_TYPE;

(* "maximum_edge_length" USE from SCHEMA geometric_model_schema *)
(* "maximum_edge_length" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
TYPE maximum_edge_length = positive_length_measure;
END_TYPE;

(* "measure_value" USE from SCHEMA measure_schema *)
(* "measure_value" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE measure_value = SELECT
  (absorbed_dose_measure,
   acceleration_measure,
   amount_of_substance_measure,
   area_measure,
   capacitance_measure,
   celsius_temperature_measure,
   conductance_measure,
   context_dependent_measure,
   count_measure,
   descriptive_measure,
   dose_equivalent_measure,
   electric_charge_measure,
   electric_current_measure,
   electric_potential_measure,
   energy_measure,
   force_measure,
   frequency_measure,
   illuminance_measure,
   inductance_measure,
   length_measure,
   luminous_flux_measure,
   luminous_intensity_measure,
   magnetic_flux_density_measure,
   magnetic_flux_measure,
   mass_measure,
   non_negative_length_measure,
   numeric_measure,
   parameter_value,
   plane_angle_measure,
   positive_length_measure,
   positive_plane_angle_measure,
   positive_ratio_measure,
   power_measure,
   pressure_measure,
   radioactivity_measure,
   ratio_measure,
   resistance_measure,
   solid_angle_measure,
   thermodynamic_temperature_measure,
   time_measure,
   velocity_measure,
   volume_measure);
END_TYPE;

(* "message" USE from SCHEMA external_reference_schema *)
(* "message" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,EXTERNAL_REFERENCE_SCHEMA *)
TYPE message = STRING;
END_TYPE;

(* "minute_in_hour" IMPLICIT from SCHEMA date_time_schema *)
TYPE minute_in_hour = INTEGER;
WHERE
  WR1: {0 <= SELF <= 59};
END_TYPE;

(* "month_in_year_number" IMPLICIT from SCHEMA date_time_schema *)
TYPE month_in_year_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 12};
END_TYPE;

(* "name_attribute_select" USE from SCHEMA basic_attribute_schema *)
(* "name_attribute_select" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,BASIC_ATTRIBUTE_SCHEMA *)
TYPE name_attribute_select = SELECT
  (derived_unit);
END_TYPE;

(* "name_item" USE from SCHEMA name_assignment_mim *)
(* "name_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,PLIB_CLASS_REFERENCE_MIM,NAME_ASSIGNMENT_MIM *)
TYPE name_item = SELECT
  (external_class_library);
END_TYPE;

(* "non_negative_length_measure" USE from SCHEMA measure_schema *)
(* "non_negative_length_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE non_negative_length_measure = length_measure;
WHERE
  WR1: SELF >= 0.0;
END_TYPE;

(* "nonnegative_integer" USE from SCHEMA mathematical_functions_schema *)
(* "nonnegative_integer" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE nonnegative_integer = INTEGER;
WHERE
  NONNEGATIVITY: SELF >= 0;
END_TYPE;

(* "numeric_measure" USE from SCHEMA measure_schema *)
(* "numeric_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE numeric_measure = NUMBER;
END_TYPE;

(* "one_or_two" USE from SCHEMA mathematical_functions_schema *)
(* "one_or_two" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE one_or_two = positive_integer;
WHERE
  IN_RANGE: (SELF = 1) OR (SELF = 2);
END_TYPE;

(* "open_closed" USE from SCHEMA mathematical_functions_schema *)
(* "open_closed" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE open_closed = ENUMERATION OF
  (open,
   closed);
END_TYPE;

(* "ordering_type" USE from SCHEMA mathematical_functions_schema *)
(* "ordering_type" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE ordering_type = ENUMERATION OF
  (by_rows,
   by_columns);
END_TYPE;

(* "organization_item" USE from SCHEMA person_organization_assignment_mim *)
(* "organization_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,PERSON_ORGANIZATION_ASSIGNMENT_MIM *)
TYPE organization_item = SELECT
  (class);
END_TYPE;

(* "parameter_value" USE from SCHEMA measure_schema *)
(* "parameter_value" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE parameter_value = REAL;
END_TYPE;

(* "path_or_composite_curve" USE from SCHEMA geometric_model_schema *)
(* "path_or_composite_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
TYPE path_or_composite_curve = SELECT
  (composite_curve,
   path);
END_TYPE;

(* "pcurve_or_surface" IMPLICIT from SCHEMA geometry_schema *)
TYPE pcurve_or_surface = SELECT
  (pcurve,
   surface);
END_TYPE;

(* "person_organization_select" IMPLICIT from SCHEMA person_organization_schema *)
TYPE person_organization_select = SELECT
  (organization,
   person,
   person_and_organization);
END_TYPE;

(* "plane_angle_measure" USE from SCHEMA measure_schema *)
(* "plane_angle_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE plane_angle_measure = REAL;
END_TYPE;

(* "plane_or_planar_box" IMPLICIT from SCHEMA draughting_element_schema *)
TYPE plane_or_planar_box = SELECT
  (planar_box,
   plane);
END_TYPE;

(* "point_and_vector_member" USE from SCHEMA ply_orientation_specification_mim *)
(* "point_and_vector_member" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PLY_ORIENTATION_SPECIFICATION_MIM *)
TYPE point_and_vector_member = SELECT
  (direction,
   point);
END_TYPE;

(* "point_and_vector_members" USE from SCHEMA ply_orientation_specification_mim *)
(* "point_and_vector_members" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PLY_ORIENTATION_SPECIFICATION_MIM *)
TYPE point_and_vector_members = LIST [2 : 3] OF point_and_vector_member;
END_TYPE;

(* "point_array_members" USE from SCHEMA ply_orientation_specification_mim *)
(* "point_array_members" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PLY_ORIENTATION_SPECIFICATION_MIM *)
TYPE point_array_members = LIST [1 : ?] OF point_and_vector;
END_TYPE;

(* "positive_integer" USE from SCHEMA mathematical_functions_schema *)
(* "positive_integer" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE positive_integer = nonnegative_integer;
WHERE
  POSITIVITY: SELF > 0;
END_TYPE;

(* "positive_length_measure" USE from SCHEMA measure_schema *)
(* "positive_length_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE positive_length_measure = non_negative_length_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

(* "positive_plane_angle_measure" USE from SCHEMA measure_schema *)
(* "positive_plane_angle_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

(* "positive_ratio_measure" USE from SCHEMA measure_schema *)
(* "positive_ratio_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE positive_ratio_measure = ratio_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

(* "power_measure" USE from SCHEMA measure_schema *)
(* "power_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE power_measure = REAL;
END_TYPE;

(* "preferred_surface_curve_representation" IMPLICIT from SCHEMA geometry_schema *)
TYPE preferred_surface_curve_representation = ENUMERATION OF
  (curve_3d,
   pcurve_s1,
   pcurve_s2);
END_TYPE;

(* "presentable_text" IMPLICIT from SCHEMA presentation_definition_schema *)
TYPE presentable_text = STRING;
WHERE
  WR1: control_characters_free(SELF);
END_TYPE;

(* "presentation_style_select" IMPLICIT from SCHEMA presentation_appearance_schema *)
TYPE presentation_style_select = SELECT
  ((* Pruned: approximation_tolerance *)
   (* Pruned: fill_area_style *)
   (* Pruned: null_style *)
   (* Pruned: pre_defined_presentation_style *)
   (* Pruned: symbol_style *)
   (* Pruned: texture_style_tessellation_specification *)
   curve_style,
   externally_defined_style,
   point_style,
   surface_style_usage,
   text_style);
END_TYPE;

(* "pressure_measure" USE from SCHEMA measure_schema *)
(* "pressure_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE pressure_measure = REAL;
END_TYPE;

(* "product_definition_occurrence_or_reference" IMPLICIT from SCHEMA product_structure_schema *)
TYPE product_definition_occurrence_or_reference = SELECT
  ((* Pruned: product_definition_occurrence_reference *)
   product_definition_occurrence);
END_TYPE;

(* "product_definition_or_reference" IMPLICIT from SCHEMA product_definition_schema *)
TYPE product_definition_or_reference = SELECT
  (generic_product_definition_reference,
   product_definition,
   product_definition_occurrence);
END_TYPE;

(* "product_definition_or_reference_or_occurrence" Generated by Shtolo to Replace SELECT *)
(* Original: TYPE product_definition_or_reference_or_occurrence = SELECT *)
TYPE product_definition_or_reference_or_occurrence = product_definition_or_reference;
END_TYPE;

(* "product_or_formation_or_definition" IMPLICIT from SCHEMA document_schema *)
TYPE product_or_formation_or_definition = SELECT
  (product,
   product_definition,
   product_definition_formation);
END_TYPE;

(* "product_space" USE from SCHEMA mathematical_functions_schema *)
(* "product_space" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE product_space = SELECT
  (listed_product_space,
   uniform_product_space);
END_TYPE;

(* "radioactivity_measure" USE from SCHEMA measure_schema *)
(* "radioactivity_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE radioactivity_measure = REAL;
END_TYPE;

(* "ratio_measure" USE from SCHEMA measure_schema *)
(* "ratio_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE ratio_measure = REAL;
END_TYPE;

(* "real_interval" USE from SCHEMA mathematical_functions_schema *)
(* "real_interval" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE real_interval = SELECT
  (elementary_space,
   finite_real_interval,
   real_interval_from_min,
   real_interval_to_max);
WHERE
  WR1: NOT ('ELEMENTARY_SPACE' IN stripped_typeof(SELF)) OR (SELF\elementary_space.space_id = es_reals);
END_TYPE;

(* "repackage_options" USE from SCHEMA mathematical_functions_schema *)
(* "repackage_options" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE repackage_options = ENUMERATION OF
  (ro_nochange,
   ro_wrap_as_tuple,
   ro_unwrap_tuple);
END_TYPE;

(* "representation_or_representation_reference" IMPLICIT from SCHEMA representation_schema *)
TYPE representation_or_representation_reference = SELECT
  (representation,
   representation_reference);
END_TYPE;

(* "represented_definition" IMPLICIT from SCHEMA product_property_representation_schema *)
TYPE represented_definition = SELECT
  (general_property,
   property_definition,
   property_definition_relationship,
   shape_aspect,
   shape_aspect_relationship);
END_TYPE;

(* "resistance_measure" USE from SCHEMA measure_schema *)
(* "resistance_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE resistance_measure = REAL;
END_TYPE;

(* "reversible_topology" IMPLICIT from SCHEMA nil *)
TYPE reversible_topology = SELECT
  (list_of_reversible_topology_item,
   reversible_topology_item,
   set_of_reversible_topology_item);
END_TYPE;

(* "reversible_topology_item" IMPLICIT from SCHEMA topology_schema *)
TYPE reversible_topology_item = SELECT
  (closed_shell,
   edge,
   face,
   face_bound,
   open_shell,
   path);
END_TYPE;

(* "role_select" USE from SCHEMA basic_attribute_schema *)
(* "role_select" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,BASIC_ATTRIBUTE_SCHEMA *)
TYPE role_select = SELECT
  (approval_date_time);
END_TYPE;

(* "second_in_minute" IMPLICIT from SCHEMA date_time_schema *)
TYPE second_in_minute = REAL;
WHERE
  WR1: {0 <= SELF < 60.0};
END_TYPE;

(* "set_of_reversible_topology_item" IMPLICIT from SCHEMA nil *)
TYPE set_of_reversible_topology_item = SET [0 : ?] OF reversible_topology_item;
END_TYPE;

(* "set_representation_item" USE from SCHEMA representation_schema *)
(* "set_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,REPRESENTATION_SCHEMA *)
TYPE set_representation_item = SET [1 : ?] OF representation_item;
END_TYPE;

(* "shape_model" USE from SCHEMA shape_property_assignment_mim *)
(* "shape_model" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM *)
TYPE shape_model = SELECT
  (shape_representation);
END_TYPE;

(* "shell" IMPLICIT from SCHEMA topology_schema *)
TYPE shell = SELECT
  (closed_shell,
   open_shell,
   vertex_shell,
   wire_shell);
END_TYPE;

(* "si_prefix" USE from SCHEMA measure_schema *)
(* "si_prefix" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE si_prefix = ENUMERATION OF
  (exa,
   peta,
   tera,
   giga,
   mega,
   kilo,
   hecto,
   deca,
   deci,
   centi,
   milli,
   micro,
   nano,
   pico,
   femto,
   atto);
END_TYPE;

(* "si_unit_name" USE from SCHEMA measure_schema *)
(* "si_unit_name" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE si_unit_name = ENUMERATION OF
  (metre,
   gram,
   second,
   ampere,
   kelvin,
   mole,
   candela,
   radian,
   steradian,
   hertz,
   newton,
   pascal,
   joule,
   watt,
   coulomb,
   volt,
   farad,
   ohm,
   siemens,
   weber,
   tesla,
   henry,
   degree_celsius,
   lumen,
   lux,
   becquerel,
   gray,
   sievert);
END_TYPE;

(* "size_select" IMPLICIT from SCHEMA presentation_appearance_schema *)
TYPE size_select = SELECT
  ((* Pruned: pre_defined_size *)
   descriptive_measure,
   measure_with_unit,
   positive_length_measure);
END_TYPE;

(* "solid_angle_measure" USE from SCHEMA measure_schema *)
(* "solid_angle_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE solid_angle_measure = REAL;
END_TYPE;

(* "source_item" USE from SCHEMA external_reference_schema *)
(* "source_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,EXTERNAL_REFERENCE_SCHEMA *)
TYPE source_item = SELECT
  (identifier,
   message);
END_TYPE;

(* "space_constraint_type" USE from SCHEMA mathematical_functions_schema *)
(* "space_constraint_type" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE space_constraint_type = ENUMERATION OF
  (sc_equal,
   sc_subspace,
   sc_member);
END_TYPE;

(* "string_representation_item_select" USE from SCHEMA tagged_text_representation_mim *)
(* "string_representation_item_select" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,TAGGED_TEXT_REPRESENTATION_MIM *)
TYPE string_representation_item_select = SELECT
  (descriptive_representation_item,
   included_text_block,
   structured_text_composition);
END_TYPE;

(* "style_context_select" USE from SCHEMA presentation_appearance_schema *)
(* "style_context_select" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
TYPE style_context_select = SELECT
  ((* Pruned: context_dependent_shape_representation *)
   (* Pruned: presentation_layer_assignment *)
   (* Pruned: presentation_set *)
   group,
   representation,
   representation_item,
   representation_relationship);
END_TYPE;

(* "styled_item_target" IMPLICIT from SCHEMA presentation_appearance_schema *)
TYPE styled_item_target = SELECT
  (geometric_representation_item,
   mapped_item,
   representation_or_representation_reference,
   topological_representation_item);
END_TYPE;

(* "surface_side" IMPLICIT from SCHEMA presentation_appearance_schema *)
TYPE surface_side = ENUMERATION OF
  (positive,
   negative,
   both);
END_TYPE;

(* "symmetry_type" USE from SCHEMA mathematical_functions_schema *)
(* "symmetry_type" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE symmetry_type = ENUMERATION OF
  (identity,
   skew,
   hermitian,
   skew_hermitian);
END_TYPE;

(* "terminator" USE from SCHEMA curve_appearance_mim *)
(* "terminator" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,CURVE_APPEARANCE_MIM *)
TYPE terminator = SELECT
  (externally_defined_terminator_symbol,
   pre_defined_terminator_symbol,
   user_defined_terminator_symbol);
END_TYPE;

(* "tessellated_edge_or_vertex" USE from SCHEMA geometric_model_schema *)
(* "tessellated_edge_or_vertex" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
TYPE tessellated_edge_or_vertex = SELECT
  (tessellated_edge,
   tessellated_vertex);
END_TYPE;

(* "tessellated_facet_long_short_edge_ratio" USE from SCHEMA geometric_model_schema *)
(* "tessellated_facet_long_short_edge_ratio" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
TYPE tessellated_facet_long_short_edge_ratio = ratio_measure;
END_TYPE;

(* "tessellation_accuracy_parameter_item" USE from SCHEMA geometric_model_schema *)
(* "tessellation_accuracy_parameter_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
TYPE tessellation_accuracy_parameter_item = SELECT
  (angular_deviation,
   chordal_deviation,
   length_to_height_ratio,
   maximum_edge_length,
   tessellated_facet_long_short_edge_ratio);
END_TYPE;

(* "text" USE from SCHEMA support_resource_schema *)
(* "text" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,SUPPORT_RESOURCE_SCHEMA *)
TYPE text = STRING;
END_TYPE;

(* "text_alignment" IMPLICIT from SCHEMA presentation_definition_schema *)
TYPE text_alignment = label;
END_TYPE;

(* "text_delineation" IMPLICIT from SCHEMA presentation_definition_schema *)
TYPE text_delineation = label;
END_TYPE;

(* "text_or_character" IMPLICIT from SCHEMA presentation_definition_schema *)
TYPE text_or_character = SELECT
  ((* Pruned: annotation_text_character *)
   annotation_text,
   composite_text,
   defined_character_glyph,
   text_literal);
END_TYPE;

(* "text_path" IMPLICIT from SCHEMA presentation_definition_schema *)
TYPE text_path = ENUMERATION OF
  (left,
   right,
   up,
   down);
END_TYPE;

(* "text_string_representation_item" IMPLICIT from SCHEMA presentation_definition_schema *)
TYPE text_string_representation_item = SELECT
  ((* Pruned: annotation_text_character *)
   annotation_text,
   axis2_placement,
   composite_text,
   defined_character_glyph,
   text_literal);
END_TYPE;

(* "thermodynamic_temperature_measure" USE from SCHEMA measure_schema *)
(* "thermodynamic_temperature_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE thermodynamic_temperature_measure = REAL;
END_TYPE;

(* "time_measure" USE from SCHEMA measure_schema *)
(* "time_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE time_measure = REAL;
END_TYPE;

(* "transition_code" IMPLICIT from SCHEMA geometry_schema *)
TYPE transition_code = ENUMERATION OF
  (discontinuous,
   continuous,
   cont_same_gradient,
   cont_same_gradient_same_curvature);
END_TYPE;

(* "trimming_preference" IMPLICIT from SCHEMA geometry_schema *)
TYPE trimming_preference = ENUMERATION OF
  (cartesian,
   parameter,
   unspecified);
END_TYPE;

(* "trimming_select" IMPLICIT from SCHEMA geometry_schema *)
TYPE trimming_select = SELECT
  (cartesian_point,
   parameter_value);
END_TYPE;

(* "tuple_space" USE from SCHEMA mathematical_functions_schema *)
(* "tuple_space" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE tuple_space = SELECT
  (extended_tuple_space,
   product_space);
END_TYPE;

(* "unit" USE from SCHEMA measure_schema *)
(* "unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE unit = SELECT
  (derived_unit,
   named_unit);
END_TYPE;

(* "value_format_type" IMPLICIT from SCHEMA qualified_measure_schema *)
TYPE value_format_type = identifier;
WHERE
  WR1: LENGTH(SELF) <= 80;
END_TYPE;

(* "value_qualifier" IMPLICIT from SCHEMA qualified_measure_schema *)
TYPE value_qualifier = SELECT
  (maths_value_precision_qualifier,
   precision_qualifier,
   type_qualifier,
   uncertainty_qualifier,
   value_format_type_qualifier);
END_TYPE;

(* "vector_or_direction" IMPLICIT from SCHEMA nil *)
TYPE vector_or_direction = SELECT
  (direction,
   vector);
END_TYPE;

(* "velocity_measure" USE from SCHEMA measure_schema *)
(* "velocity_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE velocity_measure = REAL;
END_TYPE;

(* "volume_measure" USE from SCHEMA measure_schema *)
(* "volume_measure" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
TYPE volume_measure = REAL;
END_TYPE;

(* "week_in_year_number" IMPLICIT from SCHEMA date_time_schema *)
TYPE week_in_year_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 53};
END_TYPE;

(* "year_number" IMPLICIT from SCHEMA date_time_schema *)
TYPE year_number = INTEGER;
WHERE
  WR1: (SELF > 1581);
END_TYPE;

(* "zero_or_one" USE from SCHEMA mathematical_functions_schema *)
(* "zero_or_one" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
TYPE zero_or_one = nonnegative_integer;
WHERE
  IN_RANGE: (SELF = 0) OR (SELF = 1);
END_TYPE;

(* "abs_function" USE from SCHEMA iso13584_expressions_schema *)
(* "abs_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY abs_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

(* "absorbed_dose_measure_with_unit" USE from SCHEMA measure_schema *)
(* "absorbed_dose_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY absorbed_dose_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ABSORBED_DOSE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "absorbed_dose_unit" USE from SCHEMA measure_schema *)
(* "absorbed_dose_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY absorbed_dose_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.gray);
END_ENTITY;

(* "abstracted_expression_function" USE from SCHEMA mathematical_functions_schema *)
(* "abstracted_expression_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY abstracted_expression_function
  SUBTYPE OF (maths_function, quantifier_expression);
DERIVE
  SELF\quantifier_expression.variables                            : LIST [1 : ?] OF UNIQUE generic_variable := remove_first(SELF\multiple_arity_generic_expression.operands);
  expr                                 : generic_expression                      := SELF\multiple_arity_generic_expression.operands[1];
WHERE
  WR1: SIZEOF(QUERY(operand <* SELF\multiple_arity_generic_expression.operands | NOT (has_values_space(operand)))) = 0;
END_ENTITY;

(* "acceleration_measure_with_unit" USE from SCHEMA measure_schema *)
(* "acceleration_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY acceleration_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ACCELERATION_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "acceleration_unit" USE from SCHEMA measure_schema *)
(* "acceleration_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY acceleration_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensional_exponents(1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0);
END_ENTITY;

(* "acos_function" USE from SCHEMA iso13584_expressions_schema *)
(* "acos_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY acos_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

(* "action" USE from SCHEMA action_schema *)
(* "action" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,EXTERNAL_MODEL_MIM,FILE_IDENTIFICATION_MIM,ACTION_SCHEMA *)
ENTITY action;
  name          : label;
  description   : OPTIONAL text;
  chosen_method : action_method;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

(* "action_assignment" USE from SCHEMA management_resources_schema *)
(* "action_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,EXTERNAL_MODEL_MIM,FILE_IDENTIFICATION_MIM,MANAGEMENT_RESOURCES_SCHEMA *)
ENTITY action_assignment
  ABSTRACT SUPERTYPE;
  assigned_action : action;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

(* "action_method" USE from SCHEMA action_schema *)
(* "action_method" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,EXTERNAL_MODEL_MIM,FILE_IDENTIFICATION_MIM,ACTIVITY_MIM,ACTION_SCHEMA *)
ENTITY action_method;
  name        : label;
  description : OPTIONAL text;
  consequence : text;
  purpose     : text;
END_ENTITY;

(* "action_relationship" USE from SCHEMA action_schema *)
(* "action_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,EXTERNAL_MODEL_MIM,FILE_IDENTIFICATION_MIM,ACTION_SCHEMA *)
ENTITY action_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_action : action;
  related_action  : action;
END_ENTITY;

(* "action_status" USE from SCHEMA action_schema *)
(* "action_status" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,EXTERNAL_MODEL_MIM,FILE_IDENTIFICATION_MIM,ACTION_SCHEMA *)
ENTITY action_status;
  status          : label;
  assigned_action : executed_action;
END_ENTITY;

(* "address" USE from SCHEMA person_organization_schema *)
(* "address" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,PRODUCT_VIEW_DEFINITION_MIM,PERSON_ORGANIZATION_SCHEMA *)
ENTITY address;
  internal_location       : OPTIONAL label;
  street_number           : OPTIONAL label;
  street                  : OPTIONAL label;
  postal_box              : OPTIONAL label;
  town                    : OPTIONAL label;
  region                  : OPTIONAL label;
  postal_code             : OPTIONAL label;
  country                 : OPTIONAL label;
  facsimile_number        : OPTIONAL label;
  telephone_number        : OPTIONAL label;
  electronic_mail_address : OPTIONAL label;
  telex_number            : OPTIONAL label;
DERIVE
  name : label      := get_name_value(SELF);
  url  : identifier := get_id_value(SELF);
WHERE
  WR1: EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR
       EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR
       EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number);
END_ENTITY;

(* "advanced_brep_shape_representation" USE from SCHEMA geometric_model_schema *)
(* "advanced_brep_shape_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY advanced_brep_shape_representation
  SUBTYPE OF (shape_representation);
  SELF\representation.items : SET [1 : ?] OF advanced_brep_shape_representation_items_select;
WHERE
  WR1: SIZEOF(QUERY(it
                    <* SELF.items
                    | (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MANIFOLD_SOLID_BREP',
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM'] *
                              TYPEOF(it)) =
                       1))) >
       0;
  WR2: SIZEOF(QUERY(msb
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MANIFOLD_SOLID_BREP' IN
                                TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(csh
                                        <* msb_shells(msb)
                                        | NOT (SIZEOF(QUERY(fcs
                                                            <* csh\connected_face_set.cfs_faces
                                                            | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ADVANCED_FACE' IN
                                                                   TYPEOF(fcs)))) =
                                               0))) =
                           0))) =
       0;
  WR3: SIZEOF(QUERY(msb
                    <* QUERY(it
                             <* items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MANIFOLD_SOLID_BREP' IN
                                TYPEOF(it)))
                    | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ORIENTED_CLOSED_SHELL' IN
                       TYPEOF(msb\manifold_solid_brep.outer)))) =
       0;
  WR4: SIZEOF(QUERY(brv
                    <* QUERY(it
                             <* items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BREP_WITH_VOIDS' IN TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(csh <* brv\brep_with_voids.voids | csh\oriented_closed_shell.orientation)) =
                           0))) =
       0;
  WR5: SIZEOF(QUERY(mi
                    <* QUERY(it
                             <* items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)))
                    | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ADVANCED_BREP_SHAPE_REPRESENTATION' IN
                           TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) =
       0;
END_ENTITY;

(* "advanced_face" USE from SCHEMA topology_schema *)
(* "advanced_face" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGY_SCHEMA *)
ENTITY advanced_face
  SUBTYPE OF (face_surface);
  SELF\face_surface.face_geometry : advanced_face_geometry_select;
WHERE
  WR1: SIZEOF(QUERY(elp_fbnds
                    <* QUERY(bnds
                             <* bounds
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)))
                    | NOT (SIZEOF(QUERY(oe
                                        <* elp_fbnds.bound\path.edge_list
                                        | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_CURVE' IN
                                               TYPEOF(oe\oriented_edge.edge_element)))) =
                           0))) =
       0;
  WR2: SIZEOF(QUERY(elp_fbnds
                    <* QUERY(bnds
                             <* bounds
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)))
                    | NOT (SIZEOF(QUERY(oe
                                        <* elp_fbnds.bound\path.edge_list
                                        | NOT (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LINE',
                                                       'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONIC',
                                                       'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLYLINE',
                                                       'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_CURVE',
                                                       'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.B_SPLINE_CURVE'] *
                                                      TYPEOF(oe.edge_element\edge_curve.edge_geometry)) =
                                               1))) =
                           0))) =
       0;
  WR3: SIZEOF(QUERY(elp_fbnds
                    <* QUERY(bnds
                             <* bounds
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)))
                    | NOT (SIZEOF(QUERY(oe
                                        <* elp_fbnds.bound\path.edge_list
                                        | NOT ((('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_POINT' IN
                                                 TYPEOF(oe\edge.edge_start)) AND
                                                ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CARTESIAN_POINT' IN
                                                 TYPEOF(oe\edge.edge_start\vertex_point.vertex_geometry))) AND
                                               (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_POINT' IN
                                                 TYPEOF(oe\edge.edge_end)) AND
                                                ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CARTESIAN_POINT' IN
                                                 TYPEOF(oe\edge.edge_end\vertex_point.vertex_geometry)))))) =
                           0))) =
       0;
  WR4: SIZEOF(QUERY(elp_fbnds
                    <* QUERY(bnds
                             <* bounds
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)))
                    | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ORIENTED_PATH' IN
                       TYPEOF(elp_fbnds.bound)))) =
       0;
  WR5: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SWEPT_SURFACE' IN TYPEOF(face_geometry)) OR
           (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LINE',
                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONIC',
                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLYLINE',
                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.B_SPLINE_CURVE'] *
                   TYPEOF(face_geometry\swept_surface.swept_curve)) =
            1);
  WR6: SIZEOF(QUERY(vlp_fbnds
                    <* QUERY(bnds
                             <* bounds
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_LOOP' IN
                                TYPEOF(bnds.bound)))
                    | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_POINT' IN
                            TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND
                           ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CARTESIAN_POINT' IN
                            TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))))) =
       0;
  WR7: SIZEOF(QUERY(bnd
                    <* bounds
                    | NOT (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_LOOP'] *
                                  TYPEOF(bnd.bound)) =
                           1))) =
       0;
  WR8: SIZEOF(QUERY(elp_fbnds
                    <* QUERY(bnds
                             <* bounds
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)))
                    | NOT (SIZEOF(QUERY(oe
                                        <* elp_fbnds.bound\path.edge_list
                                        | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_CURVE' IN
                                           TYPEOF(oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND
                                          NOT (SIZEOF(QUERY(sc_ag
                                                            <* oe.edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry
                                                            | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PCURVE' IN
                                                                   TYPEOF(sc_ag)))) =
                                               0))) =
                           0))) =
       0;
  WR9: (NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SWEPT_SURFACE' IN TYPEOF(face_geometry)) OR
            (NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLYLINE' IN
                  TYPEOF(face_geometry\swept_surface.swept_curve)) OR
                 (SIZEOF(face_geometry\swept_surface.swept_curve\polyline.points) >= 3))) AND
       (SIZEOF(QUERY(elp_fbnds
                     <* QUERY(bnds
                              <* bounds
                              | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)))
                     | NOT (SIZEOF(QUERY(oe
                                         <* elp_fbnds.bound\path.edge_list
                                         | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLYLINE' IN
                                            TYPEOF(oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND
                                           NOT (SIZEOF(oe\oriented_edge.edge_element\edge_curve.edge_geometry\polyline.points) >=
                                                3))) =
                            0))) =
        0);
END_ENTITY;

(* "aggregate_id_attribute" IMPLICIT from SCHEMA basic_attribute_schema *)
ENTITY aggregate_id_attribute;
  attribute_value : identifier;
  identified_item : SET [1 : ?] OF id_attribute_select;
END_ENTITY;

(* "amount_of_substance_measure_with_unit" USE from SCHEMA measure_schema *)
(* "amount_of_substance_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY amount_of_substance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "amount_of_substance_unit" USE from SCHEMA measure_schema *)
(* "amount_of_substance_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY amount_of_substance_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

(* "and_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "and_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY and_expression
  SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;

(* "annotation_curve_occurrence" USE from SCHEMA presentation_definition_schema *)
(* "annotation_curve_occurrence" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY annotation_curve_occurrence
  SUPERTYPE OF ((ONEOF(dimension_curve, leader_curve, projection_curve)))
  SUBTYPE OF (annotation_occurrence);
  SELF\styled_item.item : curve_or_curve_set;
END_ENTITY;

(* "annotation_fill_area" IMPLICIT from SCHEMA presentation_definition_schema *)
ENTITY annotation_fill_area
  SUBTYPE OF (geometric_representation_item);
  boundaries : SET [1 : ?] OF curve;
WHERE
  WR1: (SELF\geometric_representation_item.dim = 3) OR
       (SIZEOF(QUERY(curve
                     <* boundaries
                     | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CIRCLE' IN TYPEOF(curve)) OR
                            ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ELLIPSE' IN TYPEOF(curve)) OR
                            (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.B_SPLINE_CURVE' IN TYPEOF(curve)) AND
                             (curve\b_spline_curve.closed_curve = TRUE)) OR
                            (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.COMPOSITE_CURVE' IN
                              TYPEOF(curve)) AND
                             (curve\composite_curve.closed_curve = TRUE)) OR
                            (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLYLINE' IN TYPEOF(curve)) AND
                             (curve\polyline.points[LOINDEX(curve\polyline.points)] =
                              curve\polyline.points[HIINDEX(curve\polyline.points)]))))) =
        0);
END_ENTITY;

(* "annotation_fill_area_occurrence" USE from SCHEMA presentation_definition_schema *)
(* "annotation_fill_area_occurrence" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY annotation_fill_area_occurrence
  SUBTYPE OF (annotation_occurrence);
  fill_style_target     : point;
  SELF\styled_item.item : annotation_fill_area;
END_ENTITY;

(* "annotation_occurrence" USE from SCHEMA presentation_definition_schema *)
(* "annotation_occurrence" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY annotation_occurrence
  SUPERTYPE OF (ONEOF(annotation_curve_occurrence, annotation_fill_area_occurrence, annotation_placeholder_occurrence,
                      annotation_plane, annotation_text_occurrence, annotation_symbol_occurrence,
                      tessellated_annotation_occurrence))
  SUBTYPE OF (styled_item);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF);
  WR2: SIZEOF(QUERY(reps
                    <* using_representations(SELF)
                    | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ANNOTATION_REPRESENTATION_SELECT' IN
                           TYPEOF(reps)))) =
       0;
END_ENTITY;

(* "annotation_placeholder_leader_line" USE from SCHEMA draughting_element_schema *)
(* "annotation_placeholder_leader_line" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_SCHEMA *)
ENTITY annotation_placeholder_leader_line
  ABSTRACT SUPERTYPE OF (ONEOF(annotation_to_annotation_leader_line, annotation_to_model_leader_line,
                               auxiliary_leader_line))
  SUBTYPE OF (geometric_representation_item);
  geometric_elements : LIST [2 : ?] OF UNIQUE des_apll_point_select;
DERIVE
  model_end : des_apll_point_select := geometric_elements[HIINDEX(geometric_elements)];
INVERSE
  container : annotation_placeholder_occurrence_with_leader_line FOR leader_line;
UNIQUE
  UR1: geometric_elements;
END_ENTITY;

(* "annotation_placeholder_occurrence" USE from SCHEMA mechanical_design_schema *)
(* "annotation_placeholder_occurrence" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,MECHANICAL_DESIGN_SCHEMA *)
ENTITY annotation_placeholder_occurrence
  SUBTYPE OF (annotation_occurrence, geometric_representation_item);
  SELF\styled_item.item : geometric_set;
  role                  : annotation_placeholder_occurrence_role;
  line_spacing          : positive_length_measure;
INVERSE
  the_callout                                             : draughting_callout FOR contents;
  the_draughting_model_item_association_with_placeholders : SET [0:1] OF draughting_model_item_association_with_placeholder FOR annotation_placeholder;
WHERE
  WR1: md_valid_content_in_geometric_set_for_placeholder(item);
  WR2: NOT (role = annotation_placeholder_occurrence_role.gps_data) OR
           ((SIZEOF(the_draughting_model_item_association_with_placeholders) = 1) AND
            md_pmi_name_and_type_correlation(SELF));
END_ENTITY;

(* "annotation_placeholder_occurrence_with_leader_line" USE from SCHEMA draughting_element_schema *)
(* "annotation_placeholder_occurrence_with_leader_line" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_SCHEMA *)
ENTITY annotation_placeholder_occurrence_with_leader_line
  SUBTYPE OF (annotation_placeholder_occurrence);
  leader_line : SET [1 : ?] OF annotation_placeholder_leader_line;
UNIQUE
  UR1: leader_line;
END_ENTITY;

(* "annotation_plane" USE from SCHEMA draughting_element_schema *)
(* "annotation_plane" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_SCHEMA *)
ENTITY annotation_plane
  SUBTYPE OF (annotation_occurrence, geometric_representation_item);
  elements              : OPTIONAL SET [1 : ?] OF annotation_plane_element;
  SELF\styled_item.item : plane_or_planar_box;
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
  WR2: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PLANAR_BOX' IN TYPEOF(SELF\styled_item.item)) OR
           ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AXIS2_PLACEMENT_3D' IN
            TYPEOF(SELF\styled_item.item\planar_box.placement));
  WR3: (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PLANAR_BOX' IN TYPEOF(SELF\styled_item.item)) AND
        ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE_STYLE' IN
         TYPEOF(SELF\styled_item.styles[1]\presentation_style_assignment.styles[1]))) OR
       (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PLANE' IN TYPEOF(SELF\styled_item.item)) AND
        ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FILL_AREA_STYLE' IN
         TYPEOF(SELF\styled_item.styles[1]\presentation_style_assignment.styles[1])));
  WR4: (SIZEOF(SELF\styled_item.styles) = 1) AND
       (SIZEOF(SELF\styled_item.styles[1]\presentation_style_assignment.styles) = 1);
END_ENTITY;

(* "annotation_symbol_occurrence" IMPLICIT from SCHEMA presentation_definition_schema *)
ENTITY annotation_symbol_occurrence
  SUBTYPE OF (annotation_occurrence);
  SELF\styled_item.item : annotation_symbol_occurrence_item;
END_ENTITY;

(* "annotation_text" USE from SCHEMA presentation_definition_schema *)
(* "annotation_text" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY annotation_text
  SUBTYPE OF (mapped_item);
  SELF\mapped_item.mapping_target : axis2_placement;
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TEXT_STRING_REPRESENTATION' IN
       TYPEOF(SELF\mapped_item.mapping_source.mapped_representation);
  WR2: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF);
END_ENTITY;

(* "annotation_text_occurrence" USE from SCHEMA presentation_definition_schema *)
(* "annotation_text_occurrence" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY annotation_text_occurrence
  SUBTYPE OF (annotation_occurrence);
  SELF\styled_item.item : annotation_text_occurrence_item;
END_ENTITY;

(* "annotation_to_annotation_leader_line" USE from SCHEMA draughting_element_schema *)
(* "annotation_to_annotation_leader_line" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_SCHEMA *)
ENTITY annotation_to_annotation_leader_line
  SUBTYPE OF (annotation_placeholder_leader_line);
DERIVE
  start_end : des_apll_point_select := SELF\annotation_placeholder_leader_line.geometric_elements[1];
WHERE
  -- Bug 8420
  WR1: (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.APLL_POINT_WITH_SURFACE'] *
               TYPEOF(SELF\annotation_placeholder_leader_line.model_end)) =
        0) AND
       (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.APLL_POINT_WITH_SURFACE'] * TYPEOF(start_end)) = 0);
  -- The geometric_elements inherited from annotation_placeholder_leader_line shall not start nor end on the part model.
  -- IP1: An annotation_to_annotation_leader_line shall start and end at annotation boundary curves when the placeholder is replaced with annotation with rendered boundary curves.
  -- IP2: When rendered by the receiving system the leader line shall start and end on different annotation instances.
END_ENTITY;

(* "annotation_to_model_leader_line" USE from SCHEMA draughting_element_schema *)
(* "annotation_to_model_leader_line" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_SCHEMA *)
ENTITY annotation_to_model_leader_line
  SUBTYPE OF (annotation_placeholder_leader_line);
DERIVE
  start_end : des_apll_point_select := SELF\annotation_placeholder_leader_line.geometric_elements[1];
WHERE
  WR1: SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.APLL_POINT_WITH_SURFACE'] *
              TYPEOF(SELF\annotation_placeholder_leader_line.model_end)) =
       1;
  -- The geometric_elements inherited from annotation_placeholder_leader_line shall end on the part model.
  -- Bug 8420
  WR2: SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.APLL_POINT_WITH_SURFACE'] * TYPEOF(start_end)) = 0;
  -- The geometric_elements inherited from annotation_placeholder_leader_line shall not start on the part model.
END_ENTITY;

(* "apll_point" USE from SCHEMA draughting_element_schema *)
(* "apll_point" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_SCHEMA *)
ENTITY apll_point
  SUBTYPE OF (cartesian_point);
  symbol_applied : des_apll_point_symbol;
INVERSE
  container : annotation_placeholder_leader_line FOR geometric_elements;
WHERE
  WR1: SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.APLL_POINT_WITH_SURFACE'] * TYPEOF(SELF)) = 0;
  WR2: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_SET.ELEMENTS')) = 0;
END_ENTITY;

(* "apll_point_with_surface" USE from SCHEMA draughting_element_schema *)
(* "apll_point_with_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_SCHEMA *)
ENTITY apll_point_with_surface
  SUBTYPE OF (cartesian_point);
  symbol_applied     : des_apll_point_symbol;
  associated_surface : face_surface;
INVERSE
  container : annotation_placeholder_leader_line FOR geometric_elements;
WHERE
  WR1: SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.APLL_POINT'] * TYPEOF(SELF)) = 0;
  WR2: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_SET.ELEMENTS')) = 0;
END_ENTITY;

(* "application_context" IMPLICIT from SCHEMA application_context_schema *)
ENTITY application_context;
  application : label;
DERIVE
  description : text       := get_description_value(SELF);
  id          : identifier := get_id_value(SELF);
INVERSE
  context_elements : SET [1:?] OF application_context_element FOR frame_of_reference;
WHERE
  WR1: SIZEOF(USEDIN(SELF,
                     'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <=
       1;
  WR2: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

(* "application_context_element" IMPLICIT from SCHEMA application_context_schema *)
ENTITY application_context_element
  SUPERTYPE OF (ONEOF(product_concept_context, product_context, product_definition_context));
  name               : label;
  frame_of_reference : application_context;
END_ENTITY;

(* "application_defined_function" USE from SCHEMA mathematical_functions_schema *)
(* "application_defined_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY application_defined_function
  SUBTYPE OF (maths_function);
  explicit_domain : tuple_space;
  explicit_range  : tuple_space;
  parameters      : LIST OF maths_value;
WHERE
  WR1: expression_is_constant(explicit_domain);
  WR2: expression_is_constant(explicit_range);
END_ENTITY;

(* "applied_action_assignment" USE from SCHEMA activity_mim *)
(* "applied_action_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,EXTERNAL_MODEL_MIM,ACTIVITY_MIM *)
ENTITY applied_action_assignment
  SUBTYPE OF (action_assignment);
  items : SET [1 : ?] OF action_items;
END_ENTITY;

(* "applied_approval_assignment" USE from SCHEMA approval_mim *)
(* "applied_approval_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,APPROVAL_MIM *)
ENTITY applied_approval_assignment
  SUBTYPE OF (approval_assignment);
  items : SET [1 : ?] OF approval_item;
END_ENTITY;

(* "applied_approval_scope" USE from SCHEMA approval_mim *)
(* "applied_approval_scope" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,APPROVAL_MIM *)
ENTITY applied_approval_scope
  SUBTYPE OF (approval_assignment);
  items : SET [1 : ?] OF approval_scope_item;
END_ENTITY;

(* "applied_classification_assignment" USE from SCHEMA classification_assignment_mim *)
(* "applied_classification_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,CLASSIFICATION_ASSIGNMENT_MIM *)
ENTITY applied_classification_assignment
  SUBTYPE OF (classification_assignment);
  items : SET [1 : ?] OF classification_item;
END_ENTITY;

(* "applied_classification_assignment_relationship" USE from SCHEMA classification_assignment_mim *)
(* "applied_classification_assignment_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,CLASSIFICATION_ASSIGNMENT_MIM *)
ENTITY applied_classification_assignment_relationship
  SUBTYPE OF (classification_assignment_relationship);
  SELF\classification_assignment_relationship.related  : applied_classification_assignment;
  SELF\classification_assignment_relationship.relating : applied_classification_assignment;
END_ENTITY;

(* "applied_date_and_time_assignment" USE from SCHEMA date_time_assignment_mim *)
(* "applied_date_and_time_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,DATE_TIME_ASSIGNMENT_MIM *)
ENTITY applied_date_and_time_assignment
  SUBTYPE OF (date_and_time_assignment);
  items : SET [1 : ?] OF date_and_time_item;
END_ENTITY;

(* "applied_date_assignment" USE from SCHEMA date_time_assignment_mim *)
(* "applied_date_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,DATE_TIME_ASSIGNMENT_MIM *)
ENTITY applied_date_assignment
  SUBTYPE OF (date_assignment);
  items : SET [1 : ?] OF date_item;
END_ENTITY;

(* "applied_description_text_assignment" USE from SCHEMA description_assignment_mim *)
(* "applied_description_text_assignment" Path: DESCRIPTION_ASSIGNMENT_MIM *)
ENTITY applied_description_text_assignment
  SUBTYPE OF (description_text_assignment);
  items : SET [1 : ?] OF description_item;
END_ENTITY;

(* "applied_description_text_assignment_relationship" USE from SCHEMA description_assignment_mim *)
(* "applied_description_text_assignment_relationship" Path: DESCRIPTION_ASSIGNMENT_MIM *)
ENTITY applied_description_text_assignment_relationship
  SUBTYPE OF (description_text_assignment_relationship);
  SELF\description_text_assignment_relationship.related  : applied_description_text_assignment;
  SELF\description_text_assignment_relationship.relating : applied_description_text_assignment;
END_ENTITY;

(* "applied_document_reference" USE from SCHEMA document_assignment_mim *)
(* "applied_document_reference" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,DOCUMENT_ASSIGNMENT_MIM *)
ENTITY applied_document_reference
  SUBTYPE OF (document_reference);
  items : SET [1 : ?] OF document_reference_item;
END_ENTITY;

(* "applied_document_usage_constraint_assignment" USE from SCHEMA document_assignment_mim *)
(* "applied_document_usage_constraint_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,DOCUMENT_ASSIGNMENT_MIM *)
ENTITY applied_document_usage_constraint_assignment
  SUBTYPE OF (document_usage_constraint_assignment);
  items : SET [1 : ?] OF document_reference_item;
END_ENTITY;

(* "applied_external_identification_assignment" USE from SCHEMA external_item_identification_assignment_mim *)
(* "applied_external_identification_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTION_GEOMETRY_MIM,EXTERNAL_ITEM_IDENTIFICATION_ASSIGNMENT_MIM *)
ENTITY applied_external_identification_assignment
  SUBTYPE OF (external_identification_assignment);
  items : SET [1 : ?] OF external_identification_item;
END_ENTITY;

(* "applied_external_identification_assignment_relationship" USE from SCHEMA external_item_identification_assignment_mim *)
(* "applied_external_identification_assignment_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTION_GEOMETRY_MIM,EXTERNAL_ITEM_IDENTIFICATION_ASSIGNMENT_MIM *)
ENTITY applied_external_identification_assignment_relationship
  SUBTYPE OF (external_identification_assignment_relationship);
  SELF\external_identification_assignment_relationship.related  : applied_external_identification_assignment;
  SELF\external_identification_assignment_relationship.relating : applied_external_identification_assignment;
END_ENTITY;

(* "applied_group_assignment" USE from SCHEMA group_mim *)
(* "applied_group_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,GROUP_MIM *)
ENTITY applied_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET [1 : ?] OF groupable_item;
END_ENTITY;

(* "applied_identification_assignment" USE from SCHEMA identification_assignment_mim *)
(* "applied_identification_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,IDENTIFICATION_ASSIGNMENT_MIM *)
ENTITY applied_identification_assignment
  SUBTYPE OF (identification_assignment);
  items : SET [1 : ?] OF identification_item;
END_ENTITY;

(* "applied_name_assignment" USE from SCHEMA name_assignment_mim *)
(* "applied_name_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,PLIB_CLASS_REFERENCE_MIM,NAME_ASSIGNMENT_MIM *)
ENTITY applied_name_assignment
  SUBTYPE OF (name_assignment);
  item : name_item;
END_ENTITY;

(* "applied_organization_assignment" USE from SCHEMA person_organization_assignment_mim *)
(* "applied_organization_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,PERSON_ORGANIZATION_ASSIGNMENT_MIM *)
ENTITY applied_organization_assignment
  SUBTYPE OF (organization_assignment);
  items : SET [1 : ?] OF organization_item;
END_ENTITY;

(* "applied_person_and_organization_assignment" USE from SCHEMA person_organization_assignment_mim *)
(* "applied_person_and_organization_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,PERSON_ORGANIZATION_ASSIGNMENT_MIM *)
ENTITY applied_person_and_organization_assignment
  SUBTYPE OF (person_and_organization_assignment);
  items : SET [1 : ?] OF person_and_organization_item;
END_ENTITY;

(* "approval" USE from SCHEMA approval_schema *)
(* "approval" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_SCHEMA *)
ENTITY approval;
  status : approval_status;
  level  : label;
END_ENTITY;

(* "approval_assignment" USE from SCHEMA management_resources_schema *)
(* "approval_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,MANAGEMENT_RESOURCES_SCHEMA *)
ENTITY approval_assignment
  ABSTRACT SUPERTYPE;
  assigned_approval : approval;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

(* "approval_date_time" USE from SCHEMA approval_schema *)
(* "approval_date_time" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_SCHEMA *)
ENTITY approval_date_time;
  date_time      : date_time_select;
  dated_approval : approval;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

(* "approval_person_organization" USE from SCHEMA approval_schema *)
(* "approval_person_organization" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_SCHEMA *)
ENTITY approval_person_organization;
  person_organization : person_organization_select;
  authorized_approval : approval;
  role                : approval_role;
END_ENTITY;

(* "approval_relationship" USE from SCHEMA approval_schema *)
(* "approval_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_SCHEMA *)
ENTITY approval_relationship;
  name              : label;
  description       : OPTIONAL text;
  relating_approval : approval;
  related_approval  : approval;
END_ENTITY;

(* "approval_role" USE from SCHEMA approval_schema *)
(* "approval_role" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_SCHEMA *)
ENTITY approval_role;
  role : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF,
                     'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <=
       1;
END_ENTITY;

(* "approval_status" USE from SCHEMA approval_schema *)
(* "approval_status" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_SCHEMA *)
ENTITY approval_status;
  name : label;
END_ENTITY;

(* "area_based_llai" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY area_based_llai
  SUPERTYPE OF (ONEOF(butt_splice_area, darting_area, fiber_orientation_angle_tolerance_deviation_area,
                      manufacturing_edge_of_part, manufacturing_edge_of_ply, no_splice_area, overlap_splice_area,
                      ply_drop_off_stay_out_area, ply_wrinkle_allowance_area, potting_area, stitching_area,
                      surface_porosity_allowance_area, surface_preparation_area))
  SUBTYPE OF (limited_length_area_indicator);
END_ENTITY;

(* "area_measure_with_unit" USE from SCHEMA measure_schema *)
(* "area_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY area_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AREA_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "area_unit" USE from SCHEMA measure_schema *)
(* "area_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY area_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensional_exponents(2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
END_ENTITY;

(* "asin_function" USE from SCHEMA iso13584_expressions_schema *)
(* "asin_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY asin_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

(* "assembly_component_usage" USE from SCHEMA product_structure_schema *)
(* "assembly_component_usage" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,PRODUCT_STRUCTURE_SCHEMA *)
ENTITY assembly_component_usage
  SUPERTYPE OF (quantified_assembly_component_usage ANDOR
                ONEOF(multi_level_reference_designator, next_assembly_usage_occurrence, promissory_usage_occurrence,
                      specified_higher_usage_occurrence))
  SUBTYPE OF (product_definition_usage);
  reference_designator : OPTIONAL identifier;
END_ENTITY;

(* "atan_function" USE from SCHEMA iso13584_expressions_schema *)
(* "atan_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY atan_function
  SUBTYPE OF (binary_function_call);
END_ENTITY;

(* "atom_based_literal" USE from SCHEMA mathematical_functions_schema *)
(* "atom_based_literal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY atom_based_literal
  SUBTYPE OF (generic_literal);
  lit_value : atom_based_value;
END_ENTITY;

(* "attribute_classification_assignment" USE from SCHEMA management_resources_schema *)
(* "attribute_classification_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,PRODUCT_VIEW_DEFINITION_MIM,MANAGEMENT_RESOURCES_SCHEMA *)
ENTITY attribute_classification_assignment
  ABSTRACT SUPERTYPE;
  assigned_class : group;
  attribute_name : label;
  role           : classification_role;
END_ENTITY;

(* "attribute_language_assignment" USE from SCHEMA multi_linguism_mim *)
(* "attribute_language_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,MULTI_LINGUISM_MIM *)
ENTITY attribute_language_assignment
  SUBTYPE OF (attribute_classification_assignment);
  SELF\attribute_classification_assignment.assigned_class : language;
  items                                                   : SET [1 : ?] OF attribute_language_item;
WHERE
  WR1: SELF\attribute_classification_assignment.role.name IN ['primary','translated'];
  WR2: SELF\attribute_classification_assignment.attribute_name <> '';
END_ENTITY;

(* "attribute_value_assignment" USE from SCHEMA management_resources_schema *)
(* "attribute_value_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,PRODUCT_VIEW_DEFINITION_MIM,MANAGEMENT_RESOURCES_SCHEMA *)
ENTITY attribute_value_assignment
  ABSTRACT SUPERTYPE;
  attribute_name  : label;
  attribute_value : attribute_type;
  role            : attribute_value_role;
END_ENTITY;

(* "attribute_value_role" IMPLICIT from SCHEMA management_resources_schema *)
ENTITY attribute_value_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

(* "auxiliary_leader_line" USE from SCHEMA draughting_element_schema *)
(* "auxiliary_leader_line" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_SCHEMA *)
ENTITY auxiliary_leader_line
  SUBTYPE OF (annotation_placeholder_leader_line);
  controlling_leader_line : annotation_to_model_leader_line;
DERIVE
  free_space_end : des_apll_point_select := SELF\annotation_placeholder_leader_line.geometric_elements[1];
WHERE
  WR1: SELF\annotation_placeholder_leader_line.container :=:
       controlling_leader_line\annotation_placeholder_leader_line.container;
  -- An auxiliary_leader_line shall be associated to the same annotation_placeholder_occurrence_with_leader_line that the controlling_leader_line is associated to.
  WR2: SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.APLL_POINT_WITH_SURFACE'] *
              TYPEOF(free_space_end)) =
       0;
  -- The geometric_elements inherited from annotation_placeholder_leader_line shall not start on the part model.
  WR3: SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.APLL_POINT_WITH_SURFACE'] *
              TYPEOF(SELF\annotation_placeholder_leader_line.model_end)) =
       1;
  -- The geometric_elements inherited from annotation_placeholder_leader_line shall end on the part model.
END_ENTITY;

(* "axis1_placement" USE from SCHEMA geometry_schema *)
(* "axis1_placement" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY axis1_placement
  SUBTYPE OF (placement);
  axis : OPTIONAL direction;
DERIVE
  z : direction := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

(* "axis2_placement_2d" USE from SCHEMA geometry_schema *)
(* "axis2_placement_2d" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY axis2_placement_2d
  SUBTYPE OF (placement);
  ref_direction : OPTIONAL direction;
DERIVE
  p : LIST [2 : 2] OF direction := build_2axes(ref_direction);
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

(* "axis2_placement_3d" USE from SCHEMA geometry_schema *)
(* "axis2_placement_3d" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY axis2_placement_3d
  SUBTYPE OF (placement);
  axis          : OPTIONAL direction;
  ref_direction : OPTIONAL direction;
DERIVE
  p : LIST [3 : 3] OF direction := build_axes(axis, ref_direction);
WHERE
  WR1: SELF\placement.location.dim = 3;
  WR2: (NOT (EXISTS(axis))) OR (axis.dim = 3);
  WR3: (NOT (EXISTS(ref_direction))) OR (ref_direction.dim = 3);
  WR4: (NOT (EXISTS(axis))) OR (NOT (EXISTS(ref_direction))) OR (cross_product(axis, ref_direction).magnitude > 0.0);
END_ENTITY;

(* "b_spline_basis" USE from SCHEMA mathematical_functions_schema *)
(* "b_spline_basis" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY b_spline_basis
  SUBTYPE OF (maths_function, generic_literal);
  degree         : nonnegative_integer;
  repeated_knots : LIST [2 : ?] OF REAL;
DERIVE
  order     : positive_integer := degree + 1;
  num_basis : positive_integer := SIZEOF(repeated_knots) - order;
WHERE
  WR1: num_basis >= order;
  WR2: nondecreasing(repeated_knots);
  WR3: repeated_knots[order] < repeated_knots[num_basis + 1];
END_ENTITY;

(* "b_spline_curve" USE from SCHEMA geometry_schema *)
(* "b_spline_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY b_spline_curve
  SUPERTYPE OF (ONEOF(uniform_curve, b_spline_curve_with_knots, quasi_uniform_curve, bezier_curve) ANDOR
                rational_b_spline_curve)
  SUBTYPE OF (bounded_curve);
  degree              : INTEGER;
  control_points_list : LIST [2 : ?] OF cartesian_point;
  curve_form          : b_spline_curve_form;
  closed_curve        : LOGICAL;
  self_intersect      : LOGICAL;
DERIVE
  upper_index_on_control_points : INTEGER                                                      := (SIZEOF(control_points_list) -
                                                                                                   1);
  control_points                : ARRAY [0 : upper_index_on_control_points] OF cartesian_point := list_to_array(control_points_list,
                                                                                                                0,
                                                                                                                upper_index_on_control_points);
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.UNIFORM_CURVE' IN TYPEOF(SELF)) OR
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.QUASI_UNIFORM_CURVE' IN TYPEOF(SELF)) OR
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BEZIER_CURVE' IN TYPEOF(SELF)) OR
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY;

(* "b_spline_curve_with_knots" USE from SCHEMA geometry_schema *)
(* "b_spline_curve_with_knots" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,AIC_CSG,AIC_ADVANCED_BREP,GEOMETRY_SCHEMA *)
ENTITY b_spline_curve_with_knots
  SUBTYPE OF (b_spline_curve);
  knot_multiplicities : LIST [2 : ?] OF INTEGER;
  knots               : LIST [2 : ?] OF parameter_value;
  knot_spec           : knot_type;
DERIVE
  upper_index_on_knots : INTEGER := SIZEOF(knots);
WHERE
  WR1: constraints_param_b_spline(degree, upper_index_on_knots, upper_index_on_control_points, knot_multiplicities,
                                  knots);
  WR2: SIZEOF(knot_multiplicities) = upper_index_on_knots;
END_ENTITY;

(* "b_spline_function" USE from SCHEMA mathematical_functions_schema *)
(* "b_spline_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY b_spline_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  basis                                 : LIST [1 : ?] OF b_spline_basis;
DERIVE
  coef : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_table(coef);
  WR2: (space_dimension(coef.range) = 1) AND (number_superspace_of(factor1(coef.range)) = the_reals);
  WR3: SIZEOF(basis) <= SIZEOF(shape_of_array(coef));
  WR4: compare_basis_and_coef(basis, coef);
END_ENTITY;

(* "b_spline_surface" USE from SCHEMA geometry_schema *)
(* "b_spline_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY b_spline_surface
  SUPERTYPE OF (ONEOF(b_spline_surface_with_knots, uniform_surface, quasi_uniform_surface, bezier_surface) ANDOR
                rational_b_spline_surface)
  SUBTYPE OF (bounded_surface);
  u_degree            : INTEGER;
  v_degree            : INTEGER;
  control_points_list : LIST [2 : ?] OF LIST [2 : ?] OF cartesian_point;
  surface_form        : b_spline_surface_form;
  u_closed            : LOGICAL;
  v_closed            : LOGICAL;
  self_intersect      : LOGICAL;
DERIVE
  u_upper        : INTEGER                                                       := SIZEOF(control_points_list) - 1;
  v_upper        : INTEGER                                                       := SIZEOF(control_points_list[1]) - 1;
  control_points : ARRAY [0 : u_upper] OF ARRAY [0 : v_upper] OF cartesian_point := make_array_of_array(control_points_list,
                                                                                                        0, u_upper, 0,
                                                                                                        v_upper);
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BEZIER_SURFACE' IN TYPEOF(SELF)) OR
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY;

(* "b_spline_surface_with_knots" USE from SCHEMA geometry_schema *)
(* "b_spline_surface_with_knots" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,AIC_CSG,AIC_ADVANCED_BREP,GEOMETRY_SCHEMA *)
ENTITY b_spline_surface_with_knots
  SUBTYPE OF (b_spline_surface);
  u_multiplicities : LIST [2 : ?] OF INTEGER;
  v_multiplicities : LIST [2 : ?] OF INTEGER;
  u_knots          : LIST [2 : ?] OF parameter_value;
  v_knots          : LIST [2 : ?] OF parameter_value;
  knot_spec        : knot_type;
DERIVE
  knot_u_upper : INTEGER := SIZEOF(u_knots);
  knot_v_upper : INTEGER := SIZEOF(v_knots);
WHERE
  WR1: constraints_param_b_spline(SELF\b_spline_surface.u_degree, knot_u_upper, SELF\b_spline_surface.u_upper,
                                  u_multiplicities, u_knots);
  WR2: constraints_param_b_spline(SELF\b_spline_surface.v_degree, knot_v_upper, SELF\b_spline_surface.v_upper,
                                  v_multiplicities, v_knots);
  WR3: SIZEOF(u_multiplicities) = knot_u_upper;
  WR4: SIZEOF(v_multiplicities) = knot_v_upper;
END_ENTITY;

(* "banded_matrix" USE from SCHEMA mathematical_functions_schema *)
(* "banded_matrix" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY banded_matrix
  SUBTYPE OF (linearized_table_function);
  default_entry : maths_value;
  below         : INTEGER;
  above         : INTEGER;
  order         : ordering_type;
WHERE
  WR1: SIZEOF(SELF\explicit_table_function.shape) = 2;
  WR2: -below <= above;
  WR3: member_of(default_entry, factor1(SELF\linearized_table_function.source.range));
END_ENTITY;

(* "basic_sparse_matrix" USE from SCHEMA mathematical_functions_schema *)
(* "basic_sparse_matrix" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY basic_sparse_matrix
  SUBTYPE OF (explicit_table_function, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [3 : 3] OF maths_function;
  default_entry                                   : maths_value;
  order                                           : ordering_type;
DERIVE
  index : maths_function := SELF\multiple_arity_generic_expression.operands[1];
  loc   : maths_function := SELF\multiple_arity_generic_expression.operands[2];
  val   : maths_function := SELF\multiple_arity_generic_expression.operands[3];
WHERE
  WR1: function_is_1d_table(index);
  WR2: function_is_1d_table(loc);
  WR3: function_is_1d_table(val);
  WR4: check_sparse_index_domain(index.domain, index_base, shape, order);
  WR5: check_sparse_index_to_loc(index.range, loc.domain);
  WR6: loc.domain = val.domain;
  WR7: check_sparse_loc_range(loc.range, index_base, shape, order);
  WR8: member_of(default_entry, val.range);
END_ENTITY;

(* "beveled_sheet_representation" USE from SCHEMA composite_constituent_shape_mim *)
(* "beveled_sheet_representation" Path: COMPOSITE_CONSTITUENT_SHAPE_MIM *)
ENTITY beveled_sheet_representation
  SUBTYPE OF (shape_representation);
END_ENTITY;

(* "bezier_curve" USE from SCHEMA geometry_schema *)
(* "bezier_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY bezier_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY;

(* "bezier_surface" USE from SCHEMA geometry_schema *)
(* "bezier_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY bezier_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY;

(* "binary_boolean_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "binary_boolean_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY binary_boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(xor_expression, equals_expression))
  SUBTYPE OF (boolean_expression, binary_generic_expression);
END_ENTITY;

(* "binary_function_call" USE from SCHEMA iso13584_expressions_schema *)
(* "binary_function_call" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY binary_function_call
  ABSTRACT SUPERTYPE OF (ONEOF(atan_function))
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

(* "binary_generic_expression" USE from SCHEMA iso13584_generic_expressions_schema *)
(* "binary_generic_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHS_VALUE_MIM,ISO13584_GENERIC_EXPRESSIONS_SCHEMA *)
ENTITY binary_generic_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (generic_expression);
  operands : LIST [2 : 2] OF generic_expression;
END_ENTITY;

(* "binary_literal" USE from SCHEMA mathematical_functions_schema *)
(* "binary_literal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY binary_literal
  SUBTYPE OF (generic_literal);
  lit_value : BINARY;
END_ENTITY;

(* "binary_numeric_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "binary_numeric_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY binary_numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(minus_expression, div_expression, mod_expression, slash_expression, power_expression,
                               binary_function_call))
  SUBTYPE OF (numeric_expression, binary_generic_expression);
  SELF\binary_generic_expression.operands : LIST [2 : 2] OF numeric_expression;
END_ENTITY;

(* "block" USE from SCHEMA geometric_model_schema *)
(* "block" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY block
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  x        : positive_length_measure;
  y        : positive_length_measure;
  z        : positive_length_measure;
END_ENTITY;

(* "boolean_defined_function" USE from SCHEMA iso13584_expressions_schema *)
(* "boolean_defined_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY boolean_defined_function
  ABSTRACT SUPERTYPE
  SUBTYPE OF (defined_function, boolean_expression);
END_ENTITY;

(* "boolean_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "boolean_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(simple_boolean_expression, unary_boolean_expression, binary_boolean_expression,
                               multiple_arity_boolean_expression, comparison_expression, interval_expression,
                               boolean_defined_function))
  SUBTYPE OF (expression);
END_ENTITY;

(* "boolean_literal" USE from SCHEMA iso13584_expressions_schema *)
(* "boolean_literal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY boolean_literal
  SUBTYPE OF (simple_boolean_expression, generic_literal);
  the_value : BOOLEAN;
END_ENTITY;

(* "boolean_representation_item" USE from SCHEMA basic_data_representation_mim *)
(* "boolean_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,BASIC_DATA_REPRESENTATION_MIM *)
ENTITY boolean_representation_item
  SUBTYPE OF (representation_item, boolean_literal);
END_ENTITY;

(* "boolean_result" USE from SCHEMA geometric_model_schema *)
(* "boolean_result" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY boolean_result
  SUBTYPE OF (geometric_representation_item);
  operator       : boolean_operator;
  first_operand  : boolean_operand;
  second_operand : boolean_operand;
END_ENTITY;

(* "boolean_variable" USE from SCHEMA iso13584_expressions_schema *)
(* "boolean_variable" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY boolean_variable
  SUBTYPE OF (simple_boolean_expression, variable);
END_ENTITY;

(* "bound_variable_semantics" USE from SCHEMA mathematical_functions_schema *)
(* "bound_variable_semantics" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY bound_variable_semantics
  SUBTYPE OF (variable_semantics);
END_ENTITY;

(* "boundary_curve" USE from SCHEMA geometry_schema *)
(* "boundary_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY boundary_curve
  SUBTYPE OF (composite_curve_on_surface);
WHERE
  WR1: SELF\composite_curve.closed_curve;
END_ENTITY;

(* "bounded_curve" USE from SCHEMA geometry_schema *)
(* "bounded_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY bounded_curve
  SUPERTYPE OF (ONEOF(polyline, b_spline_curve, trimmed_curve, bounded_pcurve, bounded_surface_curve, composite_curve))
  SUBTYPE OF (curve);
END_ENTITY;

(* "bounded_pcurve" USE from SCHEMA geometry_schema *)
(* "bounded_pcurve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY bounded_pcurve
  SUBTYPE OF (pcurve, bounded_curve);
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BOUNDED_CURVE' IN
        TYPEOF(SELF\pcurve.reference_to_curve.items[1]));
END_ENTITY;

(* "bounded_surface" USE from SCHEMA geometry_schema *)
(* "bounded_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY bounded_surface
  SUPERTYPE OF (ONEOF(b_spline_surface, rectangular_trimmed_surface, curve_bounded_surface,
                      rectangular_composite_surface))
  SUBTYPE OF (surface);
END_ENTITY;

(* "bounded_surface_curve" USE from SCHEMA geometry_schema *)
(* "bounded_surface_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY bounded_surface_curve
  SUBTYPE OF (surface_curve, bounded_curve);
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BOUNDED_CURVE' IN TYPEOF(SELF\surface_curve.curve_3d));
END_ENTITY;

(* "box_domain" USE from SCHEMA geometric_model_schema *)
(* "box_domain" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY box_domain
  SUBTYPE OF (founded_item);
  corner  : cartesian_point;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
  zlength : positive_length_measure;
WHERE
  WR1: SIZEOF(QUERY(item
                    <* USEDIN(SELF, '')
                    | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BOXED_HALF_SPACE' IN TYPEOF(item)))) =
       0;
END_ENTITY;

(* "boxed_half_space" USE from SCHEMA geometric_model_schema *)
(* "boxed_half_space" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY boxed_half_space
  SUBTYPE OF (half_space_solid);
  enclosure : box_domain;
END_ENTITY;

(* "brep_with_voids" USE from SCHEMA geometric_model_schema *)
(* "brep_with_voids" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,AIC_CSG,GEOMETRIC_MODEL_SCHEMA *)
ENTITY brep_with_voids
  SUBTYPE OF (manifold_solid_brep);
  voids : SET [1 : ?] OF oriented_closed_shell;
END_ENTITY;

(* "butt_splice_area" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY butt_splice_area
  SUBTYPE OF (area_based_llai);
END_ENTITY;

(* "butt_splice_area_llai_specification" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY butt_splice_area_llai_specification
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "calendar_date" USE from SCHEMA date_time_schema *)
(* "calendar_date" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_MIM,DATE_TIME_ASSIGNMENT_MIM,EXTENDED_DATE_MIM,DATE_TIME_SCHEMA *)
ENTITY calendar_date
  SUBTYPE OF (date);
  day_component   : day_in_month_number;
  month_component : month_in_year_number;
WHERE
  WR1: valid_calendar_date(SELF);
END_ENTITY;

(* "capacitance_measure_with_unit" USE from SCHEMA measure_schema *)
(* "capacitance_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY capacitance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CAPACITANCE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "capacitance_unit" USE from SCHEMA measure_schema *)
(* "capacitance_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY capacitance_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.farad);
END_ENTITY;

(* "cartesian_11" USE from SCHEMA ply_orientation_specification_mim *)
(* "cartesian_11" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PLY_ORIENTATION_SPECIFICATION_MIM *)
ENTITY cartesian_11
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AXIS2_PLACEMENT_3D' IN TYPEOF(SELF);
END_ENTITY;

(* "cartesian_complex_number_region" USE from SCHEMA mathematical_functions_schema *)
(* "cartesian_complex_number_region" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY cartesian_complex_number_region
  SUBTYPE OF (maths_space, generic_literal);
  real_constraint : real_interval;
  imag_constraint : real_interval;
WHERE
  WR1: min_exists(real_constraint) OR max_exists(real_constraint) OR min_exists(imag_constraint) OR
       max_exists(imag_constraint);
END_ENTITY;

(* "cartesian_point" USE from SCHEMA geometry_schema *)
(* "cartesian_point" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY cartesian_point
  SUPERTYPE OF (ONEOF(cylindrical_point, polar_point, spherical_point))
  SUBTYPE OF (point);
  coordinates : LIST [1 : 3] OF length_measure;
END_ENTITY;

(* "cartesian_transformation_operator" IMPLICIT from SCHEMA geometry_schema *)
ENTITY cartesian_transformation_operator
  SUPERTYPE OF (ONEOF(cartesian_transformation_operator_2d, cartesian_transformation_operator_3d))
  SUBTYPE OF (geometric_representation_item, functionally_defined_transformation);
  axis1        : OPTIONAL direction;
  axis2        : OPTIONAL direction;
  local_origin : cartesian_point;
  scale        : OPTIONAL REAL;
DERIVE
  scl : REAL := NVL(scale, 1.0);
WHERE
  WR1: scl > 0.0;
END_ENTITY;

(* "cartesian_transformation_operator_2d" USE from SCHEMA geometry_schema *)
(* "cartesian_transformation_operator_2d" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY cartesian_transformation_operator_2d
  SUBTYPE OF (cartesian_transformation_operator);
DERIVE
  u : LIST [2 : 2] OF direction := base_axis(2, SELF\cartesian_transformation_operator.axis1,
                                             SELF\cartesian_transformation_operator.axis2, ?);
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

(* "cartesian_transformation_operator_3d" USE from SCHEMA geometry_schema *)
(* "cartesian_transformation_operator_3d" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY cartesian_transformation_operator_3d
  SUBTYPE OF (cartesian_transformation_operator);
  axis3 : OPTIONAL direction;
DERIVE
  u : LIST [3 : 3] OF direction := base_axis(3, SELF\cartesian_transformation_operator.axis1,
                                             SELF\cartesian_transformation_operator.axis2, axis3);
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

(* "celsius_temperature_measure_with_unit" USE from SCHEMA measure_schema *)
(* "celsius_temperature_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY celsius_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "chain_based_geometric_item_specific_usage" USE from SCHEMA shape_property_assignment_mim *)
(* "chain_based_geometric_item_specific_usage" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM *)
ENTITY chain_based_geometric_item_specific_usage
  SUBTYPE OF (geometric_item_specific_usage, chain_based_item_identified_representation_usage);
END_ENTITY;

(* "chain_based_item_identified_representation_usage" USE from SCHEMA product_property_representation_schema *)
(* "chain_based_item_identified_representation_usage" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PRODUCT_PROPERTY_REPRESENTATION_SCHEMA *)
ENTITY chain_based_item_identified_representation_usage
  SUBTYPE OF (item_identified_representation_usage);
  nodes           : LIST [2 : ?] OF UNIQUE representation;
  undirected_link : LIST [1 : ?] OF chained_representation_link;
DERIVE
  root                                                          : representation                              := nodes[1];
  SELF\item_identified_representation_usage.used_representation                                                          : representation                              := nodes[HIINDEX(nodes)];
  leaf                                                          : representation                              := used_representation;
  directed_link                                                 : LIST [1 : ?] OF representation_relationship := get_directed_link(nodes,
                                                                                                                                   undirected_link);
WHERE
  WR1: EXISTS(directed_link);
END_ENTITY;

(* "character_glyph_style_outline" USE from SCHEMA presentation_appearance_schema *)
(* "character_glyph_style_outline" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY character_glyph_style_outline
  SUBTYPE OF (founded_item);
  outline_style : curve_style;
END_ENTITY;

(* "character_glyph_style_stroke" USE from SCHEMA presentation_appearance_schema *)
(* "character_glyph_style_stroke" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY character_glyph_style_stroke
  SUBTYPE OF (founded_item);
  stroke_style : curve_style;
END_ENTITY;

(* "characteristic_data_column_header" USE from SCHEMA characteristic_mim *)
(* "characteristic_data_column_header" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,CHARACTERISTIC_MIM *)
ENTITY characteristic_data_column_header
  SUBTYPE OF (general_property);
END_ENTITY;

(* "characteristic_data_column_header_link" USE from SCHEMA characteristic_mim *)
(* "characteristic_data_column_header_link" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,CHARACTERISTIC_MIM *)
ENTITY characteristic_data_column_header_link
  SUBTYPE OF (general_property_relationship);
END_ENTITY;

(* "characteristic_data_table_header" USE from SCHEMA characteristic_mim *)
(* "characteristic_data_table_header" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,CHARACTERISTIC_MIM *)
ENTITY characteristic_data_table_header
  SUBTYPE OF (general_property);
END_ENTITY;

(* "characteristic_data_table_header_decomposition" USE from SCHEMA characteristic_mim *)
(* "characteristic_data_table_header_decomposition" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,CHARACTERISTIC_MIM *)
ENTITY characteristic_data_table_header_decomposition
  SUBTYPE OF (general_property_relationship);
END_ENTITY;

(* "characteristic_type" USE from SCHEMA characteristic_mim *)
(* "characteristic_type" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,CHARACTERISTIC_MIM *)
ENTITY characteristic_type
  SUBTYPE OF (group);
END_ENTITY;

(* "characterized_object" USE from SCHEMA product_property_definition_schema *)
(* "characterized_object" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,EXTERNAL_MODEL_MIM,PRODUCT_PROPERTY_DEFINITION_SCHEMA *)
ENTITY characterized_object;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

(* "characterized_product_concept_feature" USE from SCHEMA product_class_mim *)
(* "characterized_product_concept_feature" Path: PRODUCT_CLASS_MIM *)
ENTITY characterized_product_concept_feature
  SUBTYPE OF (product_concept_feature, characterized_object);
END_ENTITY;

(* "characterized_product_concept_feature_category" USE from SCHEMA product_class_mim *)
(* "characterized_product_concept_feature_category" Path: PRODUCT_CLASS_MIM *)
ENTITY characterized_product_concept_feature_category
  SUBTYPE OF (product_concept_feature_category, characterized_object);
END_ENTITY;

(* "circle" USE from SCHEMA geometry_schema *)
(* "circle" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY circle
  SUBTYPE OF (conic);
  radius : positive_length_measure;
END_ENTITY;

(* "class" USE from SCHEMA classification_schema *)
(* "class" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,PLIB_CLASS_REFERENCE_MIM,EXTERNAL_CLASS_MIM,CLASSIFICATION_SCHEMA *)
ENTITY class
  SUBTYPE OF (group);
END_ENTITY;

(* "class_by_extension" USE from SCHEMA classification_schema *)
(* "class_by_extension" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,PLIB_CLASS_REFERENCE_MIM,EXTERNAL_CLASS_MIM,CLASSIFICATION_SCHEMA *)
ENTITY class_by_extension
  SUBTYPE OF (class);
END_ENTITY;

(* "class_by_intension" USE from SCHEMA classification_schema *)
(* "class_by_intension" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,PLIB_CLASS_REFERENCE_MIM,EXTERNAL_CLASS_MIM,CLASSIFICATION_SCHEMA *)
ENTITY class_by_intension
  SUBTYPE OF (class);
END_ENTITY;

(* "classification_assignment" USE from SCHEMA management_resources_schema *)
(* "classification_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PRODUCT_CLASS_MIM,MANAGEMENT_RESOURCES_SCHEMA *)
ENTITY classification_assignment
  ABSTRACT SUPERTYPE;
  assigned_class : group;
  role           : classification_role;
END_ENTITY;

(* "classification_assignment_relationship" IMPLICIT from SCHEMA management_resources_schema *)
ENTITY classification_assignment_relationship;
  id            : OPTIONAL identifier;
  description   : OPTIONAL text;
  relating      : classification_assignment;
  related       : classification_assignment;
  relation_type : STRING;
WHERE
  WR1: acyclic_classification_assignment_relationship(SELF, [related],
                                                      'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CLASSIFICATION_ASSIGNMENT_RELATIONSHIP');
END_ENTITY;

(* "classification_role" IMPLICIT from SCHEMA management_resources_schema *)
ENTITY classification_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

(* "closed_shell" USE from SCHEMA topology_schema *)
(* "closed_shell" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,AIC_CSG,TOPOLOGY_SCHEMA *)
ENTITY closed_shell
  SUBTYPE OF (connected_face_set);
END_ENTITY;

(* "colour" USE from SCHEMA presentation_resource_schema *)
(* "colour" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_RESOURCE_SCHEMA *)
ENTITY colour;
END_ENTITY;

(* "colour_rgb" USE from SCHEMA presentation_resource_schema *)
(* "colour_rgb" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_RESOURCE_SCHEMA *)
ENTITY colour_rgb
  SUBTYPE OF (colour_specification);
  red   : REAL;
  green : REAL;
  blue  : REAL;
WHERE
  WR1: {0.0 <= red <= 1.0};
  WR2: {0.0 <= green <= 1.0};
  WR3: {0.0 <= blue <= 1.0};
END_ENTITY;

(* "colour_specification" USE from SCHEMA presentation_resource_schema *)
(* "colour_specification" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_RESOURCE_SCHEMA *)
ENTITY colour_specification
  SUBTYPE OF (colour);
  name : label;
END_ENTITY;

(* "comparison_equal" USE from SCHEMA iso13584_expressions_schema *)
(* "comparison_equal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY comparison_equal
  SUBTYPE OF (comparison_expression);
END_ENTITY;

(* "comparison_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "comparison_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY comparison_expression
  ABSTRACT SUPERTYPE OF (ONEOF(comparison_equal, comparison_greater, comparison_greater_equal, comparison_less,
                               comparison_less_equal, comparison_not_equal, like_expression))
  SUBTYPE OF (boolean_expression, binary_generic_expression);
  SELF\binary_generic_expression.operands : LIST [2 : 2] OF expression;
WHERE
  WR1: (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NUMERIC_EXPRESSION' IN
         TYPEOF(SELF\binary_generic_expression.operands[1])) AND
        ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NUMERIC_EXPRESSION' IN
         TYPEOF(SELF\binary_generic_expression.operands[2]))) OR
       (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BOOLEAN_EXPRESSION' IN
         TYPEOF(SELF\binary_generic_expression.operands[1])) AND
        ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BOOLEAN_EXPRESSION' IN
         TYPEOF(SELF\binary_generic_expression.operands[2]))) OR
       (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.STRING_EXPRESSION' IN
         TYPEOF(SELF\binary_generic_expression.operands[1])) AND
        ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.STRING_EXPRESSION' IN
         TYPEOF(SELF\binary_generic_expression.operands[2])));
END_ENTITY;

(* "comparison_greater" USE from SCHEMA iso13584_expressions_schema *)
(* "comparison_greater" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY comparison_greater
  SUBTYPE OF (comparison_expression);
END_ENTITY;

(* "comparison_greater_equal" USE from SCHEMA iso13584_expressions_schema *)
(* "comparison_greater_equal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY comparison_greater_equal
  SUBTYPE OF (comparison_expression);
END_ENTITY;

(* "comparison_less" USE from SCHEMA iso13584_expressions_schema *)
(* "comparison_less" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY comparison_less
  SUBTYPE OF (comparison_expression);
END_ENTITY;

(* "comparison_less_equal" USE from SCHEMA iso13584_expressions_schema *)
(* "comparison_less_equal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY comparison_less_equal
  SUBTYPE OF (comparison_expression);
END_ENTITY;

(* "comparison_not_equal" USE from SCHEMA iso13584_expressions_schema *)
(* "comparison_not_equal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY comparison_not_equal
  SUBTYPE OF (comparison_expression);
END_ENTITY;

(* "complex_number_literal" USE from SCHEMA mathematical_functions_schema *)
(* "complex_number_literal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY complex_number_literal
  SUBTYPE OF (generic_literal);
  real_part : REAL;
  imag_part : REAL;
END_ENTITY;

(* "complex_number_literal_polar" USE from SCHEMA mathematical_functions_schema *)
(* "complex_number_literal_polar" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY complex_number_literal_polar
  SUBTYPE OF (complex_number_literal);
  modulus  : REAL;
  argument : REAL;
DERIVE
  SELF\complex_number_literal.real_part                             : REAL := modulus * COS(argument);
  SELF\complex_number_literal.imag_part                             : REAL := modulus * SIN(argument);
WHERE
  WR1: modulus >= 0;
  WR2: {0 <= argument <= 2 * PI};
END_ENTITY;

(* "complex_triangulated_face" USE from SCHEMA geometric_model_schema *)
(* "complex_triangulated_face" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY complex_triangulated_face
  SUBTYPE OF (tessellated_face);
  pnindex         : LIST [0 : ?] OF INTEGER;
  triangle_strips : LIST [0 : ?] OF LIST [3 : ?] OF INTEGER;
  triangle_fans   : LIST [0 : ?] OF LIST [3 : ?] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_face.pnmax));
  WR2: NOT ((SIZEOF(pnindex) = 0) AND (SELF\tessellated_face.pnmax <> coordinates.npoints));
  WR3: NOT ((SIZEOF(triangle_strips) = 0) AND (SIZEOF(triangle_fans) = 0));
END_ENTITY;

(* "complex_triangulated_surface_set" USE from SCHEMA geometric_model_schema *)
(* "complex_triangulated_surface_set" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY complex_triangulated_surface_set
  SUBTYPE OF (tessellated_surface_set);
  pnindex         : LIST [0 : ?] OF INTEGER;
  triangle_strips : LIST [0 : ?] OF LIST [3 : ?] OF INTEGER;
  triangle_fans   : LIST [0 : ?] OF LIST [3 : ?] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_surface_set.pnmax));
  WR2: NOT ((SIZEOF(pnindex) = 0) AND (SELF\tessellated_surface_set.pnmax <> coordinates.npoints));
  WR3: NOT ((SIZEOF(triangle_strips) = 0) AND (SIZEOF(triangle_fans) = 0));
END_ENTITY;

(* "composite_assembly_sequence_definition" USE from SCHEMA part_and_zone_laminate_tables_mim *)
(* "composite_assembly_sequence_definition" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM *)
ENTITY composite_assembly_sequence_definition
  SUBTYPE OF (product_definition);
WHERE
  WR1: SIZEOF(QUERY(pdr
                    <* USEDIN(SELF,
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
                    | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN
                      TYPEOF(pdr))) >
       0;
END_ENTITY;

(* "composite_assembly_table" USE from SCHEMA part_and_zone_laminate_tables_mim *)
(* "composite_assembly_table" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM *)
ENTITY composite_assembly_table
  SUBTYPE OF (part_laminate_table);
END_ENTITY;

(* "composite_curve" USE from SCHEMA geometry_schema *)
(* "composite_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTION_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY composite_curve
  SUBTYPE OF (bounded_curve);
  segments       : LIST [1 : ?] OF composite_curve_segment;
  self_intersect : LOGICAL;
DERIVE
  n_segments   : INTEGER := SIZEOF(segments);
  closed_curve : LOGICAL := segments[n_segments].transition <> discontinuous;
WHERE
  WR1: ((NOT closed_curve) AND (SIZEOF(QUERY(temp <* segments | temp.transition = discontinuous)) = 1)) OR
       ((closed_curve) AND (SIZEOF(QUERY(temp <* segments | temp.transition = discontinuous)) = 0));
END_ENTITY;

(* "composite_curve_on_surface" USE from SCHEMA geometry_schema *)
(* "composite_curve_on_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,AIC_CSG,AIC_ADVANCED_BREP,GEOMETRY_SCHEMA *)
ENTITY composite_curve_on_surface
  SUPERTYPE OF (boundary_curve)
  SUBTYPE OF (composite_curve);
DERIVE
  basis_surface : SET [0 : 2] OF surface := get_basis_surface(SELF);
WHERE
  WR1: SIZEOF(basis_surface) > 0;
  WR2: constraints_composite_curve_on_surface(SELF);
END_ENTITY;

(* "composite_curve_segment" USE from SCHEMA geometry_schema *)
(* "composite_curve_segment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTION_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY composite_curve_segment
  SUBTYPE OF (founded_item);
  transition   : transition_code;
  same_sense   : BOOLEAN;
  parent_curve : curve;
INVERSE
  using_curves : BAG [1:?] OF composite_curve FOR segments;
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BOUNDED_CURVE' IN TYPEOF(parent_curve));
END_ENTITY;

(* "composite_sheet_representation" USE from SCHEMA composite_constituent_shape_mim *)
(* "composite_sheet_representation" Path: COMPOSITE_CONSTITUENT_SHAPE_MIM *)
ENTITY composite_sheet_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION',
               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MANIFOLD_SURFACE_SHAPE_REPRESENTATION'] *
              TYPEOF(SELF)) =
       1;
END_ENTITY;

(* "composite_text" IMPLICIT from SCHEMA presentation_definition_schema *)
ENTITY composite_text
  SUBTYPE OF (geometric_representation_item);
  collected_text : SET [2 : ?] OF text_or_character;
WHERE
  WR1: acyclic_composite_text(SELF, collected_text);
END_ENTITY;

(* "composite_text_with_blanking_box" USE from SCHEMA presentation_definition_schema *)
(* "composite_text_with_blanking_box" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY composite_text_with_blanking_box
  SUBTYPE OF (composite_text);
  blanking : planar_box;
END_ENTITY;

(* "composite_text_with_delineation" USE from SCHEMA presentation_definition_schema *)
(* "composite_text_with_delineation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY composite_text_with_delineation
  SUBTYPE OF (composite_text);
  delineation : text_delineation;
END_ENTITY;

(* "composite_text_with_extent" USE from SCHEMA presentation_definition_schema *)
(* "composite_text_with_extent" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY composite_text_with_extent
  SUBTYPE OF (composite_text);
  extent : planar_extent;
END_ENTITY;

(* "compound_representation_item" USE from SCHEMA representation_schema *)
(* "compound_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,REPRESENTATION_SCHEMA *)
ENTITY compound_representation_item
  SUPERTYPE OF (ONEOF(point_and_vector, point_array) ANDOR (ONEOF(row_representation_item, table_representation_item)))
  SUBTYPE OF (representation_item);
  item_element : compound_item_definition;
END_ENTITY;

(* "concat_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "concat_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY concat_expression
  SUBTYPE OF (string_expression, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [2 : ?] OF string_expression;
END_ENTITY;

(* "concept_feature_operator" USE from SCHEMA product_concept_schema *)
(* "concept_feature_operator" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PRODUCT_CONCEPT_SCHEMA *)
ENTITY concept_feature_operator;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

(* "concept_feature_relationship" IMPLICIT from SCHEMA product_concept_schema *)
ENTITY concept_feature_relationship;
  name                             : label;
  description                      : OPTIONAL text;
  relating_product_concept_feature : product_concept_feature;
  related_product_concept_feature  : product_concept_feature;
END_ENTITY;

(* "concept_feature_relationship_with_condition" IMPLICIT from SCHEMA product_concept_schema *)
ENTITY concept_feature_relationship_with_condition
  SUBTYPE OF (concept_feature_relationship);
  conditional_operator : concept_feature_operator;
END_ENTITY;

(* "conditional_concept_feature" USE from SCHEMA product_concept_schema *)
(* "conditional_concept_feature" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PRODUCT_CONCEPT_SCHEMA *)
ENTITY conditional_concept_feature
  SUBTYPE OF (product_concept_feature);
  condition : concept_feature_relationship_with_condition;
END_ENTITY;

(* "conductance_measure_with_unit" USE from SCHEMA measure_schema *)
(* "conductance_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY conductance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONDUCTANCE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "conductance_unit" USE from SCHEMA measure_schema *)
(* "conductance_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY conductance_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.siemens);
END_ENTITY;

(* "configuration_design" USE from SCHEMA configuration_management_schema *)
(* "configuration_design" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CONFIGURATION_MANAGEMENT_SCHEMA *)
ENTITY configuration_design;
  configuration : configuration_item;
  design        : configuration_design_item;
DERIVE
  name        : label := get_name_value(SELF);
  description : text  := get_description_value(SELF);
UNIQUE
  UR1: configuration, design;
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF,
                     'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <=
       1;
END_ENTITY;

(* "configuration_item" USE from SCHEMA configuration_management_schema *)
(* "configuration_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CONFIGURATION_MANAGEMENT_SCHEMA *)
ENTITY configuration_item;
  id           : identifier;
  name         : label;
  description  : OPTIONAL text;
  item_concept : product_concept;
  purpose      : OPTIONAL label;
END_ENTITY;

(* "configuration_item_hierarchical_relationship" USE from SCHEMA configuration_item_mim *)
(* "configuration_item_hierarchical_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,CONFIGURATION_ITEM_MIM *)
ENTITY configuration_item_hierarchical_relationship
  SUBTYPE OF (configuration_item_relationship);
END_ENTITY;

(* "configuration_item_relationship" USE from SCHEMA configuration_management_schema *)
(* "configuration_item_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CONFIGURATION_MANAGEMENT_SCHEMA *)
ENTITY configuration_item_relationship;
  name                        : label;
  description                 : OPTIONAL text;
  relating_configuration_item : configuration_item;
  related_configuration_item  : configuration_item;
END_ENTITY;

(* "configuration_item_revision_sequence" USE from SCHEMA configuration_item_mim *)
(* "configuration_item_revision_sequence" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,CONFIGURATION_ITEM_MIM *)
ENTITY configuration_item_revision_sequence
  SUBTYPE OF (configuration_item_relationship);
END_ENTITY;

(* "conic" USE from SCHEMA geometry_schema *)
(* "conic" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY conic
  SUPERTYPE OF (ONEOF(circle, ellipse, hyperbola, parabola))
  SUBTYPE OF (curve);
  position : axis2_placement;
END_ENTITY;

(* "conical_surface" USE from SCHEMA geometry_schema *)
(* "conical_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY conical_surface
  SUBTYPE OF (elementary_surface);
  radius     : length_measure;
  semi_angle : plane_angle_measure;
WHERE
  WR1: radius >= 0.0;
END_ENTITY;

(* "connected_edge_set" USE from SCHEMA topology_schema *)
(* "connected_edge_set" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,TOPOLOGY_SCHEMA *)
ENTITY connected_edge_set
  SUBTYPE OF (topological_representation_item);
  ces_edges : SET [1 : ?] OF edge;
END_ENTITY;

(* "connected_edge_sub_set" USE from SCHEMA topology_schema *)
(* "connected_edge_sub_set" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,TOPOLOGY_SCHEMA *)
ENTITY connected_edge_sub_set
  SUBTYPE OF (connected_edge_set);
  parent_edge_set : connected_edge_set;
WHERE
  WR1: SELF :<>: parent_edge_set;
END_ENTITY;

(* "connected_face_set" USE from SCHEMA topology_schema *)
(* "connected_face_set" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,TOPOLOGY_SCHEMA *)
ENTITY connected_face_set
  SUPERTYPE OF (ONEOF(closed_shell, open_shell))
  SUBTYPE OF (topological_representation_item);
  cfs_faces : SET [1 : ?] OF face;
END_ENTITY;

(* "connected_face_sub_set" USE from SCHEMA topology_schema *)
(* "connected_face_sub_set" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,TOPOLOGY_SCHEMA *)
ENTITY connected_face_sub_set
  SUBTYPE OF (connected_face_set);
  parent_face_set : connected_face_set;
WHERE
  WR1: SELF :<>: parent_face_set;
END_ENTITY;

(* "constant_function" USE from SCHEMA mathematical_functions_schema *)
(* "constant_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY constant_function
  SUBTYPE OF (maths_function, generic_literal);
  sole_output      : maths_value;
  source_of_domain : maths_space_or_function;
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
END_ENTITY;

(* "constructive_geometry_representation" USE from SCHEMA construction_geometry_mim *)
(* "constructive_geometry_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,CONSTRUCTION_GEOMETRY_MIM *)
ENTITY constructive_geometry_representation
  SUBTYPE OF (representation);
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN
        TYPEOF(SELF\representation.context_of_items)) AND
       ({2 <= SELF\representation.context_of_items\geometric_representation_context.coordinate_space_dimension <= 3});
  WR2: SIZEOF(QUERY(cgr_i
                    <* SELF.items
                    | SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AXIS2_PLACEMENT_2D',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AXIS2_PLACEMENT_3D',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.B_SPLINE_SURFACE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BOUNDED_SURFACE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CARTESIAN_POINT',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CIRCLE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONIC',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONICAL_SURFACE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE_BOUNDED_SURFACE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE_REPLICA',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CYLINDRICAL_SURFACE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DEGENERATE_PCURVE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ELEMENTARY_SURFACE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ELLIPSE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.HYPERBOLA',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LINE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OFFSET_CURVE_2D',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OFFSET_CURVE_3D',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OFFSET_SURFACE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PARABOLA',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PCURVE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PLACEMENT',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PLANE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT_ON_CURVE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT_ON_SURFACE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT_REPLICA',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.RECTANGULAR_COMPOSITE_SURFACE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.RECTANGULAR_TRIMMED_SURFACE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SPHERICAL_SURFACE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_CURVE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_OF_LINEAR_EXTRUSION',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_OF_REVOLUTION',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_REPLICA',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SWEPT_SURFACE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TOROIDAL_SURFACE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_CURVE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FACE_SURFACE',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_POINT',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONNECTED_FACE_SET',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONNECTED_EDGE_SET'] *
                             TYPEOF(cgr_i)) <>
                      1)) =
       0;
  WR3: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REPRESENTATION_RELATIONSHIP.REP_2')) > 0;
END_ENTITY;

(* "constructive_geometry_representation_relationship" USE from SCHEMA construction_geometry_mim *)
(* "constructive_geometry_representation_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,CONSTRUCTION_GEOMETRY_MIM *)
ENTITY constructive_geometry_representation_relationship
  SUBTYPE OF (representation_relationship);
  SELF\representation_relationship.rep_1 : constructive_geometry_representation_or_shape_representation;
  SELF\representation_relationship.rep_2 : constructive_geometry_representation;
WHERE
  WR1: (SELF.rep_1.context_of_items :=: SELF.rep_2.context_of_items) AND
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN
        TYPEOF(SELF.rep_1.context_of_items));
  WR2: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION' IN
            TYPEOF(SELF));
END_ENTITY;

(* "context_dependent_over_riding_styled_item" USE from SCHEMA presentation_appearance_schema *)
(* "context_dependent_over_riding_styled_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY context_dependent_over_riding_styled_item
  SUBTYPE OF (over_riding_styled_item);
  style_context : LIST [1 : ?] OF style_context_select;
WHERE
  WR1: (SIZEOF(QUERY(sc
                     <* style_context
                     | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(sc))) =
        1) OR
       (SIZEOF(QUERY(sc
                     <* style_context
                     | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM' IN TYPEOF(sc)) OR
                       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONTEXT_DEPENDENT_SHAPE_REPRESENTATION' IN
                        TYPEOF(sc)) OR
                       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REPRESENTATION_RELATIONSHIP' IN
                        TYPEOF(sc)))) =
        SIZEOF(style_context));
END_ENTITY;

(* "context_dependent_unit" USE from SCHEMA measure_schema *)
(* "context_dependent_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY context_dependent_unit
  SUBTYPE OF (named_unit);
  name : label;
END_ENTITY;

(* "conversion_based_unit" USE from SCHEMA measure_schema *)
(* "conversion_based_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY conversion_based_unit
  SUBTYPE OF (named_unit);
  name              : label;
  conversion_factor : measure_with_unit;
WHERE
  WR1: SELF\named_unit.dimensions = derive_dimensional_exponents(conversion_factor\measure_with_unit.unit_component);
END_ENTITY;

(* "convex_hexahedron" USE from SCHEMA geometric_model_schema *)
(* "convex_hexahedron" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY convex_hexahedron
  SUBTYPE OF (faceted_primitive);
WHERE
  WR1: SIZEOF(points) = 8;
  WR2: above_plane(points[1], points[2], points[3], points[4]) = 0.0;
  WR3: above_plane(points[5], points[8], points[7], points[6]) = 0.0;
  WR4: above_plane(points[1], points[4], points[8], points[5]) = 0.0;
  WR5: above_plane(points[4], points[3], points[7], points[8]) = 0.0;
  WR6: above_plane(points[3], points[2], points[6], points[7]) = 0.0;
  WR7: above_plane(points[1], points[5], points[6], points[2]) = 0.0;
  WR8: same_side([points[1],points[2],points[3]], [points[5],points[6],points[7],points[8]]);
  WR9: same_side([points[1],points[4],points[8]], [points[3],points[7],points[6],points[2]]);
  WR10: same_side([points[1],points[2],points[5]], [points[3],points[7],points[8],points[4]]);
  WR11: same_side([points[5],points[6],points[7]], [points[1],points[2],points[3],points[4]]);
  WR12: same_side([points[3],points[7],points[6]], [points[1],points[4],points[8],points[5]]);
  WR13: same_side([points[3],points[7],points[8]], [points[1],points[5],points[6],points[2]]);
END_ENTITY;

(* "coordinated_universal_time_offset" USE from SCHEMA date_time_schema *)
(* "coordinated_universal_time_offset" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_MIM,DATE_TIME_ASSIGNMENT_MIM,EXTENDED_DATE_MIM,DATE_TIME_SCHEMA *)
ENTITY coordinated_universal_time_offset;
  hour_offset   : INTEGER;
  minute_offset : OPTIONAL INTEGER;
  sense         : ahead_or_behind;
DERIVE
  actual_minute_offset : INTEGER := NVL(minute_offset, 0);
WHERE
  WR1: {0 <= hour_offset < 24};
  WR2: {0 <= actual_minute_offset <= 59};
  WR3: NOT (((hour_offset <> 0) OR (actual_minute_offset <> 0)) AND (sense = exact));
END_ENTITY;

(* "coordinates_list" USE from SCHEMA geometric_model_schema *)
(* "coordinates_list" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY coordinates_list
  SUBTYPE OF (tessellated_item);
  npoints         : INTEGER;
  position_coords : LIST [1 : ?] OF LIST [3 : 3] OF REAL;
WHERE
  WR1: npoints = SIZEOF(position_coords);
  WR2: SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REPOSITIONED_TESSELLATED_ITEM'] * TYPEOF(SELF)) = 0;
END_ENTITY;

(* "core_sample" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY core_sample
  SUBTYPE OF (point_based_llai);
END_ENTITY;

(* "core_sample_llai_specification" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY core_sample_llai_specification
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "cos_function" USE from SCHEMA iso13584_expressions_schema *)
(* "cos_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY cos_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

(* "csg_shape_representation" USE from SCHEMA aic_csg *)
(* "csg_shape_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,AIC_CSG *)
ENTITY csg_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
  WR2: SIZEOF(QUERY(it
                    <* SELF.items
                    | (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CSG_SOLID',
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM',
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AXIS2_PLACEMENT_3D',
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SOLID_REPLICA',
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REVOLVED_FACE_SOLID',
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EXTRUDED_FACE_SOLID'] *
                              TYPEOF(it)) <>
                       1))) =
       0;
  WR3: SIZEOF(QUERY(mi
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)))
                    | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CSG_SHAPE_REPRESENTATION' IN
                           TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) =
       0;
  WR4: SIZEOF(QUERY(sr
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SOLID_REPLICA' IN TYPEOF(it)))
                    | (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CSG_SOLID',
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REVOLVED_FACE_SOLID',
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EXTRUDED_FACE_SOLID'] *
                              TYPEOF(sr\solid_replica.parent_solid)) =
                       0))) =
       0;
  WR5: SIZEOF(QUERY(it
                    <* SELF.items
                    | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AXIS2_PLACEMENT_3D' IN TYPEOF(it)))) >
       0;
END_ENTITY;

(* "csg_solid" USE from SCHEMA geometric_model_schema *)
(* "csg_solid" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY csg_solid
  SUBTYPE OF (solid_model);
  tree_root_expression : csg_select;
END_ENTITY;

(* "cubic_bezier_tessellated_edge" USE from SCHEMA geometric_model_schema *)
(* "cubic_bezier_tessellated_edge" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY cubic_bezier_tessellated_edge
  SUBTYPE OF (tessellated_edge);
  SELF\tessellated_edge.line_strip : LIST [4 : ?] OF INTEGER;
END_ENTITY;

(* "cubic_bezier_triangulated_face" USE from SCHEMA geometric_model_schema *)
(* "cubic_bezier_triangulated_face" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY cubic_bezier_triangulated_face
  SUBTYPE OF (tessellated_face);
  ctriangles : LIST [1 : ?] OF LIST [10 : 10] OF INTEGER;
WHERE
  WR1: SIZEOF(SELF\tessellated_face.normals) = 0;
END_ENTITY;

(* "cubic_tessellated_connecting_edge" USE from SCHEMA geometric_model_schema *)
(* "cubic_tessellated_connecting_edge" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY cubic_tessellated_connecting_edge
  SUBTYPE OF (cubic_bezier_tessellated_edge);
  smooth : LOGICAL;
  face1  : cubic_bezier_triangulated_face;
  face2  : cubic_bezier_triangulated_face;
END_ENTITY;

(* "curve" USE from SCHEMA geometry_schema *)
(* "curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY curve
  SUPERTYPE OF (ONEOF(line, conic, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

(* "curve_11" USE from SCHEMA ply_orientation_specification_mim *)
(* "curve_11" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PLY_ORIENTATION_SPECIFICATION_MIM *)
ENTITY curve_11
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE' IN TYPEOF(SELF)) OR
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(SELF));
END_ENTITY;

(* "curve_bounded_surface" USE from SCHEMA geometry_schema *)
(* "curve_bounded_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRY_SCHEMA *)
ENTITY curve_bounded_surface
  SUBTYPE OF (bounded_surface);
  basis_surface  : surface;
  boundaries     : SET [1 : ?] OF boundary_curve;
  implicit_outer : BOOLEAN;
WHERE
  WR1: (NOT implicit_outer) OR
       (SIZEOF(QUERY(temp
                     <* boundaries
                     | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) =
        0);
  WR2: (NOT (implicit_outer)) OR
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BOUNDED_SURFACE' IN TYPEOF(basis_surface));
  WR3: SIZEOF(QUERY(temp
                    <* boundaries
                    | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) <=
       1;
  WR4: SIZEOF(QUERY(temp <* boundaries | (temp\composite_curve_on_surface.basis_surface[1] <> basis_surface))) = 0;
END_ENTITY;

(* "curve_replica" USE from SCHEMA geometry_schema *)
(* "curve_replica" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRY_SCHEMA *)
ENTITY curve_replica
  SUBTYPE OF (curve);
  parent_curve   : curve;
  transformation : cartesian_transformation_operator;
WHERE
  WR1: transformation.dim = parent_curve.dim;
  WR2: acyclic_curve_replica(SELF, parent_curve);
END_ENTITY;

(* "curve_style" USE from SCHEMA presentation_appearance_schema *)
(* "curve_style" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY curve_style
  SUBTYPE OF (founded_item);
  name         : label;
  curve_font   : OPTIONAL curve_font_or_scaled_curve_font_select;
  curve_width  : OPTIONAL size_select;
  curve_colour : OPTIONAL colour;
WHERE
  WR1: EXISTS(curve_font) OR EXISTS(curve_width) OR EXISTS(curve_colour);
END_ENTITY;

(* "curve_style_font" USE from SCHEMA presentation_appearance_schema *)
(* "curve_style_font" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY curve_style_font
  SUBTYPE OF (founded_item);
  name         : label;
  pattern_list : LIST [1 : ?] OF curve_style_font_pattern;
END_ENTITY;

(* "curve_style_font_and_scaling" USE from SCHEMA presentation_appearance_schema *)
(* "curve_style_font_and_scaling" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,CURVE_APPEARANCE_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY curve_style_font_and_scaling
  SUBTYPE OF (founded_item);
  name               : label;
  curve_font         : curve_style_font_select;
  curve_font_scaling : REAL;
END_ENTITY;

(* "curve_style_font_pattern" USE from SCHEMA presentation_appearance_schema *)
(* "curve_style_font_pattern" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,CURVE_APPEARANCE_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY curve_style_font_pattern
  SUBTYPE OF (founded_item);
  visible_segment_length   : positive_length_measure;
  invisible_segment_length : positive_length_measure;
END_ENTITY;

(* "curve_swept_solid_shape_representation" USE from SCHEMA aic_curve_swept_solid *)
(* "curve_swept_solid_shape_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,AIC_CURVE_SWEPT_SOLID *)
ENTITY curve_swept_solid_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF(QUERY(it
                    <* SELF.items
                    | NOT (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SWEPT_AREA_SOLID',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SWEPT_DISK_SOLID',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AXIS2_PLACEMENT_3D'] *
                                  TYPEOF(it)) =
                           1))) =
       0;
  WR2: SIZEOF(QUERY(it
                    <* SELF.items
                    | SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SWEPT_AREA_SOLID',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SWEPT_DISK_SOLID',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM'] *
                             TYPEOF(it)) =
                      1)) >
       0;
  WR3: SIZEOF(QUERY(mi
                    <* QUERY(it
                             <* items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM' IN TYPEOF(it))
                    | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION' IN
                           TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) =
       0;
  WR4: SIZEOF(QUERY(scsas
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_CURVE_SWEPT_AREA_SOLID' IN
                               TYPEOF(it))
                    | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_CURVE' IN
                            TYPEOF(scsas\surface_curve_swept_area_solid.directrix)) OR
                           ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PCURVE' IN
                            TYPEOF(scsas\surface_curve_swept_area_solid.directrix))))) =
       0;
END_ENTITY;

(* "cyclide_segment_solid" USE from SCHEMA geometric_model_schema *)
(* "cyclide_segment_solid" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY cyclide_segment_solid
  SUBTYPE OF (geometric_representation_item);
  position    : axis2_placement_3d;
  radius1     : positive_length_measure;
  radius2     : positive_length_measure;
  cone_angle1 : plane_angle_measure;
  cone_angle2 : plane_angle_measure;
  turn_angle  : plane_angle_measure;
END_ENTITY;

(* "cylindrical_11" USE from SCHEMA ply_orientation_specification_mim *)
(* "cylindrical_11" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PLY_ORIENTATION_SPECIFICATION_MIM *)
ENTITY cylindrical_11
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE' IN TYPEOF(SELF));
END_ENTITY;

(* "cylindrical_point" USE from SCHEMA geometry_schema *)
(* "cylindrical_point" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY cylindrical_point
  SUBTYPE OF (cartesian_point);
  r     : length_measure;
  theta : plane_angle_measure;
  z     : length_measure;
DERIVE
  SELF\cartesian_point.coordinates                      : LIST [3 : 3] OF length_measure := [r * COS(theta),
                                                                                             r * SIN(theta),
                                                                                             z];
WHERE
  WR1: r >= 0.0;
END_ENTITY;

(* "cylindrical_surface" USE from SCHEMA geometry_schema *)
(* "cylindrical_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY cylindrical_surface
  SUBTYPE OF (elementary_surface);
  radius : positive_length_measure;
END_ENTITY;

(* "darting_area" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY darting_area
  SUBTYPE OF (area_based_llai);
END_ENTITY;

(* "darting_area_llai_specification" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY darting_area_llai_specification
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "data_environment" USE from SCHEMA material_property_representation_schema *)
(* "data_environment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,MATERIAL_PROPERTY_REPRESENTATION_SCHEMA *)
ENTITY data_environment;
  name        : label;
  description : text;
  elements    : SET [1 : ?] OF characterized_property_representation;
END_ENTITY;

(* "date" USE from SCHEMA date_time_schema *)
(* "date" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_MIM,DATE_TIME_ASSIGNMENT_MIM,DATE_TIME_SCHEMA *)
ENTITY date
  SUPERTYPE OF (ONEOF(calendar_date, ordinal_date, week_of_year_and_day_date, year_month));
  year_component : year_number;
END_ENTITY;

(* "date_and_time" USE from SCHEMA date_time_schema *)
(* "date_and_time" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_MIM,DATE_TIME_ASSIGNMENT_MIM,EXTENDED_DATE_MIM,DATE_TIME_SCHEMA *)
ENTITY date_and_time;
  date_component : date;
  time_component : local_time;
END_ENTITY;

(* "date_and_time_assignment" USE from SCHEMA management_resources_schema *)
(* "date_and_time_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_MIM,MANAGEMENT_RESOURCES_SCHEMA *)
ENTITY date_and_time_assignment
  ABSTRACT SUPERTYPE;
  assigned_date_and_time : date_and_time;
  role                   : date_time_role;
END_ENTITY;

(* "date_assignment" USE from SCHEMA management_resources_schema *)
(* "date_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_MIM,MANAGEMENT_RESOURCES_SCHEMA *)
ENTITY date_assignment
  ABSTRACT SUPERTYPE;
  assigned_date : date;
  role          : date_role;
END_ENTITY;

(* "date_representation_item" USE from SCHEMA basic_data_representation_mim *)
(* "date_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,BASIC_DATA_REPRESENTATION_MIM *)
ENTITY date_representation_item
  SUBTYPE OF (representation_item, date);
END_ENTITY;

(* "date_role" USE from SCHEMA date_time_schema *)
(* "date_role" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_MIM,DATE_TIME_SCHEMA *)
ENTITY date_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF,
                     'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <=
       1;
END_ENTITY;

(* "date_time_representation_item" USE from SCHEMA basic_data_representation_mim *)
(* "date_time_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,BASIC_DATA_REPRESENTATION_MIM *)
ENTITY date_time_representation_item
  SUBTYPE OF (representation_item, date_and_time);
END_ENTITY;

(* "date_time_role" USE from SCHEMA date_time_schema *)
(* "date_time_role" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_MIM,DATE_TIME_SCHEMA *)
ENTITY date_time_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF,
                     'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <=
       1;
END_ENTITY;

(* "defined_character_glyph" USE from SCHEMA presentation_definition_schema *)
(* "defined_character_glyph" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY defined_character_glyph
  SUBTYPE OF (geometric_representation_item);
  definition : defined_glyph_select;
  placement  : axis2_placement;
END_ENTITY;

(* "defined_function" USE from SCHEMA iso13584_expressions_schema *)
(* "defined_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY defined_function
  ABSTRACT SUPERTYPE OF ((ONEOF(numeric_defined_function, string_defined_function, boolean_defined_function)) ANDOR
                         sql_mappable_defined_function);
END_ENTITY;

(* "definite_integral_expression" USE from SCHEMA mathematical_functions_schema *)
(* "definite_integral_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY definite_integral_expression
  SUBTYPE OF (quantifier_expression);
  lower_limit_neg_infinity : BOOLEAN;
  upper_limit_pos_infinity : BOOLEAN;
DERIVE
  integrand                            : generic_expression                      := SELF\multiple_arity_generic_expression.operands[1];
  variable_of_integration              : maths_variable                          := SELF\multiple_arity_generic_expression.operands[2];
  SELF\quantifier_expression.variables                            : LIST [1 : 1] OF UNIQUE generic_variable := [variable_of_integration];
WHERE
  WR1: has_values_space(integrand);
  WR2: space_is_continuum(values_space_of(integrand));
  WR3: definite_integral_expr_check(SELF\multiple_arity_generic_expression.operands, lower_limit_neg_infinity,
                                    upper_limit_pos_infinity);
END_ENTITY;

(* "definite_integral_function" USE from SCHEMA mathematical_functions_schema *)
(* "definite_integral_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY definite_integral_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  variable_of_integration               : input_selector;
  lower_limit_neg_infinity              : BOOLEAN;
  upper_limit_pos_infinity              : BOOLEAN;
DERIVE
  integrand : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: space_is_continuum(integrand.range);
  WR2: definite_integral_check(integrand.domain, variable_of_integration, lower_limit_neg_infinity,
                               upper_limit_pos_infinity);
END_ENTITY;

(* "definitional_representation" USE from SCHEMA representation_schema *)
(* "definitional_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,REPRESENTATION_SCHEMA *)
ENTITY definitional_representation
  SUBTYPE OF (representation);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT' IN
       TYPEOF(SELF\representation.context_of_items);
END_ENTITY;

(* "definitional_representation_relationship" USE from SCHEMA representation_schema *)
(* "definitional_representation_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,REPRESENTATION_SCHEMA *)
ENTITY definitional_representation_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: acyclic_representation_relationship(SELF, [SELF\representation_relationship.rep_2],
                                           'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REPRESENTATION');
END_ENTITY;

(* "degenerate_pcurve" USE from SCHEMA geometry_schema *)
(* "degenerate_pcurve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY degenerate_pcurve
  SUBTYPE OF (point);
  basis_surface      : surface;
  reference_to_curve : definitional_representation;
WHERE
  WR1: SIZEOF(reference_to_curve\representation.items) = 1;
  WR2: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE' IN TYPEOF(reference_to_curve\representation.items[1]);
  WR3: reference_to_curve\representation.items[1]\geometric_representation_item.dim = 2;
END_ENTITY;

(* "degenerate_toroidal_surface" USE from SCHEMA geometry_schema *)
(* "degenerate_toroidal_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,AIC_CSG,AIC_ADVANCED_BREP,GEOMETRY_SCHEMA *)
ENTITY degenerate_toroidal_surface
  SUBTYPE OF (toroidal_surface);
  select_outer : BOOLEAN;
WHERE
  WR1: major_radius < minor_radius;
END_ENTITY;

(* "dependent_product_definition_exchange_context" USE from SCHEMA application_context_schema *)
(* "dependent_product_definition_exchange_context" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,APPLICATION_CONTEXT_SCHEMA *)
ENTITY dependent_product_definition_exchange_context
  ABSTRACT SUPERTYPE
  SUBTYPE OF (product_definition_context);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) *
              ['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.INDENTIFICATION_DEPENDENT_PRODUCT_DEFINITION_EXCHANGE_CONTEXT',
               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LANGUAGE_DEPENDENT_PRODUCT_DEFINITION_EXCHANGE_CONTEXT']) >
       0;
END_ENTITY;

(* "dependent_variable_definition" USE from SCHEMA mathematical_functions_schema *)
(* "dependent_variable_definition" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY dependent_variable_definition
  SUBTYPE OF (unary_generic_expression);
  name        : label;
  description : text;
END_ENTITY;

(* "derived_unit" USE from SCHEMA measure_schema *)
(* "derived_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY derived_unit
  SUPERTYPE OF (ONEOF(absorbed_dose_unit, acceleration_unit, radioactivity_unit, area_unit, capacitance_unit,
                      dose_equivalent_unit, electric_charge_unit, conductance_unit, electric_potential_unit,
                      energy_unit, magnetic_flux_density_unit, force_unit, frequency_unit, illuminance_unit,
                      inductance_unit, magnetic_flux_unit, power_unit, pressure_unit, resistance_unit, velocity_unit,
                      volume_unit));
  elements : SET [1 : ?] OF derived_unit_element;
DERIVE
  name : label := get_name_value(SELF);
WHERE
  WR1: (SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (elements[1].exponent <> 1.0));
  WR2: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

(* "derived_unit_element" USE from SCHEMA measure_schema *)
(* "derived_unit_element" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY derived_unit_element;
  unit     : named_unit;
  exponent : REAL;
END_ENTITY;

(* "description_attribute" USE from SCHEMA basic_attribute_schema *)
(* "description_attribute" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,BASIC_ATTRIBUTE_SCHEMA *)
ENTITY description_attribute;
  attribute_value : text;
  described_item  : description_attribute_select;
END_ENTITY;

(* "description_text" USE from SCHEMA systems_engineering_representation_schema *)
(* "description_text" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,SYSTEMS_ENGINEERING_REPRESENTATION_SCHEMA *)
ENTITY description_text;
  description : text;
END_ENTITY;

(* "description_text_assignment" USE from SCHEMA systems_engineering_representation_schema *)
(* "description_text_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,SYSTEMS_ENGINEERING_REPRESENTATION_SCHEMA *)
ENTITY description_text_assignment
  ABSTRACT SUPERTYPE;
  description : description_text;
END_ENTITY;

(* "description_text_assignment_relationship" USE from SCHEMA systems_engineering_representation_schema *)
(* "description_text_assignment_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,SYSTEMS_ENGINEERING_REPRESENTATION_SCHEMA *)
ENTITY description_text_assignment_relationship;
  id            : OPTIONAL identifier;
  description   : OPTIONAL text;
  relating      : description_text_assignment;
  related       : description_text_assignment;
  relation_type : STRING;
WHERE
  WR1: acyclic_description_text_assignment_relationship(SELF, [related],
                                                        'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DESCRIPTION_TEXT_ASSIGNMENT_RELATIONSHIP');
END_ENTITY;

(* "descriptive_representation_item" USE from SCHEMA qualified_measure_schema *)
(* "descriptive_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,QUALIFIED_MEASURE_SCHEMA *)
ENTITY descriptive_representation_item
  SUPERTYPE OF (ONEOF(tagged_text_item, uniform_resource_identifier))
  SUBTYPE OF (representation_item);
  description : text;
END_ENTITY;

(* "dielectric_constant_measure_with_unit" USE from SCHEMA value_with_unit_extension_mim *)
(* "dielectric_constant_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,VALUE_WITH_UNIT_EXTENSION_MIM *)
ENTITY dielectric_constant_measure_with_unit
  SUBTYPE OF (ratio_measure_with_unit);
END_ENTITY;

(* "dimension_curve" USE from SCHEMA draughting_element_schema *)
(* "dimension_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_SCHEMA *)
ENTITY dimension_curve
  SUBTYPE OF (annotation_curve_occurrence);
WHERE
  WR1: (SIZEOF(QUERY(dct
                     <* USEDIN(SELF,
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TERMINATOR_SYMBOL.ANNOTATED_CURVE')
                     | (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSION_CURVE_TERMINATOR' IN
                         TYPEOF(dct))))) <=
        2);
  WR2: SIZEOF(QUERY(dcdc
                    <* USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DRAUGHTING_CALLOUT.CONTENTS')
                    | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT' IN
                       TYPEOF(dcdc)))) >=
       1;
  WR3: (SIZEOF(QUERY(dct1
                     <* USEDIN(SELF,
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TERMINATOR_SYMBOL.ANNOTATED_CURVE')
                     | (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSION_CURVE_TERMINATOR' IN
                         TYPEOF(dct1)) AND
                        (dct1\dimension_curve_terminator.role = dimension_extent_usage.origin)))) <=
        1) AND
       (SIZEOF(QUERY(dct2
                     <* USEDIN(SELF,
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TERMINATOR_SYMBOL.ANNOTATED_CURVE')
                     | (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSION_CURVE_TERMINATOR' IN
                         TYPEOF(dct2)) AND
                        (dct2\dimension_curve_terminator.role = dimension_extent_usage.target)))) <=
        1);
END_ENTITY;

ENTITY dimension_curve_terminator
  SUBTYPE OF (terminator_symbol);
  role : dimension_extent_usage;
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSION_CURVE' IN
       TYPEOF(SELF\terminator_symbol.annotated_curve);
END_ENTITY;

(* "dimensional_exponents" USE from SCHEMA measure_schema *)
(* "dimensional_exponents" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY dimensional_exponents;
  length_exponent                    : REAL;
  mass_exponent                      : REAL;
  time_exponent                      : REAL;
  electric_current_exponent          : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent       : REAL;
  luminous_intensity_exponent        : REAL;
END_ENTITY;

(* "dimensional_location" USE from SCHEMA shape_dimension_schema *)
(* "dimensional_location" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_DIMENSION_SCHEMA *)
ENTITY dimensional_location
  SUBTYPE OF (shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
  WR2: SELF\shape_aspect_relationship.relating_shape_aspect.of_shape :=:
       SELF\shape_aspect_relationship.related_shape_aspect.of_shape;
END_ENTITY;

(* "dimensional_size" USE from SCHEMA shape_dimension_schema *)
(* "dimensional_size" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_DIMENSION_SCHEMA *)
ENTITY dimensional_size;
  applies_to : shape_aspect;
  name       : label;
DERIVE
  id : identifier := get_id_value(SELF);
UNIQUE
  UR1: id, applies_to;
WHERE
  WR1: applies_to.product_definitional = TRUE;
  WR2: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

(* "direction" USE from SCHEMA geometry_schema *)
(* "direction" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY direction
  SUBTYPE OF (geometric_representation_item);
  direction_ratios : LIST [2 : 3] OF REAL;
WHERE
  WR1: SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
END_ENTITY;

(* "div_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "div_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY div_expression
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

(* "document" USE from SCHEMA document_schema *)
(* "document" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,EXTERNAL_MODEL_MIM,DOCUMENT_SCHEMA *)
ENTITY document;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
  kind        : document_type;
INVERSE
  representation_types : SET [0:?] OF document_representation_type FOR represented_document;
END_ENTITY;

(* "document_file" USE from SCHEMA file_identification_mim *)
(* "document_file" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,FILE_IDENTIFICATION_MIM *)
ENTITY document_file
  SUBTYPE OF (document, characterized_object);
WHERE
  WR1: SELF\characterized_object.name = '';
  WR2: NOT EXISTS(SELF\characterized_object.description);
  WR3: SIZEOF(QUERY(drt <* SELF\document.representation_types | drt.name IN ['digital','physical'])) = 1;
END_ENTITY;

(* "document_identifier" USE from SCHEMA specification_document_mim *)
(* "document_identifier" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SPECIFICATION_DOCUMENT_MIM *)
ENTITY document_identifier
  SUBTYPE OF (group);
UNIQUE
  UR1: SELF\group.name, SELF\group.description;
END_ENTITY;

(* "document_identifier_assignment" USE from SCHEMA specification_document_mim *)
(* "document_identifier_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SPECIFICATION_DOCUMENT_MIM *)
ENTITY document_identifier_assignment
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : document_identifier;
  items                                : SET [1 : ?] OF document_identifier_assigned_item;
END_ENTITY;

(* "document_product_association" USE from SCHEMA document_schema *)
(* "document_product_association" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,DOCUMENT_SCHEMA *)
ENTITY document_product_association
  ABSTRACT SUPERTYPE;
  name              : label;
  description       : OPTIONAL text;
  relating_document : document;
  related_product   : product_or_formation_or_definition;
END_ENTITY;

(* "document_product_equivalence" USE from SCHEMA document_assignment_mim *)
(* "document_product_equivalence" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,DOCUMENT_ASSIGNMENT_MIM *)
ENTITY document_product_equivalence
  SUBTYPE OF (document_product_association);
WHERE
  WR1: SELF\document_product_association.name = 'equivalence';
  WR2: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT' IN
            TYPEOF(SELF\document_product_association.related_product)) OR
           ((SELF\document_product_association.relating_document.kind.product_data_type =
             'configuration controlled document') AND
            (SIZEOF(QUERY(prpc
                          <* USEDIN(SELF\document_product_association.related_product,
                                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                          | prpc.name = 'document')) =
             1));
  WR3: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION_FORMATION' IN
            TYPEOF(SELF.related_product)) OR
           ((SELF\document_product_association.relating_document.kind.product_data_type =
             'configuration controlled document version') AND
            (SIZEOF(QUERY(prpc
                          <* USEDIN(SELF.related_product\product_definition_formation.of_product,
                                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                          | prpc.name = 'document')) =
             1));
  WR4: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product)) OR
           ((SELF\document_product_association.relating_document.kind.product_data_type =
             'configuration controlled document definition') AND
            (SIZEOF(QUERY(prpc
                          <* USEDIN(SELF\document_product_association.related_product\product_definition.formation.of_product,
                                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                          | prpc.name = 'document')) =
             1));
END_ENTITY;

(* "document_reference" USE from SCHEMA management_resources_schema *)
(* "document_reference" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,MANAGEMENT_RESOURCES_SCHEMA *)
ENTITY document_reference
  ABSTRACT SUPERTYPE;
  assigned_document : document;
  source            : label;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

(* "document_representation_type" USE from SCHEMA document_schema *)
(* "document_representation_type" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,EXTERNAL_MODEL_MIM,DOCUMENT_SCHEMA *)
ENTITY document_representation_type;
  name                 : label;
  represented_document : document;
END_ENTITY;

(* "document_type" USE from SCHEMA document_schema *)
(* "document_type" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,EXTERNAL_MODEL_MIM,DOCUMENT_SCHEMA *)
ENTITY document_type;
  product_data_type : label;
END_ENTITY;

(* "document_usage_constraint" IMPLICIT from SCHEMA document_schema *)
ENTITY document_usage_constraint;
  source                : document;
  subject_element       : label;
  subject_element_value : text;
END_ENTITY;

(* "document_usage_constraint_assignment" USE from SCHEMA management_resources_schema *)
(* "document_usage_constraint_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,MANAGEMENT_RESOURCES_SCHEMA *)
ENTITY document_usage_constraint_assignment
  ABSTRACT SUPERTYPE;
  assigned_document_usage : document_usage_constraint;
  role                    : document_usage_role;
END_ENTITY;

(* "document_usage_role" IMPLICIT from SCHEMA management_resources_schema *)
ENTITY document_usage_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

(* "dose_equivalent_measure_with_unit" USE from SCHEMA measure_schema *)
(* "dose_equivalent_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY dose_equivalent_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DOSE_EQUIVALENT_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "dose_equivalent_unit" USE from SCHEMA measure_schema *)
(* "dose_equivalent_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY dose_equivalent_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.sievert);
END_ENTITY;

(* "draped_orientation_angle" USE from SCHEMA ply_orientation_specification_mim *)
(* "draped_orientation_angle" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PLY_ORIENTATION_SPECIFICATION_MIM *)
ENTITY draped_orientation_angle
  SUBTYPE OF (ply_orientation_angle);
END_ENTITY;

(* "draughting_callout" USE from SCHEMA draughting_element_schema *)
(* "draughting_callout" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_SCHEMA *)
ENTITY draughting_callout
  SUBTYPE OF (geometric_representation_item);
  contents : SET [1 : ?] OF draughting_callout_element;
WHERE
  WR1: (SIZEOF(QUERY(l_1
                     <* SELF\draughting_callout.contents
                     | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LEADER_CURVE' IN (TYPEOF(l_1)))) =
        0) OR
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LEADER_DIRECTED_CALLOUT' IN (TYPEOF(SELF))) AND
       (SIZEOF(QUERY(l_1
                     <* SELF\draughting_callout.contents
                     | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PROJECTION_CURVE' IN (TYPEOF(l_1)))) =
        0) OR
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PROJECTION_DIRECTED_CALLOUT' IN (TYPEOF(SELF))) AND
       (SIZEOF(QUERY(l_1
                     <* SELF\draughting_callout.contents
                     | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSION_CURVE' IN (TYPEOF(l_1)))) =
        0) OR
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT' IN (TYPEOF(SELF)));
  WR2: SIZEOF(QUERY(apo
                    <* contents
                    | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ANNOTATION_PLACEHOLDER_OCCURRENCE' IN
                      TYPEOF(apo))) <
       2;
END_ENTITY;

(* "draughting_model" IMPLICIT from SCHEMA draughting_element_schema *)
ENTITY draughting_model
  SUBTYPE OF (representation);
  SELF\representation.items : SET [1 : ?] OF draughting_model_item_select;
UNIQUE
  UR1: SELF\representation.name;
WHERE
  WR1: SIZEOF(QUERY(mi
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)))
                    | NOT (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHAPE_REPRESENTATION',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DRAUGHTING_MODEL'] *
                                  TYPEOF(mi\mapped_item.mapping_source.mapped_representation)) =
                           1))) =
       0;
  WR2: SIZEOF(QUERY(smi
                    <* QUERY(si
                             <* QUERY(it
                                      <* SELF.items
                                      | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.STYLED_ITEM' IN
                                         TYPEOF(it)))
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM' IN
                                TYPEOF(si\styled_item.item)))
                    | (NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHAPE_REPRESENTATION' IN
                             TYPEOF(smi\styled_item.item\mapped_item.mapping_source.mapped_representation)) AND
                            (SIZEOF(QUERY(sty
                                          <* smi\styled_item.styles
                                          | (NOT (SIZEOF(QUERY(psa
                                                               <* sty.styles
                                                               | (NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE_STYLE' IN
                                                                       TYPEOF(psa))))) =
                                                  1)))) =
                             1))))) =
       0;
END_ENTITY;

ENTITY draughting_model_item_association
  SUBTYPE OF (item_identified_representation_usage);
  SELF\item_identified_representation_usage.definition          : draughting_model_item_definition;
  SELF\item_identified_representation_usage.used_representation : annotation_representation_select;
  SELF\item_identified_representation_usage.identified_item     : draughting_model_item_association_select;
END_ENTITY;

(* "the_draughting_model_item_association_with_placeholders" IMPLICIT from SCHEMA mechanical_design_schema *)
ENTITY draughting_model_item_association_with_placeholder
  SUBTYPE OF (draughting_model_item_association);
  SELF\draughting_model_item_association.used_representation : draughting_model;
  SELF\item_identified_representation_usage.identified_item  : draughting_callout;
  annotation_placeholder                                     : annotation_placeholder_occurrence;
END_ENTITY;

(* "draughting_pre_defined_colour" USE from SCHEMA presentation_resource_schema *)
(* "draughting_pre_defined_colour" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_RESOURCE_SCHEMA *)
ENTITY draughting_pre_defined_colour
  SUBTYPE OF (pre_defined_colour);
WHERE
  WR1: SELF\pre_defined_item.name IN ['red','green','blue','yellow','magenta','cyan','black','white'];
END_ENTITY;

(* "draughting_pre_defined_curve_font" USE from SCHEMA presentation_appearance_schema *)
(* "draughting_pre_defined_curve_font" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY draughting_pre_defined_curve_font
  SUBTYPE OF (pre_defined_curve_font);
WHERE
  WR1: SELF\pre_defined_item.name IN ['continuous','chain','chain double dash','dashed','dotted'];
END_ENTITY;

(* "draughting_pre_defined_text_font" USE from SCHEMA presentation_resource_schema *)
(* "draughting_pre_defined_text_font" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_RESOURCE_SCHEMA *)
ENTITY draughting_pre_defined_text_font
  SUBTYPE OF (pre_defined_text_font);
WHERE
  WR1: SELF\pre_defined_item.name[1:8] = 'ISO 3098';
END_ENTITY;

(* "eccentric_cone" USE from SCHEMA geometric_model_schema *)
(* "eccentric_cone" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY eccentric_cone
  SUBTYPE OF (geometric_representation_item);
  position    : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  height      : positive_length_measure;
  x_offset    : length_measure;
  y_offset    : length_measure;
  ratio       : REAL;
WHERE
  WR1: ratio >= 0.0;
END_ENTITY;

(* "edge" USE from SCHEMA topology_schema *)
(* "edge" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,TOPOLOGY_SCHEMA *)
ENTITY edge
  SUPERTYPE OF (ONEOF(edge_curve, oriented_edge, subedge))
  SUBTYPE OF (topological_representation_item);
  edge_start : vertex;
  edge_end   : vertex;
END_ENTITY;

(* "edge_based_wireframe_model" USE from SCHEMA geometric_model_schema *)
(* "edge_based_wireframe_model" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,EDGE_BASED_WIREFRAME_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY edge_based_wireframe_model
  SUBTYPE OF (geometric_representation_item);
  ebwm_boundary : SET [1 : ?] OF connected_edge_set;
END_ENTITY;

(* "edge_based_wireframe_shape_representation" USE from SCHEMA aic_edge_based_wireframe *)
(* "edge_based_wireframe_shape_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,AIC_EDGE_BASED_WIREFRAME *)
ENTITY edge_based_wireframe_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF(QUERY(it
                    <* SELF.items
                    | NOT (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_BASED_WIREFRAME_MODEL',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AXIS2_PLACEMENT_3D'] *
                                  TYPEOF(it)) =
                           1))) =
       0;
  WR2: SIZEOF(QUERY(it
                    <* SELF.items
                    | (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_BASED_WIREFRAME_MODEL',
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM'] *
                              TYPEOF(it)) =
                       1))) >=
       1;
  WR3: SIZEOF(QUERY(ebwm
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN
                                TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(eb
                                        <* ebwm\edge_based_wireframe_model.ebwm_boundary
                                        | NOT (SIZEOF(QUERY(edges
                                                            <* eb.ces_edges
                                                            | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_CURVE' IN
                                                                   TYPEOF(edges)))) =
                                               0))) =
                           0))) =
       0;
  WR4: SIZEOF(QUERY(ebwm
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN
                                TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(eb
                                        <* ebwm\edge_based_wireframe_model.ebwm_boundary
                                        | NOT (SIZEOF(QUERY(pline_edges
                                                            <* QUERY(edges
                                                                     <* eb.ces_edges
                                                                     | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLYLINE' IN
                                                                        TYPEOF(edges\edge_curve.edge_geometry)))
                                                            | NOT (SIZEOF(pline_edges\edge_curve.edge_geometry\polyline.points) >
                                                                   2))) =
                                               0))) =
                           0))) =
       0;
  WR5: SIZEOF(QUERY(ebwm
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN
                                TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(eb
                                        <* ebwm\edge_based_wireframe_model.ebwm_boundary
                                        | NOT (SIZEOF(QUERY(edges
                                                            <* eb.ces_edges
                                                            | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_POINT' IN
                                                                    TYPEOF(edges.edge_start)) AND
                                                                   ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_POINT' IN
                                                                    TYPEOF(edges.edge_end))))) =
                                               0))) =
                           0))) =
       0;
  WR6: SIZEOF(QUERY(ebwm
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN
                                TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(eb
                                        <* ebwm\edge_based_wireframe_model.ebwm_boundary
                                        | NOT (SIZEOF(QUERY(edges
                                                            <* eb.ces_edges
                                                            | NOT valid_wireframe_edge_curve(edges\edge_curve.edge_geometry))) =
                                               0))) =
                           0))) =
       0;
  WR7: SIZEOF(QUERY(ebwm
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN
                                TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(eb
                                        <* ebwm\edge_based_wireframe_model.ebwm_boundary
                                        | NOT (SIZEOF(QUERY(edges
                                                            <* eb.ces_edges
                                                            | NOT (valid_wireframe_vertex_point(edges.edge_start\vertex_point.vertex_geometry) AND
                                                                   valid_wireframe_vertex_point(edges.edge_end\vertex_point.vertex_geometry)))) =
                                               0))) =
                           0))) =
       0;
  WR8: SIZEOF(QUERY(mi
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)))
                    | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN
                           TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) =
       0;
  WR9: SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
END_ENTITY;

(* "edge_curve" USE from SCHEMA topology_schema *)
(* "edge_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,TOPOLOGY_SCHEMA *)
ENTITY edge_curve
  SUBTYPE OF (edge, geometric_representation_item);
  edge_geometry : curve;
  same_sense    : BOOLEAN;
END_ENTITY;

(* "edge_loop" USE from SCHEMA topology_schema *)
(* "edge_loop" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,TOPOLOGY_SCHEMA *)
ENTITY edge_loop
  SUBTYPE OF (loop, path);
DERIVE
  ne : INTEGER := SIZEOF(SELF\path.edge_list);
WHERE
  WR1: (SELF\path.edge_list[1].edge_start) :=: (SELF\path.edge_list[ne].edge_end);
END_ENTITY;

(* "edge_sealing" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY edge_sealing
  SUBTYPE OF (line_based_llai);
END_ENTITY;

(* "edge_sealing_llai_specification" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY edge_sealing_llai_specification
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "electric_charge_measure_with_unit" USE from SCHEMA measure_schema *)
(* "electric_charge_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY electric_charge_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ELECTRIC_CHARGE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "electric_charge_unit" USE from SCHEMA measure_schema *)
(* "electric_charge_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY electric_charge_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.coulomb);
END_ENTITY;

(* "electric_current_measure_with_unit" USE from SCHEMA measure_schema *)
(* "electric_current_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY electric_current_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ELECTRIC_CURRENT_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "electric_current_unit" USE from SCHEMA measure_schema *)
(* "electric_current_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY electric_current_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

(* "electric_potential_measure_with_unit" USE from SCHEMA measure_schema *)
(* "electric_potential_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY electric_potential_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ELECTRIC_POTENTIAL_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "electric_potential_unit" USE from SCHEMA measure_schema *)
(* "electric_potential_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY electric_potential_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.volt);
END_ENTITY;

(* "elementary_brep_shape_representation" USE from SCHEMA geometric_model_schema *)
(* "elementary_brep_shape_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY elementary_brep_shape_representation
  SUBTYPE OF (shape_representation);
  SELF\representation.items : SET [1 : ?] OF advanced_brep_shape_representation_items_select;
WHERE
  WR1: SIZEOF(QUERY(it
                    <* SELF.items
                    | SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MANIFOLD_SOLID_BREP',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM'] *
                             TYPEOF(it)) =
                      1)) >
       0;
  WR2: SIZEOF(QUERY(msb
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it))
                    | NOT (SIZEOF(QUERY(csh
                                        <* msb_shells(msb)
                                        | NOT (SIZEOF(QUERY(fcs
                                                            <* csh.cfs_faces
                                                            | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FACE_SURFACE' IN
                                                                   TYPEOF(fcs)))) =
                                               0))) =
                           0))) =
       0;
  WR3: SIZEOF(QUERY(msb
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it))
                    | NOT (SIZEOF(QUERY(csh
                                        <* msb_shells(msb)
                                        | NOT (SIZEOF(QUERY(fcs
                                                            <* csh\connected_face_set.cfs_faces
                                                            | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ELEMENTARY_SURFACE' IN
                                                                    TYPEOF(fcs\face_surface.face_geometry))))) =
                                               0))) =
                           0))) =
       0;
  WR4: SIZEOF(QUERY(msb
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it))
                    | NOT (SIZEOF(QUERY(csh
                                        <* msb_shells(msb)
                                        | NOT (SIZEOF(QUERY(fcs
                                                            <* csh\connected_face_set.cfs_faces
                                                            | NOT (SIZEOF(QUERY(elp_fbnds
                                                                                <* QUERY(bnds
                                                                                         <* fcs.bounds
                                                                                         | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN
                                                                                           TYPEOF(bnds.bound))
                                                                                | NOT (SIZEOF(QUERY(oe
                                                                                                    <* elp_fbnds.bound\path.edge_list
                                                                                                    | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_CURVE' IN
                                                                                                           TYPEOF(oe.edge_element)))) =
                                                                                       0))) =
                                                                   0))) =
                                               0))) =
                           0))) =
       0;
  WR5: SIZEOF(QUERY(msb
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it))
                    | NOT (SIZEOF(QUERY(csh
                                        <* msb_shells(msb)
                                        | NOT (SIZEOF(QUERY(fcs
                                                            <* csh\connected_face_set.cfs_faces
                                                            | NOT (SIZEOF(QUERY(elp_fbnds
                                                                                <* QUERY(bnds
                                                                                         <* fcs.bounds
                                                                                         | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN
                                                                                           TYPEOF(bnds.bound))
                                                                                | NOT (SIZEOF(QUERY(oe
                                                                                                    <* elp_fbnds.bound\path.edge_list
                                                                                                    | NOT (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LINE',
                                                                                                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONIC',
                                                                                                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLYLINE'] *
                                                                                                                  TYPEOF(oe.edge_element\edge_curve.edge_geometry)) =
                                                                                                           1))) =
                                                                                       0))) =
                                                                   0))) =
                                               0))) =
                           0))) =
       0;
  WR6: SIZEOF(QUERY(msb
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it))
                    | NOT (SIZEOF(QUERY(csh
                                        <* msb_shells(msb)
                                        | NOT (SIZEOF(QUERY(fcs
                                                            <* csh\connected_face_set.cfs_faces
                                                            | NOT (SIZEOF(QUERY(elp_fbnds
                                                                                <* QUERY(bnds
                                                                                         <* fcs.bounds
                                                                                         | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN
                                                                                           TYPEOF(bnds.bound))
                                                                                | NOT (SIZEOF(QUERY(oe
                                                                                                    <* elp_fbnds.bound\path.edge_list
                                                                                                    | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_POINT' IN
                                                                                                            TYPEOF(oe.edge_start)) AND
                                                                                                           ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_POINT' IN
                                                                                                            TYPEOF(oe.edge_end))))) =
                                                                                       0))) =
                                                                   0))) =
                                               0))) =
                           0))) =
       0;
  WR7: SIZEOF(QUERY(msb
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it))
                    | NOT (SIZEOF(QUERY(csh
                                        <* msb_shells(msb)
                                        | NOT (SIZEOF(QUERY(fcs
                                                            <* csh\connected_face_set.cfs_faces
                                                            | NOT (SIZEOF(QUERY(elp_fbnds
                                                                                <* QUERY(bnds
                                                                                         <* fcs.bounds
                                                                                         | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN
                                                                                           TYPEOF(bnds.bound))
                                                                                | NOT (SIZEOF(QUERY(oe
                                                                                                    <* elp_fbnds.bound\path.edge_list
                                                                                                    | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLYLINE' IN
                                                                                                       TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND
                                                                                                      (NOT (SIZEOF(oe\oriented_edge.edge_element\edge_curve.edge_geometry\polyline.points) >=
                                                                                                            3)))) =
                                                                                       0))) =
                                                                   0))) =
                                               0))) =
                           0))) =
       0;
  WR8: SIZEOF(QUERY(msb
                    <* QUERY(it
                             <* items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it))
                    | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ORIENTED_CLOSED_SHELL' IN
                      TYPEOF(msb\manifold_solid_brep.outer))) =
       0;
  WR9: SIZEOF(QUERY(brv
                    <* QUERY(it
                             <* items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BREP_WITH_VOIDS' IN TYPEOF(it))
                    | NOT (SIZEOF(QUERY(csh <* brv\brep_with_voids.voids | csh\oriented_closed_shell.orientation)) =
                           0))) =
       0;
  WR10: SIZEOF(QUERY(mi
                     <* QUERY(it
                              <* items
                              | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM' IN TYPEOF(it))
                     | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ELEMENTARY_BREP_SHAPE_REPRESENTATION' IN
                            TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) =
        0;
  WR11: SIZEOF(QUERY(msb
                     <* QUERY(it
                              <* SELF.items
                              | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it))
                     | NOT (SIZEOF(QUERY(csh
                                         <* msb_shells(msb)
                                         | NOT (SIZEOF(QUERY(fcs
                                                             <* csh\connected_face_set.cfs_faces
                                                             | NOT (SIZEOF(QUERY(vlp_fbnds
                                                                                 <* QUERY(bnds
                                                                                          <* fcs.bounds
                                                                                          | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_LOOP' IN
                                                                                            TYPEOF(bnds.bound))
                                                                                 | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_POINT' IN
                                                                                         TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND
                                                                                        ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CARTESIAN_POINT' IN
                                                                                         TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))))) =
                                                                    0))) =
                                                0))) =
                            0))) =
        0;
END_ENTITY;

(* "elementary_function" USE from SCHEMA mathematical_functions_schema *)
(* "elementary_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY elementary_function
  SUBTYPE OF (maths_function, generic_literal);
  func_id : elementary_function_enumerators;
END_ENTITY;

(* "elementary_space" USE from SCHEMA mathematical_functions_schema *)
(* "elementary_space" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY elementary_space
  SUBTYPE OF (maths_space, generic_literal);
  space_id : elementary_space_enumerators;
END_ENTITY;

(* "elementary_surface" USE from SCHEMA geometry_schema *)
(* "elementary_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRY_SCHEMA *)
ENTITY elementary_surface
  SUPERTYPE OF (ONEOF(plane, cylindrical_surface, conical_surface, spherical_surface, toroidal_surface))
  SUBTYPE OF (surface);
  position : axis2_placement_3d;
END_ENTITY;

(* "ellipse" USE from SCHEMA geometry_schema *)
(* "ellipse" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY ellipse
  SUBTYPE OF (conic);
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
END_ENTITY;

(* "ellipsoid" USE from SCHEMA geometric_model_schema *)
(* "ellipsoid" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY ellipsoid
  SUBTYPE OF (geometric_representation_item);
  position    : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  semi_axis_3 : positive_length_measure;
END_ENTITY;

(* "energy_measure_with_unit" USE from SCHEMA measure_schema *)
(* "energy_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY energy_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ENERGY_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "energy_unit" USE from SCHEMA measure_schema *)
(* "energy_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY energy_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.joule);
END_ENTITY;

(* "environment" USE from SCHEMA iso13584_generic_expressions_schema *)
(* "environment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHS_VALUE_MIM,ISO13584_GENERIC_EXPRESSIONS_SCHEMA *)
ENTITY environment;
  syntactic_representation : generic_variable;
  semantics                : variable_semantics;
END_ENTITY;

(* "equals_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "equals_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY equals_expression
  SUBTYPE OF (binary_boolean_expression);
END_ENTITY;

(* "evaluated_degenerate_pcurve" USE from SCHEMA geometry_schema *)
(* "evaluated_degenerate_pcurve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY evaluated_degenerate_pcurve
  SUBTYPE OF (degenerate_pcurve);
  equivalent_point : cartesian_point;
END_ENTITY;

(* "exclusive_product_concept_feature_category" USE from SCHEMA product_class_mim *)
(* "exclusive_product_concept_feature_category" Path: PRODUCT_CLASS_MIM *)
ENTITY exclusive_product_concept_feature_category
  SUBTYPE OF (product_concept_feature_category);
END_ENTITY;

(* "executed_action" USE from SCHEMA action_schema *)
(* "executed_action" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,EXTERNAL_MODEL_MIM,FILE_IDENTIFICATION_MIM,ACTION_SCHEMA *)
ENTITY executed_action
  SUBTYPE OF (action);
END_ENTITY;

(* "exp_function" USE from SCHEMA iso13584_expressions_schema *)
(* "exp_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY exp_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

(* "expanded_uncertainty" USE from SCHEMA qualified_measure_schema *)
(* "expanded_uncertainty" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTENDED_MEASURE_REPRESENTATION_MIM,QUALIFIED_MEASURE_SCHEMA *)
ENTITY expanded_uncertainty
  SUBTYPE OF (standard_uncertainty);
  coverage_factor : REAL;
END_ENTITY;

(* "explicit_table_function" USE from SCHEMA mathematical_functions_schema *)
(* "explicit_table_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY explicit_table_function
  ABSTRACT SUPERTYPE OF (ONEOF(listed_real_data, listed_integer_data, listed_logical_data, listed_string_data,
                               listed_complex_number_data, listed_data, externally_listed_data,
                               linearized_table_function, basic_sparse_matrix))
  SUBTYPE OF (maths_function);
  index_base : zero_or_one;
  shape      : LIST [1 : ?] OF positive_integer;
END_ENTITY;

(* "expression" USE from SCHEMA iso13584_expressions_schema *)
(* "expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY expression
  ABSTRACT SUPERTYPE OF (ONEOF(numeric_expression, boolean_expression, string_expression))
  SUBTYPE OF (generic_expression);
END_ENTITY;

(* "expression_conversion_based_unit" USE from SCHEMA value_with_unit_extension_mim *)
(* "expression_conversion_based_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,VALUE_WITH_UNIT_EXTENSION_MIM *)
ENTITY expression_conversion_based_unit
  SUBTYPE OF (context_dependent_unit, variable_semantics);
INVERSE
  associated_variable_environment : environment FOR semantics;
END_ENTITY;

(* "expression_denoted_function" USE from SCHEMA mathematical_functions_schema *)
(* "expression_denoted_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY expression_denoted_function
  SUBTYPE OF (maths_function, unary_generic_expression);
DERIVE
  expr : generic_expression := SELF\unary_generic_expression.operand;
WHERE
  WR1: (schema_prefix + 'FUNCTION_SPACE') IN TYPEOF(values_space_of(expr));
END_ENTITY;

(* "extended_tuple_space" USE from SCHEMA mathematical_functions_schema *)
(* "extended_tuple_space" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY extended_tuple_space
  SUBTYPE OF (maths_space, generic_literal);
  base     : tuple_space;
  extender : maths_space;
WHERE
  WR1: expression_is_constant(base) AND expression_is_constant(extender);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: extender <> the_empty_space;
END_ENTITY;

(* "external_class_library" USE from SCHEMA external_class_mim *)
(* "external_class_library" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,EXTERNAL_CLASS_MIM *)
ENTITY external_class_library
  SUBTYPE OF (external_source);
END_ENTITY;

(* "external_identification_assignment" USE from SCHEMA management_resources_schema *)
(* "external_identification_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTION_GEOMETRY_MIM,BASIC_CURVE_MIM,MANAGEMENT_RESOURCES_SCHEMA *)
ENTITY external_identification_assignment
  ABSTRACT SUPERTYPE
  SUBTYPE OF (identification_assignment);
  source : external_source;
END_ENTITY;

(* "external_identification_assignment_relationship" USE from SCHEMA management_resources_schema *)
(* "external_identification_assignment_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTION_GEOMETRY_MIM,BASIC_CURVE_MIM,MANAGEMENT_RESOURCES_SCHEMA *)
ENTITY external_identification_assignment_relationship;
  id            : OPTIONAL identifier;
  description   : OPTIONAL text;
  relating      : external_identification_assignment;
  related       : external_identification_assignment;
  relation_type : STRING;
WHERE
  WR1: acyclic_external_identification_assignment_relationship(SELF, [related],
                                                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EXTERNAL_IDENTIFICATION_ASSIGNMENT_RELATIONSHIP');
END_ENTITY;

(* "external_source" USE from SCHEMA external_reference_schema *)
(* "external_source" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,EXTERNAL_REFERENCE_SCHEMA *)
ENTITY external_source;
  source_id : source_item;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF,
                     'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <=
       1;
END_ENTITY;

(* "external_source_relationship" USE from SCHEMA external_reference_schema *)
(* "external_source_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,EXTERNAL_REFERENCE_SCHEMA *)
ENTITY external_source_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_source : external_source;
  related_source  : external_source;
END_ENTITY;

(* "externally_defined_character_glyph" USE from SCHEMA presentation_definition_schema *)
(* "externally_defined_character_glyph" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY externally_defined_character_glyph
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

(* "externally_defined_class" USE from SCHEMA external_class_mim *)
(* "externally_defined_class" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,EXTERNAL_CLASS_MIM *)
ENTITY externally_defined_class
  SUBTYPE OF (class, externally_defined_item);
END_ENTITY;

(* "externally_defined_colour" USE from SCHEMA colour_mim *)
(* "externally_defined_colour" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,COLOUR_MIM *)
ENTITY externally_defined_colour
  SUBTYPE OF (colour_specification, externally_defined_item);
END_ENTITY;

(* "externally_defined_curve_font" USE from SCHEMA presentation_appearance_schema *)
(* "externally_defined_curve_font" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,CURVE_APPEARANCE_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY externally_defined_curve_font
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

(* "externally_defined_general_property" USE from SCHEMA external_properties_mim *)
(* "externally_defined_general_property" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,EXTERNAL_PROPERTIES_MIM *)
ENTITY externally_defined_general_property
  SUBTYPE OF (general_property, externally_defined_item);
END_ENTITY;

(* "externally_defined_item" USE from SCHEMA external_reference_schema *)
(* "externally_defined_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,EXTERNAL_REFERENCE_SCHEMA *)
ENTITY externally_defined_item;
  item_id : source_item;
  source  : external_source;
END_ENTITY;

(* "externally_defined_item_relationship" USE from SCHEMA external_reference_schema *)
(* "externally_defined_item_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,EXTERNAL_REFERENCE_SCHEMA *)
ENTITY externally_defined_item_relationship;
  name          : label;
  description   : OPTIONAL text;
  relating_item : externally_defined_item;
  related_item  : externally_defined_item;
END_ENTITY;

(* "externally_defined_item_with_multiple_references" USE from SCHEMA external_reference_schema *)
(* "externally_defined_item_with_multiple_references" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,EXTERNAL_REFERENCE_SCHEMA *)
ENTITY externally_defined_item_with_multiple_references
  SUBTYPE OF (externally_defined_item);
  references : LIST [1 : ?] OF UNIQUE source_item;
UNIQUE
  UR1: references;
WHERE
  WR1: NOT (SELF\externally_defined_item.item_id IN references);
END_ENTITY;

(* "externally_defined_marker" USE from SCHEMA curve_appearance_mim *)
(* "externally_defined_marker" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,CURVE_APPEARANCE_MIM *)
ENTITY externally_defined_marker
  SUBTYPE OF (externally_defined_symbol, pre_defined_marker);
END_ENTITY;

(* "externally_defined_style" USE from SCHEMA presentation_appearance_schema *)
(* "externally_defined_style" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY externally_defined_style
  SUBTYPE OF (externally_defined_item, founded_item);
END_ENTITY;

(* "externally_defined_symbol" USE from SCHEMA presentation_definition_schema *)
(* "externally_defined_symbol" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY externally_defined_symbol
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

(* "externally_defined_terminator_symbol" USE from SCHEMA curve_appearance_mim *)
(* "externally_defined_terminator_symbol" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,CURVE_APPEARANCE_MIM *)
ENTITY externally_defined_terminator_symbol
  SUBTYPE OF (externally_defined_symbol);
END_ENTITY;

(* "externally_defined_text_font" USE from SCHEMA presentation_resource_schema *)
(* "externally_defined_text_font" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_RESOURCE_SCHEMA *)
ENTITY externally_defined_text_font
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

(* "externally_listed_data" USE from SCHEMA mathematical_functions_schema *)
(* "externally_listed_data" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY externally_listed_data
  SUBTYPE OF (explicit_table_function, generic_literal, externally_defined_item);
  value_range : maths_space;
WHERE
  WR1: expression_is_constant(value_range);
END_ENTITY;

(* "extruded_area_solid" USE from SCHEMA geometric_model_schema *)
(* "extruded_area_solid" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CURVE_SWEPT_SOLID_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY extruded_area_solid
  SUBTYPE OF (swept_area_solid);
  extruded_direction : direction;
  depth              : positive_length_measure;
WHERE
  WR1: dot_product((SELF\swept_area_solid.swept_area.basis_surface\elementary_surface.position.p[3]),
                   extruded_direction) <>
       0.0;
END_ENTITY;

(* "extruded_face_solid" USE from SCHEMA geometric_model_schema *)
(* "extruded_face_solid" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY extruded_face_solid
  SUBTYPE OF (swept_face_solid);
  extruded_direction : direction;
  depth              : positive_length_measure;
WHERE
  WR1: dot_product((SELF\swept_face_solid.swept_face.face_geometry\elementary_surface.position.p[3]),
                   extruded_direction) <>
       0.0;
END_ENTITY;

(* "face" USE from SCHEMA topology_schema *)
(* "face" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,TOPOLOGY_SCHEMA *)
ENTITY face
  SUPERTYPE OF (ONEOF(face_surface, oriented_face))
  SUBTYPE OF (topological_representation_item);
  bounds : SET [1 : ?] OF face_bound;
WHERE
  WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
  WR2: SIZEOF(QUERY(temp
                    <* bounds
                    | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF(temp))) <=
       1;
END_ENTITY;

(* "face_bound" USE from SCHEMA topology_schema *)
(* "face_bound" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,TOPOLOGY_SCHEMA *)
ENTITY face_bound
  SUBTYPE OF (topological_representation_item);
  bound       : loop;
  orientation : BOOLEAN;
END_ENTITY;

(* "face_outer_bound" USE from SCHEMA topology_schema *)
(* "face_outer_bound" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,TOPOLOGY_SCHEMA *)
ENTITY face_outer_bound
  SUBTYPE OF (face_bound);
END_ENTITY;

(* "face_surface" USE from SCHEMA topology_schema *)
(* "face_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,TOPOLOGY_SCHEMA *)
ENTITY face_surface
  SUBTYPE OF (face, geometric_representation_item);
  face_geometry : surface;
  same_sense    : BOOLEAN;
WHERE
  WR1: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ORIENTED_SURFACE' IN TYPEOF(face_geometry));
END_ENTITY;

(* "faceted_brep" USE from SCHEMA geometric_model_schema *)
(* "faceted_brep" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,AIC_CSG,GEOMETRIC_MODEL_SCHEMA *)
ENTITY faceted_brep
  SUBTYPE OF (manifold_solid_brep);
END_ENTITY;

(* "faceted_brep_shape_representation" USE from SCHEMA aic_faceted_brep *)
(* "faceted_brep_shape_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,AIC_FACETED_BREP *)
ENTITY faceted_brep_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF(QUERY(it
                    <* items
                    | NOT (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FACETED_BREP',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AXIS2_PLACEMENT_3D'] *
                                  TYPEOF(it)) =
                           1))) =
       0;
  WR2: SIZEOF(QUERY(it
                    <* items
                    | (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FACETED_BREP',
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM'] *
                              TYPEOF(it)) =
                       1))) >
       0;
  WR3: SIZEOF(QUERY(fbrep
                    <* QUERY(it
                             <* items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FACETED_BREP' IN TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(csh
                                        <* msb_shells(fbrep)
                                        | NOT (SIZEOF(QUERY(fcs
                                                            <* csh\connected_face_set.cfs_faces
                                                            | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FACE_SURFACE' IN
                                                                    TYPEOF(fcs)) AND
                                                                   (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PLANE' IN
                                                                     TYPEOF(fcs\face_surface.face_geometry)) AND
                                                                    ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CARTESIAN_POINT' IN
                                                                     TYPEOF(fcs\face_surface.face_geometry\elementary_surface.position.location)))))) =
                                               0))) =
                           0))) =
       0;
  WR4: SIZEOF(QUERY(fbrep
                    <* QUERY(it
                             <* items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FACETED_BREP' IN TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(csh
                                        <* msb_shells(fbrep)
                                        | NOT (SIZEOF(QUERY(fcs
                                                            <* csh\connected_face_set.cfs_faces
                                                            | NOT (SIZEOF(QUERY(bnds
                                                                                <* fcs.bounds
                                                                                | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FACE_OUTER_BOUND' IN
                                                                                   TYPEOF(bnds)))) =
                                                                   1))) =
                                               0))) =
                           0))) =
       0;
  WR5: SIZEOF(QUERY(msb
                    <* QUERY(it
                             <* items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MANIFOLD_SOLID_BREP' IN
                                TYPEOF(it)))
                    | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ORIENTED_CLOSED_SHELL' IN
                       TYPEOF(msb\manifold_solid_brep.outer)))) =
       0;
  WR6: SIZEOF(QUERY(brv
                    <* QUERY(it
                             <* items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BREP_WITH_VOIDS' IN TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(csh <* brv\brep_with_voids.voids | csh\oriented_closed_shell.orientation)) =
                           0))) =
       0;
  WR7: SIZEOF(QUERY(mi
                    <* QUERY(it
                             <* items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)))
                    | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FACETED_BREP_SHAPE_REPRESENTATION' IN
                           TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) =
       0;
END_ENTITY;

(* "faceted_primitive" USE from SCHEMA geometric_model_schema *)
(* "faceted_primitive" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY faceted_primitive
  SUPERTYPE OF (ONEOF(tetrahedron, convex_hexahedron))
  SUBTYPE OF (geometric_representation_item);
  points : LIST [4 : ?] OF UNIQUE cartesian_point;
WHERE
  WR1: points[1].dim = 3;
END_ENTITY;

(* "fiber_orientation_angle_tolerance_deviation_area" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY fiber_orientation_angle_tolerance_deviation_area
  SUBTYPE OF (area_based_llai);
END_ENTITY;

(* "fiber_orientation_angle_tolerance_deviation_area_llai_specification" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY fiber_orientation_angle_tolerance_deviation_area_llai_specification
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "fill_area_style_colour" USE from SCHEMA presentation_appearance_schema *)
(* "fill_area_style_colour" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY fill_area_style_colour;
  name        : label;
  fill_colour : colour;
END_ENTITY;

(* "finite_function" USE from SCHEMA mathematical_functions_schema *)
(* "finite_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY finite_function
  SUBTYPE OF (maths_function, generic_literal);
  pairs : SET [1 : ?] OF LIST [2 : 2] OF maths_value;
WHERE
  WR1: VALUE_UNIQUE(list_selected_components(pairs, 1));
END_ENTITY;

(* "finite_integer_interval" USE from SCHEMA mathematical_functions_schema *)
(* "finite_integer_interval" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY finite_integer_interval
  SUBTYPE OF (maths_space, generic_literal);
  min : INTEGER;
  max : INTEGER;
DERIVE
  size : positive_integer := max - min + 1;
WHERE
  WR1: min <= max;
END_ENTITY;

(* "finite_real_interval" USE from SCHEMA mathematical_functions_schema *)
(* "finite_real_interval" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY finite_real_interval
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
  max         : REAL;
  max_closure : open_closed;
WHERE
  WR1: min < max;
END_ENTITY;

(* "finite_space" USE from SCHEMA mathematical_functions_schema *)
(* "finite_space" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY finite_space
  SUBTYPE OF (maths_space, generic_literal);
  members : SET OF maths_value;
WHERE
  WR1: VALUE_UNIQUE(members);
  WR2: SIZEOF(QUERY(expr
                    <* QUERY(member
                             <* members
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GENERIC_EXPRESSION' IN
                               TYPEOF(member))
                    | NOT expression_is_constant(expr))) =
       0;
  WR3: no_cyclic_space_reference(SELF, []);
END_ENTITY;

(* "flat_pattern_ply_representation_relationship" USE from SCHEMA composite_constituent_shape_mim *)
(* "flat_pattern_ply_representation_relationship" Path: COMPOSITE_CONSTITUENT_SHAPE_MIM *)
ENTITY flat_pattern_ply_representation_relationship
  SUBTYPE OF (shape_representation_relationship);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHAPE_REPRESENTATION' IN
       (TYPEOF(SELF\representation_relationship.rep_1) * TYPEOF(SELF\representation_relationship.rep_2));
  WR2: SELF\representation_relationship.rep_1\representation.context_of_items\geometric_representation_context.coordinate_space_dimension =
       3;
END_ENTITY;

(* "force_measure_with_unit" USE from SCHEMA measure_schema *)
(* "force_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY force_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FORCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "force_unit" USE from SCHEMA measure_schema *)
(* "force_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY force_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.newton);
END_ENTITY;

(* "format_function" USE from SCHEMA iso13584_expressions_schema *)
(* "format_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY format_function
  SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
  value_to_format : generic_expression := SELF\binary_generic_expression.operands[1];
  format_string   : generic_expression := SELF\binary_generic_expression.operands[2];
WHERE
  WR1: (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NUMERIC_EXPRESSION') IN TYPEOF(value_to_format)) AND
       (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.STRING_EXPRESSION') IN TYPEOF(format_string));
END_ENTITY;

(* "founded_item" IMPLICIT from SCHEMA representation_schema *)
ENTITY founded_item
  SUPERTYPE OF (ONEOF(character_glyph_style_outline, character_glyph_style_stroke, curve_style, curve_style_font,
                      curve_style_font_and_scaling, curve_style_font_pattern, externally_defined_style, point_style,
                      presentation_style_assignment, surface_style_usage, text_style));
DERIVE
  users : SET [0 : ?] OF founded_item_select := using_items(SELF, []);
WHERE
  WR1: SIZEOF(users) > 0;
  WR2: NOT (SELF IN users);
END_ENTITY;

(* "free_variable_semantics" USE from SCHEMA mathematical_functions_schema *)
(* "free_variable_semantics" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY free_variable_semantics
  SUBTYPE OF (variable_semantics);
END_ENTITY;

(* "frequency_measure_with_unit" USE from SCHEMA measure_schema *)
(* "frequency_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY frequency_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FREQUENCY_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "frequency_unit" USE from SCHEMA measure_schema *)
(* "frequency_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY frequency_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.hertz);
END_ENTITY;

(* "function_application" USE from SCHEMA mathematical_functions_schema *)
(* "function_application" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY function_application
  SUBTYPE OF (multiple_arity_generic_expression);
  func      : maths_function_select;
  arguments : LIST [1 : ?] OF maths_expression;
DERIVE
  SELF\multiple_arity_generic_expression.operands                                        : LIST [2 : ?] OF generic_expression := [convert_to_maths_function(func)] +
                                                                                                                                 convert_to_operands(arguments);
WHERE
  WR1: function_applicability(func, arguments);
END_ENTITY;

(* "function_space" USE from SCHEMA mathematical_functions_schema *)
(* "function_space" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY function_space
  SUBTYPE OF (maths_space, generic_literal);
  domain_constraint : space_constraint_type;
  domain_argument   : maths_space;
  range_constraint  : space_constraint_type;
  range_argument    : maths_space;
WHERE
  WR1: expression_is_constant(domain_argument) AND expression_is_constant(range_argument);
  WR2: (domain_argument <> the_empty_space) AND (range_argument <> the_empty_space);
  WR3: (domain_constraint <> sc_member) OR NOT member_of(the_empty_space, domain_argument);
  WR4: (range_constraint <> sc_member) OR NOT member_of(the_empty_space, range_argument);
  WR5: NOT (any_space_satisfies(domain_constraint, domain_argument) AND
            any_space_satisfies(range_constraint, range_argument));
END_ENTITY;

(* "functionally_defined_transformation" IMPLICIT from SCHEMA representation_schema *)
ENTITY functionally_defined_transformation;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

(* "general_linear_function" USE from SCHEMA mathematical_functions_schema *)
(* "general_linear_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY general_linear_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  sum_index                             : one_or_two;
DERIVE
  mat : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_2d_table(mat);
  WR2: (space_dimension(mat.range) = 1) AND subspace_of_es(factor1(mat.range), es_numbers);
END_ENTITY;

(* "general_material_property" USE from SCHEMA generic_material_aspects_mim *)
(* "general_material_property" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,GENERIC_MATERIAL_ASPECTS_MIM *)
ENTITY general_material_property
  SUBTYPE OF (general_property);
WHERE
  WR1: SIZEOF(QUERY(gpa
                    <* USEDIN(SELF,
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GENERAL_PROPERTY_ASSOCIATION.BASE_DEFINITION')
                    | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MATERIAL_PROPERTY' IN
                           TYPEOF(gpa\general_property_association.derived_definition)))) =
       0;
END_ENTITY;

(* "general_property" USE from SCHEMA product_property_definition_schema *)
(* "general_property" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,PROPERTY_ASSIGNMENT_MIM,PRODUCT_PROPERTY_DEFINITION_SCHEMA *)
ENTITY general_property;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

(* "general_property_association" USE from SCHEMA product_property_definition_schema *)
(* "general_property_association" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,PRODUCT_PROPERTY_DEFINITION_SCHEMA *)
ENTITY general_property_association;
  name               : label;
  description        : OPTIONAL text;
  base_definition    : general_property;
  derived_definition : derived_property_select;
WHERE
  WR1: (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSIONAL_LOCATION',
                'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSIONAL_SIZE',
                'SHAPE_TOLERANCE_SCHEMA.GEOMETRIC_TOLERANCE'] *
               TYPEOF(derived_definition)) >
        0) OR
       (SIZEOF(USEDIN(derived_definition,
                      'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GENERAL_PROPERTY_ASSOCIATION.DERIVED_DEFINITION')) =
        1);
  WR2: (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSIONAL_LOCATION',
                'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSIONAL_SIZE',
                'SHAPE_TOLERANCE_SCHEMA.GEOMETRIC_TOLERANCE'] *
               TYPEOF(derived_definition)) >
        0) OR
       (derived_definition.name = base_definition.name);
END_ENTITY;

(* "general_property_relationship" USE from SCHEMA product_property_definition_schema *)
(* "general_property_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,PROPERTY_ASSIGNMENT_MIM,PRODUCT_PROPERTY_DEFINITION_SCHEMA *)
ENTITY general_property_relationship;
  name              : label;
  description       : OPTIONAL text;
  relating_property : general_property;
  related_property  : general_property;
END_ENTITY;

(* "generic_expression" USE from SCHEMA iso13584_generic_expressions_schema *)
(* "generic_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHS_VALUE_MIM,ISO13584_GENERIC_EXPRESSIONS_SCHEMA *)
ENTITY generic_expression
  ABSTRACT SUPERTYPE OF (ONEOF(simple_generic_expression, unary_generic_expression, binary_generic_expression,
                               multiple_arity_generic_expression));
WHERE
  WR1: is_acyclic(SELF);
END_ENTITY;

(* "generic_literal" USE from SCHEMA iso13584_generic_expressions_schema *)
(* "generic_literal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHS_VALUE_MIM,ISO13584_GENERIC_EXPRESSIONS_SCHEMA *)
ENTITY generic_literal
  ABSTRACT SUPERTYPE
  SUBTYPE OF (simple_generic_expression);
END_ENTITY;

(* "generic_product_definition_reference" USE from SCHEMA product_definition_schema *)
(* "generic_product_definition_reference" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,PRODUCT_DEFINITION_SCHEMA *)
ENTITY generic_product_definition_reference
  ABSTRACT SUPERTYPE OF (ONEOF(product_definition_reference, product_definition_reference_with_local_representation));
  source : external_source;
END_ENTITY;

(* "generic_variable" USE from SCHEMA iso13584_generic_expressions_schema *)
(* "generic_variable" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHS_VALUE_MIM,ISO13584_GENERIC_EXPRESSIONS_SCHEMA *)
ENTITY generic_variable
  ABSTRACT SUPERTYPE
  SUBTYPE OF (simple_generic_expression);
INVERSE
  interpretation : environment FOR syntactic_representation;
END_ENTITY;

(* "geometric_curve_set" USE from SCHEMA geometric_model_schema *)
(* "geometric_curve_set" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY geometric_curve_set
  SUBTYPE OF (geometric_set);
WHERE
  WR1: SIZEOF(QUERY(temp
                    <* SELF\geometric_set.elements
                    | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE' IN TYPEOF(temp)) OR
                           ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT' IN TYPEOF(temp))))) =
       0;
END_ENTITY;

(* "geometric_item_specific_usage" USE from SCHEMA shape_property_assignment_mim *)
(* "geometric_item_specific_usage" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM *)
ENTITY geometric_item_specific_usage
  SUBTYPE OF (item_identified_representation_usage);
  SELF\item_identified_representation_usage.definition          : geometric_item_specific_usage_select;
  SELF\item_identified_representation_usage.used_representation : shape_model;
  SELF\item_identified_representation_usage.identified_item     : geometric_model_item;
END_ENTITY;

(* "geometric_representation_context" USE from SCHEMA geometry_schema *)
(* "geometric_representation_context" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY geometric_representation_context
  SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
END_ENTITY;

(* "geometric_representation_item" USE from SCHEMA geometry_schema *)
(* "geometric_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY geometric_representation_item
  SUPERTYPE OF ((ONEOF(curve, direction)) ANDOR (ONEOF(curve, planar_extent)) ANDOR
                (ONEOF(annotation_fill_area, composite_text, curve, defined_character_glyph, point,
                       text_literal)) ANDOR
                ONEOF(point, direction, vector, placement, cartesian_transformation_operator, curve, surface,
                      edge_curve, face_surface, poly_loop, vertex_point, solid_model, boolean_result, sphere,
                      right_circular_cone, right_circular_cylinder, torus, block, right_angular_wedge, ellipsoid,
                      faceted_primitive, rectangular_pyramid, cyclide_segment_solid, volume, half_space_solid,
                      shell_based_surface_model, shell_based_wireframe_model, edge_based_wireframe_model,
                      geometric_set, tessellated_item) ANDOR
                (ONEOF(curve, point, vector)))
  SUBTYPE OF (representation_item);
DERIVE
  dim : dimension_count := dimension_of(SELF);
WHERE
  WR1: SIZEOF(QUERY(using_rep
                    <* using_representations(SELF)
                    | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN
                           TYPEOF(using_rep.context_of_items)))) =
       0;
END_ENTITY;

(* "geometric_set" USE from SCHEMA geometric_model_schema *)
(* "geometric_set" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY geometric_set
  SUPERTYPE OF (ONEOF(geometric_curve_set))
  SUBTYPE OF (geometric_representation_item);
  elements : SET [1 : ?] OF geometric_set_select;
END_ENTITY;

(* "geometrically_bounded_surface_shape_representation" USE from SCHEMA aic_geometrically_bounded_surface *)
(* "geometrically_bounded_surface_shape_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,AIC_GEOMETRICALLY_BOUNDED_SURFACE *)
ENTITY geometrically_bounded_surface_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF(QUERY(it
                    <* SELF.items
                    | NOT (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_SET',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AXIS2_PLACEMENT_3D'] *
                                  TYPEOF(it)) =
                           1))) =
       0;
  WR2: SIZEOF(QUERY(it
                    <* SELF.items
                    | SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_SET',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM'] *
                             TYPEOF(it)) =
                      1)) >
       0;
  WR3: SIZEOF(QUERY(mi
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM' IN TYPEOF(it))
                    | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION' IN
                            TYPEOF(mi\mapped_item.mapping_source.mapped_representation)) AND
                           (SIZEOF(QUERY(mr_it
                                         <* mi\mapped_item.mapping_source.mapped_representation.items
                                         | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_SET' IN
                                            TYPEOF(mr_it)))) >
                            0)))) =
       0;
  WR4: SIZEOF(QUERY(gs
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_SET' IN TYPEOF(it))
                    | NOT (SIZEOF(QUERY(pnt
                                        <* QUERY(gsel
                                                 <* gs\geometric_set.elements
                                                 | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT' IN
                                                   TYPEOF(gsel))
                                        | NOT (gbsf_check_point(pnt)))) =
                           0))) =
       0;
  WR5: SIZEOF(QUERY(gs
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_SET' IN TYPEOF(it))
                    | NOT (SIZEOF(QUERY(cv
                                        <* QUERY(gsel
                                                 <* gs\geometric_set.elements
                                                 | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE' IN
                                                   TYPEOF(gsel))
                                        | NOT (gbsf_check_curve(cv)))) =
                           0))) =
       0;
  WR6: SIZEOF(QUERY(gs
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_SET' IN TYPEOF(it))
                    | NOT (SIZEOF(QUERY(sf
                                        <* QUERY(gsel
                                                 <* gs\geometric_set.elements
                                                 | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE' IN
                                                   TYPEOF(gsel))
                                        | NOT (gbsf_check_surface(sf)))) =
                           0))) =
       0;
  WR7: SIZEOF(QUERY(gs
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_SET' IN TYPEOF(it))
                    | SIZEOF(QUERY(gsel
                                   <* gs\geometric_set.elements
                                   | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE' IN TYPEOF(gsel))) >
                      0)) >
       0;
END_ENTITY;

(* "geometrically_bounded_wireframe_shape_representation" USE from SCHEMA aic_geometrically_bounded_wireframe *)
(* "geometrically_bounded_wireframe_shape_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,AIC_GEOMETRICALLY_BOUNDED_WIREFRAME *)
ENTITY geometrically_bounded_wireframe_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF(QUERY(it
                    <* SELF.items
                    | NOT (SIZEOF(TYPEOF(it) *
                                  ['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_CURVE_SET',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AXIS2_PLACEMENT_3D',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM']) =
                           1))) =
       0;
  WR2: SIZEOF(QUERY(it
                    <* SELF.items
                    | (SIZEOF(TYPEOF(it) *
                              ['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_CURVE_SET',
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM']) =
                       1))) >=
       1;
  WR3: SIZEOF(QUERY(gcs
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_CURVE_SET' IN
                                TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(crv
                                        <* QUERY(elem
                                                 <* gcs\geometric_set.elements
                                                 | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE' IN
                                                    TYPEOF(elem)))
                                        | NOT valid_geometrically_bounded_wf_curve(crv))) =
                           0))) =
       0;
  WR4: SIZEOF(QUERY(gcs
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_CURVE_SET' IN
                                TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(pnts
                                        <* QUERY(elem
                                                 <* gcs\geometric_set.elements
                                                 | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT' IN
                                                    TYPEOF(elem)))
                                        | NOT valid_geometrically_bounded_wf_point(pnts))) =
                           0))) =
       0;
  WR5: SIZEOF(QUERY(gcs
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_CURVE_SET' IN
                                TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(cnc
                                        <* QUERY(elem
                                                 <* gcs\geometric_set.elements
                                                 | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONIC' IN
                                                    TYPEOF(elem)))
                                        | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AXIS2_PLACEMENT_3D' IN
                                               TYPEOF(cnc\conic.position)))) =
                           0))) =
       0;
  WR6: SIZEOF(QUERY(gcs
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_CURVE_SET' IN
                                TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(pline
                                        <* QUERY(elem
                                                 <* gcs\geometric_set.elements
                                                 | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLYLINE' IN
                                                    TYPEOF(elem)))
                                        | NOT (SIZEOF(pline\polyline.points) > 2))) =
                           0))) =
       0;
  WR7: SIZEOF(QUERY(mi
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)))
                    | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION' IN
                           TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) =
       0;
END_ENTITY;

(* "global_uncertainty_assigned_context" USE from SCHEMA representation_schema *)
(* "global_uncertainty_assigned_context" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,REPRESENTATION_SCHEMA *)
ENTITY global_uncertainty_assigned_context
  SUBTYPE OF (representation_context);
  uncertainty : SET [1 : ?] OF uncertainty_measure_with_unit;
END_ENTITY;

(* "global_unit_assigned_context" USE from SCHEMA measure_schema *)
(* "global_unit_assigned_context" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,MEASURE_SCHEMA *)
ENTITY global_unit_assigned_context
  SUBTYPE OF (representation_context);
  units : SET [1 : ?] OF unit;
END_ENTITY;

(* "group" USE from SCHEMA group_schema *)
(* "group" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,PLIB_CLASS_REFERENCE_MIM,EXTERNAL_CLASS_MIM,GROUP_SCHEMA *)
ENTITY group;
  name        : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

(* "group_assignment" USE from SCHEMA management_resources_schema *)
(* "group_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,MANAGEMENT_RESOURCES_SCHEMA *)
ENTITY group_assignment
  ABSTRACT SUPERTYPE;
  assigned_group : group;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

(* "group_relationship" USE from SCHEMA group_schema *)
(* "group_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PRODUCT_CLASS_MIM,GROUP_SCHEMA *)
ENTITY group_relationship;
  name           : label;
  description    : OPTIONAL text;
  relating_group : group;
  related_group  : group;
END_ENTITY;

(* "guide_curve" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY guide_curve
  SUBTYPE OF (line_based_llai);
END_ENTITY;

(* "guide_curve_llai_specification" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY guide_curve_llai_specification
  SUBTYPE OF (line_based_llai);
END_ENTITY;

(* "half_space_solid" USE from SCHEMA geometric_model_schema *)
(* "half_space_solid" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY half_space_solid
  SUBTYPE OF (geometric_representation_item);
  base_surface   : surface;
  agreement_flag : BOOLEAN;
END_ENTITY;

(* "homogeneous_linear_function" USE from SCHEMA mathematical_functions_schema *)
(* "homogeneous_linear_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY homogeneous_linear_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  sum_index                             : one_or_two;
DERIVE
  mat : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_2d_table(mat);
  WR2: (space_dimension(mat.range) = 1) AND subspace_of_es(factor1(mat.range), es_numbers);
END_ENTITY;

(* "hyperbola" USE from SCHEMA geometry_schema *)
(* "hyperbola" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY hyperbola
  SUBTYPE OF (conic);
  semi_axis      : positive_length_measure;
  semi_imag_axis : positive_length_measure;
END_ENTITY;

(* "id_attribute" USE from SCHEMA basic_attribute_schema *)
(* "id_attribute" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,BASIC_ATTRIBUTE_SCHEMA *)
ENTITY id_attribute;
  attribute_value : identifier;
  identified_item : id_attribute_select;
END_ENTITY;

(* "identification_assignment" USE from SCHEMA management_resources_schema *)
(* "identification_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,MANAGEMENT_RESOURCES_SCHEMA *)
ENTITY identification_assignment
  ABSTRACT SUPERTYPE;
  assigned_id : identifier;
  role        : identification_role;
END_ENTITY;

(* "identification_role" IMPLICIT from SCHEMA management_resources_schema *)
ENTITY identification_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

(* "illuminance_measure_with_unit" USE from SCHEMA measure_schema *)
(* "illuminance_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY illuminance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ILLUMINANCE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "illuminance_unit" USE from SCHEMA measure_schema *)
(* "illuminance_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY illuminance_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.lux);
END_ENTITY;

(* "imported_curve_function" USE from SCHEMA mathematical_functions_schema *)
(* "imported_curve_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY imported_curve_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : curve;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;

(* "imported_point_function" USE from SCHEMA mathematical_functions_schema *)
(* "imported_point_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY imported_point_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry : point;
END_ENTITY;

(* "imported_surface_function" USE from SCHEMA mathematical_functions_schema *)
(* "imported_surface_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY imported_surface_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : surface;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;

(* "imported_volume_function" USE from SCHEMA mathematical_functions_schema *)
(* "imported_volume_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY imported_volume_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : volume;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;

(* "included_text_block" USE from SCHEMA tagged_text_representation_mim *)
(* "included_text_block" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,TAGGED_TEXT_REPRESENTATION_MIM *)
ENTITY included_text_block
  SUBTYPE OF (mapped_item);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.STRUCTURED_TEXT_REPRESENTATION' IN
       TYPEOF(SELF\mapped_item.mapping_source.mapped_representation);
END_ENTITY;

(* "inclusion_product_concept_feature" USE from SCHEMA product_class_mim *)
(* "inclusion_product_concept_feature" Path: PRODUCT_CLASS_MIM *)
ENTITY inclusion_product_concept_feature
  SUBTYPE OF (conditional_concept_feature);
WHERE
  WR1: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PACKAGE_PRODUCT_CONCEPT_FEATURE' IN TYPEOF(SELF));
  WR2: SIZEOF(QUERY(cfr
                    <* USEDIN(SELF,
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONCEPT_FEATURE_RELATIONSHIP.RELATING_PRODUCT_CONCEPT_FEATURE')
                    | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN
                      TYPEOF(cfr))) +
       SIZEOF(QUERY(cfr
                    <* USEDIN(SELF,
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONCEPT_FEATURE_RELATIONSHIP.RELATED_PRODUCT_CONCEPT_FEATURE')
                    | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN
                      TYPEOF(cfr))) =
       0;
  WR3: SELF.condition.conditional_operator.name = 'implication';
END_ENTITY;

(* "index_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "index_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY index_expression
  SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
  operand : generic_expression := SELF\binary_generic_expression.operands[1];
  index   : generic_expression := SELF\binary_generic_expression.operands[2];
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.STRING_EXPRESSION' IN TYPEOF(operand)) AND
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(index));
  WR2: is_int_expr(index);
END_ENTITY;

(* "inductance_measure_with_unit" USE from SCHEMA measure_schema *)
(* "inductance_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY inductance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.INDUCTANCE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "inductance_unit" USE from SCHEMA measure_schema *)
(* "inductance_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY inductance_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.henry);
END_ENTITY;

(* "int_literal" USE from SCHEMA iso13584_expressions_schema *)
(* "int_literal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY int_literal
  SUBTYPE OF (literal_number);
  SELF\literal_number.the_value : INTEGER;
END_ENTITY;

(* "int_numeric_variable" USE from SCHEMA iso13584_expressions_schema *)
(* "int_numeric_variable" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY int_numeric_variable
  SUBTYPE OF (numeric_variable);
END_ENTITY;

(* "int_value_function" USE from SCHEMA iso13584_expressions_schema *)
(* "int_value_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY int_value_function
  SUBTYPE OF (value_function);
END_ENTITY;

(* "integer_defined_function" USE from SCHEMA iso13584_expressions_schema *)
(* "integer_defined_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY integer_defined_function
  ABSTRACT SUPERTYPE
  SUBTYPE OF (numeric_defined_function);
END_ENTITY;

(* "integer_interval_from_min" USE from SCHEMA mathematical_functions_schema *)
(* "integer_interval_from_min" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY integer_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min : INTEGER;
END_ENTITY;

(* "integer_interval_to_max" USE from SCHEMA mathematical_functions_schema *)
(* "integer_interval_to_max" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY integer_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max : INTEGER;
END_ENTITY;

(* "integer_representation_item" USE from SCHEMA basic_data_representation_mim *)
(* "integer_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,BASIC_DATA_REPRESENTATION_MIM *)
ENTITY integer_representation_item
  SUBTYPE OF (representation_item, int_literal);
END_ENTITY;

(* "integer_tuple_literal" USE from SCHEMA mathematical_functions_schema *)
(* "integer_tuple_literal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY integer_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST [1 : ?] OF INTEGER;
END_ENTITY;

(* "intersection_curve" USE from SCHEMA geometry_schema *)
(* "intersection_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY intersection_curve
  SUBTYPE OF (surface_curve);
WHERE
  WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
  WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) <>
       associated_surface(SELF\surface_curve.associated_geometry[2]);
END_ENTITY;

(* "interval_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "interval_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY interval_expression
  SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
DERIVE
  interval_low  : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
  interval_item : generic_expression := SELF\multiple_arity_generic_expression.operands[2];
  interval_high : generic_expression := SELF\multiple_arity_generic_expression.operands[3];
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EXPRESSION' IN TYPEOF(interval_low)) AND
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EXPRESSION' IN TYPEOF(interval_item)) AND
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EXPRESSION' IN TYPEOF(interval_high));
  WR2: (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.STRING_EXPRESSION' IN TYPEOF(SELF.interval_low)) AND
        ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.STRING_EXPRESSION' IN TYPEOF(SELF.interval_high)) AND
        ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.STRING_EXPRESSION' IN TYPEOF(SELF.interval_item))) OR
       (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(SELF.interval_low)) AND
        ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(SELF.interval_item)) AND
        ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(SELF.interval_high)));
END_ENTITY;

(* "invisibility" USE from SCHEMA presentation_appearance_schema *)
(* "invisibility" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY invisibility;
  invisible_items : SET [1 : ?] OF invisible_item;
END_ENTITY;

(* "item_identified_representation_usage" USE from SCHEMA product_property_representation_schema *)
(* "item_identified_representation_usage" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PRODUCT_PROPERTY_REPRESENTATION_SCHEMA *)
ENTITY item_identified_representation_usage;
  name                : label;
  description         : OPTIONAL text;
  definition          : item_identified_representation_usage_definition;
  used_representation : representation;
  identified_item     : item_identified_representation_usage_select;
UNIQUE
  UR1: used_representation, identified_item;
  UR2: used_representation, definition;
WHERE
  WR1: valid_identified_item_in_representation(identified_item, used_representation);
END_ENTITY;

(* "known_source" USE from SCHEMA plib_class_reference_mim *)
(* "known_source" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,PLIB_CLASS_REFERENCE_MIM *)
ENTITY known_source
  SUBTYPE OF (external_source, pre_defined_item);
END_ENTITY;

(* "laid_orientation_angle" USE from SCHEMA ply_orientation_specification_mim *)
(* "laid_orientation_angle" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PLY_ORIENTATION_SPECIFICATION_MIM *)
ENTITY laid_orientation_angle
  SUBTYPE OF (ply_orientation_angle);
END_ENTITY;

(* "laminate_table" USE from SCHEMA part_and_zone_laminate_tables_mim *)
(* "laminate_table" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM *)
ENTITY laminate_table
  SUPERTYPE OF (ONEOF(part_laminate_table, zone_structural_makeup))
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "language" USE from SCHEMA language_schema *)
(* "language" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,PRODUCT_VIEW_DEFINITION_MIM,LANGUAGE_SCHEMA *)
ENTITY language
  SUBTYPE OF (group);
WHERE
  WR1: SELF\group.name <> '';
  -- Informal proposition
  -- - IP1: The name attribute of the language shall be an alpha-3 bibliographic code of ISO 639-2.
  -- - IP2: If present, the description attribute shall identify a country with an alpha-2 code specified in ISO 3166-1. 
END_ENTITY;

(* "leader_curve" USE from SCHEMA draughting_element_schema *)
(* "leader_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_SCHEMA *)
ENTITY leader_curve
  SUBTYPE OF (annotation_curve_occurrence);
WHERE
  WR1: SIZEOF(QUERY(ldc
                    <* USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DRAUGHTING_CALLOUT.CONTENTS')
                    | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LEADER_DIRECTED_CALLOUT' IN TYPEOF(ldc))) >=
       1;
END_ENTITY;

(* "length_function" USE from SCHEMA iso13584_expressions_schema *)
(* "length_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY length_function
  SUBTYPE OF (numeric_expression, unary_generic_expression);
  SELF\unary_generic_expression.operand : string_expression;
END_ENTITY;

(* "length_measure_with_unit" USE from SCHEMA measure_schema *)
(* "length_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY length_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LENGTH_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "length_unit" USE from SCHEMA measure_schema *)
(* "length_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY length_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 1.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

(* "like_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "like_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY like_expression
  SUBTYPE OF (comparison_expression);
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.STRING_EXPRESSION' IN
        TYPEOF(SELF\binary_generic_expression.operands[1])) AND
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.STRING_EXPRESSION' IN
        TYPEOF(SELF\binary_generic_expression.operands[2]));
END_ENTITY;

(* "limited_length_area_indicator" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY limited_length_area_indicator
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "line" USE from SCHEMA geometry_schema *)
(* "line" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY line
  SUBTYPE OF (curve);
  pnt : cartesian_point;
  dir : vector;
WHERE
  WR1: dir.dim = pnt.dim;
END_ENTITY;

(* "line_based_llai" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY line_based_llai
  SUPERTYPE OF (ONEOF(edge_sealing, guide_curve))
  SUBTYPE OF (limited_length_area_indicator);
END_ENTITY;

(* "linearized_table_function" USE from SCHEMA mathematical_functions_schema *)
(* "linearized_table_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY linearized_table_function
  SUPERTYPE OF (ONEOF(standard_table_function, regular_table_function, triangular_matrix, symmetric_matrix,
                      banded_matrix))
  SUBTYPE OF (explicit_table_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  first                                 : INTEGER;
DERIVE
  source : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_1d_array(source);
  WR2: member_of(first, source\maths_function.domain);
END_ENTITY;

(* "listed_complex_number_data" USE from SCHEMA mathematical_functions_schema *)
(* "listed_complex_number_data" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY listed_complex_number_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [2 : ?] OF REAL;
DERIVE
  SELF\explicit_table_function.shape                              : LIST [1 : ?] OF positive_integer := [SIZEOF(values) DIV
                                                                                                         2];
WHERE
  WR1: NOT ODD(SIZEOF(values));
END_ENTITY;

(* "listed_data" USE from SCHEMA mathematical_functions_schema *)
(* "listed_data" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY listed_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values      : LIST [1 : ?] OF maths_value;
  value_range : maths_space;
DERIVE
  SELF\explicit_table_function.shape                              : LIST [1 : ?] OF positive_integer := [SIZEOF(values)];
WHERE
  WR1: expression_is_constant(value_range);
  WR2: SIZEOF(QUERY(val <* values | NOT (member_of(val, value_range)))) = 0;
END_ENTITY;

(* "listed_integer_data" USE from SCHEMA mathematical_functions_schema *)
(* "listed_integer_data" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY listed_integer_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1 : ?] OF INTEGER;
DERIVE
  SELF\explicit_table_function.shape                              : LIST [1 : ?] OF positive_integer := [SIZEOF(values)];
END_ENTITY;

(* "listed_logical_data" USE from SCHEMA mathematical_functions_schema *)
(* "listed_logical_data" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY listed_logical_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1 : ?] OF LOGICAL;
DERIVE
  SELF\explicit_table_function.shape                              : LIST [1 : ?] OF positive_integer := [SIZEOF(values)];
END_ENTITY;

(* "listed_product_space" USE from SCHEMA mathematical_functions_schema *)
(* "listed_product_space" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY listed_product_space
  SUBTYPE OF (maths_space, generic_literal);
  factors : LIST OF maths_space;
WHERE
  WR1: SIZEOF(QUERY(space <* factors | NOT (expression_is_constant(space)))) = 0;
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: NOT (the_empty_space IN factors);
END_ENTITY;

(* "listed_real_data" USE from SCHEMA mathematical_functions_schema *)
(* "listed_real_data" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY listed_real_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1 : ?] OF REAL;
DERIVE
  SELF\explicit_table_function.shape                              : LIST [1 : ?] OF positive_integer := [SIZEOF(values)];
END_ENTITY;

(* "listed_string_data" USE from SCHEMA mathematical_functions_schema *)
(* "listed_string_data" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY listed_string_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1 : ?] OF STRING;
DERIVE
  SELF\explicit_table_function.shape                              : LIST [1 : ?] OF positive_integer := [SIZEOF(values)];
END_ENTITY;

(* "literal_number" USE from SCHEMA iso13584_expressions_schema *)
(* "literal_number" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY literal_number
  ABSTRACT SUPERTYPE OF (ONEOF(int_literal, real_literal))
  SUBTYPE OF (simple_numeric_expression, generic_literal);
  the_value : NUMBER;
END_ENTITY;

(* "local_time" USE from SCHEMA date_time_schema *)
(* "local_time" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_MIM,DATE_TIME_ASSIGNMENT_MIM,EXTENDED_DATE_MIM,DATE_TIME_SCHEMA *)
ENTITY local_time;
  hour_component   : hour_in_day;
  minute_component : OPTIONAL minute_in_hour;
  second_component : OPTIONAL second_in_minute;
  zone             : coordinated_universal_time_offset;
WHERE
  WR1: valid_time(SELF);
END_ENTITY;

(* "log_function" USE from SCHEMA iso13584_expressions_schema *)
(* "log_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY log_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

(* "log10_function" USE from SCHEMA iso13584_expressions_schema *)
(* "log10_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY log10_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

(* "log2_function" USE from SCHEMA iso13584_expressions_schema *)
(* "log2_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY log2_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

(* "logical_literal" USE from SCHEMA mathematical_functions_schema *)
(* "logical_literal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY logical_literal
  SUBTYPE OF (generic_literal);
  lit_value : LOGICAL;
END_ENTITY;

(* "logical_representation_item" USE from SCHEMA basic_data_representation_mim *)
(* "logical_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,BASIC_DATA_REPRESENTATION_MIM *)
ENTITY logical_representation_item
  SUBTYPE OF (representation_item, logical_literal);
END_ENTITY;

(* "loop" USE from SCHEMA topology_schema *)
(* "loop" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,TOPOLOGY_SCHEMA *)
ENTITY loop
  SUPERTYPE OF (ONEOF(vertex_loop, edge_loop, poly_loop))
  SUBTYPE OF (topological_representation_item);
END_ENTITY;

(* "loss_tangent_measure_with_unit" USE from SCHEMA value_with_unit_extension_mim *)
(* "loss_tangent_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,VALUE_WITH_UNIT_EXTENSION_MIM *)
ENTITY loss_tangent_measure_with_unit
  SUBTYPE OF (ratio_measure_with_unit);
END_ENTITY;

(* "luminous_flux_measure_with_unit" USE from SCHEMA measure_schema *)
(* "luminous_flux_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY luminous_flux_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LUMINOUS_FLUX_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "luminous_flux_unit" USE from SCHEMA measure_schema *)
(* "luminous_flux_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY luminous_flux_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.lumen);
END_ENTITY;

(* "luminous_intensity_measure_with_unit" USE from SCHEMA measure_schema *)
(* "luminous_intensity_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY luminous_intensity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LUMINOUS_INTENSITY_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "luminous_intensity_unit" USE from SCHEMA measure_schema *)
(* "luminous_intensity_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY luminous_intensity_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
END_ENTITY;

(* "magnetic_flux_density_measure_with_unit" USE from SCHEMA measure_schema *)
(* "magnetic_flux_density_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY magnetic_flux_density_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAGNETIC_FLUX_DENSITY_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "magnetic_flux_density_unit" USE from SCHEMA measure_schema *)
(* "magnetic_flux_density_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY magnetic_flux_density_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.tesla);
END_ENTITY;

(* "magnetic_flux_measure_with_unit" USE from SCHEMA measure_schema *)
(* "magnetic_flux_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY magnetic_flux_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAGNETIC_FLUX_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "magnetic_flux_unit" USE from SCHEMA measure_schema *)
(* "magnetic_flux_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY magnetic_flux_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.weber);
END_ENTITY;

(* "make_from_usage_option" USE from SCHEMA product_structure_schema *)
(* "make_from_usage_option" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PRODUCT_STRUCTURE_SCHEMA *)
ENTITY make_from_usage_option
  SUBTYPE OF (product_definition_usage);
  ranking           : INTEGER;
  ranking_rationale : text;
  quantity          : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component))) OR (quantity.value_component > 0);
END_ENTITY;

(* "manifold_solid_brep" USE from SCHEMA geometric_model_schema *)
(* "manifold_solid_brep" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,AIC_CSG,GEOMETRIC_MODEL_SCHEMA *)
ENTITY manifold_solid_brep
  SUBTYPE OF (solid_model);
  outer : closed_shell;
END_ENTITY;

(* "manifold_surface_shape_representation" USE from SCHEMA aic_manifold_surface *)
(* "manifold_surface_shape_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,AIC_MANIFOLD_SURFACE *)
ENTITY manifold_surface_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF(QUERY(it
                    <* SELF.items
                    | NOT (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_SURFACE_MODEL',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AXIS2_PLACEMENT_3D'] *
                                  TYPEOF(it)) =
                           1))) =
       0;
  WR2: SIZEOF(QUERY(it
                    <* SELF.items
                    | SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_SURFACE_MODEL',
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM'] *
                             TYPEOF(it)) =
                      1)) >
       0;
  WR3: SIZEOF(QUERY(mi
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM' IN TYPEOF(it))
                    | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN
                            TYPEOF(mi\mapped_item.mapping_source.mapped_representation)) AND
                           (SIZEOF(QUERY(mr_it
                                         <* mi\mapped_item.mapping_source.mapped_representation.items
                                         | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN
                                            TYPEOF(mr_it)))) >
                            0)))) =
       0;
  WR4: SIZEOF(QUERY(sbsm
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN
                               TYPEOF(it))
                    | NOT (SIZEOF(QUERY(sh
                                        <* sbsm\shell_based_surface_model.sbsm_boundary
                                        | NOT (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OPEN_SHELL',
                                                       'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ORIENTED_CLOSED_SHELL',
                                                       'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CLOSED_SHELL'] *
                                                      TYPEOF(sh)) =
                                               1))) =
                           0))) =
       0;
  WR5: SIZEOF(QUERY(sbsm
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN
                               TYPEOF(it))
                    | NOT (SIZEOF(QUERY(cfs
                                        <* sbsm\shell_based_surface_model.sbsm_boundary
                                        | NOT (SIZEOF(QUERY(fa
                                                            <* cfs\connected_face_set.cfs_faces
                                                            | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FACE_SURFACE' IN
                                                                   TYPEOF(fa)))) =
                                               0))) =
                           0))) =
       0;
  WR6: SIZEOF(QUERY(sbsm
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN
                               TYPEOF(it))
                    | NOT (SIZEOF(QUERY(cfs
                                        <* sbsm\shell_based_surface_model.sbsm_boundary
                                        | NOT (SIZEOF(QUERY(fa
                                                            <* cfs\connected_face_set.cfs_faces
                                                            | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ADVANCED_FACE' IN
                                                                    TYPEOF(fa)) OR
                                                                   (msf_surface_check(fa\face_surface.face_geometry))))) =
                                               0))) =
                           0))) =
       0;
  WR7: SIZEOF(QUERY(sbsm
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN
                               TYPEOF(it))
                    | NOT (SIZEOF(QUERY(cfs
                                        <* sbsm\shell_based_surface_model.sbsm_boundary
                                        | NOT (SIZEOF(QUERY(fa
                                                            <* cfs\connected_face_set.cfs_faces
                                                            | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ADVANCED_FACE' IN
                                                                    TYPEOF(fa)) OR
                                                                   (SIZEOF(QUERY(bnds
                                                                                 <* fa.bounds
                                                                                 | NOT (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP',
                                                                                                'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_LOOP'] *
                                                                                               TYPEOF(bnds.bound)) =
                                                                                        1))) =
                                                                    0)))) =
                                               0))) =
                           0))) =
       0;
  WR8: SIZEOF(QUERY(sbsm
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN
                               TYPEOF(it))
                    | NOT (SIZEOF(QUERY(cfs
                                        <* sbsm\shell_based_surface_model.sbsm_boundary
                                        | NOT (SIZEOF(QUERY(fa
                                                            <* cfs\connected_face_set.cfs_faces
                                                            | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ADVANCED_FACE' IN
                                                                    TYPEOF(fa)) OR
                                                                   (SIZEOF(QUERY(elp_fbnds
                                                                                 <* QUERY(bnds
                                                                                          <* fa.bounds
                                                                                          | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN
                                                                                            TYPEOF(bnds.bound))
                                                                                 | NOT (SIZEOF(QUERY(oe
                                                                                                     <* elp_fbnds\path.edge_list
                                                                                                     | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_CURVE' IN
                                                                                                            TYPEOF(oe.edge_element)))) =
                                                                                        0))) =
                                                                    0)))) =
                                               0))) =
                           0))) =
       0;
  WR9: SIZEOF(QUERY(sbsm
                    <* QUERY(it
                             <* SELF.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN
                               TYPEOF(it))
                    | NOT (SIZEOF(QUERY(cfs
                                        <* sbsm\shell_based_surface_model.sbsm_boundary
                                        | NOT (SIZEOF(QUERY(fa
                                                            <* cfs\connected_face_set.cfs_faces
                                                            | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ADVANCED_FACE' IN
                                                                    TYPEOF(fa)) OR
                                                                   (SIZEOF(QUERY(elp_fbnds
                                                                                 <* QUERY(bnds
                                                                                          <* fa.bounds
                                                                                          | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN
                                                                                            TYPEOF(bnds.bound))
                                                                                 | NOT (SIZEOF(QUERY(oe_cv
                                                                                                     <* QUERY(oe
                                                                                                              <* elp_fbnds\path.edge_list
                                                                                                              | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_CURVE' IN
                                                                                                                TYPEOF(oe.edge_element))
                                                                                                     | NOT (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.B_SPLINE_CURVE',
                                                                                                                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONIC',
                                                                                                                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE_REPLICA',
                                                                                                                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LINE',
                                                                                                                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OFFSET_CURVE_3D',
                                                                                                                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PCURVE',
                                                                                                                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLYLINE',
                                                                                                                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_CURVE'] *
                                                                                                                   TYPEOF(oe_cv.edge_element\edge_curve.edge_geometry)) =
                                                                                                            1))) =
                                                                                        0))) =
                                                                    0)))) =
                                               0))) =
                           0))) =
       0;
  WR10: SIZEOF(QUERY(sbsm
                     <* QUERY(it
                              <* SELF.items
                              | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN
                                TYPEOF(it))
                     | NOT (SIZEOF(QUERY(cfs
                                         <* sbsm\shell_based_surface_model.sbsm_boundary
                                         | NOT (SIZEOF(QUERY(fa
                                                             <* cfs\connected_face_set.cfs_faces
                                                             | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ADVANCED_FACE' IN
                                                                     TYPEOF(fa)) OR
                                                                    (SIZEOF(QUERY(elp_fbnds
                                                                                  <* QUERY(bnds
                                                                                           <* fa.bounds
                                                                                           | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN
                                                                                             TYPEOF(bnds.bound))
                                                                                  | NOT (SIZEOF(QUERY(oe
                                                                                                      <* elp_fbnds\path.edge_list
                                                                                                      | NOT (msf_curve_check(oe.edge_element\edge_curve.edge_geometry)))) =
                                                                                         0))) =
                                                                     0)))) =
                                                0))) =
                            0))) =
        0;
  WR11: SIZEOF(QUERY(sbsm
                     <* QUERY(it
                              <* SELF.items
                              | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN
                                TYPEOF(it))
                     | NOT (SIZEOF(QUERY(cfs
                                         <* sbsm\shell_based_surface_model.sbsm_boundary
                                         | NOT (SIZEOF(QUERY(fa
                                                             <* cfs\connected_face_set.cfs_faces
                                                             | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ADVANCED_FACE' IN
                                                                     TYPEOF(fa)) OR
                                                                    (SIZEOF(QUERY(elp_fbnds
                                                                                  <* QUERY(bnds
                                                                                           <* fa.bounds
                                                                                           | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN
                                                                                             TYPEOF(bnds.bound))
                                                                                  | NOT (SIZEOF(QUERY(oe
                                                                                                      <* elp_fbnds\path.edge_list
                                                                                                      | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_POINT' IN
                                                                                                              TYPEOF(oe.edge_element.edge_start)) AND
                                                                                                             ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_POINT' IN
                                                                                                              TYPEOF(oe.edge_element.edge_end))))) =
                                                                                         0))) =
                                                                     0)))) =
                                                0))) =
                            0))) =
        0;
  WR12: SIZEOF(QUERY(sbsm
                     <* QUERY(it
                              <* SELF.items
                              | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN
                                TYPEOF(it))
                     | NOT (SIZEOF(QUERY(cfs
                                         <* sbsm\shell_based_surface_model.sbsm_boundary
                                         | NOT (SIZEOF(QUERY(fa
                                                             <* cfs\connected_face_set.cfs_faces
                                                             | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ADVANCED_FACE' IN
                                                                     TYPEOF(fa)) OR
                                                                    (SIZEOF(QUERY(elp_fbnds
                                                                                  <* QUERY(bnds
                                                                                           <* fa.bounds
                                                                                           | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN
                                                                                             TYPEOF(bnds.bound))
                                                                                  | NOT (SIZEOF(QUERY(oe
                                                                                                      <* elp_fbnds\path.edge_list
                                                                                                      | NOT ((SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CARTESIAN_POINT',
                                                                                                                      'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DEGENERATE_PCURVE',
                                                                                                                      'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT_ON_CURVE',
                                                                                                                      'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT_ON_SURFACE'] *
                                                                                                                     TYPEOF(oe.edge_element.edge_start\vertex_point.vertex_geometry)) =
                                                                                                              1) AND
                                                                                                             (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CARTESIAN_POINT',
                                                                                                                      'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DEGENERATE_PCURVE',
                                                                                                                      'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT_ON_CURVE',
                                                                                                                      'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT_ON_SURFACE'] *
                                                                                                                     TYPEOF(oe.edge_element.edge_end\vertex_point.vertex_geometry)) =
                                                                                                              1)))) =
                                                                                         0))) =
                                                                     0)))) =
                                                0))) =
                            0))) =
        0;
  WR13: SIZEOF(QUERY(sbsm
                     <* QUERY(it
                              <* SELF.items
                              | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN
                                TYPEOF(it))
                     | NOT (SIZEOF(QUERY(cfs
                                         <* sbsm\shell_based_surface_model.sbsm_boundary
                                         | NOT (SIZEOF(QUERY(fa
                                                             <* cfs\connected_face_set.cfs_faces
                                                             | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ADVANCED_FACE' IN
                                                                     TYPEOF(fa)) OR
                                                                    (SIZEOF(QUERY(vlp_fbnds
                                                                                  <* QUERY(bnds
                                                                                           <* fa.bounds
                                                                                           | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_LOOP' IN
                                                                                             TYPEOF(bnds.bound))
                                                                                  | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_POINT' IN
                                                                                         TYPEOF(vlp_fbnds\vertex_loop.loop_vertex)))) =
                                                                     0)))) =
                                                0))) =
                            0))) =
        0;
  WR14: SIZEOF(QUERY(sbsm
                     <* QUERY(it
                              <* SELF.items
                              | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN
                                TYPEOF(it))
                     | NOT (SIZEOF(QUERY(cfs
                                         <* sbsm\shell_based_surface_model.sbsm_boundary
                                         | NOT (SIZEOF(QUERY(fa
                                                             <* cfs\connected_face_set.cfs_faces
                                                             | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ADVANCED_FACE' IN
                                                                     TYPEOF(fa)) OR
                                                                    (SIZEOF(QUERY(vlp_fbnds
                                                                                  <* QUERY(bnds
                                                                                           <* fa.bounds
                                                                                           | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_LOOP' IN
                                                                                             TYPEOF(bnds.bound))
                                                                                  | NOT (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CARTESIAN_POINT',
                                                                                                 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DEGENERATE_PCURVE',
                                                                                                 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT_ON_CURVE',
                                                                                                 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT_ON_SURFACE'] *
                                                                                                TYPEOF(vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) =
                                                                                         1))) =
                                                                     0)))) =
                                                0))) =
                            0))) =
        0;
END_ENTITY;

(* "manufacturing_edge_of_part" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY manufacturing_edge_of_part
  SUBTYPE OF (area_based_llai);
END_ENTITY;

(* "manufacturing_edge_of_part_llai_specification" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY manufacturing_edge_of_part_llai_specification
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "manufacturing_edge_of_ply" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY manufacturing_edge_of_ply
  SUBTYPE OF (area_based_llai);
END_ENTITY;

(* "manufacturing_edge_of_ply_llai_specification" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY manufacturing_edge_of_ply_llai_specification
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "mapped_item" USE from SCHEMA representation_schema *)
(* "mapped_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,REPRESENTATION_SCHEMA *)
ENTITY mapped_item
  SUBTYPE OF (representation_item);
  mapping_source : representation_map;
  mapping_target : representation_item;
WHERE
  WR1: acyclic_mapped_representation(SELF);
END_ENTITY;

(* "mass_measure_with_unit" USE from SCHEMA measure_schema *)
(* "mass_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY mass_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MASS_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "mass_unit" USE from SCHEMA measure_schema *)
(* "mass_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY mass_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

(* "material_designation" USE from SCHEMA material_property_definition_schema *)
(* "material_designation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,MATERIAL_PROPERTY_DEFINITION_SCHEMA *)
ENTITY material_designation;
  name        : label;
  definitions : SET [1 : ?] OF characterized_definition;
END_ENTITY;

(* "material_designation_characterization" USE from SCHEMA material_property_definition_schema *)
(* "material_designation_characterization" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,MATERIAL_PROPERTY_DEFINITION_SCHEMA *)
ENTITY material_designation_characterization;
  name        : label;
  description : text;
  designation : material_designation;
  property    : characterized_material_property;
END_ENTITY;

(* "material_property" USE from SCHEMA material_property_definition_schema *)
(* "material_property" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,MATERIAL_PROPERTY_DEFINITION_SCHEMA *)
ENTITY material_property
  SUBTYPE OF (property_definition);
UNIQUE
  UR1: SELF\property_definition.name, SELF\property_definition.definition;
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CHARACTERIZED_OBJECT' IN
        TYPEOF(SELF\property_definition.definition)) OR
       (SIZEOF(bag_to_set(USEDIN(SELF,
                                 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) -
               QUERY(temp
                     <* bag_to_set(USEDIN(SELF,
                                          'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))
                     | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MATERIAL_PROPERTY_REPRESENTATION' IN
                        TYPEOF(temp)))) =
        0);
END_ENTITY;

(* "material_property_representation" USE from SCHEMA material_property_representation_schema *)
(* "material_property_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,MATERIAL_PROPERTY_REPRESENTATION_SCHEMA *)
ENTITY material_property_representation
  SUBTYPE OF (property_definition_representation);
  dependent_environment : data_environment;
END_ENTITY;

(* "mathematical_description" USE from SCHEMA mathematical_functions_schema *)
(* "mathematical_description" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY mathematical_description;
  described  : maths_expression;
  describing : STRING;
  encoding   : label;
END_ENTITY;

(* "maths_boolean_variable" USE from SCHEMA mathematical_functions_schema *)
(* "maths_boolean_variable" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY maths_boolean_variable
  SUBTYPE OF (maths_variable, boolean_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space, es_booleans);
END_ENTITY;

(* "maths_enum_literal" USE from SCHEMA mathematical_functions_schema *)
(* "maths_enum_literal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY maths_enum_literal
  SUBTYPE OF (generic_literal);
  lit_value : maths_enum_atom;
END_ENTITY;

(* "maths_function" USE from SCHEMA mathematical_functions_schema *)
(* "maths_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY maths_function
  ABSTRACT SUPERTYPE OF (ONEOF(finite_function, constant_function, selector_function, elementary_function,
                               restriction_function, repackaging_function, reindexed_array_function,
                               series_composed_function, parallel_composed_function, explicit_table_function,
                               homogeneous_linear_function, general_linear_function, b_spline_basis, b_spline_function,
                               rationalize_function, partial_derivative_function, definite_integral_function,
                               abstracted_expression_function, expression_denoted_function, imported_point_function,
                               imported_curve_function, imported_surface_function, imported_volume_function,
                               application_defined_function))
  SUBTYPE OF (generic_expression);
DERIVE
  domain : tuple_space := derive_function_domain(SELF);
  range  : tuple_space := derive_function_range(SELF);
END_ENTITY;

(* "maths_integer_variable" USE from SCHEMA mathematical_functions_schema *)
(* "maths_integer_variable" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY maths_integer_variable
  SUBTYPE OF (maths_variable, int_numeric_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space, es_integers);
END_ENTITY;

(* "maths_real_variable" USE from SCHEMA mathematical_functions_schema *)
(* "maths_real_variable" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY maths_real_variable
  SUBTYPE OF (maths_variable, real_numeric_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space, es_reals);
END_ENTITY;

(* "maths_space" USE from SCHEMA mathematical_functions_schema *)
(* "maths_space" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY maths_space
  ABSTRACT SUPERTYPE OF (ONEOF(elementary_space, finite_integer_interval, integer_interval_from_min,
                               integer_interval_to_max, finite_real_interval, real_interval_from_min,
                               real_interval_to_max, cartesian_complex_number_region, polar_complex_number_region,
                               finite_space, uniform_product_space, listed_product_space, extended_tuple_space,
                               function_space))
  SUBTYPE OF (generic_expression);
END_ENTITY;

(* "maths_string_variable" USE from SCHEMA mathematical_functions_schema *)
(* "maths_string_variable" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY maths_string_variable
  SUBTYPE OF (maths_variable, string_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space, es_strings);
END_ENTITY;

(* "maths_tuple_literal" USE from SCHEMA mathematical_functions_schema *)
(* "maths_tuple_literal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY maths_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST OF maths_value;
END_ENTITY;

(* "maths_value_precision_qualifier" USE from SCHEMA qualified_measure_schema *)
(* "maths_value_precision_qualifier" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTENDED_MEASURE_REPRESENTATION_MIM,QUALIFIED_MEASURE_SCHEMA *)
ENTITY maths_value_precision_qualifier;
  precision_value : maths_value;
END_ENTITY;

(* "maths_variable" USE from SCHEMA mathematical_functions_schema *)
(* "maths_variable" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY maths_variable
  SUBTYPE OF (generic_variable);
  values_space : maths_space;
  name         : label;
WHERE
  WR1: expression_is_constant(values_space);
END_ENTITY;

(* "maximum_function" USE from SCHEMA iso13584_expressions_schema *)
(* "maximum_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY maximum_function
  SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;

(* "measure_qualification" USE from SCHEMA qualified_measure_schema *)
(* "measure_qualification" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTENDED_MEASURE_REPRESENTATION_MIM,QUALIFIED_MEASURE_SCHEMA *)
ENTITY measure_qualification;
  name              : label;
  description       : text;
  qualified_measure : measure_with_unit;
  qualifiers        : SET [1 : ?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp
                    <* qualifiers
                    | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRECISION_QUALIFIER' IN TYPEOF(temp)) OR
                      ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MATHS_VALUE_PRECISION_QUALIFIER' IN
                       TYPEOF(temp)))) <
       2;
  WR2: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REPRESENTATION_ITEM' IN
            TYPEOF(SELF\measure_qualification.qualified_measure));
END_ENTITY;

(* "measure_representation_item" USE from SCHEMA qualified_measure_schema *)
(* "measure_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,QUALIFIED_MEASURE_SCHEMA *)
ENTITY measure_representation_item
  SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY;

(* "measure_with_unit" USE from SCHEMA measure_schema *)
(* "measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY measure_with_unit
  SUPERTYPE OF (ONEOF(length_measure_with_unit, mass_measure_with_unit, time_measure_with_unit,
                      electric_current_measure_with_unit, thermodynamic_temperature_measure_with_unit,
                      celsius_temperature_measure_with_unit, amount_of_substance_measure_with_unit,
                      luminous_intensity_measure_with_unit, plane_angle_measure_with_unit,
                      solid_angle_measure_with_unit, area_measure_with_unit, volume_measure_with_unit,
                      ratio_measure_with_unit, acceleration_measure_with_unit, capacitance_measure_with_unit,
                      electric_charge_measure_with_unit, conductance_measure_with_unit,
                      electric_potential_measure_with_unit, energy_measure_with_unit,
                      magnetic_flux_density_measure_with_unit, force_measure_with_unit, frequency_measure_with_unit,
                      illuminance_measure_with_unit, inductance_measure_with_unit, luminous_flux_measure_with_unit,
                      magnetic_flux_measure_with_unit, power_measure_with_unit, pressure_measure_with_unit,
                      resistance_measure_with_unit, velocity_measure_with_unit, absorbed_dose_measure_with_unit,
                      radioactivity_measure_with_unit, dose_equivalent_measure_with_unit));
  value_component : measure_value;
  unit_component  : unit;
WHERE
  WR1: valid_units(SELF);
END_ENTITY;

(* "minimum_function" USE from SCHEMA iso13584_expressions_schema *)
(* "minimum_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY minimum_function
  SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;

(* "minus_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "minus_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY minus_expression
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

(* "minus_function" USE from SCHEMA iso13584_expressions_schema *)
(* "minus_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY minus_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

(* "mod_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "mod_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY mod_expression
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

(* "mult_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "mult_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY mult_expression
  SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

(* "multi_language_attribute_assignment" USE from SCHEMA multi_linguism_mim *)
(* "multi_language_attribute_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,MULTI_LINGUISM_MIM *)
ENTITY multi_language_attribute_assignment
  SUBTYPE OF (attribute_value_assignment);
  items : SET [1 : ?] OF multi_language_attribute_item;
DERIVE
  translation_language : language := language_indication[1]\attribute_classification_assignment.assigned_class;
INVERSE
  language_indication : SET [1:1] OF attribute_language_assignment FOR items;
WHERE
  WR1: (SELF\attribute_value_assignment.role.name = 'alternate language');
  WR2: SIZEOF(QUERY(ala
                    <* language_indication
                    | (ala\attribute_classification_assignment.attribute_name = 'attribute_value') AND
                      (ala\attribute_classification_assignment.role.name = 'translated'))) =
       1;
  WR3: SELF\attribute_value_assignment.attribute_name <> '';
  WR4: SIZEOF(QUERY(ci
                    <* items
                    | SIZEOF(QUERY(ata
                                   <* USEDIN(ci,
                                             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS')
                                   | (ata\attribute_value_assignment.attribute_name =
                                      SELF\attribute_value_assignment.attribute_name) AND
                                     (ata.translation_language :=: translation_language))) >
                      1)) =
       0;
  WR5: SIZEOF(QUERY(ci
                    <* items
                    | SIZEOF(QUERY(ata
                                   <* USEDIN(ci,
                                             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS')
                                   | (ata\attribute_classification_assignment.role.name = 'primary') AND
                                     (ata\attribute_classification_assignment.attribute_name =
                                      SELF\attribute_value_assignment.attribute_name) AND
                                     (ata\attribute_classification_assignment.assigned_class :=:
                                      translation_language))) >
                      0)) =
       0;
END_ENTITY;

(* "multi_level_reference_designator" USE from SCHEMA product_structure_schema *)
(* "multi_level_reference_designator" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,PRODUCT_STRUCTURE_SCHEMA *)
ENTITY multi_level_reference_designator
  SUBTYPE OF (assembly_component_usage);
  location : LIST [1 : ?] OF UNIQUE next_assembly_usage_occurrence;
DERIVE
  SELF\product_definition_relationship.relating_product_definition                                                             : product_definition              := location[1]\product_definition_relationship.relating_product_definition;
  root                                                             : product_definition              := relating_product_definition;
  SELF\product_definition_relationship.related_product_definition                                                             : product_definition_or_reference := location[HIINDEX(location)]\product_definition_relationship.related_product_definition;
  leaf                                                             : product_definition_or_reference := related_product_definition;
UNIQUE
  UR1: location;
WHERE
  WR1: unambiguously_specified_multi_level_reference_designator(location);
  WR2: SIZEOF(QUERY(cp <* location | NOT (EXISTS(cp\assembly_component_usage.reference_designator)))) = 0;
END_ENTITY;

(* "multiple_arity_boolean_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "multiple_arity_boolean_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY multiple_arity_boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(and_expression, or_expression))
  SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [2 : ?] OF boolean_expression;
END_ENTITY;

(* "multiple_arity_function_call" USE from SCHEMA iso13584_expressions_schema *)
(* "multiple_arity_function_call" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY multiple_arity_function_call
  ABSTRACT SUPERTYPE OF (ONEOF(maximum_function, minimum_function))
  SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

(* "multiple_arity_generic_expression" USE from SCHEMA iso13584_generic_expressions_schema *)
(* "multiple_arity_generic_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHS_VALUE_MIM,ISO13584_GENERIC_EXPRESSIONS_SCHEMA *)
ENTITY multiple_arity_generic_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (generic_expression);
  operands : LIST [2 : ?] OF generic_expression;
END_ENTITY;

(* "multiple_arity_numeric_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "multiple_arity_numeric_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY multiple_arity_numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(plus_expression, mult_expression, multiple_arity_function_call))
  SUBTYPE OF (numeric_expression, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [2 : ?] OF numeric_expression;
END_ENTITY;

(* "name_assignment" USE from SCHEMA management_resources_schema *)
(* "name_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,PLIB_CLASS_REFERENCE_MIM,EXTERNAL_CLASS_MIM,MANAGEMENT_RESOURCES_SCHEMA *)
ENTITY name_assignment
  ABSTRACT SUPERTYPE;
  assigned_name : label;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

(* "name_attribute" USE from SCHEMA basic_attribute_schema *)
(* "name_attribute" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,BASIC_ATTRIBUTE_SCHEMA *)
ENTITY name_attribute;
  attribute_value : label;
  named_item      : name_attribute_select;
END_ENTITY;

(* "named_unit" USE from SCHEMA measure_schema *)
(* "named_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY named_unit
  SUPERTYPE OF (ONEOF(si_unit, conversion_based_unit, context_dependent_unit) ANDOR
                ONEOF(length_unit, mass_unit, time_unit, electric_current_unit, thermodynamic_temperature_unit,
                      amount_of_substance_unit, luminous_flux_unit, luminous_intensity_unit, plane_angle_unit,
                      solid_angle_unit, ratio_unit));
  dimensions : dimensional_exponents;
END_ENTITY;

(* "next_assembly_usage_occurrence" USE from SCHEMA product_structure_schema *)
(* "next_assembly_usage_occurrence" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PRODUCT_STRUCTURE_SCHEMA *)
ENTITY next_assembly_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
DERIVE
  product_definition_occurrence_id : identifier := SELF\product_definition_relationship.related_product_definition\product_definition_occurrence.id;
UNIQUE
  UR1: SELF\assembly_component_usage.reference_designator,
       SELF\product_definition_relationship.relating_product_definition;
  UR2: product_definition_occurrence_id, SELF\product_definition_relationship.relating_product_definition;
END_ENTITY;

(* "no_splice_area" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY no_splice_area
  SUBTYPE OF (area_based_llai);
END_ENTITY;

(* "no_splice_area_llai_specification" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY no_splice_area_llai_specification
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "not_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "not_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY not_expression
  SUBTYPE OF (unary_boolean_expression);
  SELF\unary_generic_expression.operand : boolean_expression;
END_ENTITY;

(* "null_representation_item" USE from SCHEMA characteristic_mim *)
(* "null_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,CHARACTERISTIC_MIM *)
ENTITY null_representation_item
  SUBTYPE OF (representation_item);
END_ENTITY;

(* "numeric_defined_function" USE from SCHEMA iso13584_expressions_schema *)
(* "numeric_defined_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY numeric_defined_function
  ABSTRACT SUPERTYPE OF (ONEOF(integer_defined_function, real_defined_function))
  SUBTYPE OF (numeric_expression, defined_function);
END_ENTITY;

(* "numeric_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "numeric_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(simple_numeric_expression, unary_numeric_expression, binary_numeric_expression,
                               multiple_arity_numeric_expression, length_function, value_function,
                               numeric_defined_function))
  SUBTYPE OF (expression);
DERIVE
  is_int       : BOOLEAN := is_int_expr(SELF);
  sql_mappable : BOOLEAN := is_sql_mappable(SELF);
END_ENTITY;

(* "numeric_variable" USE from SCHEMA iso13584_expressions_schema *)
(* "numeric_variable" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY numeric_variable
  SUPERTYPE OF (ONEOF(int_numeric_variable, real_numeric_variable))
  SUBTYPE OF (simple_numeric_expression, variable);
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.INT_NUMERIC_VARIABLE' IN TYPEOF(SELF)) OR
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REAL_NUMERIC_VARIABLE' IN TYPEOF(SELF));
END_ENTITY;

(* "object_role" USE from SCHEMA basic_attribute_schema *)
(* "object_role" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,EXTERNAL_MODEL_MIM,FILE_IDENTIFICATION_MIM,BASIC_ATTRIBUTE_SCHEMA *)
ENTITY object_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

(* "odd_function" USE from SCHEMA iso13584_expressions_schema *)
(* "odd_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY odd_function
  SUBTYPE OF (unary_boolean_expression);
  SELF\unary_generic_expression.operand : numeric_expression;
WHERE
  WR1: is_int_expr(operand);
END_ENTITY;

(* "offset_curve_2d" USE from SCHEMA geometry_schema *)
(* "offset_curve_2d" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRY_SCHEMA *)
ENTITY offset_curve_2d
  SUBTYPE OF (curve);
  basis_curve    : curve;
  distance       : length_measure;
  self_intersect : LOGICAL;
WHERE
  WR1: basis_curve.dim = 2;
END_ENTITY;

(* "offset_curve_3d" USE from SCHEMA geometry_schema *)
(* "offset_curve_3d" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRY_SCHEMA *)
ENTITY offset_curve_3d
  SUBTYPE OF (curve);
  basis_curve    : curve;
  distance       : length_measure;
  self_intersect : LOGICAL;
  ref_direction  : direction;
WHERE
  WR1: (basis_curve.dim = 3) AND (ref_direction.dim = 3);
END_ENTITY;

(* "offset_surface" USE from SCHEMA geometry_schema *)
(* "offset_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRY_SCHEMA *)
ENTITY offset_surface
  SUBTYPE OF (surface);
  basis_surface  : surface;
  distance       : length_measure;
  self_intersect : LOGICAL;
END_ENTITY;

(* "open_shell" USE from SCHEMA topology_schema *)
(* "open_shell" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,MANIFOLD_SURFACE_MIM,TOPOLOGY_SCHEMA *)
ENTITY open_shell
  SUBTYPE OF (connected_face_set);
END_ENTITY;

(* "or_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "or_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY or_expression
  SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;

(* "ordinal_date" USE from SCHEMA date_time_schema *)
(* "ordinal_date" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_MIM,DATE_TIME_ASSIGNMENT_MIM,DATE_TIME_SCHEMA *)
ENTITY ordinal_date
  SUBTYPE OF (date);
  day_component : day_in_year_number;
WHERE
  WR1: (NOT leap_year(SELF.year_component) AND {1 <= day_component <= 365}) OR
       (leap_year(SELF.year_component) AND {1 <= day_component <= 366});
END_ENTITY;

(* "organization" USE from SCHEMA person_organization_schema *)
(* "organization" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,PRODUCT_VIEW_DEFINITION_MIM,PERSON_ORGANIZATION_SCHEMA *)
ENTITY organization;
  id          : OPTIONAL identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

(* "organization_assignment" USE from SCHEMA management_resources_schema *)
(* "organization_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,PLIB_CLASS_REFERENCE_MIM,MANAGEMENT_RESOURCES_SCHEMA *)
ENTITY organization_assignment
  ABSTRACT SUPERTYPE;
  assigned_organization : organization;
  role                  : organization_role;
END_ENTITY;

(* "organization_relationship" USE from SCHEMA person_organization_schema *)
(* "organization_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,PRODUCT_VIEW_DEFINITION_MIM,PERSON_ORGANIZATION_SCHEMA *)
ENTITY organization_relationship;
  name                  : label;
  description           : OPTIONAL text;
  relating_organization : organization;
  related_organization  : organization;
END_ENTITY;

(* "organization_role" USE from SCHEMA person_organization_schema *)
(* "organization_role" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,PLIB_CLASS_REFERENCE_MIM,PERSON_ORGANIZATION_SCHEMA *)
ENTITY organization_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF,
                     'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <=
       1;
END_ENTITY;

(* "organizational_address" USE from SCHEMA person_organization_schema *)
(* "organizational_address" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,PRODUCT_VIEW_DEFINITION_MIM,PERSON_ORGANIZATION_SCHEMA *)
ENTITY organizational_address
  SUBTYPE OF (address);
  organizations : SET [1 : ?] OF organization;
  description   : OPTIONAL text;
END_ENTITY;

(* "oriented_closed_shell" USE from SCHEMA topology_schema *)
(* "oriented_closed_shell" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,AIC_CSG,TOPOLOGY_SCHEMA *)
ENTITY oriented_closed_shell
  SUBTYPE OF (closed_shell);
  closed_shell_element : closed_shell;
  orientation          : BOOLEAN;
DERIVE
  SELF\connected_face_set.cfs_faces                         : SET [1 : ?] OF face := conditional_reverse(SELF.orientation,
                                                                                                         SELF.closed_shell_element.cfs_faces);
WHERE
  WR1: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ORIENTED_CLOSED_SHELL' IN
            TYPEOF(SELF.closed_shell_element));
END_ENTITY;

(* "oriented_edge" USE from SCHEMA topology_schema *)
(* "oriented_edge" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,TOPOLOGY_SCHEMA *)
ENTITY oriented_edge
  SUBTYPE OF (edge);
  edge_element : edge;
  orientation  : BOOLEAN;
DERIVE
  SELF\edge.edge_start           : vertex := boolean_choose(SELF.orientation, SELF.edge_element.edge_start,
                                                            SELF.edge_element.edge_end);
  SELF\edge.edge_end             : vertex := boolean_choose(SELF.orientation, SELF.edge_element.edge_end,
                                                            SELF.edge_element.edge_start);
WHERE
  WR1: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ORIENTED_EDGE' IN TYPEOF(SELF.edge_element));
END_ENTITY;

(* "oriented_face" IMPLICIT from SCHEMA topology_schema *)
ENTITY oriented_face
  SUBTYPE OF (face);
  face_element : face;
  orientation  : BOOLEAN;
DERIVE
  SELF\face.bounds           : SET [1 : ?] OF face_bound := conditional_reverse(SELF.orientation,
                                                                                SELF.face_element.bounds);
WHERE
  WR1: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ORIENTED_FACE' IN TYPEOF(SELF.face_element));
END_ENTITY;

(* "oriented_open_shell" IMPLICIT from SCHEMA topology_schema *)
ENTITY oriented_open_shell
  SUBTYPE OF (open_shell);
  open_shell_element : open_shell;
  orientation        : BOOLEAN;
DERIVE
  SELF\connected_face_set.cfs_faces                         : SET [1 : ?] OF face := conditional_reverse(SELF.orientation,
                                                                                                         SELF.open_shell_element.cfs_faces);
WHERE
  WR1: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ORIENTED_OPEN_SHELL' IN
            TYPEOF(SELF.open_shell_element));
END_ENTITY;

(* "oriented_path" IMPLICIT from SCHEMA topology_schema *)
ENTITY oriented_path
  SUBTYPE OF (path);
  path_element : path;
  orientation  : BOOLEAN;
DERIVE
  SELF\path.edge_list           : LIST [1 : ?] OF UNIQUE oriented_edge := conditional_reverse(SELF.orientation,
                                                                                              SELF.path_element.edge_list);
WHERE
  WR1: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ORIENTED_PATH' IN TYPEOF(SELF.path_element));
END_ENTITY;

(* "oriented_surface" USE from SCHEMA geometry_schema *)
(* "oriented_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY oriented_surface
  SUBTYPE OF (surface);
  orientation : BOOLEAN;
END_ENTITY;

(* "outer_boundary_curve" USE from SCHEMA geometry_schema *)
(* "outer_boundary_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY outer_boundary_curve
  SUBTYPE OF (boundary_curve);
END_ENTITY;

(* "over_riding_styled_item" USE from SCHEMA presentation_appearance_schema *)
(* "over_riding_styled_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY over_riding_styled_item
  SUBTYPE OF (styled_item);
  over_ridden_style : styled_item;
END_ENTITY;

(* "overlap_splice_area" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY overlap_splice_area
  SUBTYPE OF (area_based_llai);
END_ENTITY;

(* "overlap_splice_area_llai_specification" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY overlap_splice_area_llai_specification
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "package_product_concept_feature" USE from SCHEMA product_class_mim *)
(* "package_product_concept_feature" Path: PRODUCT_CLASS_MIM *)
ENTITY package_product_concept_feature
  SUBTYPE OF (product_concept_feature);
WHERE
  WR1: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF(SELF));
  WR2: SIZEOF(QUERY(cfr
                    <* USEDIN(SELF,
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONCEPT_FEATURE_RELATIONSHIP.RELATING_PRODUCT_CONCEPT_FEATURE')
                    | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN
                       TYPEOF(cfr)) AND
                      (SIZEOF(QUERY(ipcf
                                    <* USEDIN(cfr,
                                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONDITIONAL_CONCEPT_FEATURE.CONDITION')
                                    | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.INCLUSION_PRODUCT_CONCEPT_FEATURE' IN
                                      TYPEOF(ipcf))) =
                       1))) >
       0;
END_ENTITY;

(* "parabola" USE from SCHEMA geometry_schema *)
(* "parabola" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY parabola
  SUBTYPE OF (conic);
  focal_dist : length_measure;
WHERE
  WR1: focal_dist <> 0.0;
END_ENTITY;

(* "parallel_composed_function" USE from SCHEMA mathematical_functions_schema *)
(* "parallel_composed_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY parallel_composed_function
  SUBTYPE OF (maths_function, multiple_arity_generic_expression);
  source_of_domain : maths_space_or_function;
  prep_functions   : LIST [1 : ?] OF maths_function;
  final_function   : maths_function_select;
DERIVE
  SELF\multiple_arity_generic_expression.operands                                        : LIST [2 : ?] OF generic_expression := convert_to_operands_prcmfn(source_of_domain,
                                                                                                                                                            prep_functions,
                                                                                                                                                            final_function);
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
  WR3: parallel_composed_function_domain_check(domain_from(source_of_domain), prep_functions);
  WR4: parallel_composed_function_composability_check(prep_functions, final_function);
END_ENTITY;

(* "parametric_representation_context" USE from SCHEMA representation_schema *)
(* "parametric_representation_context" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,REPRESENTATION_SCHEMA *)
ENTITY parametric_representation_context
  SUBTYPE OF (representation_context);
END_ENTITY;

(* "part_laminate_table" USE from SCHEMA part_and_zone_laminate_tables_mim *)
(* "part_laminate_table" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM *)
ENTITY part_laminate_table
  SUPERTYPE OF (ONEOF(composite_assembly_table, ply_laminate_table))
  SUBTYPE OF (laminate_table);
END_ENTITY;

(* "partial_derivative_expression" USE from SCHEMA mathematical_functions_schema *)
(* "partial_derivative_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY partial_derivative_expression
  SUBTYPE OF (unary_generic_expression);
  d_variables : LIST [1 : ?] OF maths_variable;
  extension   : extension_options;
DERIVE
  derivand : generic_expression := SELF\unary_generic_expression.operand;
WHERE
  WR1: has_values_space(derivand);
  WR2: space_is_continuum(values_space_of(derivand));
  WR3: SIZEOF(QUERY(vbl
                    <* d_variables
                    | (NOT subspace_of(values_space_of(vbl), the_reals)) AND
                      (NOT subspace_of(values_space_of(vbl), the_complex_numbers)))) =
       0;
END_ENTITY;

(* "partial_derivative_function" USE from SCHEMA mathematical_functions_schema *)
(* "partial_derivative_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY partial_derivative_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  d_variables                           : LIST [1 : ?] OF input_selector;
  extension                             : extension_options;
DERIVE
  derivand : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: space_is_continuum(derivand.range);
  WR2: partial_derivative_check(derivand.domain, d_variables);
END_ENTITY;

(* "partial_document_with_structured_text_representation_assignment" USE from SCHEMA specification_document_mim *)
(* "partial_document_with_structured_text_representation_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SPECIFICATION_DOCUMENT_MIM *)
ENTITY partial_document_with_structured_text_representation_assignment
  SUBTYPE OF (applied_document_usage_constraint_assignment, characterized_object);
END_ENTITY;

(* "path" USE from SCHEMA topology_schema *)
(* "path" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,TOPOLOGY_SCHEMA *)
ENTITY path
  SUPERTYPE OF (ONEOF(edge_loop, oriented_path))
  SUBTYPE OF (topological_representation_item);
  edge_list : LIST [1 : ?] OF UNIQUE oriented_edge;
WHERE
  WR1: path_head_to_tail(SELF);
END_ENTITY;

(* "pcurve" USE from SCHEMA geometry_schema *)
(* "pcurve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTION_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY pcurve
  SUBTYPE OF (curve);
  basis_surface      : surface;
  reference_to_curve : definitional_representation;
WHERE
  WR1: SIZEOF(reference_to_curve\representation.items) = 1;
  WR2: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE' IN TYPEOF(reference_to_curve\representation.items[1]);
  WR3: reference_to_curve\representation.items[1]\geometric_representation_item.dim = 2;
END_ENTITY;

(* "percentage_laminate_table" USE from SCHEMA part_and_zone_laminate_tables_mim *)
(* "percentage_laminate_table" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM *)
ENTITY percentage_laminate_table
  SUBTYPE OF (zone_structural_makeup);
END_ENTITY;

(* "person" USE from SCHEMA person_organization_schema *)
(* "person" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,PRODUCT_VIEW_DEFINITION_MIM,PERSON_ORGANIZATION_SCHEMA *)
ENTITY person;
  id            : identifier;
  last_name     : OPTIONAL label;
  first_name    : OPTIONAL label;
  middle_names  : OPTIONAL LIST [1 : ?] OF label;
  prefix_titles : OPTIONAL LIST [1 : ?] OF label;
  suffix_titles : OPTIONAL LIST [1 : ?] OF label;
WHERE
  WR1: EXISTS(last_name) OR EXISTS(first_name);
END_ENTITY;

(* "person_and_organization" USE from SCHEMA person_organization_schema *)
(* "person_and_organization" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,PRODUCT_VIEW_DEFINITION_MIM,PERSON_ORGANIZATION_SCHEMA *)
ENTITY person_and_organization;
  the_person       : person;
  the_organization : organization;
DERIVE
  name        : label := get_name_value(SELF);
  description : text  := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF,
                     'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <=
       1;
END_ENTITY;

(* "person_and_organization_address" USE from SCHEMA person_organization_mim *)
(* "person_and_organization_address" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,PERSON_ORGANIZATION_MIM *)
ENTITY person_and_organization_address
  SUBTYPE OF (organizational_address, personal_address);
  SELF\organizational_address.organizations : SET [1 : 1] OF organization;
  SELF\personal_address.people              : SET [1 : 1] OF person;
WHERE
  WR1: SIZEOF(QUERY(pao
                    <* USEDIN(SELF\personal_address.people[1],
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PERSON_AND_ORGANIZATION.THE_PERSON')
                    | pao.the_organization :=: SELF\organizational_address.organizations[1])) =
       1;
END_ENTITY;

(* "person_and_organization_assignment" USE from SCHEMA management_resources_schema *)
(* "person_and_organization_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,PLIB_CLASS_REFERENCE_MIM,MANAGEMENT_RESOURCES_SCHEMA *)
ENTITY person_and_organization_assignment
  ABSTRACT SUPERTYPE;
  assigned_person_and_organization : person_and_organization;
  role                             : person_and_organization_role;
END_ENTITY;

(* "person_and_organization_role" USE from SCHEMA person_organization_schema *)
(* "person_and_organization_role" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTERNAL_LIBRARY_MIM,PLIB_CLASS_REFERENCE_MIM,PERSON_ORGANIZATION_SCHEMA *)
ENTITY person_and_organization_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF,
                     'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <=
       1;
END_ENTITY;

(* "personal_address" USE from SCHEMA person_organization_schema *)
(* "personal_address" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,PRODUCT_VIEW_DEFINITION_MIM,PERSON_ORGANIZATION_SCHEMA *)
ENTITY personal_address
  SUBTYPE OF (address);
  people      : SET [1 : ?] OF person;
  description : OPTIONAL text;
END_ENTITY;

(* "placement" USE from SCHEMA geometry_schema *)
(* "placement" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY placement
  SUPERTYPE OF (ONEOF(axis1_placement, axis2_placement_2d, axis2_placement_3d))
  SUBTYPE OF (geometric_representation_item);
  location : cartesian_point;
END_ENTITY;

(* "planar_box" USE from SCHEMA presentation_resource_schema *)
(* "planar_box" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_RESOURCE_SCHEMA *)
ENTITY planar_box
  SUBTYPE OF (planar_extent);
  placement : axis2_placement;
END_ENTITY;

(* "planar_extent" IMPLICIT from SCHEMA presentation_resource_schema *)
ENTITY planar_extent
  SUBTYPE OF (geometric_representation_item);
  size_in_x : length_measure;
  size_in_y : length_measure;
END_ENTITY;

(* "plane" USE from SCHEMA geometry_schema *)
(* "plane" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY plane
  SUBTYPE OF (elementary_surface);
END_ENTITY;

(* "plane_angle_measure_with_unit" USE from SCHEMA measure_schema *)
(* "plane_angle_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY plane_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PLANE_ANGLE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "plane_angle_unit" USE from SCHEMA measure_schema *)
(* "plane_angle_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY plane_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

(* "plus_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "plus_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY plus_expression
  SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

(* "ply_angle_representation" USE from SCHEMA ply_orientation_specification_mim *)
(* "ply_angle_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PLY_ORIENTATION_SPECIFICATION_MIM *)
ENTITY ply_angle_representation
  SUBTYPE OF (representation);
  SELF\representation.items : SET [1 : 1] OF measure_representation_item;
END_ENTITY;

(* "ply_drop_off_stay_out_area" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY ply_drop_off_stay_out_area
  SUBTYPE OF (area_based_llai);
END_ENTITY;

(* "ply_drop_off_stay_out_area_llai_specification" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY ply_drop_off_stay_out_area_llai_specification
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "ply_laminate_sequence_definition" USE from SCHEMA part_and_zone_laminate_tables_mim *)
(* "ply_laminate_sequence_definition" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM *)
ENTITY ply_laminate_sequence_definition
  SUBTYPE OF (product_definition);
WHERE
  WR1: SIZEOF(QUERY(pdr
                    <* USEDIN(SELF,
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
                    | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN
                      TYPEOF(pdr))) >
       0;
END_ENTITY;

(* "ply_laminate_table" USE from SCHEMA part_and_zone_laminate_tables_mim *)
(* "ply_laminate_table" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM *)
ENTITY ply_laminate_table
  SUBTYPE OF (part_laminate_table);
END_ENTITY;

(* "ply_orientation_angle" USE from SCHEMA ply_orientation_specification_mim *)
(* "ply_orientation_angle" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PLY_ORIENTATION_SPECIFICATION_MIM *)
ENTITY ply_orientation_angle
  SUBTYPE OF (representation_relationship);
  SELF\representation_relationship.rep_1 : reinforcement_orientation_basis;
  SELF\representation_relationship.rep_2 : ply_angle_representation;
END_ENTITY;

(* "ply_wrinkle_allowance_area" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY ply_wrinkle_allowance_area
  SUBTYPE OF (area_based_llai);
END_ENTITY;

(* "ply_wrinkle_allowance_area_llai_specification" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY ply_wrinkle_allowance_area_llai_specification
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "point" USE from SCHEMA geometry_schema *)
(* "point" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY point
  SUPERTYPE OF (ONEOF(cartesian_point, point_on_curve, point_on_surface, point_replica, degenerate_pcurve))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

(* "point_and_vector" USE from SCHEMA ply_orientation_specification_mim *)
(* "point_and_vector" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PLY_ORIENTATION_SPECIFICATION_MIM *)
ENTITY point_and_vector
  SUBTYPE OF (compound_representation_item, geometric_representation_item);
  SELF\compound_representation_item.item_element : point_and_vector_members;
END_ENTITY;

(* "point_array" USE from SCHEMA ply_orientation_specification_mim *)
(* "point_array" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PLY_ORIENTATION_SPECIFICATION_MIM *)
ENTITY point_array
  SUBTYPE OF (compound_representation_item, geometric_representation_item);
  SELF\compound_representation_item.item_element : point_array_members;
END_ENTITY;

(* "point_based_llai" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY point_based_llai
  SUPERTYPE OF (ONEOF(core_sample, strategy_point))
  SUBTYPE OF (limited_length_area_indicator);
END_ENTITY;

(* "point_on_curve" USE from SCHEMA geometry_schema *)
(* "point_on_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY point_on_curve
  SUBTYPE OF (point);
  basis_curve     : curve;
  point_parameter : parameter_value;
END_ENTITY;

(* "point_on_surface" USE from SCHEMA geometry_schema *)
(* "point_on_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY point_on_surface
  SUBTYPE OF (point);
  basis_surface     : surface;
  point_parameter_u : parameter_value;
  point_parameter_v : parameter_value;
END_ENTITY;

(* "point_replica" USE from SCHEMA geometry_schema *)
(* "point_replica" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRY_SCHEMA *)
ENTITY point_replica
  SUBTYPE OF (point);
  parent_pt      : point;
  transformation : cartesian_transformation_operator;
WHERE
  WR1: transformation.dim = parent_pt.dim;
  WR2: acyclic_point_replica(SELF, parent_pt);
END_ENTITY;

(* "point_style" USE from SCHEMA presentation_appearance_schema *)
(* "point_style" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY point_style
  SUBTYPE OF (founded_item);
  name          : label;
  marker        : OPTIONAL marker_select;
  marker_size   : OPTIONAL size_select;
  marker_colour : OPTIONAL colour;
WHERE
  WR1: EXISTS(marker) OR EXISTS(marker_size) OR EXISTS(marker_colour);
END_ENTITY;

(* "polar_11" USE from SCHEMA ply_orientation_specification_mim *)
(* "polar_11" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PLY_ORIENTATION_SPECIFICATION_MIM *)
ENTITY polar_11
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AXIS2_PLACEMENT_3D' IN TYPEOF(SELF));
END_ENTITY;

(* "polar_complex_number_region" USE from SCHEMA mathematical_functions_schema *)
(* "polar_complex_number_region" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY polar_complex_number_region
  SUBTYPE OF (maths_space, generic_literal);
  centre               : complex_number_literal;
  distance_constraint  : real_interval;
  direction_constraint : finite_real_interval;
WHERE
  WR1: min_exists(distance_constraint) AND (real_min(distance_constraint) >= 0.0);
  WR2: {-PI <= direction_constraint.min < PI};
  WR3: direction_constraint.max - direction_constraint.min <= 2.0 * PI;
  WR4: (direction_constraint.max - direction_constraint.min < 2.0 * PI) OR (direction_constraint.min_closure = open);
  WR5: (direction_constraint.max - direction_constraint.min < 2.0 * PI) OR (direction_constraint.max_closure = open) OR
       (direction_constraint.min = -PI);
  WR6: (real_min(distance_constraint) > 0.0) OR max_exists(distance_constraint) OR
       (direction_constraint.max - direction_constraint.min < 2.0 * PI) OR (direction_constraint.max_closure = open);
END_ENTITY;

(* "polar_point" USE from SCHEMA geometry_schema *)
(* "polar_point" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY polar_point
  SUBTYPE OF (cartesian_point);
  r     : length_measure;
  theta : plane_angle_measure;
DERIVE
  SELF\cartesian_point.coordinates                      : LIST [2 : 2] OF length_measure := [r * COS(theta),
                                                                                             r * SIN(theta)];
WHERE
  WR1: r >= 0.0;
END_ENTITY;

(* "poly_loop" USE from SCHEMA topology_schema *)
(* "poly_loop" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,TOPOLOGY_SCHEMA *)
ENTITY poly_loop
  SUBTYPE OF (loop, geometric_representation_item);
  polygon : LIST [3 : ?] OF UNIQUE cartesian_point;
END_ENTITY;

(* "polyline" USE from SCHEMA geometry_schema *)
(* "polyline" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,AIC_CSG,AIC_ADVANCED_BREP,GEOMETRY_SCHEMA *)
ENTITY polyline
  SUBTYPE OF (bounded_curve);
  points : LIST [2 : ?] OF cartesian_point;
END_ENTITY;

(* "positive_length_measure_with_unit" USE from SCHEMA measure_schema *)
(* "positive_length_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY positive_length_measure_with_unit
  SUBTYPE OF (length_measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POSITIVE_LENGTH_MEASURE' IN
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

(* "positive_plane_angle_measure_with_unit" USE from SCHEMA measure_schema *)
(* "positive_plane_angle_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY positive_plane_angle_measure_with_unit
  SUBTYPE OF (plane_angle_measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' IN
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

(* "potting_area" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY potting_area
  SUBTYPE OF (area_based_llai);
END_ENTITY;

(* "potting_area_llai_specification" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY potting_area_llai_specification
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "power_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "power_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY power_expression
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

(* "power_measure_with_unit" USE from SCHEMA measure_schema *)
(* "power_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY power_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POWER_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "power_unit" USE from SCHEMA measure_schema *)
(* "power_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY power_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.watt);
END_ENTITY;

(* "pre_defined_character_glyph" USE from SCHEMA presentation_definition_schema *)
(* "pre_defined_character_glyph" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY pre_defined_character_glyph
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

(* "pre_defined_colour" USE from SCHEMA presentation_resource_schema *)
(* "pre_defined_colour" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_RESOURCE_SCHEMA *)
ENTITY pre_defined_colour
  SUBTYPE OF (pre_defined_item, colour);
END_ENTITY;

(* "pre_defined_curve_font" USE from SCHEMA presentation_appearance_schema *)
(* "pre_defined_curve_font" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY pre_defined_curve_font
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

(* "pre_defined_item" USE from SCHEMA external_reference_schema *)
(* "pre_defined_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,CURVE_APPEARANCE_MIM,EXTERNAL_REFERENCE_SCHEMA *)
ENTITY pre_defined_item;
  name : label;
END_ENTITY;

(* "pre_defined_marker" USE from SCHEMA presentation_appearance_schema *)
(* "pre_defined_marker" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY pre_defined_marker
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

(* "pre_defined_point_marker_symbol" USE from SCHEMA curve_appearance_mim *)
(* "pre_defined_point_marker_symbol" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,CURVE_APPEARANCE_MIM *)
ENTITY pre_defined_point_marker_symbol
  SUBTYPE OF (pre_defined_marker, pre_defined_symbol);
WHERE
  WR1: SELF.name IN ['asterisk','circle','dot','plus','square','triangle','x'];
END_ENTITY;

(* "pre_defined_symbol" USE from SCHEMA presentation_definition_schema *)
(* "pre_defined_symbol" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY pre_defined_symbol
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

(* "pre_defined_terminator_symbol" USE from SCHEMA curve_appearance_mim *)
(* "pre_defined_terminator_symbol" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,CURVE_APPEARANCE_MIM *)
ENTITY pre_defined_terminator_symbol
  SUBTYPE OF (pre_defined_symbol);
WHERE
  WR1: SELF.name IN
       ['blanked arrow',
        'blanked box',
        'blanked dot',
        'blanked triangle',
        'dimension origin',
        'filled arrow',
        'filled box',
        'filled dot',
        'integral symbol',
        'open arrow',
        'slash',
        'unfilled arrow',
        'unfilled triangle',
        'filled triangle'];
END_ENTITY;

(* "pre_defined_text_font" USE from SCHEMA presentation_resource_schema *)
(* "pre_defined_text_font" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_RESOURCE_SCHEMA *)
ENTITY pre_defined_text_font
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

(* "precision_qualifier" USE from SCHEMA qualified_measure_schema *)
(* "precision_qualifier" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTENDED_MEASURE_REPRESENTATION_MIM,QUALIFIED_MEASURE_SCHEMA *)
ENTITY precision_qualifier;
  precision_value : INTEGER;
END_ENTITY;

(* "presentation_style_assignment" USE from SCHEMA presentation_appearance_schema *)
(* "presentation_style_assignment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY presentation_style_assignment
  SUBTYPE OF (founded_item);
  styles : SET [1 : ?] OF presentation_style_select;
WHERE
  WR1: SIZEOF(QUERY(style1
                    <* styles
                    | NOT (SIZEOF(QUERY(style2
                                        <* (styles - style1)
                                        | NOT ((TYPEOF(style1) <> TYPEOF(style2)) OR
                                               (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_STYLE_USAGE',
                                                        'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EXTERNALLY_DEFINED_STYLE'] *
                                                       TYPEOF(style1)) =
                                                1)))) =
                           0))) =
       0;
  WR2: SIZEOF(QUERY(style1
                    <* styles
                    | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_STYLE_USAGE' IN TYPEOF(style1))) <=
       2;
  WR3: SIZEOF(QUERY(style1
                    <* styles
                    | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_STYLE_USAGE' IN TYPEOF(style1)) AND
                      (SIZEOF(QUERY(style2
                                    <* (styles - style1)
                                    | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_STYLE_USAGE' IN
                                       TYPEOF(style2)) AND
                                      ((style1\surface_style_usage.side = both) OR
                                       (style2\surface_style_usage.side = both) OR
                                       (style1\surface_style_usage.side = style2\surface_style_usage.side)))) >
                       0))) =
       0;
END_ENTITY;

(* "presentation_style_by_context" USE from SCHEMA presentation_appearance_schema *)
(* "presentation_style_by_context" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY presentation_style_by_context
  SUBTYPE OF (presentation_style_assignment);
  style_context : style_context_select;
END_ENTITY;

(* "pressure_measure_with_unit" USE from SCHEMA measure_schema *)
(* "pressure_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY pressure_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRESSURE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "pressure_unit" USE from SCHEMA measure_schema *)
(* "pressure_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY pressure_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.pascal);
END_ENTITY;

(* "product" USE from SCHEMA product_definition_schema *)
(* "product" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,DOCUMENT_AND_VERSION_IDENTIFICATION_MIM,PRODUCT_DEFINITION_SCHEMA *)
ENTITY product;
  id                 : identifier;
  name               : label;
  description        : OPTIONAL text;
  frame_of_reference : SET [1 : ?] OF product_context;
END_ENTITY;

(* "product_category" USE from SCHEMA product_definition_schema *)
(* "product_category" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PRODUCT_DEFINITION_SCHEMA *)
ENTITY product_category;
  name        : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

(* "product_class" USE from SCHEMA product_class_mim *)
(* "product_class" Path: PRODUCT_CLASS_MIM *)
ENTITY product_class
  SUBTYPE OF (product_concept, characterized_object);
END_ENTITY;

(* "product_concept" USE from SCHEMA product_concept_schema *)
(* "product_concept" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CONFIGURATION_ITEM_MIM,PRODUCT_CONCEPT_SCHEMA *)
ENTITY product_concept;
  id             : identifier;
  name           : label;
  description    : OPTIONAL text;
  market_context : product_concept_context;
UNIQUE
  UR1: id;
END_ENTITY;

(* "product_concept_context" USE from SCHEMA application_context_schema *)
(* "product_concept_context" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CONFIGURATION_ITEM_MIM,APPLICATION_CONTEXT_SCHEMA *)
ENTITY product_concept_context
  SUBTYPE OF (application_context_element);
  market_segment_type : label;
END_ENTITY;

(* "product_concept_feature" USE from SCHEMA product_concept_schema *)
(* "product_concept_feature" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PRODUCT_CONCEPT_SCHEMA *)
ENTITY product_concept_feature;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

(* "product_concept_feature_association" USE from SCHEMA product_concept_schema *)
(* "product_concept_feature_association" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PRODUCT_CONCEPT_SCHEMA *)
ENTITY product_concept_feature_association;
  name        : label;
  description : OPTIONAL text;
  concept     : product_concept;
  feature     : product_concept_feature;
END_ENTITY;

(* "product_concept_feature_category" USE from SCHEMA product_class_mim *)
(* "product_concept_feature_category" Path: PRODUCT_CLASS_MIM *)
ENTITY product_concept_feature_category
  SUBTYPE OF (group);
WHERE
  WR1: SIZEOF(QUERY(aga
                    <* USEDIN(SELF,
                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GROUP_ASSIGNMENT.ASSIGNED_GROUP')
                    | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.APPLIED_GROUP_ASSIGNMENT' IN
                       TYPEOF(aga)) AND
                      ((aga\group_assignment.role\object_role.name <> 'specification category member') OR
                       (SIZEOF(QUERY(i
                                     <* aga\applied_group_assignment.items
                                     | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_CONCEPT_FEATURE' IN
                                        TYPEOF(i)) AND
                                       NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONDITIONAL_CONCEPT_FEATURE' IN
                                            TYPEOF(i)))) <>
                        SIZEOF(aga\applied_group_assignment.items))))) =
       0;
END_ENTITY;

(* "product_concept_feature_category_usage" USE from SCHEMA product_class_mim *)
(* "product_concept_feature_category_usage" Path: PRODUCT_CLASS_MIM *)
ENTITY product_concept_feature_category_usage
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_concept_feature_category;
  items                                : SET [1 : ?] OF category_usage_item;
WHERE
  WR1: SELF.role.name IN ['mandatory category usage','optional category usage'];
END_ENTITY;

(* "product_concept_relationship" USE from SCHEMA product_concept_schema *)
(* "product_concept_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PRODUCT_CONCEPT_SCHEMA *)
ENTITY product_concept_relationship;
  name                     : label;
  description              : OPTIONAL text;
  relating_product_concept : product_concept;
  related_product_concept  : product_concept;
END_ENTITY;

(* "product_context" IMPLICIT from SCHEMA application_context_schema *)
ENTITY product_context
  SUBTYPE OF (application_context_element);
  discipline_type : label;
END_ENTITY;

(* "product_definition" USE from SCHEMA product_definition_schema *)
(* "product_definition" Path: PRODUCT_DEFINITION_SCHEMA *)
ENTITY product_definition
  SUPERTYPE OF (ONEOF(composite_assembly_sequence_definition, laminate_table, ply_laminate_sequence_definition));
  id                 : identifier;
  description        : OPTIONAL text;
  formation          : product_definition_formation;
  frame_of_reference : product_definition_context;
DERIVE
  name : label := get_name_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

(* "product_definition_context" USE from SCHEMA application_context_schema *)
(* "product_definition_context" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,APPLICATION_CONTEXT_SCHEMA *)
ENTITY product_definition_context
  SUBTYPE OF (application_context_element);
  life_cycle_stage : label;
END_ENTITY;

(* "product_definition_context_association" USE from SCHEMA product_definition_schema *)
(* "product_definition_context_association" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,PRODUCT_DEFINITION_SCHEMA *)
ENTITY product_definition_context_association;
  definition         : product_definition;
  frame_of_reference : product_definition_context;
  role               : product_definition_context_role;
END_ENTITY;

(* "product_definition_context_role" IMPLICIT from SCHEMA product_definition_schema *)
ENTITY product_definition_context_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

(* "product_definition_formation" USE from SCHEMA product_definition_schema *)
(* "product_definition_formation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,DOCUMENT_AND_VERSION_IDENTIFICATION_MIM,PRODUCT_DEFINITION_SCHEMA *)
ENTITY product_definition_formation;
  id          : identifier;
  description : OPTIONAL text;
  of_product  : product;
UNIQUE
  UR1: id, of_product;
END_ENTITY;

(* "product_definition_formation_relationship" USE from SCHEMA product_definition_schema *)
(* "product_definition_formation_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,PRODUCT_DEFINITION_SCHEMA *)
ENTITY product_definition_formation_relationship;
  id                                    : identifier;
  name                                  : label;
  description                           : OPTIONAL text;
  relating_product_definition_formation : product_definition_formation;
  related_product_definition_formation  : product_definition_formation;
END_ENTITY;

(* "product_definition_occurrence" USE from SCHEMA product_structure_schema *)
(* "product_definition_occurrence" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,PRODUCT_STRUCTURE_SCHEMA *)
ENTITY product_definition_occurrence
  SUPERTYPE OF (product_definition_specified_occurrence);
  id          : identifier;
  name        : OPTIONAL label;
  description : OPTIONAL text;
  definition  : OPTIONAL product_definition_or_reference_or_occurrence;
  quantity    : OPTIONAL measure_with_unit;
DERIVE
  descendant_occurrences : SET [0 : ?] OF product_definition_specified_occurrence := get_descendant_occurrences(SELF);
INVERSE
  assembly_usages   : SET [0:?] OF assembly_component_usage FOR related_product_definition;
  child_occurrences : SET [0:?] OF product_definition_specified_occurrence FOR occurrence_usage;
WHERE
  WR1: NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION_OCCURRENCE' IN
             TYPEOF(definition)) OR
            ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION_OCCURRENCE_REFERENCE' IN
             TYPEOF(definition))) OR
           ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION_SPECIFIED_OCCURRENCE' IN
            TYPEOF(SELF));
  WR2: EXISTS(definition) OR
       (SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONFIGURATION_DESIGN.DESIGN')) > 0);
  WR3: NOT ('NUMBER' IN TYPEOF(quantity\measure_with_unit.value_component)) OR
           (quantity\measure_with_unit.value_component > 0);
END_ENTITY;

(* "product_definition_reference" USE from SCHEMA product_definition_schema *)
(* "product_definition_reference" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,PRODUCT_DEFINITION_SCHEMA *)
ENTITY product_definition_reference
  SUBTYPE OF (generic_product_definition_reference);
  product_id                      : identifier;
  product_definition_formation_id : identifier;
  product_definition_id           : identifier;
  id_owning_organization_name     : OPTIONAL label;
END_ENTITY;

(* "product_definition_reference_with_local_representation" USE from SCHEMA product_definition_schema *)
(* "product_definition_reference_with_local_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,ASSEMBLY_STRUCTURE_MIM,PRODUCT_DEFINITION_SCHEMA *)
ENTITY product_definition_reference_with_local_representation
  SUBTYPE OF (generic_product_definition_reference, product_definition);
END_ENTITY;

(* "product_definition_relationship" USE from SCHEMA product_definition_schema *)
(* "product_definition_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,PRODUCT_DEFINITION_SCHEMA *)
ENTITY product_definition_relationship;
  id                          : identifier;
  name                        : label;
  description                 : OPTIONAL text;
  relating_product_definition : product_definition_or_reference;
  related_product_definition  : product_definition_or_reference;
END_ENTITY;

(* "product_definition_shape" USE from SCHEMA product_property_definition_schema *)
(* "product_definition_shape" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PRODUCT_PROPERTY_DEFINITION_SCHEMA *)
ENTITY product_definition_shape
  SUBTYPE OF (property_definition);
UNIQUE
  UR1: SELF\property_definition.definition;
WHERE
  WR1: SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CHARACTERIZED_PRODUCT_DEFINITION',
               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CHARACTERIZED_OBJECT'] *
              TYPEOF(SELF\property_definition.definition)) >
       0;
END_ENTITY;

(* "product_definition_specified_occurrence" IMPLICIT from SCHEMA product_structure_schema *)
ENTITY product_definition_specified_occurrence
  SUBTYPE OF (product_definition_occurrence);
  SELF\product_definition_occurrence.definition : product_definition_occurrence_or_reference;
  occurrence_usage                              : product_definition_occurrence_or_reference;
UNIQUE
  UR1: occurrence_usage, id;
WHERE
  WR1: SIZEOF(assembly_usages) = 0;
  WR2: acyclic_product_definition_specified_occurrence(SELF, SELF\product_definition_occurrence.definition);
END_ENTITY;

(* "product_definition_usage" USE from SCHEMA product_structure_schema *)
(* "product_definition_usage" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,PRODUCT_STRUCTURE_SCHEMA *)
ENTITY product_definition_usage
  SUPERTYPE OF (ONEOF(make_from_usage_option, assembly_component_usage))
  SUBTYPE OF (product_definition_relationship);
UNIQUE
  UR1: SELF\product_definition_relationship.id, SELF\product_definition_relationship.relating_product_definition,
       SELF\product_definition_relationship.related_product_definition;
WHERE
  WR1: acyclic_product_definition_relationship(SELF, [SELF\product_definition_relationship.related_product_definition],
                                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION_USAGE');
END_ENTITY;

(* "product_definition_with_associated_documents" USE from SCHEMA product_definition_schema *)
(* "product_definition_with_associated_documents" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,DOCUMENT_ASSIGNMENT_MIM,PRODUCT_DEFINITION_SCHEMA *)
ENTITY product_definition_with_associated_documents
  SUBTYPE OF (product_definition);
  documentation_ids : SET [1 : ?] OF document;
END_ENTITY;

(* "product_related_product_category" USE from SCHEMA product_definition_schema *)
(* "product_related_product_category" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PRODUCT_DEFINITION_SCHEMA *)
ENTITY product_related_product_category
  SUBTYPE OF (product_category);
  products : SET [1 : ?] OF product;
END_ENTITY;

(* "projection_curve" USE from SCHEMA draughting_element_schema *)
(* "projection_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_SCHEMA *)
ENTITY projection_curve
  SUBTYPE OF (annotation_curve_occurrence);
END_ENTITY;

(* "promissory_usage_occurrence" USE from SCHEMA product_structure_schema *)
(* "promissory_usage_occurrence" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,PRODUCT_STRUCTURE_SCHEMA *)
ENTITY promissory_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;

(* "property_definition" USE from SCHEMA product_property_definition_schema *)
(* "property_definition" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,PRODUCT_PROPERTY_DEFINITION_SCHEMA *)
ENTITY property_definition;
  name        : label;
  description : OPTIONAL text;
  definition  : characterized_definition;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

(* "property_definition_relationship" USE from SCHEMA material_property_definition_schema *)
(* "property_definition_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,MATERIAL_PROPERTY_DEFINITION_SCHEMA *)
ENTITY property_definition_relationship;
  name                         : label;
  description                  : text;
  relating_property_definition : property_definition;
  related_property_definition  : property_definition;
END_ENTITY;

(* "property_definition_representation" USE from SCHEMA product_property_representation_schema *)
(* "property_definition_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,PRODUCT_PROPERTY_REPRESENTATION_SCHEMA *)
ENTITY property_definition_representation;
  definition          : represented_definition;
  used_representation : representation;
DERIVE
  description : text  := get_description_value(SELF);
  name        : label := get_name_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF,
                     'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <=
       1;
  WR2: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

(* "qualified_representation_item" USE from SCHEMA qualified_measure_schema *)
(* "qualified_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTENDED_MEASURE_REPRESENTATION_MIM,QUALIFIED_MEASURE_SCHEMA *)
ENTITY qualified_representation_item
  SUBTYPE OF (representation_item);
  qualifiers : SET [1 : ?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp
                    <* qualifiers
                    | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRECISION_QUALIFIER' IN TYPEOF(temp)) OR
                      ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MATHS_VALUE_PRECISION_QUALIFIER' IN
                       TYPEOF(temp)))) <
       2;
END_ENTITY;

(* "qualitative_uncertainty" USE from SCHEMA qualified_measure_schema *)
(* "qualitative_uncertainty" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTENDED_MEASURE_REPRESENTATION_MIM,QUALIFIED_MEASURE_SCHEMA *)
ENTITY qualitative_uncertainty
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : text;
END_ENTITY;

(* "quantified_assembly_component_usage" USE from SCHEMA product_structure_schema *)
(* "quantified_assembly_component_usage" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,PRODUCT_STRUCTURE_SCHEMA *)
ENTITY quantified_assembly_component_usage
  SUBTYPE OF (assembly_component_usage);
  quantity : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component))) OR (quantity.value_component > 0);
END_ENTITY;

(* "quantifier_expression" USE from SCHEMA mathematical_functions_schema *)
(* "quantifier_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY quantifier_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (multiple_arity_generic_expression);
  variables : LIST [1 : ?] OF UNIQUE generic_variable;
WHERE
  WR1: SIZEOF(QUERY(vrbl <* variables | NOT (vrbl IN SELF\multiple_arity_generic_expression.operands))) = 0;
  WR2: SIZEOF(QUERY(vrbl
                    <* variables
                    | NOT ((schema_prefix + 'BOUND_VARIABLE_SEMANTICS') IN TYPEOF(vrbl.interpretation.semantics)))) =
       0;
END_ENTITY;

(* "quasi_uniform_curve" USE from SCHEMA geometry_schema *)
(* "quasi_uniform_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY quasi_uniform_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY;

(* "quasi_uniform_surface" USE from SCHEMA geometry_schema *)
(* "quasi_uniform_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY quasi_uniform_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY;

(* "radioactivity_measure_with_unit" USE from SCHEMA measure_schema *)
(* "radioactivity_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY radioactivity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.RADIOACTIVITY_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "radioactivity_unit" USE from SCHEMA measure_schema *)
(* "radioactivity_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY radioactivity_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.becquerel);
END_ENTITY;

(* "range_characteristic" USE from SCHEMA characteristic_mim *)
(* "range_characteristic" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,CHARACTERISTIC_MIM *)
ENTITY range_characteristic
  SUBTYPE OF (representation, descriptive_representation_item);
WHERE
  WR1: NOT (SELF\representation.name IN
            ['tolerance',
             'minimum tolerance',
             'maximum tolerance',
             'nominal tolerance',
             'plus minus tolerance',
             'symmetrical tolerance',
             'statistical tolerance']);
END_ENTITY;

(* "ratio_measure_with_unit" USE from SCHEMA measure_schema *)
(* "ratio_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY ratio_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.RATIO_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "ratio_unit" USE from SCHEMA measure_schema *)
(* "ratio_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY ratio_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

(* "rational_b_spline_curve" USE from SCHEMA geometry_schema *)
(* "rational_b_spline_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY rational_b_spline_curve
  SUBTYPE OF (b_spline_curve);
  weights_data : LIST [2 : ?] OF REAL;
DERIVE
  weights : ARRAY [0 : upper_index_on_control_points] OF REAL := list_to_array(weights_data, 0,
                                                                               upper_index_on_control_points);
WHERE
  WR1: SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.control_points_list);
  WR2: curve_weights_positive(SELF);
END_ENTITY;

(* "rational_b_spline_surface" USE from SCHEMA geometry_schema *)
(* "rational_b_spline_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY rational_b_spline_surface
  SUBTYPE OF (b_spline_surface);
  weights_data : LIST [2 : ?] OF LIST [2 : ?] OF REAL;
DERIVE
  weights : ARRAY [0 : u_upper] OF ARRAY [0 : v_upper] OF REAL := make_array_of_array(weights_data, 0, u_upper, 0,
                                                                                      v_upper);
WHERE
  WR1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.control_points_list)) AND
       (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_surface.control_points_list[1]));
  WR2: surface_weights_positive(SELF);
END_ENTITY;

(* "rational_representation_item" USE from SCHEMA basic_data_representation_mim *)
(* "rational_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,BASIC_DATA_REPRESENTATION_MIM *)
ENTITY rational_representation_item
  SUBTYPE OF (representation_item, slash_expression);
WHERE
  WR1: SIZEOF(QUERY(operand
                    <* SELF\binary_generic_expression.operands
                    | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.INT_LITERAL' IN TYPEOF(operand)))) =
       0;
END_ENTITY;

(* "rationalize_function" USE from SCHEMA mathematical_functions_schema *)
(* "rationalize_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY rationalize_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
DERIVE
  fun : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: (space_dimension(fun.domain) = 1) AND (space_dimension(fun.range) = 1);
  WR2: number_tuple_subspace_check(factor1(fun.range));
  WR3: space_dimension(factor1(fun.range)) > 1;
END_ENTITY;

(* "real_defined_function" USE from SCHEMA iso13584_expressions_schema *)
(* "real_defined_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY real_defined_function
  ABSTRACT SUPERTYPE
  SUBTYPE OF (numeric_defined_function);
END_ENTITY;

(* "real_interval_from_min" USE from SCHEMA mathematical_functions_schema *)
(* "real_interval_from_min" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY real_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
END_ENTITY;

(* "real_interval_to_max" USE from SCHEMA mathematical_functions_schema *)
(* "real_interval_to_max" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY real_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max         : REAL;
  max_closure : open_closed;
END_ENTITY;

(* "real_literal" USE from SCHEMA iso13584_expressions_schema *)
(* "real_literal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY real_literal
  SUBTYPE OF (literal_number);
  SELF\literal_number.the_value : REAL;
END_ENTITY;

(* "real_numeric_variable" USE from SCHEMA iso13584_expressions_schema *)
(* "real_numeric_variable" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY real_numeric_variable
  SUBTYPE OF (numeric_variable);
END_ENTITY;

(* "real_representation_item" USE from SCHEMA basic_data_representation_mim *)
(* "real_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,BASIC_DATA_REPRESENTATION_MIM *)
ENTITY real_representation_item
  SUBTYPE OF (representation_item, real_literal);
END_ENTITY;

(* "real_tuple_literal" USE from SCHEMA mathematical_functions_schema *)
(* "real_tuple_literal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY real_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST [1 : ?] OF REAL;
END_ENTITY;

(* "rectangular_composite_surface" USE from SCHEMA geometry_schema *)
(* "rectangular_composite_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRY_SCHEMA *)
ENTITY rectangular_composite_surface
  SUBTYPE OF (bounded_surface);
  segments : LIST [1 : ?] OF LIST [1 : ?] OF surface_patch;
DERIVE
  n_u : INTEGER := SIZEOF(segments);
  n_v : INTEGER := SIZEOF(segments[1]);
WHERE
  WR1: SIZEOF(QUERY(s <* segments | n_v <> SIZEOF(s))) = 0;
  WR2: constraints_rectangular_composite_surface(SELF);
END_ENTITY;

(* "rectangular_pyramid" USE from SCHEMA geometric_model_schema *)
(* "rectangular_pyramid" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY rectangular_pyramid
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  xlength  : positive_length_measure;
  ylength  : positive_length_measure;
  height   : positive_length_measure;
END_ENTITY;

(* "rectangular_trimmed_surface" USE from SCHEMA geometry_schema *)
(* "rectangular_trimmed_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRY_SCHEMA *)
ENTITY rectangular_trimmed_surface
  SUBTYPE OF (bounded_surface);
  basis_surface : surface;
  u1            : parameter_value;
  u2            : parameter_value;
  v1            : parameter_value;
  v2            : parameter_value;
  usense        : BOOLEAN;
  vsense        : BOOLEAN;
WHERE
  WR1: u1 <> u2;
  WR2: v1 <> v2;
  WR3: (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface)) AND
        (NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PLANE' IN TYPEOF(basis_surface)))) OR
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface)) OR
       (usense = (u2 > u1));
  WR4: (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SPHERICAL_SURFACE' IN TYPEOF(basis_surface)) OR
        ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TOROIDAL_SURFACE' IN TYPEOF(basis_surface))) OR
       (vsense = (v2 > v1));
END_ENTITY;

(* "regular_table_function" USE from SCHEMA mathematical_functions_schema *)
(* "regular_table_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY regular_table_function
  SUBTYPE OF (linearized_table_function);
  increments : LIST [1 : ?] OF INTEGER;
WHERE
  WR1: SIZEOF(increments) = SIZEOF(SELF\explicit_table_function.shape);
  WR2: extremal_position_check(SELF);
END_ENTITY;

(* "reindexed_array_function" USE from SCHEMA mathematical_functions_schema *)
(* "reindexed_array_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY reindexed_array_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  starting_indices                      : LIST [1 : ?] OF INTEGER;
WHERE
  WR1: function_is_array(SELF\unary_generic_expression.operand);
  WR2: SIZEOF(starting_indices) = SIZEOF(shape_of_array(SELF\unary_generic_expression.operand));
END_ENTITY;

(* "reinforcement_orientation_basis" USE from SCHEMA ply_orientation_specification_mim *)
(* "reinforcement_orientation_basis" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PLY_ORIENTATION_SPECIFICATION_MIM *)
ENTITY reinforcement_orientation_basis
  SUBTYPE OF (representation);
  SELF\representation.items : SET [1 : 1] OF basis_11_direction_member;
END_ENTITY;

(* "repackaging_function" USE from SCHEMA mathematical_functions_schema *)
(* "repackaging_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY repackaging_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  input_repack                          : repackage_options;
  output_repack                         : repackage_options;
  selected_output                       : nonnegative_integer;
WHERE
  WR1: (input_repack <> ro_wrap_as_tuple) OR
       ((space_dimension(operand.domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(operand.domain))));
  WR2: (output_repack <> ro_unwrap_tuple) OR
       ((space_dimension(operand.range) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(operand.range))));
  WR3: selected_output <= space_dimension(repackage(operand.range, output_repack));
END_ENTITY;

(* "reparametrised_composite_curve_segment" USE from SCHEMA geometry_schema *)
(* "reparametrised_composite_curve_segment" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY reparametrised_composite_curve_segment
  SUBTYPE OF (composite_curve_segment);
  param_length : parameter_value;
WHERE
  WR1: param_length > 0.0;
END_ENTITY;

(* "repositioned_tessellated_item" USE from SCHEMA geometric_model_schema *)
(* "repositioned_tessellated_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY repositioned_tessellated_item
  SUBTYPE OF (tessellated_item);
  location : axis2_placement_3d;
WHERE
  WR1: NOT (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TESSELLATED_CURVE_SET',
                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TESSELLATED_GEOMETRIC_SET',
                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TESSELLATED_POINT_SET',
                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TESSELLATED_SURFACE_SET',
                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TESSELLATED_SHELL',
                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TESSELLATED_SOLID',
                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TESSELLATED_WIRE'] *
                   TYPEOF(SELF)) =
            0);
END_ENTITY;

(* "representation" USE from SCHEMA representation_schema *)
(* "representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,REPRESENTATION_SCHEMA *)
ENTITY representation
  SUPERTYPE OF (ONEOF(reinforcement_orientation_basis, ply_angle_representation));
  name             : label;
  items            : SET [1 : ?] OF representation_item;
  context_of_items : representation_context;
DERIVE
  id          : identifier := get_id_value(SELF);
  description : text       := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF,
                     'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <=
       1;
END_ENTITY;

(* "representation_context" USE from SCHEMA representation_schema *)
(* "representation_context" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,REPRESENTATION_SCHEMA *)
ENTITY representation_context;
  context_identifier : identifier;
  context_type       : text;
INVERSE
  representations_in_context : SET [1:?] OF representation FOR context_of_items;
END_ENTITY;

(* "representation_context_reference" USE from SCHEMA representation_schema *)
(* "representation_context_reference" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,REPRESENTATION_SCHEMA *)
ENTITY representation_context_reference;
  context_identifier : identifier;
INVERSE
  representations_in_context : SET [1:?] OF representation_reference FOR context_of_items;
END_ENTITY;

(* "representation_item" USE from SCHEMA representation_schema *)
(* "representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,REPRESENTATION_SCHEMA *)
ENTITY representation_item
  SUPERTYPE OF ((ONEOF(boolean_representation_item, date_representation_item, date_time_representation_item,
                       integer_representation_item, logical_representation_item, rational_representation_item,
                       real_representation_item)) ANDOR
                ONEOF(compound_representation_item, mapped_item, value_representation_item) ANDOR
                ONEOF(mapped_item, styled_item));
  name : label;
WHERE
  WR1: SIZEOF(using_representations(SELF)) > 0;
END_ENTITY;

(* "representation_item_relationship" USE from SCHEMA representation_schema *)
(* "representation_item_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,REPRESENTATION_SCHEMA *)
ENTITY representation_item_relationship;
  name                         : label;
  description                  : OPTIONAL text;
  relating_representation_item : representation_item;
  related_representation_item  : representation_item;
END_ENTITY;

(* "representation_map" USE from SCHEMA representation_schema *)
(* "representation_map" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,REPRESENTATION_SCHEMA *)
ENTITY representation_map;
  mapping_origin        : representation_item;
  mapped_representation : representation;
INVERSE
  map_usage : SET [1:?] OF mapped_item FOR mapping_source;
WHERE
  WR1: item_in_context(mapping_origin, mapped_representation\representation.context_of_items);
END_ENTITY;

(* "representation_reference" USE from SCHEMA representation_schema *)
(* "representation_reference" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,REPRESENTATION_SCHEMA *)
ENTITY representation_reference;
  id               : identifier;
  context_of_items : representation_context_reference;
END_ENTITY;

(* "representation_relationship" USE from SCHEMA representation_schema *)
(* "representation_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,REPRESENTATION_SCHEMA *)
ENTITY representation_relationship;
  name        : label;
  description : OPTIONAL text;
  rep_1       : representation_or_representation_reference;
  rep_2       : representation_or_representation_reference;
END_ENTITY;

(* "resistance_measure_with_unit" USE from SCHEMA measure_schema *)
(* "resistance_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY resistance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.RESISTANCE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "resistance_unit" USE from SCHEMA measure_schema *)
(* "resistance_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY resistance_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.ohm);
END_ENTITY;

(* "restriction_function" USE from SCHEMA mathematical_functions_schema *)
(* "restriction_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY restriction_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_space;
END_ENTITY;

(* "revolved_area_solid" USE from SCHEMA geometric_model_schema *)
(* "revolved_area_solid" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CURVE_SWEPT_SOLID_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY revolved_area_solid
  SUBTYPE OF (swept_area_solid);
  axis  : axis1_placement;
  angle : plane_angle_measure;
DERIVE
  axis_line : line := representation_item('') || geometric_representation_item() || curve() ||
                      line(axis.location,
                           representation_item('') || geometric_representation_item() || vector(axis.z, 1.0));
END_ENTITY;

(* "revolved_face_solid" USE from SCHEMA geometric_model_schema *)
(* "revolved_face_solid" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY revolved_face_solid
  SUBTYPE OF (swept_face_solid);
  axis  : axis1_placement;
  angle : plane_angle_measure;
DERIVE
  axis_line : line := representation_item('') || geometric_representation_item() || curve() ||
                      line(axis.location,
                           representation_item('') || geometric_representation_item() || vector(axis.z, 1.0));
END_ENTITY;

(* "right_angular_wedge" USE from SCHEMA geometric_model_schema *)
(* "right_angular_wedge" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY right_angular_wedge
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  x        : positive_length_measure;
  y        : positive_length_measure;
  z        : positive_length_measure;
  ltx      : length_measure;
WHERE
  WR1: ((0.0 <= ltx) AND (ltx < x));
END_ENTITY;

(* "right_circular_cone" USE from SCHEMA geometric_model_schema *)
(* "right_circular_cone" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY right_circular_cone
  SUBTYPE OF (geometric_representation_item);
  position   : axis1_placement;
  height     : positive_length_measure;
  radius     : length_measure;
  semi_angle : plane_angle_measure;
WHERE
  WR1: radius >= 0.0;
END_ENTITY;

(* "right_circular_cylinder" USE from SCHEMA geometric_model_schema *)
(* "right_circular_cylinder" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY right_circular_cylinder
  SUBTYPE OF (geometric_representation_item);
  position : axis1_placement;
  height   : positive_length_measure;
  radius   : positive_length_measure;
END_ENTITY;

(* "role_association" USE from SCHEMA basic_attribute_schema *)
(* "role_association" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,BASIC_ATTRIBUTE_SCHEMA *)
ENTITY role_association;
  role           : object_role;
  item_with_role : role_select;
END_ENTITY;

(* "row_representation_item" USE from SCHEMA characteristic_mim *)
(* "row_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,CHARACTERISTIC_MIM *)
ENTITY row_representation_item
  SUBTYPE OF (compound_representation_item);
  SELF\compound_representation_item.item_element : list_representation_item;
END_ENTITY;

(* "ruled_surface_swept_area_solid" USE from SCHEMA aic_curve_swept_solid *)
(* "ruled_surface_swept_area_solid" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,AIC_CURVE_SWEPT_SOLID *)
ENTITY ruled_surface_swept_area_solid
  SUBTYPE OF (surface_curve_swept_area_solid);
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF(SELF.reference_surface)) AND
       (SELF.reference_surface\b_spline_surface.u_degree = 1);
  WR2: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PCURVE' IN TYPEOF(SELF.directrix)) OR
       (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.B_SPLINE_CURVE' IN
         TYPEOF(SELF.directrix\surface_curve.curve_3d)) AND
        (SELF.directrix\surface_curve.curve_3d\b_spline_curve.degree =
         SELF.reference_surface\b_spline_surface.v_degree));
END_ENTITY;

(* "seam_curve" USE from SCHEMA geometry_schema *)
(* "seam_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY seam_curve
  SUBTYPE OF (surface_curve);
WHERE
  WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
  WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) =
       associated_surface(SELF\surface_curve.associated_geometry[2]);
  WR3: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[1]);
  WR4: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[2]);
END_ENTITY;

(* "selector_function" USE from SCHEMA mathematical_functions_schema *)
(* "selector_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY selector_function
  SUBTYPE OF (maths_function, generic_literal);
  selector         : input_selector;
  source_of_domain : maths_space_or_function;
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
END_ENTITY;

(* "series_composed_function" USE from SCHEMA mathematical_functions_schema *)
(* "series_composed_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY series_composed_function
  SUBTYPE OF (maths_function, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [2 : ?] OF maths_function;
WHERE
  WR1: composable_sequence(SELF\multiple_arity_generic_expression.operands);
END_ENTITY;

(* "shape_aspect" USE from SCHEMA product_property_definition_schema *)
(* "shape_aspect" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PRODUCT_PROPERTY_DEFINITION_SCHEMA *)
ENTITY shape_aspect;
  name                 : label;
  description          : OPTIONAL text;
  of_shape             : product_definition_shape;
  product_definitional : LOGICAL;
DERIVE
  id : identifier := get_id_value(SELF);
UNIQUE
  UR1: id, of_shape;
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

(* "shape_aspect_relationship" USE from SCHEMA product_property_definition_schema *)
(* "shape_aspect_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PRODUCT_PROPERTY_DEFINITION_SCHEMA *)
ENTITY shape_aspect_relationship;
  name                  : label;
  description           : OPTIONAL text;
  relating_shape_aspect : shape_aspect;
  related_shape_aspect  : shape_aspect;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

(* "shape_definition_representation" USE from SCHEMA product_property_representation_schema *)
(* "shape_definition_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PRODUCT_PROPERTY_REPRESENTATION_SCHEMA *)
ENTITY shape_definition_representation
  SUBTYPE OF (property_definition_representation);
  SELF\property_definition_representation.definition          : property_definition;
  SELF\property_definition_representation.used_representation : shape_representation;
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(definition)) OR
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHAPE_DEFINITION' IN
        TYPEOF(definition\property_definition.definition));
END_ENTITY;

(* "shape_representation" USE from SCHEMA product_property_representation_schema *)
(* "shape_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,PRODUCT_PROPERTY_REPRESENTATION_SCHEMA *)
ENTITY shape_representation
  SUBTYPE OF (representation);
END_ENTITY;

(* "shape_representation_reference" USE from SCHEMA product_property_representation_schema *)
(* "shape_representation_reference" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRODUCT_PROPERTY_REPRESENTATION_SCHEMA *)
ENTITY shape_representation_reference
  SUBTYPE OF (representation_reference);
END_ENTITY;

(* "shape_representation_relationship" USE from SCHEMA product_property_representation_schema *)
(* "shape_representation_relationship" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PRODUCT_PROPERTY_REPRESENTATION_SCHEMA *)
ENTITY shape_representation_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHAPE_REPRESENTATION',
               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHAPE_REPRESENTATION_REFERENCE'] *
              (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2))) >=
       1;
END_ENTITY;

(* "shell_based_surface_model" USE from SCHEMA geometric_model_schema *)
(* "shell_based_surface_model" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,MANIFOLD_SURFACE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY shell_based_surface_model
  SUBTYPE OF (geometric_representation_item);
  sbsm_boundary : SET [1 : ?] OF shell;
WHERE
  WR1: constraints_geometry_shell_based_surface_model(SELF);
END_ENTITY;

(* "shell_based_wireframe_model" USE from SCHEMA geometric_model_schema *)
(* "shell_based_wireframe_model" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,SHELL_BASED_WIREFRAME_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY shell_based_wireframe_model
  SUBTYPE OF (geometric_representation_item);
  sbwm_boundary : SET [1 : ?] OF shell;
WHERE
  WR1: constraints_geometry_shell_based_wireframe_model(SELF);
END_ENTITY;

(* "shell_based_wireframe_shape_representation" USE from SCHEMA aic_shell_based_wireframe *)
(* "shell_based_wireframe_shape_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,AIC_SHELL_BASED_WIREFRAME *)
ENTITY shell_based_wireframe_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF(QUERY(it
                    <* SELF.items
                    | NOT (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_WIREFRAME_MODEL',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AXIS2_PLACEMENT_3D'] *
                                  TYPEOF(it)) =
                           1))) =
       0;
  WR2: SIZEOF(QUERY(it
                    <* SELF.items
                    | (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_WIREFRAME_MODEL',
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM'] *
                              TYPEOF(it)) =
                       1))) >=
       1;
  WR3: SIZEOF(QUERY(sbwm
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN
                                TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(ws
                                        <* QUERY(sb
                                                 <* sbwm\shell_based_wireframe_model.sbwm_boundary
                                                 | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.WIRE_SHELL' IN
                                                    TYPEOF(sb)))
                                        | NOT (SIZEOF(QUERY(eloop
                                                            <* QUERY(wsb
                                                                     <* ws\wire_shell.wire_shell_extent
                                                                     | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN
                                                                        TYPEOF(wsb)))
                                                            | NOT (SIZEOF(QUERY(el
                                                                                <* eloop\path.edge_list
                                                                                | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_CURVE' IN
                                                                                       TYPEOF(el.edge_element)))) =
                                                                   0))) =
                                               0))) =
                           0))) =
       0;
  WR4: SIZEOF(QUERY(sbwm
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN
                                TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(ws
                                        <* QUERY(sb
                                                 <* sbwm\shell_based_wireframe_model.sbwm_boundary
                                                 | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.WIRE_SHELL' IN
                                                    TYPEOF(sb)))
                                        | NOT (SIZEOF(QUERY(eloop
                                                            <* QUERY(wsb
                                                                     <* ws\wire_shell.wire_shell_extent
                                                                     | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN
                                                                        TYPEOF(wsb)))
                                                            | NOT (SIZEOF(QUERY(pline_el
                                                                                <* QUERY(el
                                                                                         <* eloop\path.edge_list
                                                                                         | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLYLINE' IN
                                                                                            TYPEOF(el.edge_element\edge_curve.edge_geometry)))
                                                                                | NOT (SIZEOF(pline_el.edge_element\edge_curve.edge_geometry\polyline.points) >
                                                                                       2))) =
                                                                   0))) =
                                               0))) =
                           0))) =
       0;
  WR5: SIZEOF(QUERY(sbwm
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN
                                TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(ws
                                        <* QUERY(sb
                                                 <* sbwm\shell_based_wireframe_model.sbwm_boundary
                                                 | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.WIRE_SHELL' IN
                                                    TYPEOF(sb)))
                                        | NOT (SIZEOF(QUERY(eloop
                                                            <* QUERY(wsb
                                                                     <* ws\wire_shell.wire_shell_extent
                                                                     | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN
                                                                        TYPEOF(wsb)))
                                                            | NOT (SIZEOF(QUERY(el
                                                                                <* eloop\path.edge_list
                                                                                | NOT valid_wireframe_edge_curve(el.edge_element\edge_curve.edge_geometry))) =
                                                                   0))) =
                                               0))) =
                           0))) =
       0;
  WR6: SIZEOF(QUERY(sbwm
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN
                                TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(ws
                                        <* QUERY(sb
                                                 <* sbwm\shell_based_wireframe_model.sbwm_boundary
                                                 | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.WIRE_SHELL' IN
                                                    TYPEOF(sb)))
                                        | NOT (SIZEOF(QUERY(eloop
                                                            <* QUERY(wsb
                                                                     <* ws\wire_shell.wire_shell_extent
                                                                     | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN
                                                                        TYPEOF(wsb)))
                                                            | NOT (SIZEOF(QUERY(el
                                                                                <* eloop\path.edge_list
                                                                                | NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_POINT' IN
                                                                                        TYPEOF(el.edge_element.edge_start)) AND
                                                                                       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_POINT' IN
                                                                                        TYPEOF(el.edge_element.edge_end))))) =
                                                                   0))) =
                                               0))) =
                           0))) =
       0;
  WR7: SIZEOF(QUERY(sbwm
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN
                                TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(ws
                                        <* QUERY(sb
                                                 <* sbwm\shell_based_wireframe_model.sbwm_boundary
                                                 | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.WIRE_SHELL' IN
                                                    TYPEOF(sb)))
                                        | NOT (SIZEOF(QUERY(eloop
                                                            <* QUERY(wsb
                                                                     <* ws\wire_shell.wire_shell_extent
                                                                     | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN
                                                                        TYPEOF(wsb)))
                                                            | NOT (SIZEOF(QUERY(el
                                                                                <* eloop\path.edge_list
                                                                                | NOT (valid_wireframe_vertex_point(el.edge_element.edge_start\vertex_point.vertex_geometry) AND
                                                                                       valid_wireframe_vertex_point(el.edge_element.edge_end\vertex_point.vertex_geometry)))) =
                                                                   0))) =
                                               0))) =
                           0))) =
       0;
  WR8: SIZEOF(QUERY(sbwm
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN
                                TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(ws
                                        <* QUERY(sb
                                                 <* sbwm\shell_based_wireframe_model.sbwm_boundary
                                                 | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.WIRE_SHELL' IN
                                                    TYPEOF(sb)))
                                        | NOT (SIZEOF(QUERY(vloop
                                                            <* QUERY(wsb
                                                                     <* ws\wire_shell.wire_shell_extent
                                                                     | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_LOOP' IN
                                                                        TYPEOF(wsb)))
                                                            | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_POINT' IN
                                                                   TYPEOF(vloop\vertex_loop.loop_vertex)))) =
                                               0))) =
                           0))) =
       0;
  WR9: SIZEOF(QUERY(sbwm
                    <* QUERY(it
                             <* SELF.items
                             | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN
                                TYPEOF(it)))
                    | NOT (SIZEOF(QUERY(ws
                                        <* QUERY(sb
                                                 <* sbwm\shell_based_wireframe_model.sbwm_boundary
                                                 | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.WIRE_SHELL' IN
                                                    TYPEOF(sb)))
                                        | NOT (SIZEOF(QUERY(vloop
                                                            <* QUERY(wsb
                                                                     <* ws\wire_shell.wire_shell_extent
                                                                     | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_LOOP' IN
                                                                        TYPEOF(wsb)))
                                                            | NOT valid_wireframe_vertex_point(vloop\vertex_loop.loop_vertex\vertex_point.vertex_geometry))) =
                                               0))) =
                           0))) =
       0;
  WR10: SIZEOF(QUERY(sbwm
                     <* QUERY(it
                              <* SELF.items
                              | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN
                                 TYPEOF(it)))
                     | NOT (SIZEOF(QUERY(vs
                                         <* QUERY(sb
                                                  <* sbwm\shell_based_wireframe_model.sbwm_boundary
                                                  | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_SHELL' IN
                                                     TYPEOF(sb)))
                                         | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_POINT' IN
                                                TYPEOF(vs\vertex_shell.vertex_shell_extent.loop_vertex)))) =
                            0))) =
        0;
  WR11: SIZEOF(QUERY(sbwm
                     <* QUERY(it
                              <* SELF.items
                              | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN
                                 TYPEOF(it)))
                     | NOT (SIZEOF(QUERY(vs
                                         <* QUERY(sb
                                                  <* sbwm\shell_based_wireframe_model.sbwm_boundary
                                                  | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_SHELL' IN
                                                     TYPEOF(sb)))
                                         | NOT valid_wireframe_vertex_point(vs\vertex_shell.vertex_shell_extent.loop_vertex\vertex_point.vertex_geometry))) =
                            0))) =
        0;
  WR12: SIZEOF(QUERY(mi
                     <* QUERY(it
                              <* SELF.items
                              | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)))
                     | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN
                            TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) =
        0;
  WR13: SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
END_ENTITY;

(* "si_absorbed_dose_unit" USE from SCHEMA measure_schema *)
(* "si_absorbed_dose_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_absorbed_dose_unit
  SUBTYPE OF (absorbed_dose_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.gray;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

(* "si_capacitance_unit" USE from SCHEMA measure_schema *)
(* "si_capacitance_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_capacitance_unit
  SUBTYPE OF (capacitance_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.farad;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

(* "si_conductance_unit" USE from SCHEMA measure_schema *)
(* "si_conductance_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_conductance_unit
  SUBTYPE OF (conductance_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.siemens;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

(* "si_dose_equivalent_unit" USE from SCHEMA measure_schema *)
(* "si_dose_equivalent_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_dose_equivalent_unit
  SUBTYPE OF (dose_equivalent_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.sievert;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

(* "si_electric_charge_unit" USE from SCHEMA measure_schema *)
(* "si_electric_charge_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_electric_charge_unit
  SUBTYPE OF (electric_charge_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.coulomb;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

(* "si_electric_potential_unit" USE from SCHEMA measure_schema *)
(* "si_electric_potential_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_electric_potential_unit
  SUBTYPE OF (electric_potential_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.volt;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

(* "si_energy_unit" USE from SCHEMA measure_schema *)
(* "si_energy_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_energy_unit
  SUBTYPE OF (energy_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.joule;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

(* "si_force_unit" USE from SCHEMA measure_schema *)
(* "si_force_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_force_unit
  SUBTYPE OF (force_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.newton;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

(* "si_frequency_unit" USE from SCHEMA measure_schema *)
(* "si_frequency_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_frequency_unit
  SUBTYPE OF (frequency_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.hertz;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

(* "si_illuminance_unit" USE from SCHEMA measure_schema *)
(* "si_illuminance_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_illuminance_unit
  SUBTYPE OF (illuminance_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.lux;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

(* "si_inductance_unit" USE from SCHEMA measure_schema *)
(* "si_inductance_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_inductance_unit
  SUBTYPE OF (inductance_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.henry;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

(* "si_magnetic_flux_density_unit" USE from SCHEMA measure_schema *)
(* "si_magnetic_flux_density_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_magnetic_flux_density_unit
  SUBTYPE OF (magnetic_flux_density_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.tesla;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

(* "si_magnetic_flux_unit" USE from SCHEMA measure_schema *)
(* "si_magnetic_flux_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_magnetic_flux_unit
  SUBTYPE OF (magnetic_flux_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.weber;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

(* "si_power_unit" USE from SCHEMA measure_schema *)
(* "si_power_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_power_unit
  SUBTYPE OF (power_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.watt;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

(* "si_pressure_unit" USE from SCHEMA measure_schema *)
(* "si_pressure_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_pressure_unit
  SUBTYPE OF (pressure_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.pascal;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

(* "si_radioactivity_unit" USE from SCHEMA measure_schema *)
(* "si_radioactivity_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_radioactivity_unit
  SUBTYPE OF (radioactivity_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.becquerel;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

(* "si_resistance_unit" USE from SCHEMA measure_schema *)
(* "si_resistance_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_resistance_unit
  SUBTYPE OF (resistance_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.ohm;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

(* "si_unit" USE from SCHEMA measure_schema *)
(* "si_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY si_unit
  SUBTYPE OF (named_unit);
  prefix : OPTIONAL si_prefix;
  name   : si_unit_name;
DERIVE
  SELF\named_unit.dimensions                 : dimensional_exponents := dimensions_for_si_unit(name);
WHERE
  WR1: NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MASS_UNIT' IN TYPEOF(SELF)) AND
            (SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DERIVED_UNIT_ELEMENT.UNIT')) >
             0)) OR
           (prefix = si_prefix.kilo);
END_ENTITY;

(* "simple_boolean_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "simple_boolean_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY simple_boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(boolean_literal, boolean_variable))
  SUBTYPE OF (boolean_expression, simple_generic_expression);
END_ENTITY;

(* "simple_generic_expression" USE from SCHEMA iso13584_generic_expressions_schema *)
(* "simple_generic_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHS_VALUE_MIM,ISO13584_GENERIC_EXPRESSIONS_SCHEMA *)
ENTITY simple_generic_expression
  ABSTRACT SUPERTYPE OF (ONEOF(generic_literal, generic_variable))
  SUBTYPE OF (generic_expression);
END_ENTITY;

(* "simple_numeric_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "simple_numeric_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY simple_numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(literal_number, numeric_variable))
  SUBTYPE OF (numeric_expression, simple_generic_expression);
END_ENTITY;

(* "simple_string_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "simple_string_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY simple_string_expression
  ABSTRACT SUPERTYPE OF (ONEOF(string_literal, string_variable))
  SUBTYPE OF (string_expression, simple_generic_expression);
END_ENTITY;

(* "sin_function" USE from SCHEMA iso13584_expressions_schema *)
(* "sin_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY sin_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

(* "slash_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "slash_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY slash_expression
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

(* "smeared_material_definition" USE from SCHEMA part_and_zone_laminate_tables_mim *)
(* "smeared_material_definition" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM *)
ENTITY smeared_material_definition
  SUBTYPE OF (zone_structural_makeup);
END_ENTITY;

(* "solid_angle_measure_with_unit" USE from SCHEMA measure_schema *)
(* "solid_angle_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY solid_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SOLID_ANGLE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "solid_angle_unit" USE from SCHEMA measure_schema *)
(* "solid_angle_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY solid_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

(* "solid_curve_font" USE from SCHEMA styled_curve_mim *)
(* "solid_curve_font" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,STYLED_CURVE_MIM *)
ENTITY solid_curve_font
  SUBTYPE OF (pre_defined_curve_font);
END_ENTITY;

(* "solid_model" USE from SCHEMA geometric_model_schema *)
(* "solid_model" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY solid_model
  SUPERTYPE OF (ONEOF(csg_solid, manifold_solid_brep, swept_face_solid, swept_area_solid, swept_disk_solid,
                      solid_replica))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

(* "solid_replica" USE from SCHEMA geometric_model_schema *)
(* "solid_replica" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY solid_replica
  SUBTYPE OF (solid_model);
  parent_solid   : solid_model;
  transformation : cartesian_transformation_operator_3d;
WHERE
  WR1: acyclic_solid_replica(SELF, parent_solid);
  WR2: parent_solid\geometric_representation_item.dim = 3;
END_ENTITY;

(* "specification_definition" USE from SCHEMA specification_document_mim *)
(* "specification_definition" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SPECIFICATION_DOCUMENT_MIM *)
ENTITY specification_definition
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "specified_higher_usage_occurrence" USE from SCHEMA product_structure_schema *)
(* "specified_higher_usage_occurrence" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,SHAPE_PROPERTY_ASSIGNMENT_MIM,PRODUCT_STRUCTURE_SCHEMA *)
ENTITY specified_higher_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
  upper_usage : assembly_component_usage;
  next_usage  : next_assembly_usage_occurrence;
UNIQUE
  UR1: upper_usage, next_usage;
WHERE
  WR1: SELF :<>: upper_usage;
  WR2: SELF\product_definition_relationship.relating_product_definition :=: upper_usage.relating_product_definition;
  WR3: SELF\product_definition_relationship.related_product_definition :=: next_usage.related_product_definition;
  WR4: (upper_usage.related_product_definition :=: next_usage.relating_product_definition) OR
       (SIZEOF(QUERY(pdr
                     <* USEDIN(upper_usage.related_product_definition,
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                     | pdr.relating_product_definition :=: next_usage.relating_product_definition)) =
        1);
  WR5: SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SPECIFIED_HIGHER_USAGE_OCCURRENCE'] *
              TYPEOF(upper_usage)) =
       1;
END_ENTITY;

(* "sphere" USE from SCHEMA geometric_model_schema *)
(* "sphere" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY sphere
  SUBTYPE OF (geometric_representation_item);
  radius : positive_length_measure;
  centre : point;
END_ENTITY;

(* "spherical_point" USE from SCHEMA geometry_schema *)
(* "spherical_point" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY spherical_point
  SUBTYPE OF (cartesian_point);
  r     : length_measure;
  theta : plane_angle_measure;
  phi   : plane_angle_measure;
DERIVE
  SELF\cartesian_point.coordinates                      : LIST [3 : 3] OF length_measure := [r * SIN(theta) * COS(phi),
                                                                                             r * SIN(theta) * SIN(phi),
                                                                                             r * COS(theta)];
WHERE
  WR1: r >= 0.0;
END_ENTITY;

(* "spherical_surface" USE from SCHEMA geometry_schema *)
(* "spherical_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRY_SCHEMA *)
ENTITY spherical_surface
  SUBTYPE OF (elementary_surface);
  radius : positive_length_measure;
END_ENTITY;

(* "sql_mappable_defined_function" USE from SCHEMA iso13584_expressions_schema *)
(* "sql_mappable_defined_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY sql_mappable_defined_function
  ABSTRACT SUPERTYPE
  SUBTYPE OF (defined_function);
END_ENTITY;

(* "square_root_function" USE from SCHEMA iso13584_expressions_schema *)
(* "square_root_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY square_root_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

(* "standard_table_function" USE from SCHEMA mathematical_functions_schema *)
(* "standard_table_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY standard_table_function
  SUBTYPE OF (linearized_table_function);
  order : ordering_type;
WHERE
  WR1: extremal_position_check(SELF);
END_ENTITY;

(* "standard_uncertainty" USE from SCHEMA qualified_measure_schema *)
(* "standard_uncertainty" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTENDED_MEASURE_REPRESENTATION_MIM,QUALIFIED_MEASURE_SCHEMA *)
ENTITY standard_uncertainty
  SUPERTYPE OF (expanded_uncertainty)
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : REAL;
END_ENTITY;

(* "stitching_area" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY stitching_area
  SUBTYPE OF (area_based_llai);
END_ENTITY;

(* "stitching_area_llai_specification" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY stitching_area_llai_specification
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "strategy_point" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY strategy_point
  SUBTYPE OF (point_based_llai);
END_ENTITY;

(* "strategy_point_llai_specification" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY strategy_point_llai_specification
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "strict_triangular_matrix" USE from SCHEMA mathematical_functions_schema *)
(* "strict_triangular_matrix" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY strict_triangular_matrix
  SUBTYPE OF (triangular_matrix);
  main_diagonal_value : maths_value;
END_ENTITY;

(* "string_defined_function" USE from SCHEMA iso13584_expressions_schema *)
(* "string_defined_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY string_defined_function
  ABSTRACT SUPERTYPE
  SUBTYPE OF (defined_function, string_expression);
END_ENTITY;

(* "string_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "string_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY string_expression
  ABSTRACT SUPERTYPE OF (ONEOF(simple_string_expression, index_expression, substring_expression, concat_expression,
                               format_function, string_defined_function))
  SUBTYPE OF (expression);
END_ENTITY;

(* "string_literal" USE from SCHEMA iso13584_expressions_schema *)
(* "string_literal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY string_literal
  SUBTYPE OF (simple_string_expression, generic_literal);
  the_value : STRING;
END_ENTITY;

(* "string_variable" USE from SCHEMA iso13584_expressions_schema *)
(* "string_variable" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY string_variable
  SUBTYPE OF (simple_string_expression, variable);
END_ENTITY;

(* "structured_text_composition" USE from SCHEMA tagged_text_representation_mim *)
(* "structured_text_composition" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,TAGGED_TEXT_REPRESENTATION_MIM *)
ENTITY structured_text_composition
  SUBTYPE OF (compound_representation_item);
END_ENTITY;

(* "structured_text_representation" USE from SCHEMA tagged_text_representation_mim *)
(* "structured_text_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,TAGGED_TEXT_REPRESENTATION_MIM *)
ENTITY structured_text_representation
  SUBTYPE OF (representation);
  SELF\representation.items : SET [1 : ?] OF string_representation_item_select;
END_ENTITY;

(* "styled_item" USE from SCHEMA presentation_appearance_schema *)
(* "styled_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY styled_item
  SUBTYPE OF (representation_item);
  styles : SET [0 : ?] OF presentation_style_assignment;
  item   : styled_item_target;
WHERE
  WR1: (SIZEOF(styles) = 0) AND
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.STYLED_TESSELLATED_ITEM_WITH_COLOURS' IN TYPEOF(SELF)) OR
       (SIZEOF(styles) = 1) OR
       (SIZEOF(styles) > 1) AND
       (SIZEOF(QUERY(pres_style
                     <* styles
                     | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRESENTATION_STYLE_BY_CONTEXT' IN
                            TYPEOF(pres_style)))) =
        0);
  WR2: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.STYLED_ITEM' IN TYPEOF(item));
  WR3: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM' IN TYPEOF(item)) OR
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item)) OR
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONTEXT_DEPENDENT_OVER_RIDING_STYLED_ITEM' IN TYPEOF(SELF));
END_ENTITY;

(* "subedge" USE from SCHEMA topology_schema *)
(* "subedge" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,TOPOLOGY_SCHEMA *)
ENTITY subedge
  SUBTYPE OF (edge);
  parent_edge : edge;
WHERE
  WR1: SELF :<>: parent_edge;
END_ENTITY;

(* "subpath" USE from SCHEMA topology_schema *)
(* "subpath" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,TOPOLOGY_SCHEMA *)
ENTITY subpath
  SUBTYPE OF (path);
  parent_path : path;
WHERE
  WR1: SELF :<>: parent_path;
  WR2: NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE_LOOP' IN TYPEOF(SELF)) AND
            ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OPEN_PATH' IN TYPEOF(parent_path)));
END_ENTITY;

(* "substring_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "substring_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY substring_expression
  SUBTYPE OF (string_expression, multiple_arity_generic_expression);
DERIVE
  operand : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
  index1  : generic_expression := SELF\multiple_arity_generic_expression.operands[2];
  index2  : generic_expression := SELF\multiple_arity_generic_expression.operands[3];
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.STRING_EXPRESSION' IN TYPEOF(operand)) AND
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(index1)) AND
       ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(index2));
  WR2: SIZEOF(SELF\multiple_arity_generic_expression.operands) = 3;
  WR3: is_int_expr(index1);
  WR4: is_int_expr(index2);
END_ENTITY;

(* "surface" USE from SCHEMA geometry_schema *)
(* "surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY surface
  SUPERTYPE OF (ONEOF(elementary_surface, swept_surface, bounded_surface, offset_surface, surface_replica))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

(* "surface_curve" USE from SCHEMA geometry_schema *)
(* "surface_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTION_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY surface_curve
  SUPERTYPE OF (ONEOF(intersection_curve, seam_curve) ANDOR bounded_surface_curve)
  SUBTYPE OF (curve);
  curve_3d              : curve;
  associated_geometry   : LIST [1 : 2] OF pcurve_or_surface;
  master_representation : preferred_surface_curve_representation;
DERIVE
  basis_surface : SET [1 : 2] OF surface := get_basis_surface(SELF);
WHERE
  WR1: curve_3d.dim = 3;
  WR2: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PCURVE' IN TYPEOF(associated_geometry[1])) OR
       (master_representation <> pcurve_s1);
  WR3: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PCURVE' IN TYPEOF(associated_geometry[2])) OR
       (master_representation <> pcurve_s2);
  WR4: NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PCURVE' IN TYPEOF(curve_3d));
END_ENTITY;

(* "surface_curve_swept_area_solid" USE from SCHEMA geometric_model_schema *)
(* "surface_curve_swept_area_solid" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CURVE_SWEPT_SOLID_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY surface_curve_swept_area_solid
  SUBTYPE OF (swept_area_solid);
  directrix         : curve;
  start_param       : REAL;
  end_param         : REAL;
  reference_surface : surface;
WHERE
  WR1: (NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_CURVE' IN TYPEOF(directrix))) OR
       (reference_surface IN (directrix\surface_curve.basis_surface));
END_ENTITY;

(* "surface_of_linear_extrusion" USE from SCHEMA geometry_schema *)
(* "surface_of_linear_extrusion" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY surface_of_linear_extrusion
  SUBTYPE OF (swept_surface);
  extrusion_axis : vector;
END_ENTITY;

(* "surface_of_revolution" USE from SCHEMA geometry_schema *)
(* "surface_of_revolution" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY surface_of_revolution
  SUBTYPE OF (swept_surface);
  axis_position : axis1_placement;
DERIVE
  axis_line : line := representation_item('') || geometric_representation_item() || curve() ||
                      line(axis_position.location,
                           representation_item('') || geometric_representation_item() || vector(axis_position.z, 1.0));
END_ENTITY;

(* "surface_patch" USE from SCHEMA geometry_schema *)
(* "surface_patch" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY surface_patch
  SUBTYPE OF (founded_item);
  parent_surface : bounded_surface;
  u_transition   : transition_code;
  v_transition   : transition_code;
  u_sense        : BOOLEAN;
  v_sense        : BOOLEAN;
INVERSE
  using_surfaces : BAG [1:?] OF rectangular_composite_surface FOR segments;
WHERE
  WR1: (NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE_BOUNDED_SURFACE' IN TYPEOF(parent_surface)));
END_ENTITY;

(* "surface_porosity_allowance_area" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY surface_porosity_allowance_area
  SUBTYPE OF (area_based_llai);
END_ENTITY;

(* "surface_porosity_allowance_area_llai_specification" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY surface_porosity_allowance_area_llai_specification
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "surface_preparation_area" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY surface_preparation_area
  SUBTYPE OF (area_based_llai);
END_ENTITY;

(* "surface_preparation_area_llai_specification" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY surface_preparation_area_llai_specification
  SUBTYPE OF (product_definition);
END_ENTITY;

(* "surface_replica" USE from SCHEMA geometry_schema *)
(* "surface_replica" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRY_SCHEMA *)
ENTITY surface_replica
  SUBTYPE OF (surface);
  parent_surface : surface;
  transformation : cartesian_transformation_operator_3d;
WHERE
  WR1: acyclic_surface_replica(SELF, parent_surface);
END_ENTITY;

ENTITY surface_style_usage
  SUBTYPE OF (founded_item);
  side  : surface_side;
  style : surface_side_style_select;
END_ENTITY;

(* "swept_area_solid" IMPLICIT from SCHEMA geometric_model_schema *)
ENTITY swept_area_solid
  SUPERTYPE OF (ONEOF(revolved_area_solid, extruded_area_solid, surface_curve_swept_area_solid))
  SUBTYPE OF (solid_model);
  swept_area : curve_bounded_surface;
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PLANE' IN TYPEOF(swept_area.basis_surface);
END_ENTITY;

(* "swept_disk_solid" USE from SCHEMA geometric_model_schema *)
(* "swept_disk_solid" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CURVE_SWEPT_SOLID_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY swept_disk_solid
  SUBTYPE OF (solid_model);
  directrix    : curve;
  radius       : positive_length_measure;
  inner_radius : OPTIONAL positive_length_measure;
  start_param  : REAL;
  end_param    : REAL;
WHERE
  WR1: directrix.dim = 3;
  WR2: (NOT EXISTS(inner_radius)) OR (radius > inner_radius);
END_ENTITY;

(* "swept_face_solid" IMPLICIT from SCHEMA geometric_model_schema *)
ENTITY swept_face_solid
  SUPERTYPE OF (ONEOF(extruded_face_solid, revolved_face_solid))
  SUBTYPE OF (solid_model);
  swept_face : face_surface;
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PLANE' IN TYPEOF(swept_face.face_geometry);
END_ENTITY;

(* "swept_surface" USE from SCHEMA geometry_schema *)
(* "swept_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY swept_surface
  SUPERTYPE OF (ONEOF(surface_of_linear_extrusion, surface_of_revolution))
  SUBTYPE OF (surface);
  swept_curve : curve;
END_ENTITY;

(* "symmetric_banded_matrix" USE from SCHEMA mathematical_functions_schema *)
(* "symmetric_banded_matrix" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY symmetric_banded_matrix
  SUBTYPE OF (symmetric_matrix);
  default_entry : maths_value;
  above         : nonnegative_integer;
WHERE
  WR1: member_of(default_entry, factor1(SELF\linearized_table_function.source.range));
END_ENTITY;

(* "symmetric_matrix" USE from SCHEMA mathematical_functions_schema *)
(* "symmetric_matrix" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY symmetric_matrix
  SUBTYPE OF (linearized_table_function);
  symmetry : symmetry_type;
  triangle : lower_upper;
  order    : ordering_type;
WHERE
  WR1: SIZEOF(SELF\explicit_table_function.shape) = 2;
  WR2: SELF\explicit_table_function.shape[1] = SELF\explicit_table_function.shape[2];
  WR3: NOT (symmetry = symmetry_type.skew) OR
           ((space_dimension(SELF\linearized_table_function.source.range) = 1) AND
            subspace_of_es(factor1(SELF\linearized_table_function.source.range), es_numbers));
  WR4: NOT ((symmetry = symmetry_type.hermitian) OR (symmetry = symmetry_type.skew_hermitian)) OR
           ((space_dimension(SELF\linearized_table_function.source.range) = 1) AND
            subspace_of_es(factor1(SELF\linearized_table_function.source.range), es_complex_numbers));
END_ENTITY;

(* "table_representation_item" USE from SCHEMA characteristic_mim *)
(* "table_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,CHARACTERISTIC_MIM *)
ENTITY table_representation_item
  SUBTYPE OF (compound_representation_item);
WHERE
  WR1: SIZEOF(QUERY(itet
                    <* SELF\compound_representation_item.item_element
                    | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ROW_REPRESENTATION_ITEM' IN
                           TYPEOF(itet)))) =
       0;
END_ENTITY;

(* "tagged_text_format" USE from SCHEMA tagged_text_representation_mim *)
(* "tagged_text_format" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,TAGGED_TEXT_REPRESENTATION_MIM *)
ENTITY tagged_text_format
  SUBTYPE OF (representation_context);
END_ENTITY;

(* "tagged_text_item" USE from SCHEMA tagged_text_representation_mim *)
(* "tagged_text_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,TAGGED_TEXT_REPRESENTATION_MIM *)
ENTITY tagged_text_item
  SUBTYPE OF (descriptive_representation_item);
END_ENTITY;

(* "tan_function" USE from SCHEMA iso13584_expressions_schema *)
(* "tan_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY tan_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

(* "terminator_symbol" IMPLICIT from SCHEMA draughting_element_schema *)
ENTITY terminator_symbol
  SUBTYPE OF (annotation_symbol_occurrence);
  annotated_curve : annotation_curve_occurrence;
END_ENTITY;

(* "tessellated_annotation_occurrence" USE from SCHEMA draughting_element_schema *)
(* "tessellated_annotation_occurrence" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,DRAUGHTING_ELEMENT_SCHEMA *)
ENTITY tessellated_annotation_occurrence
  SUBTYPE OF (annotation_occurrence);
  SELF\styled_item.item : tessellated_geometric_set;
END_ENTITY;

(* "tessellated_connecting_edge" USE from SCHEMA geometric_model_schema *)
(* "tessellated_connecting_edge" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY tessellated_connecting_edge
  SUBTYPE OF (tessellated_edge);
  smooth           : LOGICAL;
  face1            : tessellated_face;
  face2            : tessellated_face;
  line_strip_face1 : LIST [2 : ?] OF INTEGER;
  line_strip_face2 : LIST [2 : ?] OF INTEGER;
WHERE
  WR1: SIZEOF(line_strip_face1) = SIZEOF(line_strip_face2);
  WR2: SIZEOF(line_strip_face1) = SIZEOF(SELF\tessellated_edge.line_strip);
  WR3: NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CUBIC_BEZIER_TRIANGULATED_FACE') IN TYPEOF(face1));
  WR4: NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CUBIC_BEZIER_TRIANGULATED_FACE') IN TYPEOF(face2));
END_ENTITY;

(* "tessellated_curve_set" USE from SCHEMA geometric_model_schema *)
(* "tessellated_curve_set" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY tessellated_curve_set
  SUBTYPE OF (tessellated_item);
  coordinates : coordinates_list;
  line_strips : LIST [1 : ?] OF LIST [2 : ?] OF INTEGER;
END_ENTITY;

(* "tessellated_edge" USE from SCHEMA geometric_model_schema *)
(* "tessellated_edge" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY tessellated_edge
  SUPERTYPE OF (ONEOF(tessellated_connecting_edge, cubic_bezier_tessellated_edge))
  SUBTYPE OF (tessellated_structured_item);
  coordinates    : coordinates_list;
  geometric_link : OPTIONAL edge_or_curve;
  line_strip     : LIST [2 : ?] OF INTEGER;
END_ENTITY;

(* "tessellated_face" USE from SCHEMA geometric_model_schema *)
(* "tessellated_face" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY tessellated_face
  ABSTRACT SUPERTYPE OF (ONEOF(triangulated_face, complex_triangulated_face, cubic_bezier_triangulated_face))
  SUBTYPE OF (tessellated_structured_item);
  coordinates    : coordinates_list;
  pnmax          : INTEGER;
  normals        : LIST [0 : ?] OF LIST [3 : 3] OF REAL;
  geometric_link : OPTIONAL face_or_surface;
WHERE
  WR1: ((SIZEOF(normals) = 0) OR (SIZEOF(normals) = 1) OR (SIZEOF(normals) = pnmax));
END_ENTITY;

(* "tessellated_geometric_set" USE from SCHEMA geometric_model_schema *)
(* "tessellated_geometric_set" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY tessellated_geometric_set
  SUBTYPE OF (tessellated_item);
  children : SET [1 : ?] OF tessellated_item;
END_ENTITY;

(* "tessellated_item" USE from SCHEMA geometric_model_schema *)
(* "tessellated_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY tessellated_item
  ABSTRACT SUPERTYPE OF (ONEOF(coordinates_list, tessellated_solid, tessellated_shell, tessellated_wire,
                               tessellated_geometric_set, tessellated_curve_set, tessellated_point_set,
                               tessellated_surface_set, tessellated_structured_item))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: SIZEOF(QUERY(using_rep
                    <* using_representations(SELF)
                    | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TESSELLATED_SHAPE_REPRESENTATION' IN
                           TYPEOF(using_rep)))) =
       0;
END_ENTITY;

(* "tessellated_point_set" USE from SCHEMA geometric_model_schema *)
(* "tessellated_point_set" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY tessellated_point_set
  SUBTYPE OF (tessellated_item);
  coordinates : coordinates_list;
  point_list  : LIST [1 : ?] OF INTEGER;
END_ENTITY;

(* "tessellated_shape_representation" USE from SCHEMA geometric_model_schema *)
(* "tessellated_shape_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY tessellated_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN
       TYPEOF(SELF\representation.context_of_items);
  WR2: NOT (SIZEOF(QUERY(it
                         <* SELF.items
                         | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TESSELLATED_ITEM' IN TYPEOF(it))) =
            0);
END_ENTITY;

(* "tessellated_shape_representation_with_accuracy_parameters" USE from SCHEMA geometric_model_schema *)
(* "tessellated_shape_representation_with_accuracy_parameters" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY tessellated_shape_representation_with_accuracy_parameters
  SUBTYPE OF (tessellated_shape_representation);
  tessellation_accuracy_parameters : SET [1 : ?] OF tessellation_accuracy_parameter_item;
END_ENTITY;

(* "tessellated_shell" USE from SCHEMA geometric_model_schema *)
(* "tessellated_shell" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY tessellated_shell
  SUBTYPE OF (tessellated_item);
  items            : SET [1 : ?] OF tessellated_structured_item;
  topological_link : OPTIONAL connected_face_set;
END_ENTITY;

(* "tessellated_solid" USE from SCHEMA geometric_model_schema *)
(* "tessellated_solid" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY tessellated_solid
  SUBTYPE OF (tessellated_item);
  items          : SET [1 : ?] OF tessellated_structured_item;
  geometric_link : OPTIONAL manifold_solid_brep;
END_ENTITY;

(* "tessellated_structured_item" USE from SCHEMA geometric_model_schema *)
(* "tessellated_structured_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY tessellated_structured_item
  SUPERTYPE OF (ONEOF(tessellated_face, tessellated_edge, tessellated_vertex))
  SUBTYPE OF (tessellated_item);
END_ENTITY;

(* "tessellated_surface_set" USE from SCHEMA geometric_model_schema *)
(* "tessellated_surface_set" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY tessellated_surface_set
  ABSTRACT SUPERTYPE OF (ONEOF(triangulated_surface_set, complex_triangulated_surface_set))
  SUBTYPE OF (tessellated_item);
  coordinates : coordinates_list;
  pnmax       : INTEGER;
  normals     : LIST [0 : ?] OF LIST [3 : 3] OF REAL;
WHERE
  WR1: ((SIZEOF(normals) = 0) OR (SIZEOF(normals) = 1) OR (SIZEOF(normals) = pnmax));
END_ENTITY;

(* "tessellated_vertex" USE from SCHEMA geometric_model_schema *)
(* "tessellated_vertex" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY tessellated_vertex
  SUBTYPE OF (tessellated_structured_item);
  coordinates      : coordinates_list;
  topological_link : OPTIONAL vertex_point;
  point_index      : INTEGER;
END_ENTITY;

(* "tessellated_wire" USE from SCHEMA geometric_model_schema *)
(* "tessellated_wire" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY tessellated_wire
  SUBTYPE OF (tessellated_item);
  items                : SET [1 : ?] OF tessellated_edge_or_vertex;
  geometric_model_link : OPTIONAL path_or_composite_curve;
END_ENTITY;

(* "tetrahedron" USE from SCHEMA geometric_model_schema *)
(* "tetrahedron" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY tetrahedron
  SUBTYPE OF (faceted_primitive);
WHERE
  WR1: SIZEOF(points) = 4;
  WR2: above_plane(points[1], points[2], points[3], points[4]) <> 0.0;
END_ENTITY;

(* "text_literal" USE from SCHEMA presentation_definition_schema *)
(* "text_literal" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY text_literal
  SUBTYPE OF (geometric_representation_item);
  literal   : presentable_text;
  placement : axis2_placement;
  alignment : text_alignment;
  path      : text_path;
  font      : font_select;
END_ENTITY;

(* "text_literal_with_blanking_box" USE from SCHEMA presentation_definition_schema *)
(* "text_literal_with_blanking_box" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY text_literal_with_blanking_box
  SUBTYPE OF (text_literal);
  blanking : planar_box;
END_ENTITY;

(* "text_literal_with_delineation" USE from SCHEMA presentation_definition_schema *)
(* "text_literal_with_delineation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY text_literal_with_delineation
  SUBTYPE OF (text_literal);
  delineation : text_delineation;
END_ENTITY;

(* "text_literal_with_extent" USE from SCHEMA presentation_definition_schema *)
(* "text_literal_with_extent" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY text_literal_with_extent
  SUBTYPE OF (text_literal);
  extent : planar_extent;
END_ENTITY;

(* "text_string_representation" USE from SCHEMA presentation_definition_schema *)
(* "text_string_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_DEFINITION_SCHEMA *)
ENTITY text_string_representation
  SUBTYPE OF (representation);
  SELF\representation.items : SET [1 : ?] OF text_string_representation_item;
WHERE
  WR1: SIZEOF(QUERY(item
                    <* SELF\representation.items
                    | NOT (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TEXT_LITERAL',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ANNOTATION_TEXT',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ANNOTATION_TEXT_CHARACTER',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DEFINED_CHARACTER_GLYPH',
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.COMPOSITE_TEXT'] *
                                  TYPEOF(item)) =
                           0))) >=
       1;
  WR2: SIZEOF(QUERY(a2p
                    <* QUERY(item
                             <* SELF\representation.items
                             | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AXIS2_PLACEMENT' IN TYPEOF(item))
                    | NOT ((SIZEOF(QUERY(at
                                         <* QUERY(item
                                                  <* SELF\representation.items
                                                  | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ANNOTATION_TEXT' IN
                                                    TYPEOF(item))
                                         | (at\mapped_item.mapping_target :=: a2p))) >=
                            1) OR
                           (SIZEOF(QUERY(atc
                                         <* QUERY(item
                                                  <* SELF\representation.items
                                                  | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ANNOTATION_TEXT_CHARACTER' IN
                                                    TYPEOF(item))
                                         | (atc\mapped_item.mapping_target :=: a2p))) >=
                            1)))) =
       0;
END_ENTITY;

(* "text_style" USE from SCHEMA presentation_appearance_schema *)
(* "text_style" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY text_style
  SUBTYPE OF (founded_item);
  name                 : label;
  character_appearance : character_style_select;
END_ENTITY;

(* "text_style_for_defined_font" USE from SCHEMA presentation_appearance_schema *)
(* "text_style_for_defined_font" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY text_style_for_defined_font;
  text_colour : colour;
END_ENTITY;

(* "text_style_with_box_characteristics" USE from SCHEMA presentation_appearance_schema *)
(* "text_style_with_box_characteristics" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY text_style_with_box_characteristics
  SUBTYPE OF (text_style);
  characteristics : SET [1 : 4] OF box_characteristic_select;
WHERE
  WR1: SIZEOF(QUERY(c1 <* characteristics | SIZEOF(QUERY(c2 <* characteristics - c1 | TYPEOF(c1) = TYPEOF(c2))) > 0)) =
       0;
END_ENTITY;

(* "text_style_with_mirror" USE from SCHEMA presentation_appearance_schema *)
(* "text_style_with_mirror" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY text_style_with_mirror
  SUBTYPE OF (text_style);
  mirror_placement : axis2_placement;
END_ENTITY;

(* "text_style_with_spacing" USE from SCHEMA presentation_appearance_schema *)
(* "text_style_with_spacing" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,ASSOCIATIVE_TEXT_MIM,PRESENTATION_APPEARANCE_SCHEMA *)
ENTITY text_style_with_spacing
  SUBTYPE OF (text_style);
  character_spacing : character_spacing_select;
END_ENTITY;

(* "thermal_resistance_measure_with_unit" USE from SCHEMA value_with_unit_extension_mim *)
(* "thermal_resistance_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,VALUE_WITH_UNIT_EXTENSION_MIM *)
ENTITY thermal_resistance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.THERMAL_RESISTANCE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "thermal_resistance_unit" USE from SCHEMA value_with_unit_extension_mim *)
(* "thermal_resistance_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,VALUE_WITH_UNIT_EXTENSION_MIM *)
ENTITY thermal_resistance_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensional_exponents(-1.0, -1.0, -3.0, 0.0, 1.0, 0.0, 0.0);
END_ENTITY;

(* "thermodynamic_temperature_measure_with_unit" USE from SCHEMA measure_schema *)
(* "thermodynamic_temperature_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY thermodynamic_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "thermodynamic_temperature_unit" USE from SCHEMA measure_schema *)
(* "thermodynamic_temperature_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY thermodynamic_temperature_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

(* "thickness_laminate_table" USE from SCHEMA part_and_zone_laminate_tables_mim *)
(* "thickness_laminate_table" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM *)
ENTITY thickness_laminate_table
  SUBTYPE OF (zone_structural_makeup);
END_ENTITY;

(* "time_measure_with_unit" USE from SCHEMA measure_schema *)
(* "time_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY time_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TIME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "time_unit" USE from SCHEMA measure_schema *)
(* "time_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY time_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 1.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

(* "topological_representation_item" USE from SCHEMA topology_schema *)
(* "topological_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,TOPOLOGY_SCHEMA *)
ENTITY topological_representation_item
  SUPERTYPE OF (ONEOF(vertex, edge, face_bound, face, vertex_shell, wire_shell, connected_edge_set, connected_face_set,
                      (loop ANDOR path)))
  SUBTYPE OF (representation_item);
DERIVE
  permanent_id           : identifier := get_id_value(SELF);
  permanent_aggregate_id : identifier := get_aggregate_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF,
                     'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AGGREGATE_ID_ATTRIBUTE.IDENTIFIED_ITEM')) <=
       1;
END_ENTITY;

(* "toroidal_surface" USE from SCHEMA geometry_schema *)
(* "toroidal_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY toroidal_surface
  SUBTYPE OF (elementary_surface);
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
END_ENTITY;

(* "torus" USE from SCHEMA geometric_model_schema *)
(* "torus" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY torus
  SUBTYPE OF (geometric_representation_item);
  position     : axis1_placement;
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
WHERE
  WR1: major_radius > minor_radius;
END_ENTITY;

(* "triangular_matrix" USE from SCHEMA mathematical_functions_schema *)
(* "triangular_matrix" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY triangular_matrix
  SUBTYPE OF (linearized_table_function);
  default_entry : maths_value;
  lo_up         : lower_upper;
  order         : ordering_type;
WHERE
  WR1: SIZEOF(SELF\explicit_table_function.shape) = 2;
  WR2: member_of(default_entry, SELF\maths_function.range);
END_ENTITY;

(* "triangulated_face" USE from SCHEMA geometric_model_schema *)
(* "triangulated_face" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY triangulated_face
  SUBTYPE OF (tessellated_face);
  pnindex   : LIST [0 : ?] OF INTEGER;
  triangles : LIST [1 : ?] OF LIST [3 : 3] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_face.pnmax));
  WR2: NOT ((SIZEOF(pnindex) = 0) AND (SELF\tessellated_face.pnmax <> coordinates.npoints));
END_ENTITY;

(* "triangulated_surface_set" USE from SCHEMA geometric_model_schema *)
(* "triangulated_surface_set" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,GEOMETRIC_MODEL_SCHEMA *)
ENTITY triangulated_surface_set
  SUBTYPE OF (tessellated_surface_set);
  pnindex   : LIST [0 : ?] OF INTEGER;
  triangles : LIST [1 : ?] OF LIST [3 : 3] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_surface_set.pnmax));
  WR2: NOT ((SIZEOF(pnindex) = 0) AND (SELF\tessellated_surface_set.pnmax <> coordinates.npoints));
END_ENTITY;

(* "trimmed_curve" USE from SCHEMA geometry_schema *)
(* "trimmed_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTION_GEOMETRY_MIM,GEOMETRY_SCHEMA *)
ENTITY trimmed_curve
  SUBTYPE OF (bounded_curve);
  basis_curve           : curve;
  trim_1                : SET [1 : 2] OF trimming_select;
  trim_2                : SET [1 : 2] OF trimming_select;
  sense_agreement       : BOOLEAN;
  master_representation : trimming_preference;
WHERE
  WR1: (HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
  WR2: (HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
END_ENTITY;

(* "type_qualifier" USE from SCHEMA qualified_measure_schema *)
(* "type_qualifier" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTENDED_MEASURE_REPRESENTATION_MIM,QUALIFIED_MEASURE_SCHEMA *)
ENTITY type_qualifier;
  name : label;
END_ENTITY;

(* "unary_boolean_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "unary_boolean_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY unary_boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(not_expression, odd_function))
  SUBTYPE OF (boolean_expression, unary_generic_expression);
END_ENTITY;

(* "unary_function_call" USE from SCHEMA iso13584_expressions_schema *)
(* "unary_function_call" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY unary_function_call
  ABSTRACT SUPERTYPE OF (ONEOF(abs_function, minus_function, sin_function, cos_function, tan_function, asin_function,
                               acos_function, exp_function, log_function, log2_function, log10_function,
                               square_root_function))
  SUBTYPE OF (unary_numeric_expression);
END_ENTITY;

(* "unary_generic_expression" USE from SCHEMA iso13584_generic_expressions_schema *)
(* "unary_generic_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHS_VALUE_MIM,ISO13584_GENERIC_EXPRESSIONS_SCHEMA *)
ENTITY unary_generic_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (generic_expression);
  operand : generic_expression;
END_ENTITY;

(* "unary_numeric_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "unary_numeric_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY unary_numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(unary_function_call))
  SUBTYPE OF (numeric_expression, unary_generic_expression);
  SELF\unary_generic_expression.operand : numeric_expression;
END_ENTITY;

(* "uncertainty_assigned_representation" USE from SCHEMA representation_schema *)
(* "uncertainty_assigned_representation" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTENDED_MEASURE_REPRESENTATION_MIM,REPRESENTATION_SCHEMA *)
ENTITY uncertainty_assigned_representation
  SUBTYPE OF (representation);
  uncertainty : SET [1 : ?] OF uncertainty_measure_with_unit;
END_ENTITY;

(* "uncertainty_measure_with_unit" USE from SCHEMA representation_schema *)
(* "uncertainty_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,REPRESENTATION_SCHEMA *)
ENTITY uncertainty_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  name        : label;
  description : OPTIONAL text;
WHERE
  WR1: valid_measure_value(SELF\measure_with_unit.value_component);
END_ENTITY;

(* "uncertainty_qualifier" USE from SCHEMA qualified_measure_schema *)
(* "uncertainty_qualifier" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTENDED_MEASURE_REPRESENTATION_MIM,QUALIFIED_MEASURE_SCHEMA *)
ENTITY uncertainty_qualifier
  SUPERTYPE OF (ONEOF(standard_uncertainty, qualitative_uncertainty));
  measure_name : label;
  description  : text;
END_ENTITY;

(* "uniform_curve" USE from SCHEMA geometry_schema *)
(* "uniform_curve" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY uniform_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY;

(* "uniform_product_space" USE from SCHEMA mathematical_functions_schema *)
(* "uniform_product_space" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHEMATICAL_FUNCTIONS_SCHEMA *)
ENTITY uniform_product_space
  SUBTYPE OF (maths_space, generic_literal);
  base     : maths_space;
  exponent : positive_integer;
WHERE
  WR1: expression_is_constant(base);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: base <> the_empty_space;
END_ENTITY;

(* "uniform_resource_identifier" USE from SCHEMA tagged_text_representation_mim *)
(* "uniform_resource_identifier" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,TAGGED_TEXT_REPRESENTATION_MIM *)
ENTITY uniform_resource_identifier
  SUBTYPE OF (descriptive_representation_item);
END_ENTITY;

(* "uniform_surface" USE from SCHEMA geometry_schema *)
(* "uniform_surface" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,GEOMETRY_SCHEMA *)
ENTITY uniform_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY;

(* "user_defined_11" USE from SCHEMA ply_orientation_specification_mim *)
(* "user_defined_11" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PLY_ORIENTATION_SPECIFICATION_MIM *)
ENTITY user_defined_11
  SUBTYPE OF (representation_item);
END_ENTITY;

(* "user_defined_curve_font" USE from SCHEMA styled_curve_mim *)
(* "user_defined_curve_font" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,DRAUGHTING_ELEMENT_MIM,STYLED_CURVE_MIM *)
ENTITY user_defined_curve_font
  SUBTYPE OF (curve_style_font, mapped_item);
END_ENTITY;

(* "user_defined_llai" COPY from SCHEMA limited_length_or_area_indicator_assignment_mim *)
ENTITY user_defined_llai
  SUBTYPE OF (limited_length_area_indicator);
END_ENTITY;

(* "user_defined_marker" USE from SCHEMA curve_appearance_mim *)
(* "user_defined_marker" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,CURVE_APPEARANCE_MIM *)
ENTITY user_defined_marker
  SUBTYPE OF (mapped_item, pre_defined_marker);
END_ENTITY;

(* "user_defined_terminator_symbol" USE from SCHEMA curve_appearance_mim *)
(* "user_defined_terminator_symbol" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,CURVE_APPEARANCE_MIM *)
ENTITY user_defined_terminator_symbol
  SUBTYPE OF (mapped_item, pre_defined_symbol);
END_ENTITY;

(* "value_format_type_qualifier" USE from SCHEMA qualified_measure_schema *)
(* "value_format_type_qualifier" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,CHARACTERISTIC_MIM,EXTENDED_MEASURE_REPRESENTATION_MIM,QUALIFIED_MEASURE_SCHEMA *)
ENTITY value_format_type_qualifier;
  format_type : value_format_type;
END_ENTITY;

(* "value_function" USE from SCHEMA iso13584_expressions_schema *)
(* "value_function" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY value_function
  SUPERTYPE OF (int_value_function)
  SUBTYPE OF (numeric_expression, unary_generic_expression);
  SELF\unary_generic_expression.operand : string_expression;
END_ENTITY;

(* "value_range" USE from SCHEMA extended_measure_representation_mim *)
(* "value_range" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,SPECIFICATION_DOCUMENT_MIM,EXTENDED_MEASURE_REPRESENTATION_MIM *)
ENTITY value_range
  SUBTYPE OF (compound_representation_item);
WHERE
  WR1: ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SET_REPRESENTATION_ITEM' IN TYPEOF(item_element)) AND
       value_range_wr1(item_element);
  WR2: value_range_wr2(item_element);
  WR3: value_range_wr3(item_element);
END_ENTITY;

(* "value_representation_item" USE from SCHEMA representation_schema *)
(* "value_representation_item" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,REPRESENTATION_SCHEMA *)
ENTITY value_representation_item
  SUBTYPE OF (representation_item);
  value_component : measure_value;
WHERE
  WR1: SIZEOF(QUERY(rep
                    <* using_representations(SELF)
                    | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN
                           TYPEOF(rep.context_of_items)))) =
       0;
END_ENTITY;

(* "variable" USE from SCHEMA iso13584_expressions_schema *)
(* "variable" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHS_VALUE_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY variable
  ABSTRACT SUPERTYPE OF (ONEOF(numeric_variable, boolean_variable, string_variable))
  SUBTYPE OF (generic_variable);
END_ENTITY;

(* "variable_semantics" USE from SCHEMA iso13584_generic_expressions_schema *)
(* "variable_semantics" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,MATHS_VALUE_MIM,ISO13584_GENERIC_EXPRESSIONS_SCHEMA *)
ENTITY variable_semantics
  ABSTRACT SUPERTYPE;
END_ENTITY;

(* "vector" USE from SCHEMA geometry_schema *)
(* "vector" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM,AIC_CSG,AIC_ADVANCED_BREP,GEOMETRY_SCHEMA *)
ENTITY vector
  SUBTYPE OF (geometric_representation_item);
  orientation : direction;
  magnitude   : length_measure;
WHERE
  WR1: magnitude >= 0.0;
END_ENTITY;

(* "vector_style" USE from SCHEMA curve_appearance_mim *)
(* "vector_style" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,TESSELLATED_GEOMETRY_MIM,CURVE_APPEARANCE_MIM *)
ENTITY vector_style
  SUBTYPE OF (curve_style, pre_defined_terminator_symbol);
END_ENTITY;

(* "velocity_measure_with_unit" USE from SCHEMA measure_schema *)
(* "velocity_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY velocity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VELOCITY_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "velocity_unit" USE from SCHEMA measure_schema *)
(* "velocity_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY velocity_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensional_exponents(1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0);
END_ENTITY;

(* "vertex" USE from SCHEMA topology_schema *)
(* "vertex" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,TOPOLOGY_SCHEMA *)
ENTITY vertex
  SUBTYPE OF (topological_representation_item);
END_ENTITY;

(* "vertex_loop" USE from SCHEMA topology_schema *)
(* "vertex_loop" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,TOPOLOGY_SCHEMA *)
ENTITY vertex_loop
  SUBTYPE OF (loop);
  loop_vertex : vertex;
END_ENTITY;

(* "vertex_point" USE from SCHEMA topology_schema *)
(* "vertex_point" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,TOPOLOGY_SCHEMA *)
ENTITY vertex_point
  SUBTYPE OF (vertex, geometric_representation_item);
  vertex_geometry : point;
END_ENTITY;

(* "vertex_shell" USE from SCHEMA topology_schema *)
(* "vertex_shell" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,SHELL_BASED_WIREFRAME_MIM,TOPOLOGY_SCHEMA *)
ENTITY vertex_shell
  SUBTYPE OF (topological_representation_item);
  vertex_shell_extent : vertex_loop;
END_ENTITY;

(* "volume" IMPLICIT from SCHEMA geometry_schema *)
ENTITY volume
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

(* "volume_measure_with_unit" USE from SCHEMA measure_schema *)
(* "volume_measure_with_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY volume_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VOLUME_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

(* "volume_unit" USE from SCHEMA measure_schema *)
(* "volume_unit" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,MEASURE_SCHEMA *)
ENTITY volume_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensional_exponents(3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
END_ENTITY;

(* "week_of_year_and_day_date" USE from SCHEMA date_time_schema *)
(* "week_of_year_and_day_date" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_MIM,DATE_TIME_ASSIGNMENT_MIM,DATE_TIME_SCHEMA *)
ENTITY week_of_year_and_day_date
  SUBTYPE OF (date);
  week_component : week_in_year_number;
  day_component  : OPTIONAL day_in_week_number;
WHERE
  WR1: NOT (leap_year(SELF\date.year_component)) OR {1 <= (day_component + (7 * (week_component - 1))) <= 366};
  WR2: leap_year(SELF\date.year_component) OR {1 <= (day_component + (7 * (week_component - 1))) <= 365};
END_ENTITY;

(* "wire_shell" USE from SCHEMA topology_schema *)
(* "wire_shell" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,SHELL_BASED_WIREFRAME_MIM,TOPOLOGY_SCHEMA *)
ENTITY wire_shell
  SUBTYPE OF (topological_representation_item);
  wire_shell_extent : SET [1 : ?] OF loop;
WHERE
  WR1: NOT mixed_loop_type_set(wire_shell_extent);
END_ENTITY;

(* "xor_expression" USE from SCHEMA iso13584_expressions_schema *)
(* "xor_expression" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,COMPOSITE_CONSTITUENT_SHAPE_MIM,ADVANCED_BOUNDARY_REPRESENTATION_MIM,TOPOLOGICALLY_BOUNDED_SURFACE_MIM,B_SPLINE_GEOMETRY_MIM,BASIC_GEOMETRY_MIM,ELEMENTAL_GEOMETRIC_SHAPE_MIM,ELEMENTAL_TOPOLOGY_MIM,FOUNDATION_REPRESENTATION_MIM,VALUE_WITH_UNIT_MIM,ISO13584_EXPRESSIONS_SCHEMA *)
ENTITY xor_expression
  SUBTYPE OF (binary_boolean_expression);
  SELF\binary_generic_expression.operands : LIST [2 : 2] OF boolean_expression;
END_ENTITY;

(* "year_month" USE from SCHEMA date_time_schema *)
(* "year_month" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,STOCK_MATERIAL_MIM,APPROVAL_MIM,DATE_TIME_ASSIGNMENT_MIM,DATE_TIME_SCHEMA *)
ENTITY year_month
  SUBTYPE OF (date);
  month_component : month_in_year_number;
END_ENTITY;

(* "zone_structural_makeup" USE from SCHEMA part_and_zone_laminate_tables_mim *)
(* "zone_structural_makeup" Path: LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM,PART_AND_ZONE_LAMINATE_TABLES_MIM *)
ENTITY zone_structural_makeup
  SUPERTYPE OF (ONEOF((thickness_laminate_table AND smeared_material_definition),
                      (percentage_laminate_table AND smeared_material_definition), thickness_laminate_table,
                      percentage_laminate_table, smeared_material_definition))
  SUBTYPE OF (laminate_table);
END_ENTITY;

(* "above_plane" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION above_plane(p1 : cartesian_point;
                     p2 : cartesian_point;
                     p3 : cartesian_point;
                     p4 : cartesian_point) : REAL;
LOCAL
  dir2 : direction := dummy_gri || direction([1.0,0.0,0.0]);
  dir3 : direction := dummy_gri || direction([1.0,0.0,0.0]);
  dir4 : direction := dummy_gri || direction([1.0,0.0,0.0]);
  val  : REAL;
  mag  : REAL;
END_LOCAL;
  IF (p1.dim <> 3)
  THEN
    RETURN(?);
  END_IF;
  REPEAT i := 1 TO 3;
    dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
    dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
    dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
    mag := dir4.direction_ratios[i] * dir4.direction_ratios[i];
  END_REPEAT;
  mag := SQRT(mag);
  val := mag * dot_product(dir4, cross_product(dir2, dir3).orientation);
  RETURN(val);
END_FUNCTION;

(* "acyclic" IMPLICIT from SCHEMA iso13584_generic_expressions_schema *)
FUNCTION acyclic(arg1 : generic_expression;
                 arg2 : SET OF generic_expression) : BOOLEAN;
LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SIMPLE_GENERIC_EXPRESSION' IN TYPEOF(arg1))
  THEN
    RETURN(TRUE);
  END_IF;
  IF arg1 IN arg2
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.UNARY_GENERIC_EXPRESSION' IN TYPEOF(arg1)
  THEN
    RETURN(acyclic(arg1\unary_generic_expression.operand, arg2 + [arg1]));
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BINARY_GENERIC_EXPRESSION' IN TYPEOF(arg1)
  THEN
    RETURN(acyclic(arg1\binary_generic_expression.operands[1], arg2 + [arg1]) AND
           acyclic(arg1\binary_generic_expression.operands[2], arg2 + [arg1]));
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION' IN TYPEOF(arg1)
  THEN
    result := TRUE;
    REPEAT i := 1 TO SIZEOF(arg1\multiple_arity_generic_expression.operands);
      result := result AND acyclic(arg1\multiple_arity_generic_expression.operands[i], arg2 + [arg1]);
    END_REPEAT;
    RETURN(result);
  END_IF;
  RETURN(result);
END_FUNCTION;

(* "acyclic_classification_assignment_relationship" IMPLICIT from SCHEMA management_resources_schema *)
FUNCTION acyclic_classification_assignment_relationship(relation : classification_assignment_relationship;
                                                        relatives : SET [1 : ?] OF classification_assignment;
                                                        specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF classification_assignment_relationship;
END_LOCAL;
  IF relation.relating IN relatives
  THEN
    RETURN(FALSE);
  END_IF;
  x := QUERY(car
             <* bag_to_set(USEDIN(relation.relating,
                                  'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CLASSIFICATION_ASSIGNMENT_RELATIONSHIP.RELATED'))
             | specific_relation IN TYPEOF(car));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_classification_assignment_relationship(x[i], relatives + relation.relating, specific_relation)
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "acyclic_composite_text" IMPLICIT from SCHEMA presentation_definition_schema *)
FUNCTION acyclic_composite_text(start_composite : composite_text;
                                child_text : SET [1 : ?] OF text_or_character) : LOGICAL;
LOCAL
  i                     : INTEGER;
  local_composite_text  : SET [0 : ?] OF composite_text;
  local_annotation_text : SET [0 : ?] OF annotation_text;
  local_children        : SET [0 : ?] OF text_or_character;
END_LOCAL;
  local_composite_text := QUERY(child
                                <* child_text
                                | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.COMPOSITE_TEXT' IN
                                   TYPEOF(child)));
  IF (SIZEOF(local_composite_text) > 0)
  THEN
    REPEAT i := 1 TO HIINDEX(local_composite_text);
      IF (start_composite :=: local_composite_text[i])
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  local_children := child_text;
  IF (SIZEOF(local_composite_text)) > 0
  THEN
    REPEAT i := 1 TO HIINDEX(local_composite_text);
      local_children := local_children + local_composite_text[i].collected_text;
    END_REPEAT;
  END_IF;
  local_annotation_text := QUERY(child
                                 <* child_text
                                 | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ANNOTATION_TEXT' IN
                                    TYPEOF(child)));
  IF (SIZEOF(local_annotation_text) > 0)
  THEN
    REPEAT i := 1 TO HIINDEX(local_annotation_text);
      local_children := local_children +
                        QUERY(item
                              <* local_annotation_text[i]\mapped_item.mapping_source.mapped_representation.items
                              | SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ANNOTATION_TEXT',
                                        'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.COMPOSITE_TEXT'] *
                                       TYPEOF(item)) >
                                0);
    END_REPEAT;
  END_IF;
  IF (local_children :<>: child_text)
  THEN
    RETURN(acyclic_composite_text(start_composite, local_children));
  ELSE
    RETURN(TRUE);
  END_IF;
END_FUNCTION;

(* "acyclic_curve_replica" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION acyclic_curve_replica(rep : curve_replica;
                               parent : curve) : BOOLEAN;
  IF NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE_REPLICA') IN TYPEOF(parent))
  THEN
    RETURN(TRUE);
  END_IF;
  (* Return TRUE if the parent is not of type curve_replica *)
  IF (parent :=: rep)
  THEN
    RETURN(FALSE);
  ELSE
    RETURN(acyclic_curve_replica(rep, parent\curve_replica.parent_curve));
  END_IF;
END_FUNCTION;

(* "acyclic_description_text_assignment_relationship" IMPLICIT from SCHEMA systems_engineering_representation_schema *)
FUNCTION acyclic_description_text_assignment_relationship(relation : description_text_assignment_relationship;
                                                          relatives : SET [1 : ?] OF description_text_assignment;
                                                          specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF description_text_assignment_relationship;
END_LOCAL;
  IF relation.relating IN relatives
  THEN
    RETURN(FALSE);
  END_IF;
  x := QUERY(dtar
             <* bag_to_set(USEDIN(relation.relating,
                                  'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DESCRIPTION_TEXT_ASSIGNMENT_RELATIONSHIP.RELATED'))
             | specific_relation IN TYPEOF(dtar));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_description_text_assignment_relationship(x[i], relatives + relation.relating, specific_relation)
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "acyclic_external_identification_assignment_relationship" IMPLICIT from SCHEMA management_resources_schema *)
FUNCTION acyclic_external_identification_assignment_relationship(relation : external_identification_assignment_relationship;
                                                                 relatives : SET [1 : ?] OF external_identification_assignment;
                                                                 specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF external_identification_assignment_relationship;
END_LOCAL;
  IF relation.relating IN relatives
  THEN
    RETURN(FALSE);
  END_IF;
  x := QUERY(eiar
             <* bag_to_set(USEDIN(relation.relating,
                                  'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EXTERNAL_IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.RELATED'))
             | specific_relation IN TYPEOF(eiar));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_external_identification_assignment_relationship(x[i], relatives + relation.relating,
                                                                   specific_relation)
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "acyclic_mapped_representation" IMPLICIT from SCHEMA representation_schema *)
FUNCTION acyclic_mapped_representation(mi : mapped_item) : BOOLEAN;
LOCAL
  rms : SET OF representation_map;
  mis : SET OF mapped_item;
  rs1 : SET OF representation;
  rs2 : SET OF representation;
END_LOCAL;
  rs1 := using_representations(mi);
  rs2 := [];
  -- loop as long as there are elements in rs1
  REPEAT WHILE SIZEOF(rs1) > 0;
    REPEAT i := 1 TO HIINDEX(rs1);
      rms := bag_to_set(USEDIN(rs1[i],
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
      IF SIZEOF(rms) > 0
      THEN
        REPEAT j := 1 TO HIINDEX(rms);
          mis := bag_to_set(USEDIN(rms[i],
                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM.MAPPING_SOURCE'));
          IF SIZEOF(mis) > 0
          THEN
            REPEAT j := 1 TO HIINDEX(mis);
              IF mis[i] :=: mi
              THEN
                RETURN(FALSE);
              END_IF;
              rs2 := rs2 + using_representations(mis[i]);
            END_REPEAT;
          END_IF;
        END_REPEAT;
      END_IF;
    END_REPEAT;
    rs1 := rs2;
    rs2 := [];
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "acyclic_point_replica" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION acyclic_point_replica(rep : point_replica;
                               parent : point) : BOOLEAN;
  IF NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT_REPLICA') IN TYPEOF(parent))
  THEN
    RETURN(TRUE);
  END_IF;
  (* Return TRUE if the parent is not of type point_replica *)
  IF (parent :=: rep)
  THEN
    RETURN(FALSE);
  ELSE
    RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
  END_IF;
END_FUNCTION;

(* "acyclic_product_definition_relationship" IMPLICIT from SCHEMA product_definition_schema *)
FUNCTION acyclic_product_definition_relationship(relation : product_definition_relationship;
                                                 relatives : SET [1 : ?] OF product_definition_or_reference;
                                                 specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF product_definition_relationship;
END_LOCAL;
  IF relation.relating_product_definition IN relatives
  THEN
    RETURN(FALSE);
  END_IF;
  x := QUERY(pd
             <* bag_to_set(USEDIN(relation.relating_product_definition,
                                  'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION'))
             | specific_relation IN TYPEOF(pd));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition,
                                                   specific_relation)
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "acyclic_product_definition_specified_occurrence" IMPLICIT from SCHEMA product_structure_schema *)
FUNCTION acyclic_product_definition_specified_occurrence(pdso : product_definition_specified_occurrence;
                                                         definition : product_definition_occurrence) : BOOLEAN;
  IF NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION_SPECIFIED_OCCURRENCE') IN
          TYPEOF(definition))
  THEN
    RETURN(TRUE);
  END_IF;
  IF (definition :=: pdso)
  THEN
    RETURN(FALSE);
  ELSE
    RETURN(acyclic_product_definition_specified_occurrence(pdso, definition\product_definition_occurrence.definition));
  END_IF;
END_FUNCTION;

(* "acyclic_representation_relationship" IMPLICIT from SCHEMA representation_schema *)
FUNCTION acyclic_representation_relationship(relation : representation_relationship;
                                             relatives : SET [1 : ?] OF representation;
                                             specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF representation_relationship;
END_LOCAL;
  IF relation.rep_1 IN relatives
  THEN
    RETURN(FALSE);
  END_IF;
  x := QUERY(r
             <* bag_to_set(USEDIN(relation.rep_1,
                                  'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REPRESENTATION_RELATIONSHIP.REP_2'))
             | specific_relation IN TYPEOF(r));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_representation_relationship(x[i], relatives + relation.rep_1, specific_relation)
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "acyclic_solid_replica" IMPLICIT from SCHEMA geometric_model_schema *)
FUNCTION acyclic_solid_replica(rep : solid_replica;
                               parent : solid_model) : BOOLEAN;
  IF NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SOLID_REPLICA') IN TYPEOF(parent))
  THEN
    RETURN(TRUE);
  END_IF;
  (* Return TRUE if the parent is not of type solid_replica. *)
  IF (parent :=: rep)
  THEN
    RETURN(FALSE);
  ELSE
    RETURN(acyclic_solid_replica(rep, parent\solid_replica.parent_solid));
  END_IF;
END_FUNCTION;

(* "acyclic_surface_replica" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION acyclic_surface_replica(rep : surface_replica;
                                 parent : surface) : BOOLEAN;
  IF NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_REPLICA') IN TYPEOF(parent))
  THEN
    RETURN(TRUE);
  END_IF;
  (* Return TRUE if the parent is not of type surface_replica *)
  IF (parent :=: rep)
  THEN
    RETURN(FALSE);
  ELSE
    RETURN(acyclic_surface_replica(rep, parent\surface_replica.parent_surface));
  END_IF;
END_FUNCTION;

(* "all_members_of_es" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION all_members_of_es(sv : SET OF maths_value;
                           es : elementary_space_enumerators) : LOGICAL;

CONSTANT
  base_types : SET OF STRING :=
               ['NUMBER',
                'COMPLEX_NUMBER_LITERAL',
                'REAL',
                'INTEGER',
                'LOGICAL',
                'BOOLEAN',
                'STRING',
                'BINARY',
                'MATHS_SPACE',
                'MATHS_FUNCTION',
                'LIST',
                'ELEMENTARY_SPACE_ENUMERATORS',
                'ORDERING_TYPE',
                'LOWER_UPPER',
                'SYMMETRY_TYPE',
                'ELEMENTARY_FUNCTION_ENUMERATORS',
                'OPEN_CLOSED',
                'SPACE_CONSTRAINT_TYPE',
                'REPACKAGE_OPTIONS',
                'EXTENSION_OPTIONS'];
END_CONSTANT;
LOCAL
  v        : maths_value;
  key_type : STRING             := '';
  types    : SET OF STRING;
  ge       : generic_expression;
  cum      : LOGICAL            := TRUE;
  vspc     : maths_space;
END_LOCAL;
  IF NOT EXISTS(sv) OR NOT EXISTS(es)
  THEN
    RETURN(FALSE);
  END_IF;
  CASE es OF
    es_numbers : key_type := 'NUMBER';
    es_complex_numbers : key_type := 'COMPLEX_NUMBER_LITERAL';
    es_reals : key_type := 'REAL';
    es_integers : key_type := 'INTEGER';
    es_logicals : key_type := 'LOGICAL';
    es_booleans : key_type := 'BOOLEAN';
    es_strings : key_type := 'STRING';
    es_binarys : key_type := 'BINARY';
    es_maths_spaces : key_type := 'MATHS_SPACE';
    es_maths_functions : key_type := 'MATHS_FUNCTION';
    es_generics : RETURN(TRUE);
  END_CASE;
  REPEAT i := 1 TO SIZEOF(sv);
    IF NOT EXISTS(sv[i])
    THEN
      RETURN(FALSE);
    END_IF;
    v := simplify_maths_value(sv[i]);
    types := stripped_typeof(v);
    IF key_type IN types
    THEN
      SKIP;
    END_IF;
    IF (es = es_numbers) AND ('COMPLEX_NUMBER_LITERAL' IN types)
    THEN
      SKIP;
    END_IF;
    IF SIZEOF(base_types * types) > 0
    THEN
      RETURN(FALSE);
    END_IF;
    ge := v;
    IF has_values_space(ge)
    THEN
      vspc := values_space_of(ge);
      IF NOT subspace_of_es(vspc, es)
      THEN
        IF NOT compatible_spaces(vspc, make_elementary_space(es))
        THEN
          RETURN(FALSE);
        END_IF;
        cum := UNKNOWN;
      END_IF;
    ELSE
      cum := UNKNOWN;
    END_IF;
    IF cum = FALSE
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(cum);
END_FUNCTION;

(* "any_space_satisfies" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION any_space_satisfies(sc : space_constraint_type;
                             spc : maths_space) : BOOLEAN;
LOCAL
  spc_id : elementary_space_enumerators;
END_LOCAL;
  IF (sc = sc_equal) OR NOT ('ELEMENTARY_SPACE' IN stripped_typeof(spc))
  THEN
    RETURN(FALSE);
  END_IF;
  spc_id := spc\elementary_space.space_id;
  IF sc = sc_subspace
  THEN
    RETURN(bool(spc_id = es_generics));
  END_IF;
  IF sc = sc_member
  THEN
    RETURN(bool((spc_id = es_generics) OR (spc_id = es_maths_spaces)));
  END_IF;
  -- Should be unreachable.
  RETURN(?);
END_FUNCTION;

(* "assoc_product_space" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION assoc_product_space(ts1 : tuple_space;
                             ts2 : tuple_space) : tuple_space;
LOCAL
  types1  : SET OF STRING         := stripped_typeof(ts1);
  types2  : SET OF STRING         := stripped_typeof(ts2);
  up1     : uniform_product_space := make_uniform_product_space(the_reals, 1);
  up2     : uniform_product_space := make_uniform_product_space(the_reals, 1);
  lp1     : listed_product_space  := the_zero_tuple_space;
  lp2     : listed_product_space  := the_zero_tuple_space;
  lps     : listed_product_space  := the_zero_tuple_space;
  et1     : extended_tuple_space  := the_tuples;
  et2     : extended_tuple_space  := the_tuples;
  ets     : extended_tuple_space  := the_tuples;
  use_up1 : BOOLEAN;
  use_up2 : BOOLEAN;
  use_lp1 : BOOLEAN;
  use_lp2 : BOOLEAN;
  factors : LIST OF maths_space   := [];
  tspace  : tuple_space;
END_LOCAL;
  -- Identify type of first operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types1
  THEN
    up1 := ts1;
    use_up1 := TRUE;
    use_lp1 := FALSE;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types1
    THEN
      lp1 := ts1;
      use_up1 := FALSE;
      use_lp1 := TRUE;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types1)
      THEN
        RETURN(?);
      END_IF;
      et1 := ts1;
      use_up1 := FALSE;
      use_lp1 := FALSE;
    END_IF;
  END_IF;
  -- Identify type of second operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types2
  THEN
    up2 := ts2;
    use_up2 := TRUE;
    use_lp2 := FALSE;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types2
    THEN
      lp2 := ts2;
      use_up2 := FALSE;
      use_lp2 := TRUE;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types2)
      THEN
        RETURN(?);
      END_IF;
      et2 := ts2;
      use_up2 := FALSE;
      use_lp2 := FALSE;
    END_IF;
  END_IF;
  -- Construction for each combination of cases
  IF use_up1
  THEN
    IF use_up2
    THEN
      IF up1.base = up2.base
      THEN
        tspace := make_uniform_product_space(up1.base, up1.exponent + up2.exponent);
      ELSE
        factors := [up1.base:up1.exponent,up2.base:up2.exponent];
        tspace := make_listed_product_space(factors);
      END_IF;
    ELSE
      IF use_lp2
      THEN
        factors := [up1.base:up1.exponent];
        factors := factors + lp2.factors;
        tspace := make_listed_product_space(factors);
      ELSE
        tspace := assoc_product_space(up1, et2.base);
        tspace := make_extended_tuple_space(tspace, et2.extender);
      END_IF;
    END_IF;
  ELSE
    IF use_lp1
    THEN
      IF use_up2
      THEN
        factors := [up2.base:up2.exponent];
        factors := lp1.factors + factors;
        tspace := make_listed_product_space(factors);
      ELSE
        IF use_lp2
        THEN
          tspace := make_listed_product_space(lp1.factors + lp2.factors);
        ELSE
          tspace := assoc_product_space(lp1, et2.base);
          tspace := make_extended_tuple_space(tspace, et2.extender);
        END_IF;
      END_IF;
    ELSE
      IF use_up2
      THEN
        IF et1.extender = up2.base
        THEN
          tspace := assoc_product_space(et1.base, up2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          RETURN(?);
        END_IF;
      ELSE
        IF use_lp2
        THEN
          factors := lp2.factors;
          REPEAT i := 1 TO SIZEOF(factors);
            IF et1.extender <> factors[i]
            THEN
              RETURN(?);
            END_IF;
          END_REPEAT;
          tspace := assoc_product_space(et1.base, lp2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          IF et1.extender = et2.extender
          THEN
            tspace := assoc_product_space(et1, et2.base);
          ELSE
            RETURN(?);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(tspace);
END_FUNCTION;

(* "associated_surface" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION associated_surface(arg : pcurve_or_surface) : surface;
LOCAL
  surf : surface;
END_LOCAL;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PCURVE' IN TYPEOF(arg)
  THEN
    surf := arg\pcurve.basis_surface;
  ELSE
    surf := arg;
  END_IF;
  RETURN(surf);
END_FUNCTION;

(* "atan2" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION atan2(y : REAL;
               x : REAL) : REAL;
LOCAL
  r : REAL;
END_LOCAL;
  IF (y = 0.0) AND (x = 0.0)
  THEN
    RETURN(?);
  END_IF;
  r := ATAN(y, x);
  IF x < 0.0
  THEN
    IF y < 0.0
    THEN
      r := r - PI;
    ELSE
      r := r + PI;
    END_IF;
  END_IF;
  RETURN(r);
END_FUNCTION;

(* "bag_to_set" IMPLICIT from SCHEMA support_resource_schema *)
FUNCTION bag_to_set(the_bag : BAG OF GENERIC : INTYPE) : SET OF GENERIC : INTYPE;
LOCAL
  the_set : SET OF GENERIC : INTYPE := [];
END_LOCAL;
  IF SIZEOF(the_bag) > 0
  THEN
    REPEAT i := 1 TO HIINDEX(the_bag);
      the_set := the_set + the_bag[i];
    END_REPEAT;
  END_IF;
  RETURN(the_set);
END_FUNCTION;

(* "base_axis" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION base_axis(dim : INTEGER;
                   axis1 : direction;
                   axis2 : direction;
                   axis3 : direction) : LIST [2 : 3] OF direction;
LOCAL
  u      : LIST [2 : 3] OF direction;
  factor : REAL;
  d1     : direction;
  d2     : direction;
END_LOCAL;
  IF (dim = 3)
  THEN
    d1 := NVL(normalise(axis3), dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1, axis1);
    u := [d2,second_proj_axis(d1, d2, axis2),d1];
  ELSE
    IF EXISTS(axis1)
    THEN
      d1 := normalise(axis1);
      u := [d1,orthogonal_complement(d1)];
      IF EXISTS(axis2)
      THEN
        factor := dot_product(axis2, u[2]);
        IF (factor < 0.0)
        THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2)
      THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1),d1];
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0,0.0]),dummy_gri || direction([0.0,1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);
END_FUNCTION;

(* "bool" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION bool(lgcl : LOGICAL) : BOOLEAN;
  IF NOT EXISTS(lgcl)
  THEN
    RETURN(FALSE);
  END_IF;
  IF lgcl <> TRUE
  THEN
    RETURN(FALSE);
  END_IF;
  RETURN(TRUE);
END_FUNCTION;

(* "boolean_choose" IMPLICIT from SCHEMA topology_schema *)
FUNCTION boolean_choose(b : BOOLEAN;
                        choice1 : GENERIC : ITEM;
                        choice2 : GENERIC : ITEM) : GENERIC : ITEM;
  IF b
  THEN
    RETURN(choice1);
  ELSE
    RETURN(choice2);
  END_IF;
END_FUNCTION;

(* "build_2axes" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION build_2axes(ref_direction : direction) : LIST [2 : 2] OF direction;
LOCAL
  d : direction := NVL(normalise(ref_direction), dummy_gri || direction([1.0,0.0]));
END_LOCAL;
  RETURN([d,orthogonal_complement(d)]);
END_FUNCTION;

(* "build_axes" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION build_axes(axis : direction;
                    ref_direction : direction) : LIST [3 : 3] OF direction;
LOCAL
  d1 : direction;
  d2 : direction;
END_LOCAL;
  d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
  d2 := first_proj_axis(d1, ref_direction);
  RETURN([d2,normalise(cross_product(d1, d2))\vector.orientation,d1]);
END_FUNCTION;

(* "check_geometric_dimension" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION check_geometric_dimension(capt : SET [0 : ?] OF cartesian_point;
                                   dir : SET [0 : ?] OF direction;
                                   grc : SET [1 : ?] OF geometric_representation_context) : BOOLEAN;
LOCAL
  globaldim : INTEGER                       := 0;
  reps      : SET [0 : ?] OF representation := [];
  result    : BOOLEAN                       := TRUE;
END_LOCAL;
  globaldim := geometric_dimensionalities_in_contexts(grc);
  IF (globaldim > 0)
  THEN
    IF (SIZEOF(capt) > 0)
    THEN
      REPEAT i := 1 TO HIINDEX(capt);
        IF (HIINDEX(capt[i].coordinates) <> globaldim)
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    IF (SIZEOF(dir) > 0)
    THEN
      REPEAT i := 1 TO HIINDEX(dir);
        IF (HIINDEX(dir[i].direction_ratios) <> globaldim)
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(result);
  ELSE
    IF (SIZEOF(capt) > 0)
    THEN
      REPEAT i := 1 TO HIINDEX(capt);
        reps := using_representations(capt[i]);
        IF (SIZEOF(reps) > 0)
        THEN
          REPEAT j := 1 TO HIINDEX(reps);
            IF (HIINDEX(capt[i].coordinates) <>
                reps[j].context_of_items\geometric_representation_context.coordinate_space_dimension)
            THEN
              RETURN(FALSE);
            END_IF;
          END_REPEAT;
        ELSE
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    IF (SIZEOF(dir) > 0)
    THEN
      REPEAT i := 1 TO HIINDEX(dir);
        reps := using_representations(dir[i]);
        IF (SIZEOF(reps) > 0)
        THEN
          REPEAT j := 1 TO HIINDEX(reps);
            IF (HIINDEX(dir[i].direction_ratios) <>
                reps[j].context_of_items\geometric_representation_context.coordinate_space_dimension)
            THEN
              RETURN(FALSE);
            END_IF;
          END_REPEAT;
        ELSE
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN(result);
END_FUNCTION;

(* "check_sparse_index_domain" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION check_sparse_index_domain(idxdom : tuple_space;
                                   base : zero_or_one;
                                   shape : LIST [1 : ?] OF positive_integer;
                                   order : ordering_type) : BOOLEAN;
LOCAL
  mthspc   : maths_space;
  interval : finite_integer_interval;
  i        : INTEGER;
END_LOCAL;
  mthspc := factor1(idxdom);
  -- A consequence of WR1 of basic_sparse_matrix is that here we need only
  -- consider the case that mthspc is a finite integer interval and is the only
  -- factor space of idxdom.
  interval := mthspc;
  IF order = by_rows
  THEN
    i := 1;
  ELSE
    i := 2;
  END_IF;
  RETURN(bool((interval.min <= base) AND (interval.max >= base + shape[i])));
END_FUNCTION;

(* "check_sparse_index_to_loc" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION check_sparse_index_to_loc(index_range : tuple_space;
                                   loc_domain : tuple_space) : BOOLEAN;
LOCAL
  temp         : maths_space;
  idx_rng_itvl : finite_integer_interval;
  loc_dmn_itvl : finite_integer_interval;
END_LOCAL;
  temp := factor1(index_range);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF(temp)
  THEN
    temp := factor1(temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
  THEN
    RETURN(FALSE);
  END_IF;
  idx_rng_itvl := temp;
  temp := factor1(loc_domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF(temp)
  THEN
    temp := factor1(temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
  THEN
    RETURN(FALSE);
  END_IF;
  loc_dmn_itvl := temp;
  RETURN(bool((loc_dmn_itvl.min <= idx_rng_itvl.min) AND (idx_rng_itvl.max <= loc_dmn_itvl.max + 1)));
END_FUNCTION;

(* "check_sparse_loc_range" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION check_sparse_loc_range(locrng : tuple_space;
                                base : zero_or_one;
                                shape : LIST [1 : ?] OF positive_integer;
                                order : ordering_type) : BOOLEAN;
LOCAL
  mthspc   : maths_space;
  interval : finite_integer_interval;
  i        : INTEGER;
END_LOCAL;
  IF space_dimension(locrng) <> 1
  THEN
    RETURN(FALSE);
  END_IF;
  mthspc := factor1(locrng);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(mthspc))
  THEN
    RETURN(FALSE);
  END_IF;
  interval := mthspc;
  IF order = by_rows
  THEN
    i := 2;
  ELSE
    i := 1;
  END_IF;
  RETURN(bool((interval.min >= base) AND (interval.max <= base + shape[i] - 1)));
END_FUNCTION;

(* "closed_shell_reversed" IMPLICIT from SCHEMA topology_schema *)
FUNCTION closed_shell_reversed(a_shell : closed_shell) : oriented_closed_shell;
LOCAL
  the_reverse : oriented_closed_shell;
END_LOCAL;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell))
  THEN
    the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || closed_shell() ||
                   oriented_closed_shell(a_shell\oriented_closed_shell.closed_shell_element,
                                         NOT (a_shell\oriented_closed_shell.orientation));
  ELSE
    the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || closed_shell() ||
                   oriented_closed_shell(a_shell, FALSE);
  END_IF;
  RETURN(the_reverse);
END_FUNCTION;

(* "compare_basis_and_coef" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION compare_basis_and_coef(basis : LIST [1 : ?] OF b_spline_basis;
                                coef : maths_function) : BOOLEAN;
LOCAL
  shape : LIST OF positive_integer;
END_LOCAL;
  IF NOT EXISTS(basis) OR NOT EXISTS(coef)
  THEN
    RETURN(FALSE);
  END_IF;
  shape := shape_of_array(coef);
  IF NOT EXISTS(shape)
  THEN
    RETURN(FALSE);
  END_IF;
  IF SIZEOF(shape) < SIZEOF(basis)
  THEN
    RETURN(FALSE);
  END_IF;
  REPEAT i := 1 TO SIZEOF(basis);
    IF (basis[i].num_basis = shape[i]) <> TRUE
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "compatible_complex_number_regions" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION compatible_complex_number_regions(sp1 : maths_space;
                                           sp2 : maths_space) : BOOLEAN;
LOCAL
  typenames   : SET OF STRING                   := stripped_typeof(sp1);
  crgn1       : cartesian_complex_number_region;
  crgn2       : cartesian_complex_number_region;
  prgn1       : polar_complex_number_region;
  prgn2       : polar_complex_number_region;
  prgn1c2     : polar_complex_number_region;
  prgn2c1     : polar_complex_number_region;
  sp1_is_crgn : BOOLEAN;
  sp2_is_crgn : BOOLEAN;
END_LOCAL;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames
  THEN
    sp1_is_crgn := TRUE;
    crgn1 := sp1;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames
    THEN
      sp1_is_crgn := FALSE;
      prgn1 := sp1;
    ELSE
      RETURN(TRUE);
    END_IF;
  END_IF;
  typenames := stripped_typeof(sp2);
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames
  THEN
    sp2_is_crgn := TRUE;
    crgn2 := sp2;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames
    THEN
      sp2_is_crgn := FALSE;
      prgn2 := sp2;
    ELSE
      RETURN(TRUE);
    END_IF;
  END_IF;
  IF sp1_is_crgn AND sp2_is_crgn
  THEN
    RETURN(compatible_intervals(crgn1.real_constraint, crgn2.real_constraint) AND
           compatible_intervals(crgn1.imag_constraint, crgn2.imag_constraint));
  END_IF;
  IF NOT sp1_is_crgn AND
         NOT sp2_is_crgn AND (prgn1.centre.real_part = prgn2.centre.real_part) AND
             (prgn1.centre.imag_part = prgn2.centre.imag_part)
  THEN
    IF NOT compatible_intervals(prgn1.distance_constraint, prgn2.distance_constraint)
    THEN
      RETURN(FALSE);
    END_IF;
    IF compatible_intervals(prgn1.direction_constraint, prgn2.direction_constraint)
    THEN
      RETURN(TRUE);
    END_IF;
    IF (prgn1.direction_constraint.max > PI) AND (prgn2.direction_constraint.max < PI)
    THEN
      RETURN(compatible_intervals(prgn2.direction_constraint,
                                  make_finite_real_interval(-PI, open, prgn1.direction_constraint.max - 2.0 * PI,
                                                            prgn1.direction_constraint.max_closure)));
    END_IF;
    IF (prgn2.direction_constraint.max > PI) AND (prgn1.direction_constraint.max < PI)
    THEN
      RETURN(compatible_intervals(prgn1.direction_constraint,
                                  make_finite_real_interval(-PI, open, prgn2.direction_constraint.max - 2.0 * PI,
                                                            prgn2.direction_constraint.max_closure)));
    END_IF;
    RETURN(FALSE);
  END_IF;
  -- Make do with imperfect tests for remaining cases.
  IF sp1_is_crgn AND NOT sp2_is_crgn
  THEN
    crgn2 := enclose_pregion_in_cregion(prgn2);
    prgn1 := enclose_cregion_in_pregion(crgn1, prgn2.centre);
    RETURN(compatible_complex_number_regions(crgn1, crgn2) AND compatible_complex_number_regions(prgn1, prgn2));
  END_IF;
  IF NOT sp1_is_crgn AND sp2_is_crgn
  THEN
    crgn1 := enclose_pregion_in_cregion(prgn1);
    prgn2 := enclose_cregion_in_pregion(crgn2, prgn1.centre);
    RETURN(compatible_complex_number_regions(crgn1, crgn2) AND compatible_complex_number_regions(prgn1, prgn2));
  END_IF;
  -- Two polar regions with different centres
  prgn1c2 := enclose_pregion_in_pregion(prgn1, prgn2.centre);
  prgn2c1 := enclose_pregion_in_pregion(prgn2, prgn1.centre);
  RETURN(compatible_complex_number_regions(prgn1, prgn2c1) AND compatible_complex_number_regions(prgn1c2, prgn2));
END_FUNCTION;

(* "compatible_es_values" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION compatible_es_values(esval1 : elementary_space_enumerators;
                              esval2 : elementary_space_enumerators) : BOOLEAN;
LOCAL
  esval1_is_numeric : LOGICAL;
  esval2_is_numeric : LOGICAL;
END_LOCAL;
  IF (esval1 = esval2) OR (esval1 = es_generics) OR (esval2 = es_generics)
  THEN
    RETURN(TRUE);
  END_IF;
  esval1_is_numeric := (esval1 >= es_numbers) AND (esval1 <= es_integers);
  esval2_is_numeric := (esval2 >= es_numbers) AND (esval2 <= es_integers);
  IF (esval1_is_numeric AND (esval2 = es_numbers)) OR (esval2_is_numeric AND (esval1 = es_numbers))
  THEN
    RETURN(TRUE);
  END_IF;
  IF esval1_is_numeric XOR esval2_is_numeric
  THEN
    RETURN(FALSE);
  END_IF;
  IF ((esval1 = es_logicals) AND (esval2 = es_booleans)) OR ((esval1 = es_booleans) AND (esval2 = es_logicals))
  THEN
    RETURN(TRUE);
  END_IF;
  -- All other cases are incompatible
  RETURN(FALSE);
END_FUNCTION;

(* "compatible_intervals" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION compatible_intervals(sp1 : maths_space;
                              sp2 : maths_space) : BOOLEAN;
LOCAL
  amin : REAL;
  amax : REAL;
END_LOCAL;
  IF min_exists(sp1) AND max_exists(sp2)
  THEN
    amin := real_min(sp1);
    amax := real_max(sp2);
    IF amin > amax
    THEN
      RETURN(FALSE);
    END_IF;
    IF amin = amax
    THEN
      RETURN(min_included(sp1) AND max_included(sp2));
    END_IF;
  END_IF;
  IF min_exists(sp2) AND max_exists(sp1)
  THEN
    amin := real_min(sp2);
    amax := real_max(sp1);
    IF amin > amax
    THEN
      RETURN(FALSE);
    END_IF;
    IF amin = amax
    THEN
      RETURN(min_included(sp2) AND max_included(sp1));
    END_IF;
  END_IF;
  RETURN(TRUE);
END_FUNCTION;

(* "compatible_spaces" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION compatible_spaces(sp1 : maths_space;
                           sp2 : maths_space) : BOOLEAN;
LOCAL
  types1 : SET OF STRING := stripped_typeof(sp1);
  types2 : SET OF STRING := stripped_typeof(sp2);
  lgcl   : LOGICAL       := UNKNOWN;
  m      : INTEGER;
  n      : INTEGER;
  s1     : maths_space;
  s2     : maths_space;
END_LOCAL;
  IF 'FINITE_SPACE' IN types1
  THEN
    REPEAT i := 1 TO SIZEOF(sp1\finite_space.members);
      lgcl := member_of(sp1\finite_space.members[i], sp2);
      IF lgcl <> FALSE
      THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
    RETURN(FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types2
  THEN
    REPEAT i := 1 TO SIZEOF(sp2\finite_space.members);
      lgcl := member_of(sp2\finite_space.members[i], sp1);
      IF lgcl <> FALSE
      THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
    RETURN(FALSE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1
  THEN
    IF sp1\elementary_space.space_id = es_generics
    THEN
      RETURN(TRUE);
    END_IF;
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      RETURN(compatible_es_values(sp1\elementary_space.space_id, sp2\elementary_space.space_id));
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types2) OR ('INTEGER_INTERVAL_FROM_MIN' IN types2) OR
       ('INTEGER_INTERVAL_TO_MAX' IN types2)
    THEN
      RETURN(compatible_es_values(sp1\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR ('REAL_INTERVAL_FROM_MIN' IN types2) OR ('REAL_INTERVAL_TO_MAX' IN types2)
    THEN
      RETURN(compatible_es_values(sp1\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types2) OR ('POLAR_COMPLEX_NUMBER_REGION' IN types2)
    THEN
      RETURN(compatible_es_values(sp1\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2
    THEN
      RETURN(bool(sp1\elementary_space.space_id = es_maths_functions));
    END_IF;
    RETURN(TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types2
  THEN
    IF sp2\elementary_space.space_id = es_generics
    THEN
      RETURN(TRUE);
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types1) OR ('INTEGER_INTERVAL_FROM_MIN' IN types1) OR
       ('INTEGER_INTERVAL_TO_MAX' IN types1)
    THEN
      RETURN(compatible_es_values(sp2\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types1) OR ('REAL_INTERVAL_FROM_MIN' IN types1) OR ('REAL_INTERVAL_TO_MAX' IN types1)
    THEN
      RETURN(compatible_es_values(sp2\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types1) OR ('POLAR_COMPLEX_NUMBER_REGION' IN types1)
    THEN
      RETURN(compatible_es_values(sp2\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types1
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types1
    THEN
      RETURN(bool(sp2\elementary_space.space_id = es_maths_functions));
    END_IF;
    RETURN(TRUE);
  END_IF;
  IF subspace_of_es(sp1, es_integers)
  THEN
    IF subspace_of_es(sp2, es_integers)
    THEN
      RETURN(compatible_intervals(sp1, sp2));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF subspace_of_es(sp2, es_integers)
  THEN
    RETURN(FALSE);
  END_IF;
  IF subspace_of_es(sp1, es_reals)
  THEN
    IF subspace_of_es(sp2, es_reals)
    THEN
      RETURN(compatible_intervals(sp1, sp2));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF subspace_of_es(sp2, es_reals)
  THEN
    RETURN(FALSE);
  END_IF;
  IF subspace_of_es(sp1, es_complex_numbers)
  THEN
    IF subspace_of_es(sp2, es_complex_numbers)
    THEN
      RETURN(compatible_complex_number_regions(sp1, sp2));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF subspace_of_es(sp2, es_complex_numbers)
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN types1
  THEN
    IF 'UNIFORM_PRODUCT_SPACE' IN types2
    THEN
      IF sp1\uniform_product_space.exponent <> sp2\uniform_product_space.exponent
      THEN
        RETURN(FALSE);
      END_IF;
      RETURN(compatible_spaces(sp1\uniform_product_space.base, sp2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2
    THEN
      n := SIZEOF(sp2\listed_product_space.factors);
      IF sp1\uniform_product_space.exponent <> n
      THEN
        RETURN(FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\uniform_product_space.base, sp2\listed_product_space.factors[i])
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2
    THEN
      m := sp1\uniform_product_space.exponent;
      n := space_dimension(sp2\extended_tuple_space.base);
      IF m < n
      THEN
        RETURN(FALSE);
      END_IF;
      IF m = n
      THEN
        RETURN(compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN(compatible_spaces(sp1,
                               assoc_product_space(sp2\extended_tuple_space.base,
                                                   make_uniform_product_space(sp2\extended_tuple_space.extender,
                                                                              m - n))));
    END_IF;
    IF 'FUNCTION_SPACE' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    RETURN(TRUE);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types1
  THEN
    n := SIZEOF(sp1\listed_product_space.factors);
    IF 'UNIFORM_PRODUCT_SPACE' IN types2
    THEN
      IF n <> sp2\uniform_product_space.exponent
      THEN
        RETURN(FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp2\uniform_product_space.base, sp1\listed_product_space.factors[i])
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(TRUE);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2
    THEN
      IF n <> SIZEOF(sp2\listed_product_space.factors)
      THEN
        RETURN(FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\listed_product_space.factors[i], sp2\listed_product_space.factors[i])
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2
    THEN
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n < m
      THEN
        RETURN(FALSE);
      END_IF;
      IF n = m
      THEN
        RETURN(compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN(compatible_spaces(sp1,
                               assoc_product_space(sp2\extended_tuple_space.base,
                                                   make_uniform_product_space(sp2\extended_tuple_space.extender,
                                                                              n - m))));
    END_IF;
    IF (schema_prefix + 'FUNCTION_SPACE') IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    RETURN(TRUE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1
  THEN
    IF ('UNIFORM_PRODUCT_SPACE' IN types2) OR ('LISTED_PRODUCT_SPACE' IN types2)
    THEN
      RETURN(compatible_spaces(sp2, sp1));
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2
    THEN
      IF NOT compatible_spaces(sp1\extended_tuple_space.extender, sp2\extended_tuple_space.extender)
      THEN
        RETURN(FALSE);
      END_IF;
      n := space_dimension(sp1\extended_tuple_space.base);
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n < m
      THEN
        RETURN(compatible_spaces(assoc_product_space(sp1\extended_tuple_space.base,
                                                     make_uniform_product_space(sp1\extended_tuple_space.extender,
                                                                                m - n)),
                                 sp2\extended_tuple_space.base));
      END_IF;
      IF n = m
      THEN
        RETURN(compatible_spaces(sp1\extended_tuple_space.base, sp2\extended_tuple_space.base));
      END_IF;
      IF n > m
      THEN
        RETURN(compatible_spaces(sp1\extended_tuple_space.base,
                                 assoc_product_space(sp2\extended_tuple_space.base,
                                                     make_uniform_product_space(sp2\extended_tuple_space.extender,
                                                                                n - m))));
      END_IF;
    END_IF;
    IF 'FUNCTION_SPACE' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    RETURN(TRUE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1
  THEN
    IF 'FUNCTION_SPACE' IN types2
    THEN
      s1 := sp1\function_space.domain_argument;
      s2 := sp2\function_space.domain_argument;
      CASE sp1\function_space.domain_constraint OF
        sc_equal : BEGIN  
                          CASE sp2\function_space.domain_constraint OF
                            sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
                            sc_subspace : lgcl := subspace_of(s1, s2);
                            sc_member : lgcl := member_of(s1, s2);
                          END_CASE;
        END;
        sc_subspace : BEGIN  
                             CASE sp2\function_space.domain_constraint OF
                               sc_equal : lgcl := subspace_of(s2, s1);
                               sc_subspace : lgcl := compatible_spaces(s1, s2);
                               sc_member : lgcl := UNKNOWN;
                             END_CASE;
        END;
        sc_member : BEGIN  
                           CASE sp2\function_space.domain_constraint OF
                             sc_equal : lgcl := member_of(s2, s1);
                             sc_subspace : lgcl := UNKNOWN;
                             sc_member : lgcl := compatible_spaces(s1, s2);
                           END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE
      THEN
        RETURN(FALSE);
      END_IF;
      s1 := sp1\function_space.range_argument;
      s2 := sp2\function_space.range_argument;
      CASE sp1\function_space.range_constraint OF
        sc_equal : BEGIN  
                          CASE sp2\function_space.range_constraint OF
                            sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
                            sc_subspace : lgcl := subspace_of(s1, s2);
                            sc_member : lgcl := member_of(s1, s2);
                          END_CASE;
        END;
        sc_subspace : BEGIN  
                             CASE sp2\function_space.range_constraint OF
                               sc_equal : lgcl := subspace_of(s2, s1);
                               sc_subspace : lgcl := compatible_spaces(s1, s2);
                               sc_member : lgcl := UNKNOWN;
                             END_CASE;
        END;
        sc_member : BEGIN  
                           CASE sp2\function_space.range_constraint OF
                             sc_equal : lgcl := member_of(s2, s1);
                             sc_subspace : lgcl := UNKNOWN;
                             sc_member : lgcl := compatible_spaces(s1, s2);
                           END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE
      THEN
        RETURN(FALSE);
      END_IF;
      RETURN(TRUE);
    END_IF;
    RETURN(TRUE);
  END_IF;
  -- Should be unreachable.
  RETURN(TRUE);
END_FUNCTION;

(* "composable_sequence" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION composable_sequence(operands : LIST [2 : ?] OF maths_function) : BOOLEAN;
  REPEAT i := 1 TO SIZEOF(operands) - 1;
    IF NOT compatible_spaces(operands[i].range, operands[i + 1].domain)
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "conditional_reverse" IMPLICIT from SCHEMA topology_schema *)
FUNCTION conditional_reverse(p : BOOLEAN;
                             an_item : reversible_topology) : reversible_topology;
  IF p
  THEN
    RETURN(an_item);
  ELSE
    RETURN(topology_reversed(an_item));
  END_IF;
END_FUNCTION;

(* "constraints_composite_curve_on_surface" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION constraints_composite_curve_on_surface(c : composite_curve_on_surface) : BOOLEAN;
LOCAL
  n_segments : INTEGER := SIZEOF(c.segments);
END_LOCAL;
  REPEAT k := 1 TO n_segments;
    IF (NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PCURVE' IN
             TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
       (NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_CURVE' IN
             TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
       (NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN
             TYPEOF(c\composite_curve.segments[k].parent_curve)))
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "constraints_geometry_shell_based_surface_model" IMPLICIT from SCHEMA geometric_model_schema *)
FUNCTION constraints_geometry_shell_based_surface_model(m : shell_based_surface_model) : BOOLEAN;
LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
  REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
    IF (NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OPEN_SHELL' IN TYPEOF(m.sbsm_boundary[j])) AND
            (NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CLOSED_SHELL' IN TYPEOF(m.sbsm_boundary[j]))))
    THEN
      result := FALSE;
      RETURN(result);
    END_IF;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

(* "constraints_geometry_shell_based_wireframe_model" IMPLICIT from SCHEMA geometric_model_schema *)
FUNCTION constraints_geometry_shell_based_wireframe_model(m : shell_based_wireframe_model) : BOOLEAN;
LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
  REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
    IF (NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.WIRE_SHELL' IN TYPEOF(m.sbwm_boundary[j])) AND
            (NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VERTEX_SHELL' IN TYPEOF(m.sbwm_boundary[j]))))
    THEN
      result := FALSE;
      RETURN(result);
    END_IF;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

(* "constraints_param_b_spline" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION constraints_param_b_spline(degree : INTEGER;
                                    up_knots : INTEGER;
                                    up_cp : INTEGER;
                                    knot_mult : LIST [0 : ?] OF INTEGER;
                                    knots : LIST [0 : ?] OF parameter_value) : BOOLEAN;
LOCAL
  result : BOOLEAN := TRUE;
  k      : INTEGER;
  sum    : INTEGER;
END_LOCAL;
  (* Find sum of knot multiplicities. *)
  sum := knot_mult[1];
  REPEAT i := 2 TO up_knots;
    sum := sum + knot_mult[i];
  END_REPEAT;
  (* Check limits holding for all B-spline parametrisations *)
  IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR (sum <> (degree + up_cp + 2))
  THEN
    result := FALSE;
    RETURN(result);
  END_IF;
  k := knot_mult[1];
  IF (k < 1) OR (k > degree + 1)
  THEN
    result := FALSE;
    RETURN(result);
  END_IF;
  REPEAT i := 2 TO up_knots;
    IF (knot_mult[i] < 1) OR (knots[i] <= knots[i - 1])
    THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    k := knot_mult[i];
    IF (i < up_knots) AND (k > degree)
    THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    IF (i = up_knots) AND (k > degree + 1)
    THEN
      result := FALSE;
      RETURN(result);
    END_IF;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

(* "constraints_rectangular_composite_surface" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION constraints_rectangular_composite_surface(s : rectangular_composite_surface) : BOOLEAN;
  REPEAT i := 1 TO s.n_u;
    REPEAT j := 1 TO s.n_v;
      IF NOT (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.B_SPLINE_SURFACE' IN
               TYPEOF(s.segments[i][j].parent_surface)) OR
              ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.RECTANGULAR_TRIMMED_SURFACE' IN
               TYPEOF(s.segments[i][j].parent_surface)))
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_REPEAT;
  (* Check the transition codes, omitting the last row or column *)
  REPEAT i := 1 TO s.n_u - 1;
    REPEAT j := 1 TO s.n_v;
      IF s.segments[i][j].u_transition = discontinuous
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_REPEAT;
  REPEAT i := 1 TO s.n_u;
    REPEAT j := 1 TO s.n_v - 1;
      IF s.segments[i][j].v_transition = discontinuous
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "control_characters_free" IMPLICIT from SCHEMA presentation_definition_schema *)
FUNCTION control_characters_free(s : STRING) : BOOLEAN;
LOCAL
  ch : STRING;
END_LOCAL;
  REPEAT i := 1 TO LENGTH(s);
    ch := s[i];
    IF (ch = '\x9') OR (ch = '\xA') OR (ch = '\xD')
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "convert_to_literal" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION convert_to_literal(val : maths_atom) : generic_literal;
LOCAL
  types : SET OF STRING := TYPEOF(val);
END_LOCAL;
  IF 'INTEGER' IN types
  THEN
    RETURN(make_int_literal(val));
  END_IF;
  IF 'REAL' IN types
  THEN
    RETURN(make_real_literal(val));
  END_IF;
  IF 'BOOLEAN' IN types
  THEN
    RETURN(make_boolean_literal(val));
  END_IF;
  IF 'STRING' IN types
  THEN
    RETURN(make_string_literal(val));
  END_IF;
  IF 'LOGICAL' IN types
  THEN
    RETURN(make_logical_literal(val));
  END_IF;
  IF 'BINARY' IN types
  THEN
    RETURN(make_binary_literal(val));
  END_IF;
  IF (schema_prefix + 'MATHS_ENUM_ATOM') IN types
  THEN
    RETURN(make_maths_enum_literal(val));
  END_IF;
  -- Should be unreachable
  RETURN(?);
END_FUNCTION;

(* "convert_to_maths_function" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION convert_to_maths_function(func : maths_function_select) : maths_function;
LOCAL
  efenum : elementary_function_enumerators;
  mthfun : maths_function;
END_LOCAL;
  IF (schema_prefix + 'MATHS_FUNCTION') IN TYPEOF(func)
  THEN
    mthfun := func;
  ELSE
    efenum := func;
    mthfun := make_elementary_function(efenum);
  END_IF;
  RETURN(mthfun);
END_FUNCTION;

(* "convert_to_maths_value" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION convert_to_maths_value(val : GENERIC : G) : maths_value;
LOCAL
  types : SET OF STRING := TYPEOF(val);
  ival  : maths_integer;
  rval  : maths_real;
  nval  : maths_number;
  tfval : maths_boolean;
  lval  : maths_logical;
  sval  : maths_string;
  bval  : maths_binary;
  tval  : maths_tuple   := the_empty_maths_tuple;
  mval  : maths_value;
END_LOCAL;
  IF (schema_prefix + 'MATHS_VALUE') IN types
  THEN
    RETURN(val);
  END_IF;
  IF 'INTEGER' IN types
  THEN
    ival := val;
    RETURN(ival);
  END_IF;
  IF 'REAL' IN types
  THEN
    rval := val;
    RETURN(rval);
  END_IF;
  IF 'NUMBER' IN types
  THEN
    nval := val;
    RETURN(nval);
  END_IF;
  IF 'BOOLEAN' IN types
  THEN
    tfval := val;
    RETURN(tfval);
  END_IF;
  IF 'LOGICAL' IN types
  THEN
    lval := val;
    RETURN(lval);
  END_IF;
  IF 'STRING' IN types
  THEN
    sval := val;
    RETURN(sval);
  END_IF;
  IF 'BINARY' IN types
  THEN
    bval := val;
    RETURN(bval);
  END_IF;
  IF 'LIST' IN types
  THEN
    REPEAT i := 1 TO SIZEOF(val);
      mval := convert_to_maths_value(val[i]);
      IF NOT EXISTS(mval)
      THEN
        RETURN(?);
      END_IF;
      INSERT(tval, mval, i - 1);
    END_REPEAT;
    RETURN(tval);
  END_IF;
  RETURN(?);
END_FUNCTION;

(* "convert_to_operand" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION convert_to_operand(val : maths_value) : generic_expression;
LOCAL
  types : SET OF STRING := stripped_typeof(val);
END_LOCAL;
  -- Use intermediate variables of appropriate declared types to help the compilers.
  IF 'GENERIC_EXPRESSION' IN types
  THEN
    RETURN(val);
  END_IF;
  IF 'MATHS_ATOM' IN types
  THEN
    RETURN(convert_to_literal(val));
  END_IF;
  IF 'ATOM_BASED_VALUE' IN types
  THEN
    RETURN(make_atom_based_literal(val));
  END_IF;
  IF 'MATHS_TUPLE' IN types
  THEN
    RETURN(make_maths_tuple_literal(val));
  END_IF;
  -- Should be unreachable
  RETURN(?);
END_FUNCTION;

(* "convert_to_operands" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION convert_to_operands(values : AGGREGATE OF maths_value) : LIST OF generic_expression;
LOCAL
  operands : LIST OF generic_expression := [];
  loc      : INTEGER                    := 0;
END_LOCAL;
  IF NOT EXISTS(values)
  THEN
    RETURN(?);
  END_IF;
  REPEAT i := LOINDEX(values) TO HIINDEX(values);
    INSERT(operands, convert_to_operand(values[i]), loc);
    loc := loc + 1;
  END_REPEAT;
  RETURN(operands);
END_FUNCTION;

(* "convert_to_operands_prcmfn" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION convert_to_operands_prcmfn(srcdom : maths_space_or_function;
                                    prepfun : LIST OF maths_function;
                                    finfun : maths_function_select) : LIST [2 : ?] OF generic_expression;
LOCAL
  operands : LIST OF generic_expression := [];
END_LOCAL;
  INSERT(operands, srcdom, 0);
  REPEAT i := 1 TO SIZEOF(prepfun);
    INSERT(operands, prepfun[i], i);
  END_REPEAT;
  INSERT(operands, convert_to_maths_function(finfun), SIZEOF(prepfun) + 1);
  RETURN(operands);
END_FUNCTION;

(* "cross_product" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION cross_product(arg1 : direction;
                       arg2 : direction) : vector;
LOCAL
  mag    : REAL;
  res    : direction;
  v1     : LIST [3 : 3] OF REAL;
  v2     : LIST [3 : 3] OF REAL;
  result : vector;
END_LOCAL;
  IF (NOT EXISTS(arg1) OR (arg1.dim = 2)) OR (NOT EXISTS(arg2) OR (arg2.dim = 2))
  THEN
    RETURN(?);
  ELSE
    BEGIN  
           v1 := normalise(arg1).direction_ratios;
           v2 := normalise(arg2).direction_ratios;
           res := dummy_gri ||
                  direction([(v1[2] * v2[3] - v1[3] * v2[2]),
                             (v1[3] * v2[1] - v1[1] * v2[3]),
                             (v1[1] * v2[2] - v1[2] * v2[1])]);
           mag := 0.0;
           REPEAT i := 1 TO 3;
             mag := mag + res.direction_ratios[i] * res.direction_ratios[i];
           END_REPEAT;
           IF (mag > 0.0)
           THEN
             result := dummy_gri || vector(res, SQRT(mag));
           ELSE
             result := dummy_gri || vector(arg1, 0.0);
           END_IF;
           RETURN(result);
    END;
  END_IF;
END_FUNCTION;

(* "curve_weights_positive" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION curve_weights_positive(b : rational_b_spline_curve) : BOOLEAN;
LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
  REPEAT i := 0 TO b.upper_index_on_control_points;
    IF b.weights[i] <= 0.0
    THEN
      result := FALSE;
      RETURN(result);
    END_IF;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

(* "definite_integral_check" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION definite_integral_check(domain : tuple_space;
                                 vrblint : input_selector;
                                 lowerinf : BOOLEAN;
                                 upperinf : BOOLEAN) : BOOLEAN;
LOCAL
  domn : tuple_space         := domain;
  fspc : maths_space;
  dim  : nonnegative_integer;
  k    : positive_integer;
END_LOCAL;
  IF (space_dimension(domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(domain)))
  THEN
    domn := factor1(domain);
  END_IF;
  dim := space_dimension(domn);
  k := vrblint;
  IF k > dim
  THEN
    RETURN(FALSE);
  END_IF;
  fspc := factor_space(domn, k);
  IF NOT ((schema_prefix + 'REAL_INTERVAL') IN TYPEOF(fspc))
  THEN
    RETURN(FALSE);
  END_IF;
  IF lowerinf AND min_exists(fspc)
  THEN
    RETURN(FALSE);
  END_IF;
  IF upperinf AND max_exists(fspc)
  THEN
    RETURN(FALSE);
  END_IF;
  RETURN(TRUE);
END_FUNCTION;

(* "definite_integral_expr_check" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION definite_integral_expr_check(operands : LIST [2 : ?] OF generic_expression;
                                      lowerinf : BOOLEAN;
                                      upperinf : BOOLEAN) : BOOLEAN;
LOCAL
  nops : INTEGER             := 2;
  vspc : maths_space;
  dim  : nonnegative_integer;
  k    : positive_integer;
  bspc : maths_space;
END_LOCAL;
  IF NOT lowerinf
  THEN
    nops := nops + 1;
  END_IF;
  IF NOT upperinf
  THEN
    nops := nops + 1;
  END_IF;
  IF SIZEOF(operands) <> nops
  THEN
    RETURN(FALSE);
  END_IF;
  IF NOT ('GENERIC_VARIABLE' IN stripped_typeof(operands[2]))
  THEN
    RETURN(FALSE);
  END_IF;
  IF NOT has_values_space(operands[2])
  THEN
    RETURN(FALSE);
  END_IF;
  vspc := values_space_of(operands[2]);
  IF NOT ('REAL_INTERVAL' IN stripped_typeof(vspc))
  THEN
    RETURN(FALSE);
  END_IF;
  IF lowerinf
  THEN
    IF min_exists(vspc)
    THEN
      RETURN(FALSE);
    END_IF;
    k := 3;
  ELSE
    IF NOT has_values_space(operands[3])
    THEN
      RETURN(FALSE);
    END_IF;
    bspc := values_space_of(operands[3]);
    IF NOT compatible_spaces(bspc, vspc)
    THEN
      RETURN(FALSE);
    END_IF;
    k := 4;
  END_IF;
  IF upperinf
  THEN
    IF max_exists(vspc)
    THEN
      RETURN(FALSE);
    END_IF;
  ELSE
    IF NOT has_values_space(operands[k])
    THEN
      RETURN(FALSE);
    END_IF;
    bspc := values_space_of(operands[k]);
    IF NOT compatible_spaces(bspc, vspc)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  RETURN(TRUE);
END_FUNCTION;

(* "derive_definite_integral_domain" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION derive_definite_integral_domain(igrl : definite_integral_function) : tuple_space;
FUNCTION process_product_space(spc : product_space;
                               idx : INTEGER;
                               prefix : INTEGER;
                               vdomn : maths_space) : product_space;
LOCAL
  uspc    : uniform_product_space;
  expnt   : INTEGER;
  factors : LIST OF maths_space;
END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN TYPEOF(spc)
  THEN
    uspc := spc;
    expnt := uspc.exponent + prefix;
    IF idx <= uspc.exponent
    THEN
      expnt := expnt - 1;
    END_IF;
    IF expnt = 0
    THEN
      RETURN(make_listed_product_space([]));
    ELSE
      RETURN(make_uniform_product_space(uspc.base, expnt));
    END_IF;
  ELSE
    factors := spc\listed_product_space.factors;
    IF idx <= SIZEOF(factors)
    THEN
      REMOVE(factors, idx);
    END_IF;
    IF prefix > 0
    THEN
      INSERT(factors, vdomn, 0);
      IF prefix > 1
      THEN
        INSERT(factors, vdomn, 0);
      END_IF;
    END_IF;
    RETURN(make_listed_product_space(factors));
  END_IF;
END_FUNCTION;
LOCAL
  idomn  : tuple_space          := igrl.integrand.domain;
  types  : SET OF STRING        := TYPEOF(idomn);
  idx    : INTEGER              := igrl.variable_of_integration;
  tupled : BOOLEAN              := bool(((space_dimension(idomn) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN types)));
  prefix : INTEGER              := 0;
  espc   : extended_tuple_space;
  vdomn  : maths_space;
END_LOCAL;
  IF tupled
  THEN
    idomn := factor1(idomn);
    types := TYPEOF(idomn);
  END_IF;
  IF igrl.lower_limit_neg_infinity
  THEN
    prefix := prefix + 1;
  END_IF;
  IF igrl.upper_limit_pos_infinity
  THEN
    prefix := prefix + 1;
  END_IF;
  vdomn := factor_space(idomn, idx);
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types
  THEN
    espc := idomn;
    idomn := make_extended_tuple_space(process_product_space(espc.base, idx, prefix, vdomn), espc.extender);
  ELSE
    idomn := process_product_space(idomn, idx, prefix, vdomn);
  END_IF;
  IF tupled
  THEN
    RETURN(one_tuples_of(idomn));
  ELSE
    RETURN(idomn);
  END_IF;
END_FUNCTION;

(* "derive_dimensional_exponents" IMPLICIT from SCHEMA measure_schema *)
FUNCTION derive_dimensional_exponents(x : unit) : dimensional_exponents;
LOCAL
  result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
END_LOCAL;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DERIVED_UNIT' IN TYPEOF(x)
  THEN
    REPEAT i := LOINDEX(x\derived_unit.elements) TO HIINDEX(x\derived_unit.elements);
      result.length_exponent := result.length_exponent +
                                (x\derived_unit.elements[i]\derived_unit_element.exponent *
                                 x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.length_exponent);
      result.mass_exponent := result.mass_exponent +
                              (x\derived_unit.elements[i]\derived_unit_element.exponent *
                               x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.mass_exponent);
      result.time_exponent := result.time_exponent +
                              (x\derived_unit.elements[i]\derived_unit_element.exponent *
                               x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.time_exponent);
      result.electric_current_exponent := result.electric_current_exponent +
                                          (x\derived_unit.elements[i]\derived_unit_element.exponent *
                                           x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.electric_current_exponent);
      result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent +
                                                   (x\derived_unit.elements[i]\derived_unit_element.exponent *
                                                    x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.thermodynamic_temperature_exponent);
      result.amount_of_substance_exponent := result.amount_of_substance_exponent +
                                             (x\derived_unit.elements[i]\derived_unit_element.exponent *
                                              x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.amount_of_substance_exponent);
      result.luminous_intensity_exponent := result.luminous_intensity_exponent +
                                            (x\derived_unit.elements[i]\derived_unit_element.exponent *
                                             x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.luminous_intensity_exponent);
    END_REPEAT;
  ELSE
    result := x\named_unit.dimensions;
  END_IF;
  RETURN(result);
END_FUNCTION;

(* "derive_elementary_function_domain" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION derive_elementary_function_domain(ef_val : elementary_function_enumerators) : tuple_space;
  IF NOT EXISTS(ef_val)
  THEN
    RETURN(?);
  END_IF;
  CASE ef_val OF
    ef_and : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_logicals));
    ef_or : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_logicals));
    ef_not : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_xor : RETURN(make_uniform_product_space(the_logicals, 2));
    ef_negate_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_add_i : RETURN(the_integer_tuples);
    ef_subtract_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_multiply_i : RETURN(the_integer_tuples);
    ef_divide_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_mod_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_exponentiate_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_eq_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_ne_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_gt_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_lt_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_ge_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_le_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_abs_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_if_i : RETURN(make_listed_product_space([the_logicals,the_integers,the_integers]));
    ef_negate_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_reciprocal_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_add_r : RETURN(the_real_tuples);
    ef_subtract_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_multiply_r : RETURN(the_real_tuples);
    ef_divide_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_mod_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_exponentiate_r : RETURN(make_listed_product_space([the_nonnegative_reals,the_reals]));
    ef_exponentiate_ri : RETURN(make_listed_product_space([the_reals,the_integers]));
    ef_eq_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_ne_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_gt_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_lt_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_ge_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_le_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_abs_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_acos_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
    ef_asin_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
    ef_atan2_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_cos_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_exp_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_ln_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_log2_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_log10_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_sin_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_sqrt_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_tan_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_if_r : RETURN(make_listed_product_space([the_logicals,the_reals,the_reals]));
    ef_negate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_reciprocal_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_add_c : RETURN(the_complex_tuples);
    ef_subtract_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
    ef_multiply_c : RETURN(the_complex_tuples);
    ef_divide_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
    ef_exponentiate_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
    ef_exponentiate_ci : RETURN(make_listed_product_space([the_complex_numbers,the_integers]));
    ef_eq_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
    ef_ne_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
    ef_conjugate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_abs_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_arg_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_cos_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_exp_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_ln_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_sin_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_sqrt_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_tan_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_if_c : RETURN(make_listed_product_space([the_logicals,the_complex_numbers,the_complex_numbers]));
    ef_subscript_s : RETURN(make_listed_product_space([the_strings,the_integers]));
    ef_eq_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_ne_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_gt_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_lt_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_ge_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_le_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_subsequence_s : RETURN(make_listed_product_space([the_strings,the_integers,the_integers]));
    ef_concat_s : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_strings));
    ef_size_s : RETURN(make_uniform_product_space(the_strings, 1));
    ef_format : RETURN(make_listed_product_space([the_numbers,the_strings]));
    ef_value : RETURN(make_uniform_product_space(the_strings, 1));
    ef_like : RETURN(make_uniform_product_space(the_strings, 2));
    ef_if_s : RETURN(make_listed_product_space([the_logicals,the_strings,the_strings]));
    ef_subscript_b : RETURN(make_listed_product_space([the_binarys,the_integers]));
    ef_eq_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_ne_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_gt_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_lt_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_ge_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_le_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_subsequence_b : RETURN(make_listed_product_space([the_binarys,the_integers,the_integers]));
    ef_concat_b : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_binarys));
    ef_size_b : RETURN(make_uniform_product_space(the_binarys, 1));
    ef_if_b : RETURN(make_listed_product_space([the_logicals,the_binarys,the_binarys]));
    ef_subscript_t : RETURN(make_listed_product_space([the_tuples,the_integers]));
    ef_eq_t : RETURN(make_uniform_product_space(the_tuples, 2));
    ef_ne_t : RETURN(make_uniform_product_space(the_tuples, 2));
    ef_concat_t : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_tuples));
    ef_size_t : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_entuple : RETURN(the_tuples);
    ef_detuple : RETURN(make_uniform_product_space(the_generics, 1));
    ef_insert : RETURN(make_listed_product_space([the_tuples,the_generics,the_integers]));
    ef_remove : RETURN(make_listed_product_space([the_tuples,the_integers]));
    ef_if_t : RETURN(make_listed_product_space([the_logicals,the_tuples,the_tuples]));
    ef_sum_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
    ef_product_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
    ef_add_it : RETURN(make_extended_tuple_space(the_integer_tuples, the_integer_tuples));
    ef_subtract_it : RETURN(make_uniform_product_space(the_integer_tuples, 2));
    ef_scalar_mult_it : RETURN(make_listed_product_space([the_integers,the_integer_tuples]));
    ef_dot_prod_it : RETURN(make_uniform_product_space(the_integer_tuples, 2));
    ef_sum_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_product_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_add_rt : RETURN(make_extended_tuple_space(the_real_tuples, the_real_tuples));
    ef_subtract_rt : RETURN(make_uniform_product_space(the_real_tuples, 2));
    ef_scalar_mult_rt : RETURN(make_listed_product_space([the_reals,the_real_tuples]));
    ef_dot_prod_rt : RETURN(make_uniform_product_space(the_real_tuples, 2));
    ef_norm_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_sum_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_product_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_add_ct : RETURN(make_extended_tuple_space(the_complex_tuples, the_complex_tuples));
    ef_subtract_ct : RETURN(make_uniform_product_space(the_complex_tuples, 2));
    ef_scalar_mult_ct : RETURN(make_listed_product_space([the_complex_numbers,the_complex_tuples]));
    ef_dot_prod_ct : RETURN(make_uniform_product_space(the_complex_tuples, 2));
    ef_norm_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_if : RETURN(make_listed_product_space([the_logicals,the_generics,the_generics]));
    ef_ensemble : RETURN(the_tuples);
    ef_member_of : RETURN(make_listed_product_space([the_generics,the_maths_spaces]));
    OTHERWISE: RETURN(?);
  END_CASE;
END_FUNCTION;

(* "derive_elementary_function_range" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION derive_elementary_function_range(ef_val : elementary_function_enumerators) : tuple_space;
  IF NOT EXISTS(ef_val)
  THEN
    RETURN(?);
  END_IF;
  CASE ef_val OF
    ef_and : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_or : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_not : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_xor : RETURN(make_uniform_product_space(the_logicals, 2));
    ef_negate_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_add_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_subtract_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_multiply_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_divide_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_mod_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_exponentiate_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_eq_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_gt_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_lt_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ge_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_le_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_abs_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_if_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_negate_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_reciprocal_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_add_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_subtract_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_multiply_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_divide_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_mod_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_exponentiate_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_exponentiate_ri : RETURN(make_uniform_product_space(the_reals, 1));
    ef_eq_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_gt_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_lt_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ge_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_le_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_abs_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_acos_r : RETURN(make_uniform_product_space(the_zero_pi_interval, 1));
    ef_asin_r : RETURN(make_uniform_product_space(the_neghalfpi_halfpi_interval, 1));
    ef_atan2_r : RETURN(make_uniform_product_space(the_negpi_pi_interval, 1));
    ef_cos_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
    ef_exp_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_ln_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_log2_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_log10_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_sin_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
    ef_sqrt_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_tan_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_if_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_negate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_reciprocal_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_add_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_subtract_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_multiply_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_divide_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_exponentiate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_exponentiate_ci : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_eq_c : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_c : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_conjugate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_abs_c : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_arg_c : RETURN(make_uniform_product_space(the_negpi_pi_interval, 1));
    ef_cos_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_exp_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_ln_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_sin_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_sqrt_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_tan_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_if_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_subscript_s : RETURN(make_uniform_product_space(the_strings, 1));
    ef_eq_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_gt_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_lt_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ge_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_le_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_subsequence_s : RETURN(make_uniform_product_space(the_strings, 1));
    ef_concat_s : RETURN(make_uniform_product_space(the_strings, 1));
    ef_size_s : RETURN(make_uniform_product_space(the_integers, 1));
    ef_format : RETURN(make_uniform_product_space(the_strings, 1));
    ef_value : RETURN(make_uniform_product_space(the_reals, 1));
    ef_like : RETURN(make_uniform_product_space(the_booleans, 1));
    ef_if_s : RETURN(make_uniform_product_space(the_strings, 1));
    ef_subscript_b : RETURN(make_uniform_product_space(the_binarys, 1));
    ef_eq_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_gt_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_lt_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ge_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_le_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_subsequence_b : RETURN(make_uniform_product_space(the_binarys, 1));
    ef_concat_b : RETURN(make_uniform_product_space(the_binarys, 1));
    ef_size_b : RETURN(make_uniform_product_space(the_integers, 1));
    ef_if_b : RETURN(make_uniform_product_space(the_binarys, 1));
    ef_subscript_t : RETURN(make_uniform_product_space(the_generics, 1));
    ef_eq_t : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_t : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_concat_t : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_size_t : RETURN(make_uniform_product_space(the_integers, 1));
    ef_entuple : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_detuple : RETURN(the_tuples);
    ef_insert : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_remove : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_if_t : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_sum_it : RETURN(make_uniform_product_space(the_integers, 1));
    ef_product_it : RETURN(make_uniform_product_space(the_integers, 1));
    ef_add_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
    ef_subtract_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
    ef_scalar_mult_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
    ef_dot_prod_it : RETURN(make_uniform_product_space(the_integers, 1));
    ef_sum_rt : RETURN(make_uniform_product_space(the_reals, 1));
    ef_product_rt : RETURN(make_uniform_product_space(the_reals, 1));
    ef_add_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_subtract_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_scalar_mult_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_dot_prod_rt : RETURN(make_uniform_product_space(the_reals, 1));
    ef_norm_rt : RETURN(make_uniform_product_space(the_reals, 1));
    ef_sum_ct : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_product_ct : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_add_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_subtract_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_scalar_mult_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_dot_prod_ct : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_norm_ct : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_if : RETURN(make_uniform_product_space(the_generics, 1));
    ef_ensemble : RETURN(make_uniform_product_space(the_maths_spaces, 1));
    ef_member_of : RETURN(make_uniform_product_space(the_logicals, 1));
    OTHERWISE: RETURN(?);
  END_CASE;
END_FUNCTION;

(* "derive_finite_function_domain" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION derive_finite_function_domain(pairs : SET [1 : ?] OF LIST [2 : 2] OF maths_value) : tuple_space;
LOCAL
  result : SET OF maths_value := [];
END_LOCAL;
  -- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
  -- three lines ambiguous in those cases where an operand is simultaneously a member
  -- of the base type and the aggregate type.
  -- REPEAT i := 1 TO SIZEOF (pairs);
  -- result := result + pairs[i][1];
  -- END_REPEAT;
  -- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components(pairs, 1);
  RETURN(one_tuples_of(make_finite_space(result)));
END_FUNCTION;

(* "derive_finite_function_range" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION derive_finite_function_range(pairs : SET [1 : ?] OF LIST [2 : 2] OF maths_value) : tuple_space;
LOCAL
  result : SET OF maths_value := [];
END_LOCAL;
  -- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
  -- three lines ambiguous in those cases where an operand is simultaneously a member
  -- of the base type and the aggregate type.
  -- REPEAT i := 1 TO SIZEOF (pairs);
  -- result := result + pairs[i][2];
  -- END_REPEAT;
  -- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components(pairs, 2);
  RETURN(one_tuples_of(make_finite_space(result)));
END_FUNCTION;

(* "derive_function_domain" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION derive_function_domain(func : maths_function) : tuple_space;
LOCAL
  typenames  : SET OF STRING                   := stripped_typeof(func);
  tspace     : tuple_space                     := make_listed_product_space([]);
  shape      : LIST OF positive_integer;
  sidxs      : LIST OF INTEGER                 := [0];
  itvl       : finite_integer_interval;
  factors    : LIST OF finite_integer_interval := [];
  is_uniform : BOOLEAN                         := TRUE;
END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames
  THEN
    RETURN(derive_finite_function_domain(func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\selector_function.source_of_domain));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames
  THEN
    RETURN(derive_elementary_function_domain(func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames
  THEN
    IF func\repackaging_function.input_repack = ro_nochange
    THEN
      RETURN(func\repackaging_function.operand.domain);
    END_IF;
    IF func\repackaging_function.input_repack = ro_wrap_as_tuple
    THEN
      RETURN(factor1(func\repackaging_function.operand.domain));
    END_IF;
    IF func\repackaging_function.input_repack = ro_unwrap_tuple
    THEN
      RETURN(one_tuples_of(func\repackaging_function.operand.domain));
    END_IF;
    RETURN(?);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames
  THEN
    shape := shape_of_array(func\unary_generic_expression.operand);
    sidxs := func\reindexed_array_function.starting_indices;
    REPEAT i := 1 TO SIZEOF(shape);
      itvl := make_finite_integer_interval(sidxs[i], sidxs[i] + shape[i] - 1);
      INSERT(factors, itvl, i - 1);
      IF shape[i] <> shape[1]
      THEN
        is_uniform := FALSE;
      END_IF;
    END_REPEAT;
    IF is_uniform
    THEN
      RETURN(make_uniform_product_space(factors[1], SIZEOF(shape)));
    END_IF;
    RETURN(make_listed_product_space(factors));
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames
  THEN
    RETURN(func\series_composed_function.operands[1].domain);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\parallel_composed_function.source_of_domain));
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames
  THEN
    shape := func\explicit_table_function.shape;
    sidxs[1] := func\explicit_table_function.index_base;
    REPEAT i := 1 TO SIZEOF(shape);
      itvl := make_finite_integer_interval(sidxs[1], sidxs[1] + shape[i] - 1);
      INSERT(factors, itvl, i - 1);
      IF shape[i] <> shape[1]
      THEN
        is_uniform := FALSE;
      END_IF;
    END_REPEAT;
    IF is_uniform
    THEN
      RETURN(make_uniform_product_space(factors[1], SIZEOF(shape)));
    END_IF;
    RETURN(make_listed_product_space(factors));
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(make_uniform_product_space(factor1(func\homogeneous_linear_function.mat.range),
                                                    func\homogeneous_linear_function.mat\explicit_table_function.shape[func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(make_uniform_product_space(factor1(func\general_linear_function.mat.range),
                                                    func\general_linear_function.mat\explicit_table_function.shape[func\general_linear_function.sum_index] -
                                                    1)));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames
  THEN
    RETURN(one_tuples_of(make_finite_real_interval(func\b_spline_basis.repeated_knots[func\b_spline_basis.order],
                                                   closed,
                                                   func\b_spline_basis.repeated_knots[func\b_spline_basis.num_basis +
                                                                                      1],
                                                   closed)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames
  THEN
    REPEAT i := 1 TO SIZEOF(func\b_spline_function.basis);
      tspace := assoc_product_space(tspace, func\b_spline_function.basis[i].domain);
    END_REPEAT;
    RETURN(one_tuples_of(tspace));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames
  THEN
    RETURN(func\rationalize_function.fun.domain);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames
  THEN
    RETURN(func\partial_derivative_function.derivand.domain);
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames
  THEN
    RETURN(derive_definite_integral_domain(func));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames
  THEN
    REPEAT i := 1 TO SIZEOF(func\abstracted_expression_function.variables);
      tspace := assoc_product_space(tspace,
                                    one_tuples_of(values_space_of(func\abstracted_expression_function.variables[i])));
    END_REPEAT;
    RETURN(tspace);
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames
  THEN
    RETURN(values_space_of(func\expression_denoted_function.expr)\function_space.domain_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(make_listed_product_space([])));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames
  THEN
    RETURN(func\imported_curve_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames
  THEN
    RETURN(func\imported_surface_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames
  THEN
    RETURN(func\imported_volume_function.parametric_domain);
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames
  THEN
    RETURN(func\application_defined_function.explicit_domain);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN(?);
END_FUNCTION;

(* "derive_function_range" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION derive_function_range(func : maths_function) : tuple_space;
LOCAL
  typenames : SET OF STRING       := stripped_typeof(func);
  tspace    : tuple_space         := make_listed_product_space([]);
  m         : nonnegative_integer := 0;
  n         : nonnegative_integer := 0;
  temp      : INTEGER             := 0;
END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames
  THEN
    RETURN(derive_finite_function_range(func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(make_finite_space([func\constant_function.sole_output])));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames
  THEN
    tspace := func.domain;
    IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(tspace))
    THEN
      tspace := factor1(tspace);
    END_IF;
    RETURN(one_tuples_of(factor_space(tspace, func\selector_function.selector)));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames
  THEN
    RETURN(derive_elementary_function_range(func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames
  THEN
    tspace := func\repackaging_function.operand.range;
    IF func\repackaging_function.output_repack = ro_wrap_as_tuple
    THEN
      tspace := one_tuples_of(tspace);
    END_IF;
    IF func\repackaging_function.output_repack = ro_unwrap_tuple
    THEN
      tspace := factor1(tspace);
    END_IF;
    IF func\repackaging_function.selected_output > 0
    THEN
      tspace := one_tuples_of(factor_space(tspace, func\repackaging_function.selected_output));
    END_IF;
    RETURN(tspace);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames
  THEN
    RETURN(func\unary_generic_expression.operand\maths_function.range);
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames
  THEN
    RETURN(func\series_composed_function.operands[SIZEOF(func\series_composed_function.operands)].range);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames
  THEN
    RETURN(func\parallel_composed_function.final_function.range);
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames
  THEN
    IF 'LISTED_REAL_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(the_reals));
    END_IF;
    IF 'LISTED_INTEGER_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(the_integers));
    END_IF;
    IF 'LISTED_LOGICAL_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(the_logicals));
    END_IF;
    IF 'LISTED_STRING_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(the_strings));
    END_IF;
    IF 'LISTED_COMPLEX_NUMBER_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(the_complex_numbers));
    END_IF;
    IF 'LISTED_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(func\listed_data.value_range));
    END_IF;
    IF 'EXTERNALLY_LISTED_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(func\externally_listed_data.value_range));
    END_IF;
    IF 'LINEARIZED_TABLE_FUNCTION' IN typenames
    THEN
      RETURN(func\linearized_table_function.source.range);
    END_IF;
    IF 'BASIC_SPARSE_MATRIX' IN typenames
    THEN
      RETURN(func\basic_sparse_matrix.val.range);
    END_IF;
    RETURN(?);
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(make_uniform_product_space(factor1(func\homogeneous_linear_function.mat.range),
                                                    func\homogeneous_linear_function.mat\explicit_table_function.shape[3 -
                                                                                                                       func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(make_uniform_product_space(factor1(func\general_linear_function.mat.range),
                                                    func\general_linear_function.mat\explicit_table_function.shape[3 -
                                                                                                                   func\general_linear_function.sum_index])));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames
  THEN
    RETURN(one_tuples_of(make_uniform_product_space(the_reals, func\b_spline_basis.num_basis)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames
  THEN
    tspace := factor1(func\b_spline_function.coef.domain);
    m := SIZEOF(func\b_spline_function.basis);
    n := space_dimension(tspace);
    IF m = n
    THEN
      RETURN(one_tuples_of(the_reals));
    END_IF;
    IF m = n - 1
    THEN
      RETURN(one_tuples_of(make_uniform_product_space(the_reals,
                                                      factor_space(tspace, n)\finite_integer_interval.size)));
    END_IF;
    tspace := extract_factors(tspace, m + 1, n);
    RETURN(one_tuples_of(make_function_space(sc_equal, tspace, sc_subspace,
                                             number_superspace_of(func\b_spline_function.coef.range))));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames
  THEN
    tspace := factor1(func\rationalize_function.fun.range);
    n := space_dimension(tspace);
    RETURN(one_tuples_of(make_uniform_product_space(number_superspace_of(factor1(tspace)), n - 1)));
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames
  THEN
    RETURN(drop_numeric_constraints(func\partial_derivative_function.derivand.range));
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames
  THEN
    RETURN(drop_numeric_constraints(func\definite_integral_function.integrand.range));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(values_space_of(func\abstracted_expression_function.expr)));
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames
  THEN
    RETURN(values_space_of(func\expression_denoted_function.expr)\function_space.range_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames
  THEN
    temp := dimension_of(func\imported_point_function.geometry);
    RETURN(one_tuples_of(make_uniform_product_space(the_reals, temp)));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames
  THEN
    temp := dimension_of(func\imported_curve_function.geometry);
    RETURN(one_tuples_of(make_uniform_product_space(the_reals, temp)));
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames
  THEN
    temp := dimension_of(func\imported_surface_function.geometry);
    RETURN(one_tuples_of(make_uniform_product_space(the_reals, temp)));
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames
  THEN
    temp := dimension_of(func\imported_volume_function.geometry);
    RETURN(one_tuples_of(make_uniform_product_space(the_reals, temp)));
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames
  THEN
    RETURN(func\application_defined_function.explicit_range);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN(?);
END_FUNCTION;

(* "dimension_of" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION dimension_of(item : geometric_representation_item) : dimension_count;
LOCAL
  x   : SET OF representation;
  y   : representation_context;
  dim : dimension_count;
END_LOCAL;
  -- For cartesian_point, direction, or vector dimension is determined by
  -- counting components.
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CARTESIAN_POINT' IN TYPEOF(item)
  THEN
    dim := SIZEOF(item\cartesian_point.coordinates);
    RETURN(dim);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIRECTION' IN TYPEOF(item)
  THEN
    dim := SIZEOF(item\direction.direction_ratios);
    RETURN(dim);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VECTOR' IN TYPEOF(item)
  THEN
    dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
    RETURN(dim);
  END_IF;
  -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 
  x := using_representations(item);
  -- Determines the dimension_count of the 
  -- geometric_representation_context.
  -- The SET x is non-empty for legal instances since this is required by WR1 of
  -- representation_item.
  IF (SIZEOF(x) > 0)
  THEN
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN(dim);
  ELSE
    RETURN(?);
  END_IF;
END_FUNCTION;

(* "dimensions_for_si_unit" IMPLICIT from SCHEMA measure_schema *)
FUNCTION dimensions_for_si_unit(n : si_unit_name) : dimensional_exponents;
  CASE n OF
    metre : RETURN(dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    gram : RETURN(dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    second : RETURN(dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
    ampere : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
    kelvin : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    mole : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
    candela : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    radian : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    steradian : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    hertz : RETURN(dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    newton : RETURN(dimensional_exponents(1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    pascal : RETURN(dimensional_exponents(-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    joule : RETURN(dimensional_exponents(2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    watt : RETURN(dimensional_exponents(2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
    coulomb : RETURN(dimensional_exponents(0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
    volt : RETURN(dimensional_exponents(2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
    farad : RETURN(dimensional_exponents(-2.0, -1.0, 4.0, 2.0, 0.0, 0.0, 0.0));
    ohm : RETURN(dimensional_exponents(2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
    siemens : RETURN(dimensional_exponents(-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
    weber : RETURN(dimensional_exponents(2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    tesla : RETURN(dimensional_exponents(0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    henry : RETURN(dimensional_exponents(2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
    degree_celsius : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    lumen : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    lux : RETURN(dimensional_exponents(-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    becquerel : RETURN(dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    gray : RETURN(dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    sievert : RETURN(dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    OTHERWISE: RETURN(?);
  END_CASE;
END_FUNCTION;

(* "domain_from" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION domain_from(ref : maths_space_or_function) : tuple_space;
LOCAL
  typenames : SET OF STRING  := stripped_typeof(ref);
  func      : maths_function;
END_LOCAL;
  IF NOT EXISTS(ref)
  THEN
    RETURN(?);
  END_IF;
  IF 'TUPLE_SPACE' IN typenames
  THEN
    RETURN(ref);
  END_IF;
  IF 'MATHS_SPACE' IN typenames
  THEN
    RETURN(one_tuples_of(ref));
  END_IF;
  func := ref;
  IF 'CONSTANT_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\selector_function.source_of_domain));
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\parallel_composed_function.source_of_domain));
  END_IF;
  RETURN(func.domain);
END_FUNCTION;

(* "dot_count" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION dot_count(str : STRING) : INTEGER;
LOCAL
  n : INTEGER := 0;
END_LOCAL;
  REPEAT i := 1 TO LENGTH(str);
    IF str[i] = '.'
    THEN
      n := n + 1;
    END_IF;
  END_REPEAT;
  RETURN(n);
END_FUNCTION;

(* "dot_product" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION dot_product(arg1 : direction;
                     arg2 : direction) : REAL;
LOCAL
  scalar : REAL;
  vec1   : direction;
  vec2   : direction;
  ndim   : INTEGER;
END_LOCAL;
  IF NOT EXISTS(arg1) OR NOT EXISTS(arg2)
  THEN
    scalar := ?;
  ELSE
    IF (arg1.dim <> arg2.dim)
    THEN
      scalar := ?;
    ELSE
      BEGIN  
             vec1 := normalise(arg1);
             vec2 := normalise(arg2);
             ndim := arg1.dim;
             scalar := 0.0;
             REPEAT i := 1 TO ndim;
               scalar := scalar + vec1.direction_ratios[i] * vec2.direction_ratios[i];
             END_REPEAT;
      END;
    END_IF;
  END_IF;
  RETURN(scalar);
END_FUNCTION;

(* "dotted_identifiers_syntax" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION dotted_identifiers_syntax(str : STRING) : BOOLEAN;
LOCAL
  k : positive_integer;
  m : positive_integer;
END_LOCAL;
  IF NOT EXISTS(str)
  THEN
    RETURN(FALSE);
  END_IF;
  k := parse_express_identifier(str, 1);
  IF k = 1
  THEN
    RETURN(FALSE);
  END_IF;
  REPEAT WHILE k <= LENGTH(str);
    IF (str[k] <> '.') OR (k = LENGTH(str))
    THEN
      RETURN(FALSE);
    END_IF;
    m := parse_express_identifier(str, k + 1);
    IF m = k + 1
    THEN
      RETURN(FALSE);
    END_IF;
    k := m;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "drop_numeric_constraints" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION drop_numeric_constraints(spc : maths_space) : maths_space;
LOCAL
  typenames : SET OF STRING        := stripped_typeof(spc);
  tspc      : listed_product_space;
  factors   : LIST OF maths_space  := [];
  xspc      : extended_tuple_space;
END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN typenames
  THEN
    RETURN(make_uniform_product_space(drop_numeric_constraints(spc\uniform_product_space.base),
                                      spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN typenames
  THEN
    tspc := spc;
    REPEAT i := 1 TO SIZEOF(tspc.factors);
      INSERT(factors, drop_numeric_constraints(tspc.factors[i]), i - 1);
    END_REPEAT;
    RETURN(make_listed_product_space(factors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN typenames
  THEN
    xspc := spc;
    RETURN(make_extended_tuple_space(drop_numeric_constraints(xspc.base), drop_numeric_constraints(xspc.extender)));
  END_IF;
  IF subspace_of_es(spc, es_numbers)
  THEN
    RETURN(number_superspace_of(spc));
  END_IF;
  RETURN(spc);
END_FUNCTION;

(* "edge_reversed" IMPLICIT from SCHEMA topology_schema *)
FUNCTION edge_reversed(an_edge : edge) : oriented_edge;
LOCAL
  the_reverse : oriented_edge;
END_LOCAL;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ORIENTED_EDGE' IN TYPEOF(an_edge))
  THEN
    the_reverse := dummy_tri || edge(an_edge.edge_end, an_edge.edge_start) ||
                   oriented_edge(an_edge\oriented_edge.edge_element, NOT (an_edge\oriented_edge.orientation));
  ELSE
    the_reverse := dummy_tri || edge(an_edge.edge_end, an_edge.edge_start) || oriented_edge(an_edge, FALSE);
  END_IF;
  RETURN(the_reverse);
END_FUNCTION;

(* "enclose_cregion_in_pregion" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION enclose_cregion_in_pregion(crgn : cartesian_complex_number_region;
                                    centre : complex_number_literal) : polar_complex_number_region;
FUNCTION angle(a : REAL) : REAL;
  REPEAT WHILE a > PI;
    a := a - 2.0 * PI;
  END_REPEAT;
  REPEAT WHILE a <= -PI;
    a := a + 2.0 * PI;
  END_REPEAT;
  RETURN(a);
END_FUNCTION;
FUNCTION strictly_in(z : REAL;
                     zitv : real_interval) : LOGICAL;
  RETURN((NOT min_exists(zitv) OR (z > real_min(zitv))) AND (NOT max_exists(zitv) OR (z < real_max(zitv))));
END_FUNCTION;
PROCEDURE angle_minmax(ab : REAL; a : REAL; a_in : BOOLEAN; VAR amin : REAL; VAR amax : REAL; VAR amin_in : BOOLEAN;
                       VAR amax_in : BOOLEAN);
  a := angle(a - ab);
  IF amin = a
  THEN
    amin_in := amin_in OR a_in;
  END_IF;
  IF amin > a
  THEN
    amin := a;
    amin_in := a_in;
  END_IF;
  IF amax = a
  THEN
    amax_in := amax_in OR a_in;
  END_IF;
  IF amax < a
  THEN
    amax := a;
    amax_in := a_in;
  END_IF;
END_PROCEDURE;
PROCEDURE range_max(r : REAL; incl : BOOLEAN; VAR rmax : REAL; VAR rmax_in : BOOLEAN);
  IF rmax = r
  THEN
    rmax_in := rmax_in OR incl;
  END_IF;
  IF rmax < r
  THEN
    rmax := r;
    rmax_in := incl;
  END_IF;
END_PROCEDURE;
PROCEDURE range_min(r : REAL; incl : BOOLEAN; VAR rmin : REAL; VAR rmin_in : BOOLEAN);
  IF rmin = r
  THEN
    rmin_in := rmin_in OR incl;
  END_IF;
  IF (rmin < 0.0) OR (rmin > r)
  THEN
    rmin := r;
    rmin_in := incl;
  END_IF;
END_PROCEDURE;
LOCAL
  xitv        : real_interval;
  yitv        : real_interval;
  is_xmin     : BOOLEAN;
  is_xmax     : BOOLEAN;
  is_ymin     : BOOLEAN;
  is_ymax     : BOOLEAN;
  xmin        : REAL                 := 0.0;
  xmax        : REAL                 := 0.0;
  ymin        : REAL                 := 0.0;
  ymax        : REAL                 := 0.0;
  xc          : REAL                 := 0.0;
  yc          : REAL                 := 0.0;
  xmin_in     : BOOLEAN              := FALSE;
  xmax_in     : BOOLEAN              := FALSE;
  ymin_in     : BOOLEAN              := FALSE;
  ymax_in     : BOOLEAN              := FALSE;
  rmin        : REAL                 := -1.0;
  rmax        : REAL                 := -1.0;
  amin        : REAL                 := 4.0;
  amax        : REAL                 := -4.0;
  rmax_exists : BOOLEAN              := TRUE;
  outside     : BOOLEAN              := TRUE;
  rmin_in     : BOOLEAN              := FALSE;
  rmax_in     : BOOLEAN              := FALSE;
  amin_in     : BOOLEAN              := FALSE;
  amax_in     : BOOLEAN              := FALSE;
  ab          : REAL                 := 0.0;
  a           : REAL                 := 0.0;
  r           : REAL                 := 0.0;
  incl        : BOOLEAN;
  ritv        : real_interval;
  aitv        : finite_real_interval;
  minclo      : open_closed          := open;
  maxclo      : open_closed          := open;
END_LOCAL;
  IF NOT EXISTS(crgn) OR NOT EXISTS(centre)
  THEN
    RETURN(?);
  END_IF;
  -- Extract elementary input information
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  is_xmin := min_exists(xitv);
  is_xmax := max_exists(xitv);
  is_ymin := min_exists(yitv);
  is_ymax := max_exists(yitv);
  IF is_xmin
  THEN
    xmin := real_min(xitv);
    xmin_in := min_included(xitv);
  END_IF;
  IF is_xmax
  THEN
    xmax := real_max(xitv);
    xmax_in := max_included(xitv);
  END_IF;
  IF is_ymin
  THEN
    ymin := real_min(yitv);
    ymin_in := min_included(yitv);
  END_IF;
  IF is_ymax
  THEN
    ymax := real_max(yitv);
    ymax_in := max_included(yitv);
  END_IF;
  rmax_exists := is_xmin AND is_xmax AND is_ymin AND is_ymax;
  -- Identify base direction with respect to which all relevant directions lie
  -- within +/- 0.5*PI, or that the centre lies properly inside crgn.
  IF is_xmin AND (xc <= xmin)
  THEN
    ab := 0.0;
  ELSE
    IF is_ymin AND (yc <= ymin)
    THEN
      ab := 0.5 * PI;
    ELSE
      IF is_ymax AND (yc >= ymax)
      THEN
        ab := -0.5 * PI;
      ELSE
        IF is_xmax AND (xc >= xmax)
        THEN
          ab := PI;
        ELSE
          outside := FALSE;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  IF NOT outside AND NOT rmax_exists
  THEN
    RETURN(?);
  END_IF;
  -- Identify any closest point on a side but not a corner.
  IF is_xmin AND (xc <= xmin) AND strictly_in(yc, yitv)
  THEN
    rmin := xmin - xc;
    rmin_in := xmin_in;
  ELSE
    IF is_ymin AND (yc <= ymin) AND strictly_in(xc, xitv)
    THEN
      rmin := ymin - yc;
      rmin_in := ymin_in;
    ELSE
      IF is_ymax AND (yc >= ymax) AND strictly_in(xc, xitv)
      THEN
        rmin := yc - ymax;
        rmin_in := ymax_in;
      ELSE
        IF is_xmax AND (xc >= xmax) AND strictly_in(yc, yitv)
        THEN
          rmin := xc - xmax;
          rmin_in := xmax_in;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  IF is_xmin
  THEN
    IF is_ymin
    THEN
      r := SQRT((xmin - xc) ** 2 + (ymin - yc) ** 2);
      incl := xmin_in AND ymin_in;
      IF rmax_exists
      THEN
        range_max(r, incl, rmax, rmax_in);
      END_IF;
      IF outside
      THEN
        IF r > 0.0
        THEN
          range_min(r, incl, rmin, rmin_in);
          a := angle(atan2(ymin - yc, xmin - xc) - ab);
          IF xc = xmin
          THEN
            incl := xmin_in;
          END_IF;
          IF yc = ymin
          THEN
            incl := ymin_in;
          END_IF;
          angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
        ELSE
          rmin := 0.0;
          rmin_in := xmin_in AND ymin_in;
          amin := angle(0.0 - ab);
          amin_in := ymin_in;
          amax := angle(0.5 * PI - ab);
          amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE
      IF xc <= xmin
      THEN
        angle_minmax(ab, -0.5 * PI, (xc = xmin) AND xmin_in, amin, amax, amin_in, amax_in);
      END_IF;
    END_IF;
    IF NOT is_ymax AND (xc <= xmin)
    THEN
      angle_minmax(ab, 0.5 * PI, (xc = xmin) AND xmin_in, amin, amax, amin_in, amax_in);
    END_IF;
  END_IF;
  IF is_ymin
  THEN
    IF is_xmax
    THEN
      r := SQRT((xmax - xc) ** 2 + (ymin - yc) ** 2);
      incl := xmax_in AND ymin_in;
      IF rmax_exists
      THEN
        range_max(r, incl, rmax, rmax_in);
      END_IF;
      IF outside
      THEN
        IF r > 0.0
        THEN
          range_min(r, incl, rmin, rmin_in);
          a := angle(atan2(ymin - yc, xmax - xc) - ab);
          IF xc = xmax
          THEN
            incl := xmax_in;
          END_IF;
          IF yc = ymin
          THEN
            incl := ymin_in;
          END_IF;
          angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
        ELSE
          rmin := 0.0;
          rmin_in := xmax_in AND ymin_in;
          amin := angle(0.5 * PI - ab);
          amin_in := ymin_in;
          amax := angle(PI - ab);
          amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE
      IF yc <= ymin
      THEN
        angle_minmax(ab, 0.0, (yc = ymin) AND ymin_in, amin, amax, amin_in, amax_in);
      END_IF;
    END_IF;
    IF NOT is_xmin AND (yc <= ymin)
    THEN
      angle_minmax(ab, PI, (yc = ymin) AND ymin_in, amin, amax, amin_in, amax_in);
    END_IF;
  END_IF;
  IF is_xmax
  THEN
    IF is_ymax
    THEN
      r := SQRT((xmax - xc) ** 2 + (ymax - yc) ** 2);
      incl := xmax_in AND ymax_in;
      IF rmax_exists
      THEN
        range_max(r, incl, rmax, rmax_in);
      END_IF;
      IF outside
      THEN
        IF r > 0.0
        THEN
          range_min(r, incl, rmin, rmin_in);
          a := angle(atan2(ymax - yc, xmax - xc) - ab);
          IF xc = xmax
          THEN
            incl := xmax_in;
          END_IF;
          IF yc = ymax
          THEN
            incl := ymax_in;
          END_IF;
          angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
        ELSE
          rmin := 0.0;
          rmin_in := xmax_in AND ymax_in;
          amin := angle(-PI - ab);
          amin_in := ymax_in;
          amax := angle(-0.5 * PI - ab);
          amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE
      IF xc >= xmax
      THEN
        angle_minmax(ab, 0.5 * PI, (xc = xmax) AND xmax_in, amin, amax, amin_in, amax_in);
      END_IF;
    END_IF;
    IF NOT is_ymin AND (xc >= xmax)
    THEN
      angle_minmax(ab, -0.5 * PI, (xc = xmax) AND xmax_in, amin, amax, amin_in, amax_in);
    END_IF;
  END_IF;
  IF is_ymax
  THEN
    IF is_xmin
    THEN
      r := SQRT((xmin - xc) ** 2 + (ymax - yc) ** 2);
      incl := xmin_in AND ymax_in;
      IF rmax_exists
      THEN
        range_max(r, incl, rmax, rmax_in);
      END_IF;
      IF outside
      THEN
        IF r > 0.0
        THEN
          range_min(r, incl, rmin, rmin_in);
          a := angle(atan2(ymax - yc, xmin - xc) - ab);
          IF xc = xmin
          THEN
            incl := xmin_in;
          END_IF;
          IF yc = ymax
          THEN
            incl := ymax_in;
          END_IF;
          angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
        ELSE
          rmin := 0.0;
          rmin_in := xmin_in AND ymax_in;
          amin := angle(0.5 * PI - ab);
          amin_in := ymax_in;
          amax := angle(PI - ab);
          amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE
      IF yc >= ymax
      THEN
        angle_minmax(ab, PI, (yc = ymax) AND ymax_in, amin, amax, amin_in, amax_in);
      END_IF;
    END_IF;
    IF NOT is_xmax AND (yc >= ymax)
    THEN
      angle_minmax(ab, 0.0, (yc = ymax) AND ymax_in, amin, amax, amin_in, amax_in);
    END_IF;
  END_IF;
  IF outside
  THEN
    amin := angle(amin + ab);
    IF amin = PI
    THEN
      amin := -PI;
    END_IF;
    amax := angle(amax + ab);
    IF amax <= amin
    THEN
      amax := amax + 2.0 * PI;
    END_IF;
  ELSE
    amin := -PI;
    amin_in := FALSE;
    amax := PI;
    amax_in := FALSE;
  END_IF;
  IF amin_in
  THEN
    minclo := closed;
  END_IF;
  IF amax_in
  THEN
    maxclo := closed;
  END_IF;
  aitv := make_finite_real_interval(amin, minclo, amax, maxclo);
  minclo := open;
  IF rmin_in
  THEN
    minclo := closed;
  END_IF;
  IF rmax_exists
  THEN
    maxclo := open;
    IF rmax_in
    THEN
      maxclo := closed;
    END_IF;
    ritv := make_finite_real_interval(rmin, minclo, rmax, maxclo);
  ELSE
    ritv := make_real_interval_from_min(rmin, minclo);
  END_IF;
  RETURN(make_polar_complex_number_region(centre, ritv, aitv));
END_FUNCTION;

(* "enclose_pregion_in_cregion" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION enclose_pregion_in_cregion(prgn : polar_complex_number_region) : cartesian_complex_number_region;
PROCEDURE nearest_good_direction(acart : REAL; aitv : finite_real_interval; VAR a : REAL; VAR a_in : BOOLEAN);
  a := acart;
  a_in := TRUE;
  IF a < aitv.min
  THEN
    IF a + 2.0 * PI < aitv.max
    THEN
      RETURN;
    END_IF;
    IF a + 2.0 * PI = aitv.max
    THEN
      a_in := max_included(aitv);
      RETURN;
    END_IF;
  ELSE
    IF a = aitv.min
    THEN
      a_in := min_included(aitv);
      RETURN;
    ELSE
      IF a < aitv.max
      THEN
        RETURN;
      ELSE
        IF a = aitv.max
        THEN
          a_in := max_included(aitv);
          RETURN;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  IF COS(acart - aitv.max) >= COS(acart - aitv.min)
  THEN
    a := aitv.max;
    a_in := max_included(aitv);
  ELSE
    a := aitv.min;
    a_in := min_included(aitv);
  END_IF;
END_PROCEDURE;
LOCAL
  xc          : REAL                 := 0.0;
  yc          : REAL                 := 0.0;
  xmin        : REAL                 := 0.0;
  xmax        : REAL                 := 0.0;
  ymin        : REAL                 := 0.0;
  ymax        : REAL                 := 0.0;
  ritv        : real_interval;
  xitv        : real_interval;
  yitv        : real_interval;
  aitv        : finite_real_interval;
  xmin_exists : BOOLEAN;
  xmax_exists : BOOLEAN;
  ymin_exists : BOOLEAN;
  ymax_exists : BOOLEAN;
  xmin_in     : BOOLEAN              := FALSE;
  xmax_in     : BOOLEAN              := FALSE;
  ymin_in     : BOOLEAN              := FALSE;
  ymax_in     : BOOLEAN              := FALSE;
  a           : REAL                 := 0.0;
  r           : REAL                 := 0.0;
  a_in        : BOOLEAN              := FALSE;
  min_clo     : open_closed          := open;
  max_clo     : open_closed          := open;
END_LOCAL;
  IF NOT EXISTS(prgn)
  THEN
    RETURN(?);
  END_IF;
  -- Extract elementary input data
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  ritv := prgn.distance_constraint;
  aitv := prgn.direction_constraint;
  -- Determine xmin data
  nearest_good_direction(PI, aitv, a, a_in);
  IF COS(a) >= 0.0
  THEN
    xmin_exists := TRUE;
    xmin := xc + real_min(ritv) * COS(a);
    xmin_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv)
    THEN
      xmin_exists := TRUE;
      xmin := xc + real_max(ritv) * COS(a);
      xmin_in := a_in AND max_included(ritv);
    ELSE
      xmin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine xmax data
  nearest_good_direction(0.0, aitv, a, a_in);
  IF COS(a) <= 0.0
  THEN
    xmax_exists := TRUE;
    xmax := xc + real_min(ritv) * COS(a);
    xmax_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv)
    THEN
      xmax_exists := TRUE;
      xmax := xc + real_max(ritv) * COS(a);
      xmax_in := a_in AND max_included(ritv);
    ELSE
      xmax_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymin data
  nearest_good_direction(-0.5 * PI, aitv, a, a_in);
  IF SIN(a) >= 0.0
  THEN
    ymin_exists := TRUE;
    ymin := yc + real_min(ritv) * SIN(a);
    ymin_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv)
    THEN
      ymin_exists := TRUE;
      ymin := yc + real_max(ritv) * SIN(a);
      ymin_in := a_in AND max_included(ritv);
    ELSE
      ymin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymax data
  nearest_good_direction(0.5 * PI, aitv, a, a_in);
  IF SIN(a) <= 0.0
  THEN
    ymax_exists := TRUE;
    ymax := yc + real_min(ritv) * SIN(a);
    ymax_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv)
    THEN
      ymax_exists := TRUE;
      ymax := yc + real_max(ritv) * SIN(a);
      ymax_in := a_in AND max_included(ritv);
    ELSE
      ymax_exists := FALSE;
    END_IF;
  END_IF;
  -- Construct result
  IF NOT (xmin_exists OR xmax_exists OR ymin_exists OR ymax_exists)
  THEN
    RETURN(?);
  END_IF;
  -- Construct real_constraint
  IF xmin_exists
  THEN
    IF xmin_in
    THEN
      min_clo := closed;
    ELSE
      min_clo := open;
    END_IF;
    IF xmax_exists
    THEN
      IF xmax_in
      THEN
        max_clo := closed;
      ELSE
        max_clo := open;
      END_IF;
      xitv := make_finite_real_interval(xmin, min_clo, xmax, max_clo);
    ELSE
      xitv := make_real_interval_from_min(xmin, min_clo);
    END_IF;
  ELSE
    IF xmax_exists
    THEN
      IF xmax_in
      THEN
        max_clo := closed;
      ELSE
        max_clo := open;
      END_IF;
      xitv := make_real_interval_to_max(xmax, max_clo);
    ELSE
      xitv := the_reals;
    END_IF;
  END_IF;
  -- Construct imag_constraint
  IF ymin_exists
  THEN
    IF ymin_in
    THEN
      min_clo := closed;
    ELSE
      min_clo := open;
    END_IF;
    IF ymax_exists
    THEN
      IF ymax_in
      THEN
        max_clo := closed;
      ELSE
        max_clo := open;
      END_IF;
      yitv := make_finite_real_interval(ymin, min_clo, ymax, max_clo);
    ELSE
      yitv := make_real_interval_from_min(ymin, min_clo);
    END_IF;
  ELSE
    IF ymax_exists
    THEN
      IF ymax_in
      THEN
        max_clo := closed;
      ELSE
        max_clo := open;
      END_IF;
      yitv := make_real_interval_to_max(ymax, max_clo);
    ELSE
      yitv := the_reals;
    END_IF;
  END_IF;
  -- Construct cartesian region
  RETURN(make_cartesian_complex_number_region(xitv, yitv));
END_FUNCTION;

(* "enclose_pregion_in_pregion" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION enclose_pregion_in_pregion(prgn : polar_complex_number_region;
                                    centre : complex_number_literal) : polar_complex_number_region;
FUNCTION angle(a : REAL) : REAL;
  REPEAT WHILE a > PI;
    a := a - 2.0 * PI;
  END_REPEAT;
  REPEAT WHILE a <= -PI;
    a := a + 2.0 * PI;
  END_REPEAT;
  RETURN(a);
END_FUNCTION;
PROCEDURE angle_range(VAR amin : REAL; VAR amax : REAL);
  amin := angle(amin);
  IF amin = PI
  THEN
    amin := -PI;
  END_IF;
  amax := angle(amax);
  IF amax <= amin
  THEN
    amax := amax + 2.0 * PI;
  END_IF;
END_PROCEDURE;
FUNCTION strictly_in(a : REAL;
                     aitv : finite_real_interval) : LOGICAL;
  a := angle(a);
  RETURN({aitv.min < a < aitv.max} OR {aitv.min < a + 2.0 * PI < aitv.max});
END_FUNCTION;
PROCEDURE find_aminmax(ab : REAL; a0 : REAL; a1 : REAL; a2 : REAL; a3 : REAL; in0 : BOOLEAN; in1 : BOOLEAN;
                       in2 : BOOLEAN; in3 : BOOLEAN; VAR amin : REAL; VAR amax : REAL; VAR amin_in : BOOLEAN;
                       VAR amax_in : BOOLEAN);
 LOCAL  
        a : REAL;
 END_LOCAL;
  amin := angle(a0 - ab);
  amin_in := in0;
  amax := amin;
  amax_in := in0;
  a := angle(a1 - ab);
  IF a = amin
  THEN
    amin_in := amin_in OR in1;
  END_IF;
  IF a < amin
  THEN
    amin := a;
    amin_in := in1;
  END_IF;
  IF a = amax
  THEN
    amax_in := amax_in OR in1;
  END_IF;
  IF a > amax
  THEN
    amax := a;
    amax_in := in1;
  END_IF;
  a := angle(a2 - ab);
  IF a = amin
  THEN
    amin_in := amin_in OR in2;
  END_IF;
  IF a < amin
  THEN
    amin := a;
    amin_in := in2;
  END_IF;
  IF a = amax
  THEN
    amax_in := amax_in OR in2;
  END_IF;
  IF a > amax
  THEN
    amax := a;
    amax_in := in2;
  END_IF;
  a := angle(a3 - ab);
  IF a = amin
  THEN
    amin_in := amin_in OR in3;
  END_IF;
  IF a < amin
  THEN
    amin := a;
    amin_in := in3;
  END_IF;
  IF a = amax
  THEN
    amax_in := amax_in OR in3;
  END_IF;
  IF a > amax
  THEN
    amax := a;
    amax_in := in3;
  END_IF;
  amin := amin + ab;
  amax := amax + ab;
  angle_range(amin, amax);
END_PROCEDURE;
LOCAL
  ritp    : real_interval;
  ritv    : real_interval;
  aitp    : finite_real_interval;
  aitv    : finite_real_interval;
  xp      : REAL                 := 0.0;
  yp      : REAL                 := 0.0;
  xc      : REAL                 := 0.0;
  yc      : REAL                 := 0.0;
  rmax    : REAL                 := 0.0;
  rmin    : REAL                 := 0.0;
  amin    : REAL                 := 0.0;
  amax    : REAL                 := 0.0;
  rc      : REAL                 := 0.0;
  acp     : REAL                 := 0.0;
  apc     : REAL                 := 0.0;
  rmax_in : BOOLEAN              := FALSE;
  rmin_in : BOOLEAN              := FALSE;
  amin_in : BOOLEAN              := FALSE;
  amax_in : BOOLEAN              := FALSE;
  rmxp    : REAL                 := 0.0;
  rmnp    : REAL                 := 0.0;
  x       : REAL                 := 0.0;
  y       : REAL                 := 0.0;
  r       : REAL                 := 0.0;
  a       : REAL                 := 0.0;
  ab      : REAL                 := 0.0;
  r0      : REAL                 := 0.0;
  a0      : REAL                 := 0.0;
  r1      : REAL                 := 0.0;
  a1      : REAL                 := 0.0;
  r2      : REAL                 := 0.0;
  a2      : REAL                 := 0.0;
  r3      : REAL                 := 0.0;
  a3      : REAL                 := 0.0;
  in0     : BOOLEAN              := FALSE;
  in1     : BOOLEAN              := FALSE;
  in2     : BOOLEAN              := FALSE;
  in3     : BOOLEAN              := FALSE;
  inn     : BOOLEAN              := FALSE;
  minclo  : open_closed          := open;
  maxclo  : open_closed          := open;
END_LOCAL;
  -- Extract elementary input information
  IF NOT EXISTS(prgn) OR NOT EXISTS(centre)
  THEN
    RETURN(?);
  END_IF;
  xp := prgn.centre.real_part;
  yp := prgn.centre.imag_part;
  ritp := prgn.distance_constraint;
  aitp := prgn.direction_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  IF (xc = xp) AND (yc = yp)
  THEN
    RETURN(prgn);
  END_IF;
  rc := SQRT((xp - xc) ** 2 + (yp - yc) ** 2);
  acp := atan2(yp - yc, xp - xc);
  apc := atan2(yc - yp, xc - xp);
  rmnp := real_min(ritp);
  -- Analyse cases by existence of max distance and direction limits
  IF max_exists(ritp)
  THEN
    rmxp := real_max(ritp);
    IF aitp.max - aitp.min = 2.0 * PI
    THEN
      inn := NOT max_included(aitp);
      a := angle(aitp.min);
      rmax := rc + rmxp;
      rmax_in := max_included(ritp);
      IF inn AND (acp = a)
      THEN
        rmax_in := FALSE;
      END_IF;
      IF rc > rmxp
      THEN
        a0 := ASIN(rmxp / rc);
        amin := angle(acp - a0);
        amin_in := max_included(ritp);
        IF amin = PI
        THEN
          amin := -PI;
        END_IF;
        amax := angle(acp + a0);
        amax_in := amin_in;
        IF amax < amin
        THEN
          amax := amax + 2.0 * PI;
        END_IF;
        rmin := rc - rmxp;
        rmin_in := amin_in;
        IF inn
        THEN
          IF apc = a
          THEN
            rmin_in := FALSE;
          END_IF;
          IF angle(amin + 0.5 * PI) = a
          THEN
            amin_in := FALSE;
          END_IF;
          IF angle(amax - 0.5 * PI) = a
          THEN
            amax_in := FALSE;
          END_IF;
        END_IF;
      ELSE
        IF rc = rmxp
        THEN
          amin := angle(acp - 0.5 * PI);
          amin_in := FALSE;
          IF amin = PI
          THEN
            amin := -PI;
          END_IF;
          amax := angle(acp + 0.5 * PI);
          amax_in := FALSE;
          IF amax < amin
          THEN
            amax := amax + 2.0 * PI;
          END_IF;
          rmin := 0.0;
          rmin_in := max_included(ritp);
          IF inn AND (apc = a)
          THEN
            rmin_in := FALSE;
          END_IF;
        ELSE
          IF rc > rmnp
          THEN
            IF inn AND (apc = a)
            THEN
              rmin := 0.0;
              rmin_in := FALSE;
              amin := aitp.min;
              amin_in := FALSE;
              amax := aitp.max;
              amax_in := FALSE;
            ELSE
              rmin := 0.0;
              rmin_in := TRUE;
              amin := -PI;
              amin_in := FALSE;
              amax := PI;
              amax_in := TRUE;
            END_IF;
          ELSE
            rmin := rmnp - rc;
            rmin_in := min_included(ritp);
            amin := -PI;
            amin_in := FALSE;
            amax := PI;
            amax_in := TRUE;
            IF inn
            THEN
              IF apc = a
              THEN
                rmin_in := FALSE;
                amin := aitp.min;
                amin_in := FALSE;
                amax := aitp.max;
                amax_in := FALSE;
              ELSE
                IF acp = a
                THEN
                  amin := aitp.min;
                  amin_in := FALSE;
                  amax := aitp.max;
                  amax_in := FALSE;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    ELSE
      x := xp + rmxp * COS(aitp.min) - xc;
      y := yp + rmxp * SIN(aitp.min) - yc;
      r0 := SQRT(x ** 2 + y ** 2);
      in0 := max_included(ritp) AND min_included(aitp);
      IF r0 <> 0.0
      THEN
        a0 := atan2(y, x);
      END_IF;
      x := xp + rmxp * COS(aitp.max) - xc;
      y := yp + rmxp * SIN(aitp.max) - yc;
      r1 := SQRT(x ** 2 + y ** 2);
      in1 := max_included(ritp) AND max_included(aitp);
      IF r1 <> 0.0
      THEN
        a1 := atan2(y, x);
      END_IF;
      x := xp + rmnp * COS(aitp.max) - xc;
      y := yp + rmnp * SIN(aitp.max) - yc;
      r2 := SQRT(x ** 2 + y ** 2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 <> 0.0
      THEN
        a2 := atan2(y, x);
      ELSE
        a2 := a1;
        in2 := in1;
      END_IF;
      IF r1 = 0.0
      THEN
        a1 := a2;
        in1 := in2;
      END_IF;
      x := xp + rmnp * COS(aitp.min) - xc;
      y := yp + rmnp * SIN(aitp.min) - yc;
      r3 := SQRT(x ** 2 + y ** 2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 <> 0.0
      THEN
        a3 := atan2(y, x);
      ELSE
        a3 := a0;
        in3 := in0;
      END_IF;
      IF r0 = 0.0
      THEN
        a0 := a3;
        in0 := in3;
      END_IF;
      IF rmnp = 0.0
      THEN
        in2 := min_included(ritp);
        in3 := in2;
      END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min))
      THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE
        IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max))
        THEN
          in1 := max_included(aitp);
          in2 := in1;
        END_IF;
      END_IF;
      IF strictly_in(acp, aitp)
      THEN
        rmax := rc + rmxp;
        rmax_in := max_included(ritp);
      ELSE
        rmax := r0;
        rmax_in := in0;
        IF rmax = r1
        THEN
          rmax_in := rmax_in OR in1;
        END_IF;
        IF rmax < r1
        THEN
          rmax := r1;
          rmax_in := in1;
        END_IF;
        IF rmax = r2
        THEN
          rmax_in := rmax_in OR in2;
        END_IF;
        IF rmax < r2
        THEN
          rmax := r2;
          rmax_in := in2;
        END_IF;
        IF rmax = r3
        THEN
          rmax_in := rmax_in OR in3;
        END_IF;
        IF rmax < r3
        THEN
          rmax := r3;
          rmax_in := in3;
        END_IF;
      END_IF;
      IF strictly_in(apc, aitp)
      THEN
        IF rc >= rmxp
        THEN
          rmin := rc - rmxp;
          rmin_in := max_included(ritp);
        ELSE
          IF rc <= rmnp
          THEN
            rmin := rmnp - rc;
            rmin_in := min_included(ritp);
          ELSE
            rmin := 0.0;
            rmin_in := TRUE;
          END_IF;
        END_IF;
      ELSE
        rmin := r0;
        rmin_in := in0;
        a := apc - aitp.min;
        r := rc * COS(a);
        IF {rmnp < r < rmxp}
        THEN
          rmin := rc * SIN(ABS(a));
          rmin_in := min_included(aitp);
        END_IF;
        a := apc - aitp.max;
        r := rc * COS(a);
        IF {rmnp < r < rmxp}
        THEN
          r := rc * SIN(ABS(a));
          inn := max_included(aitp);
          IF r = rmin
          THEN
            rmin_in := rmin_in OR inn;
          END_IF;
          IF r < rmin
          THEN
            rmin := r;
            rmin_in := inn;
          END_IF;
        END_IF;
        IF r1 = rmin
        THEN
          rmin_in := rmin_in OR in1;
        END_IF;
        IF r1 < rmin
        THEN
          rmin := r1;
          rmin_in := in1;
        END_IF;
        IF r2 = rmin
        THEN
          rmin_in := rmin_in OR in2;
        END_IF;
        IF r2 < rmin
        THEN
          rmin := r2;
          rmin_in := in2;
        END_IF;
        IF r3 = rmin
        THEN
          rmin_in := rmin_in OR in3;
        END_IF;
        IF r3 < rmin
        THEN
          rmin := r3;
          rmin_in := in3;
        END_IF;
      END_IF;
      IF rc >= rmxp
      THEN
        ab := acp;
        find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
        a := ACOS(rmxp / rc);
        IF strictly_in(apc - a, aitp)
        THEN
          amin := ab - ASIN(rmxp / rc);
          amin_in := max_included(ritp);
        END_IF;
        IF strictly_in(apc + a, aitp)
        THEN
          amax := ab + ASIN(rmxp / rc);
          amax_in := max_included(ritp);
        END_IF;
        angle_range(amin, amax);
      ELSE
        IF rc > rmnp
        THEN
          ab := angle(0.5 * (aitp.min + aitp.max));
          find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
        ELSE
          ab := angle(0.5 * (aitp.min + aitp.max));
          a0 := angle(a0 - ab);
          a1 := angle(a1 - ab);
          a2 := angle(a2 - ab);
          a3 := angle(a3 - ab);
          IF a3 > a2
          THEN
            a2 := a2 + 2.0 * PI;
          END_IF;
          IF a0 > a1
          THEN
            a0 := a0 + 2.0 * PI;
          END_IF;
          IF a3 < a0
          THEN
            amin := a3;
            amin_in := in3;
          ELSE
            amin := a0;
            amin_in := in0;
          END_IF;
          IF a2 > a1
          THEN
            amax := a2;
            amax_in := in2;
          ELSE
            amax := a1;
            amax_in := in1;
          END_IF;
          IF (amax - amin > 2.0 * PI) OR ((amax - amin = 2.0 * PI) AND (amin_in OR amax_in))
          THEN
            amin := -PI;
            amin_in := FALSE;
            amax := PI;
            amax_in := TRUE;
          ELSE
            amin := amin + ab;
            amax := amax + ab;
            angle_range(amin, amax);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    IF rmin_in
    THEN
      minclo := closed;
    END_IF;
    IF rmax_in
    THEN
      maxclo := closed;
    END_IF;
    ritv := make_finite_real_interval(rmin, minclo, rmax, maxclo);
  ELSE
    IF (rc > rmnp) AND strictly_in(apc, aitp)
    THEN
      RETURN(?);
    END_IF;
    IF aitp.max - aitp.min = 2.0 * PI
    THEN
      a := angle(aitp.min);
      IF rc > rmnp
      THEN
        IF max_included(aitp)
        THEN
          RETURN(?);
        END_IF;
        rmin := 0.0;
        rmin_in := FALSE;
        amin := aitp.min;
        amin_in := FALSE;
        amax := aitp.max;
        amax_in := FALSE;
      ELSE
        rmin := rmnp - rc;
        rmin_in := min_included(ritp);
        amin := -PI;
        amin_in := FALSE;
        amax := PI;
        amax_in := TRUE;
        IF NOT max_included(aitp)
        THEN
          IF apc = a
          THEN
            rmin_in := FALSE;
            amin := aitp.min;
            amin_in := FALSE;
            amax := aitp.max;
            amax_in := FALSE;
          ELSE
            IF acp = a
            THEN
              amin := aitp.min;
              amin_in := FALSE;
              amax := aitp.max;
              amax_in := FALSE;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    ELSE
      a0 := angle(aitp.min);
      in0 := FALSE;
      a1 := angle(aitp.max);
      in1 := FALSE;
      x := xp + rmnp * COS(aitp.max) - xc;
      y := yp + rmnp * SIN(aitp.max) - yc;
      r2 := SQRT(x ** 2 + y ** 2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 <> 0.0
      THEN
        a2 := atan2(y, x);
      ELSE
        a2 := a1;
        in2 := in1;
      END_IF;
      x := xp + rmnp * COS(aitp.min) - xc;
      y := yp + rmnp * SIN(aitp.min) - yc;
      r3 := SQRT(x ** 2 + y ** 2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 <> 0.0
      THEN
        a3 := atan2(y, x);
      ELSE
        a3 := a0;
        in3 := in0;
      END_IF;
      IF rmnp = 0.0
      THEN
        in2 := min_included(ritp);
        in3 := in2;
      END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min))
      THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE
        IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max))
        THEN
          in1 := max_included(aitp);
          in2 := in1;
        END_IF;
      END_IF;
      IF strictly_in(apc, aitp)
      THEN
        rmin := rmnp - rc;
        rmin_in := min_included(ritp);
      ELSE
        rmin := r2;
        rmin_in := in2;
        a := apc - aitp.min;
        r := rc * COS(a);
        IF rmnp < r
        THEN
          rmin := rc * SIN(ABS(a));
          rmin_in := min_included(aitp);
        END_IF;
        a := apc - aitp.max;
        r := rc * COS(a);
        IF rmnp < r
        THEN
          r := rc * SIN(ABS(a));
          inn := max_included(aitp);
          IF r = rmin
          THEN
            rmin_in := rmin_in OR inn;
          END_IF;
          IF r < rmin
          THEN
            rmin := r;
            rmin_in := inn;
          END_IF;
        END_IF;
        IF r3 = rmin
        THEN
          rmin_in := rmin_in OR in3;
        END_IF;
        IF r3 < rmin
        THEN
          rmin := r3;
          rmin_in := in3;
        END_IF;
      END_IF;
      ab := angle(0.5 * (aitp.min + aitp.max));
      IF rc > rmnp
      THEN
        find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
      ELSE
        a0 := angle(a0 - ab);
        a1 := angle(a1 - ab);
        a2 := angle(a2 - ab);
        a3 := angle(a3 - ab);
        IF a3 > a2
        THEN
          a2 := a2 + 2.0 * PI;
        END_IF;
        IF a0 > a1
        THEN
          a0 := a0 + 2.0 * PI;
        END_IF;
        IF a3 < a0
        THEN
          amin := a3;
          amin_in := in3;
        ELSE
          amin := a0;
          amin_in := in0;
        END_IF;
        IF a2 > a1
        THEN
          amax := a2;
          amax_in := in2;
        ELSE
          amax := a1;
          amax_in := in1;
        END_IF;
        IF (amax - amin > 2.0 * PI) OR ((amax - amin = 2.0 * PI) AND (amin_in OR amax_in))
        THEN
          amin := -PI;
          amin_in := FALSE;
          amax := PI;
          amax_in := TRUE;
          IF (rmin = 0.0) AND rmin_in
          THEN
            RETURN(?);
          END_IF;
        ELSE
          amin := amin + ab;
          amax := amax + ab;
          angle_range(amin, amax);
        END_IF;
      END_IF;
    END_IF;
    IF rmin_in
    THEN
      minclo := closed;
    END_IF;
    ritv := make_real_interval_from_min(rmin, minclo);
  END_IF;
  minclo := open;
  maxclo := open;
  IF amin_in
  THEN
    minclo := closed;
  END_IF;
  IF amax_in
  THEN
    maxclo := closed;
  END_IF;
  aitv := make_finite_real_interval(amin, minclo, amax, maxclo);
  -- Construct polar region
  RETURN(make_polar_complex_number_region(centre, ritv, aitv));
END_FUNCTION;

(* "equal_cregion_pregion" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION equal_cregion_pregion(crgn : cartesian_complex_number_region;
                               prgn : polar_complex_number_region) : LOGICAL;
LOCAL
  arng : REAL;
  amin : REAL;
  xc   : REAL;
  yc   : REAL;
  aitv : real_interval;
  xitv : real_interval;
  yitv : real_interval;
  c_in : BOOLEAN;
END_LOCAL;
  IF NOT EXISTS(crgn) OR NOT EXISTS(prgn)
  THEN
    RETURN(FALSE);
  END_IF;
  IF max_exists(prgn.distance_constraint)
  THEN
    RETURN(FALSE);
  END_IF;
  IF real_min(prgn.distance_constraint) <> 0.0
  THEN
    RETURN(FALSE);
  END_IF;
  c_in := min_included(prgn.distance_constraint);
  aitv := prgn.direction_constraint;
  amin := aitv.min;
  arng := aitv.max - amin;
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  IF arng = 0.5 * PI
  THEN
    IF amin = 0.0
    THEN
      RETURN(NOT max_exists(xitv) AND
                 NOT max_exists(yitv) AND min_exists(xitv) AND min_exists(yitv) AND (real_min(xitv) = xc) AND
                     (real_min(yitv) = yc) AND
                     ((c_in AND min_included(aitv) AND max_included(aitv) AND min_included(xitv) AND
                       min_included(yitv)) OR
                      (NOT c_in AND
                           NOT min_included(aitv) AND max_included(aitv) AND min_included(xitv) AND
                               NOT min_included(yitv)) OR
                      (NOT c_in AND min_included(aitv) AND
                           NOT max_included(aitv) AND NOT min_included(xitv) AND min_included(yitv)) OR
                      (NOT c_in AND
                           NOT min_included(aitv) AND
                               NOT max_included(aitv) AND NOT min_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5 * PI
    THEN
      RETURN(max_exists(xitv) AND
             NOT max_exists(yitv) AND
                 NOT min_exists(xitv) AND min_exists(yitv) AND (real_max(xitv) = xc) AND (real_min(yitv) = yc) AND
                     ((c_in AND min_included(aitv) AND max_included(aitv) AND max_included(xitv) AND
                       min_included(yitv)) OR
                      (NOT c_in AND
                           NOT min_included(aitv) AND max_included(aitv) AND max_included(xitv) AND
                               NOT min_included(yitv)) OR
                      (NOT c_in AND min_included(aitv) AND
                           NOT max_included(aitv) AND NOT max_included(xitv) AND min_included(yitv)) OR
                      (NOT c_in AND
                           NOT min_included(aitv) AND
                               NOT max_included(aitv) AND NOT max_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = -PI
    THEN
      RETURN(max_exists(xitv) AND max_exists(yitv) AND
             NOT min_exists(xitv) AND
                 NOT min_exists(yitv) AND (real_max(xitv) = xc) AND (real_max(yitv) = yc) AND
                     ((c_in AND min_included(aitv) AND max_included(aitv) AND max_included(xitv) AND
                       max_included(yitv)) OR
                      (NOT c_in AND
                           NOT min_included(aitv) AND max_included(aitv) AND max_included(xitv) AND
                               NOT max_included(yitv)) OR
                      (NOT c_in AND min_included(aitv) AND
                           NOT max_included(aitv) AND NOT max_included(xitv) AND max_included(yitv)) OR
                      (NOT c_in AND
                           NOT min_included(aitv) AND
                               NOT max_included(aitv) AND NOT max_included(xitv) AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5 * PI
    THEN
      RETURN(NOT max_exists(xitv) AND max_exists(yitv) AND min_exists(xitv) AND
                 NOT min_exists(yitv) AND (real_min(xitv) = xc) AND (real_max(yitv) = yc) AND
                     ((c_in AND min_included(aitv) AND max_included(aitv) AND min_included(xitv) AND
                       max_included(yitv)) OR
                      (NOT c_in AND
                           NOT min_included(aitv) AND max_included(aitv) AND min_included(xitv) AND
                               NOT max_included(yitv)) OR
                      (NOT c_in AND min_included(aitv) AND
                           NOT max_included(aitv) AND NOT min_included(xitv) AND max_included(yitv)) OR
                      (NOT c_in AND
                           NOT min_included(aitv) AND
                               NOT max_included(aitv) AND NOT min_included(xitv) AND NOT max_included(yitv))));
    END_IF;
  END_IF;
  IF arng = PI
  THEN
    IF amin = 0.0
    THEN
      RETURN(NOT max_exists(xitv) AND
                 NOT max_exists(yitv) AND
                     NOT min_exists(xitv) AND min_exists(yitv) AND (real_min(yitv) = yc) AND
                         ((c_in AND min_included(aitv) AND max_included(aitv) AND min_included(yitv)) OR
                          (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5 * PI
    THEN
      RETURN(max_exists(xitv) AND
             NOT max_exists(yitv) AND
                 NOT min_exists(xitv) AND
                     NOT min_exists(yitv) AND (real_max(xitv) = xc) AND
                         ((c_in AND min_included(aitv) AND max_included(aitv) AND max_included(xitv)) OR
                          (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT max_included(xitv))));
    END_IF;
    IF amin = -PI
    THEN
      RETURN(NOT max_exists(xitv) AND max_exists(yitv) AND
                 NOT min_exists(xitv) AND
                     NOT min_exists(yitv) AND (real_max(yitv) = yc) AND
                         ((c_in AND min_included(aitv) AND max_included(aitv) AND max_included(yitv)) OR
                          (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5 * PI
    THEN
      RETURN(NOT max_exists(xitv) AND
                 NOT max_exists(yitv) AND min_exists(xitv) AND
                     NOT min_exists(yitv) AND (real_min(xitv) = xc) AND
                         ((c_in AND min_included(aitv) AND max_included(aitv) AND min_included(xitv)) OR
                          (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT min_included(xitv))));
    END_IF;
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "equal_maths_functions" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION equal_maths_functions(fun1 : maths_function;
                               fun2 : maths_function) : LOGICAL;
LOCAL
  cum : LOGICAL;
END_LOCAL;
  IF fun1 = fun2
  THEN
    RETURN(TRUE);
  END_IF;
  cum := equal_maths_spaces(fun1.domain, fun2.domain);
  IF cum = FALSE
  THEN
    RETURN(FALSE);
  END_IF;
  cum := cum AND equal_maths_spaces(fun1.range, fun2.range);
  IF cum = FALSE
  THEN
    RETURN(FALSE);
  END_IF;
  -- A lot of further analysis is possible, but not required.
  RETURN(UNKNOWN);
END_FUNCTION;

(* "equal_maths_spaces" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION equal_maths_spaces(spc1 : maths_space;
                            spc2 : maths_space) : LOGICAL;
LOCAL
  spc1types : SET OF STRING       := stripped_typeof(spc1);
  spc2types : SET OF STRING       := stripped_typeof(spc2);
  set1      : SET OF maths_value;
  set2      : SET OF maths_value;
  cum       : LOGICAL             := TRUE;
  base      : maths_space;
  expnt     : INTEGER;
  factors   : LIST OF maths_space;
  factors2  : LIST OF maths_space;
  fs1       : function_space;
  fs2       : function_space;
  cum2      : LOGICAL;
END_LOCAL;
  IF spc1 = spc2
  THEN
    RETURN(TRUE);
  END_IF;
  -- Consider cases where it is not yet certain that spc1 <> spc2.
  IF 'FINITE_SPACE' IN spc1types
  THEN
    set1 := spc1\finite_space.members;
    IF 'FINITE_SPACE' IN spc2types
    THEN
      set2 := spc2\finite_space.members;
      REPEAT i := 1 TO SIZEOF(set1);
        cum := cum AND member_of(set1[i], spc2);
        IF cum = FALSE
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      IF cum = TRUE
      THEN
        REPEAT i := 1 TO SIZEOF(set2);
          cum := cum AND member_of(set2[i], spc1);
          IF cum = FALSE
          THEN
            RETURN(FALSE);
          END_IF;
        END_REPEAT;
      END_IF;
      RETURN(cum);
    END_IF;
    IF 'FINITE_INTEGER_INTERVAL' IN spc2types
    THEN
      set2 := [];
      REPEAT i := spc2\finite_integer_interval.min TO spc2\finite_integer_interval.max;
        set2 := set2 + [i];
      END_REPEAT;
      RETURN(equal_maths_spaces(spc1, make_finite_space(set2)));
    END_IF;
  END_IF;
  IF ('FINITE_INTEGER_INTERVAL' IN spc1types) AND ('FINITE_SPACE' IN spc2types)
  THEN
    set1 := [];
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      set1 := set1 + [i];
    END_REPEAT;
    RETURN(equal_maths_spaces(make_finite_space(set1), spc2));
  END_IF;
  IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc1types) AND ('POLAR_COMPLEX_NUMBER_REGION' IN spc2types)
  THEN
    RETURN(equal_cregion_pregion(spc1, spc2));
  END_IF;
  IF ('POLAR_COMPLEX_NUMBER_REGION' IN spc1types) AND ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc2types)
  THEN
    RETURN(equal_cregion_pregion(spc2, spc1));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN spc1types
  THEN
    base := spc1\uniform_product_space.base;
    expnt := spc1\uniform_product_space.exponent;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types
    THEN
      IF expnt <> spc2\uniform_product_space.exponent
      THEN
        RETURN(FALSE);
      END_IF;
      RETURN(equal_maths_spaces(base, spc2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types
    THEN
      factors := spc2\listed_product_space.factors;
      IF expnt <> SIZEOF(factors)
      THEN
        RETURN(FALSE);
      END_IF;
      REPEAT i := 1 TO SIZEOF(factors);
        cum := cum AND equal_maths_spaces(base, factors[i]);
        IF cum = FALSE
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(cum);
    END_IF;
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN spc1types
  THEN
    factors := spc1\listed_product_space.factors;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types
    THEN
      IF spc2\uniform_product_space.exponent <> SIZEOF(factors)
      THEN
        RETURN(FALSE);
      END_IF;
      base := spc2\uniform_product_space.base;
      REPEAT i := 1 TO SIZEOF(factors);
        cum := cum AND equal_maths_spaces(base, factors[i]);
        IF cum = FALSE
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(cum);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types
    THEN
      factors2 := spc2\listed_product_space.factors;
      IF SIZEOF(factors) <> SIZEOF(factors2)
      THEN
        RETURN(FALSE);
      END_IF;
      REPEAT i := 1 TO SIZEOF(factors);
        cum := cum AND equal_maths_spaces(factors[i], factors2[i]);
        IF cum = FALSE
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(cum);
    END_IF;
  END_IF;
  IF ('EXTENDED_TUPLE_SPACE' IN spc1types) AND ('EXTENDED_TUPLE_SPACE' IN spc2types)
  THEN
    RETURN(equal_maths_spaces(spc1\extended_tuple_space.extender, spc2\extended_tuple_space.extender) AND
           equal_maths_spaces(spc1\extended_tuple_space.base, spc2\extended_tuple_space.base));
  END_IF;
  IF ('FUNCTION_SPACE' IN spc1types) AND ('FUNCTION_SPACE' IN spc2types)
  THEN
    fs1 := spc1;
    fs2 := spc2;
    IF fs1.domain_constraint <> fs2.domain_constraint
    THEN
      IF (fs1.domain_constraint = sc_equal) OR (fs2.domain_constraint = sc_equal)
      THEN
        RETURN(FALSE);
      END_IF;
      IF (fs1.domain_constraint <> sc_subspace)
      THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.domain_constraint <> sc_subspace) OR (fs2.domain_constraint <> sc_member)
      THEN
        RETURN(UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.domain_constraint, fs1.domain_argument) <>
         any_space_satisfies(fs2.domain_constraint, fs2.domain_argument)
      THEN
        RETURN(FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.domain_argument))
      THEN
        RETURN(FALSE);
      END_IF;
      IF SIZEOF(['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] * stripped_typeof(fs1.domain_argument)) = 0
      THEN
        RETURN(FALSE);
      END_IF;
      RETURN(UNKNOWN);
    END_IF;
    cum := equal_maths_spaces(fs1.domain_argument, fs2.domain_argument);
    IF cum = FALSE
    THEN
      RETURN(FALSE);
    END_IF;
    IF fs1.range_constraint <> fs2.range_constraint
    THEN
      IF (fs1.range_constraint = sc_equal) OR (fs2.range_constraint = sc_equal)
      THEN
        RETURN(FALSE);
      END_IF;
      IF (fs1.range_constraint <> sc_subspace)
      THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.range_constraint <> sc_subspace) OR (fs2.range_constraint <> sc_member)
      THEN
        RETURN(UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.range_constraint, fs1.range_argument) <>
         any_space_satisfies(fs2.range_constraint, fs2.range_argument)
      THEN
        RETURN(FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.range_argument))
      THEN
        RETURN(FALSE);
      END_IF;
      IF SIZEOF(['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] * stripped_typeof(fs1.range_argument)) = 0
      THEN
        RETURN(FALSE);
      END_IF;
      RETURN(UNKNOWN);
    END_IF;
    cum := cum AND equal_maths_spaces(fs1.range_argument, fs2.range_argument);
    RETURN(cum);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "equal_maths_values" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION equal_maths_values(val1 : maths_value;
                            val2 : maths_value) : LOGICAL;
FUNCTION mem_of_vs(val1 : maths_value;
                   val2 : maths_value) : LOGICAL;
  IF NOT has_values_space(val2)
  THEN
    RETURN(UNKNOWN);
  END_IF;
  IF NOT member_of(val1, values_space_of(val2))
  THEN
    RETURN(FALSE);
  END_IF;
  RETURN(UNKNOWN);
END_FUNCTION;
LOCAL
  types1 : SET OF STRING;
  types2 : SET OF STRING;
  list1  : LIST OF maths_value;
  list2  : LIST OF maths_value;
  cum    : LOGICAL             := TRUE;
END_LOCAL;
  IF NOT EXISTS(val1) OR NOT EXISTS(val2)
  THEN
    RETURN(FALSE);
  END_IF;
  IF val1 = val2
  THEN
    RETURN(TRUE);
  END_IF;
  types1 := stripped_typeof(val1);
  types2 := stripped_typeof(val2);
  IF ('MATHS_ATOM' IN types1) OR ('COMPLEX_NUMBER_LITERAL' IN types1)
  THEN
    IF 'MATHS_ATOM' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'COMPLEX_NUMBER_LITERAL' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'LIST' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'MATHS_SPACE' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'MATHS_FUNCTION' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2
    THEN
      RETURN(mem_of_vs(val1, val2));
    END_IF;
    RETURN(UNKNOWN);
  END_IF;
  IF ('MATHS_ATOM' IN types2) OR ('COMPLEX_NUMBER_LITERAL' IN types2)
  THEN
    RETURN(equal_maths_values(val2, val1));
  END_IF;
  IF 'LIST' IN types1
  THEN
    IF 'LIST' IN types2
    THEN
      list1 := val1;
      list2 := val2;
      IF SIZEOF(list1) <> SIZEOF(list2)
      THEN
        RETURN(FALSE);
      END_IF;
      REPEAT i := 1 TO SIZEOF(list1);
        cum := cum AND equal_maths_values(list1[i], list2[i]);
        IF cum = FALSE
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(cum);
    END_IF;
    IF 'MATHS_SPACE' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'MATHS_FUNCTION' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2
    THEN
      RETURN(mem_of_vs(val1, val2));
    END_IF;
    RETURN(UNKNOWN);
  END_IF;
  IF 'LIST' IN types2
  THEN
    RETURN(equal_maths_values(val2, val1));
  END_IF;
  IF 'MATHS_SPACE' IN types1
  THEN
    IF 'MATHS_SPACE' IN types2
    THEN
      RETURN(equal_maths_spaces(val1, val2));
    END_IF;
    IF 'MATHS_FUNCTION' IN types2
    THEN
      RETURN(FALSE);
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2
    THEN
      RETURN(mem_of_vs(val1, val2));
    END_IF;
    RETURN(UNKNOWN);
  END_IF;
  IF 'MATHS_SPACE' IN types2
  THEN
    RETURN(equal_maths_values(val2, val1));
  END_IF;
  IF 'MATHS_FUNCTION' IN types1
  THEN
    IF 'MATHS_FUNCTION' IN types2
    THEN
      RETURN(equal_maths_functions(val1, val2));
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2
    THEN
      RETURN(mem_of_vs(val1, val2));
    END_IF;
    RETURN(UNKNOWN);
  END_IF;
  IF 'MATHS_FUNCTION' IN types2
  THEN
    RETURN(equal_maths_values(val2, val1));
  END_IF;
  IF ('GENERIC_EXPRESSION' IN types1) AND ('GENERIC_EXPRESSION' IN types2)
  THEN
    IF NOT has_values_space(val1) OR NOT has_values_space(val2)
    THEN
      RETURN(UNKNOWN);
    END_IF;
    IF NOT compatible_spaces(values_space_of(val1), values_space_of(val2))
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  RETURN(UNKNOWN);
END_FUNCTION;

(* "es_subspace_of_es" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION es_subspace_of_es(es1 : elementary_space_enumerators;
                           es2 : elementary_space_enumerators) : BOOLEAN;
  IF NOT EXISTS(es1) OR NOT EXISTS(es2)
  THEN
    RETURN(FALSE);
  END_IF;
  IF es1 = es2
  THEN
    RETURN(TRUE);
  END_IF;
  IF es2 = es_generics
  THEN
    RETURN(TRUE);
  END_IF;
  IF (es1 = es_booleans) AND (es2 = es_logicals)
  THEN
    RETURN(TRUE);
  END_IF;
  IF (es2 = es_numbers) AND ((es1 = es_complex_numbers) OR (es1 = es_reals) OR (es1 = es_integers))
  THEN
    RETURN(TRUE);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "expression_is_constant" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION expression_is_constant(expr : generic_expression) : BOOLEAN;
  RETURN(bool(SIZEOF(free_variables_of(expr)) = 0));
END_FUNCTION;

(* "external_version_assignment_is_valid" IMPLICIT from SCHEMA external_properties_mim *)
FUNCTION external_version_assignment_is_valid(aia : applied_external_identification_assignment) : BOOLEAN;
LOCAL
  item : external_identification_item;
  role : identification_role;
END_LOCAL;
  role := aia.role;
  IF role.name = 'version'
  THEN
    REPEAT i := LOINDEX(aia\applied_external_identification_assignment.items) TO HIINDEX(aia\applied_external_identification_assignment.items);
      item := aia\applied_external_identification_assignment.items[i];
      IF (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EXTERNALLY_DEFINED_GENERAL_PROPERTY'] *
                 TYPEOF(item)) =
          0)
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);
  ELSE
    RETURN(TRUE);
  END_IF;
END_FUNCTION;

(* "extract_factors" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION extract_factors(tspace : tuple_space;
                         m : INTEGER;
                         n : INTEGER) : tuple_space;
LOCAL
  tsp : tuple_space := the_zero_tuple_space;
END_LOCAL;
  REPEAT i := m TO n;
    tsp := assoc_product_space(tsp, factor_space(tspace, i));
  END_REPEAT;
  RETURN(tsp);
END_FUNCTION;

(* "extremal_position_check" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION extremal_position_check(fun : linearized_table_function) : BOOLEAN;
LOCAL
  source_domain   : maths_space;
  source_interval : finite_integer_interval;
  index           : INTEGER                  := 1;
  base            : INTEGER;
  shape           : LIST OF positive_integer;
  ndim            : positive_integer;
  slo             : INTEGER;
  shi             : INTEGER;
  sublo           : LIST OF INTEGER          := [];
  subhi           : LIST OF INTEGER          := [];
END_LOCAL;
  IF NOT EXISTS(fun)
  THEN
    RETURN(FALSE);
  END_IF;
  source_domain := factor1(fun.source.domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF(source_domain)
  THEN
    source_domain := factor1(source_domain);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(source_domain))
  THEN
    RETURN(FALSE);
  END_IF;
  source_interval := source_domain;
  base := fun\explicit_table_function.index_base;
  shape := fun\explicit_table_function.shape;
  IF (schema_prefix + 'STANDARD_TABLE_FUNCTION') IN TYPEOF(fun)
  THEN
    REPEAT j := 1 TO SIZEOF(shape);
      index := index * shape[j];
    END_REPEAT;
    index := fun.first + index - 1;
    RETURN(bool({source_interval.min <= index <= source_interval.max}));
  END_IF;
  IF (schema_prefix + 'REGULAR_TABLE_FUNCTION') IN TYPEOF(fun)
  THEN
    ndim := SIZEOF(fun\explicit_table_function.shape);
    REPEAT j := 1 TO ndim;
      slo := base;
      shi := base + shape[j] - 1;
      IF fun\regular_table_function.increments[j] >= 0
      THEN
        INSERT(sublo, slo, j - 1);
        INSERT(subhi, shi, j - 1);
      ELSE
        INSERT(sublo, shi, j - 1);
        INSERT(subhi, slo, j - 1);
      END_IF;
    END_REPEAT;
    index := regular_indexing(sublo, base, shape, fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min <= index <= source_interval.max})
    THEN
      RETURN(FALSE);
    END_IF;
    index := regular_indexing(subhi, base, shape, fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min <= index <= source_interval.max})
    THEN
      RETURN(FALSE);
    END_IF;
    RETURN(TRUE);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "face_bound_reversed" IMPLICIT from SCHEMA topology_schema *)
FUNCTION face_bound_reversed(a_face_bound : face_bound) : face_bound;
LOCAL
  the_reverse : face_bound;
END_LOCAL;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound))
  THEN
    the_reverse := dummy_tri || face_bound(a_face_bound\face_bound.bound, NOT (a_face_bound\face_bound.orientation)) ||
                   face_outer_bound();
  ELSE
    the_reverse := dummy_tri || face_bound(a_face_bound.bound, NOT (a_face_bound.orientation));
  END_IF;
  RETURN(the_reverse);
END_FUNCTION;

(* "face_reversed" IMPLICIT from SCHEMA topology_schema *)
FUNCTION face_reversed(a_face : face) : oriented_face;
LOCAL
  the_reverse : oriented_face;
END_LOCAL;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ORIENTED_FACE' IN TYPEOF(a_face))
  THEN
    the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.bounds)) ||
                   oriented_face(a_face\oriented_face.face_element, NOT (a_face\oriented_face.orientation));
  ELSE
    the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.bounds)) || oriented_face(a_face, FALSE);
  END_IF;
  RETURN(the_reverse);
END_FUNCTION;

(* "factor_space" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION factor_space(tspace : tuple_space;
                      idx : positive_integer) : maths_space;
LOCAL
  typenames : SET OF STRING := TYPEOF(tspace);
END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames
  THEN
    IF idx <= tspace\uniform_product_space.exponent
    THEN
      RETURN(tspace\uniform_product_space.base);
    END_IF;
    RETURN(?);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames
  THEN
    IF idx <= SIZEOF(tspace\listed_product_space.factors)
    THEN
      RETURN(tspace\listed_product_space.factors[idx]);
    END_IF;
    RETURN(?);
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames
  THEN
    IF idx <= space_dimension(tspace\extended_tuple_space.base)
    THEN
      RETURN(factor_space(tspace\extended_tuple_space.base, idx));
    END_IF;
    RETURN(tspace\extended_tuple_space.extender);
  END_IF;
  -- Should not be reachable.
  RETURN(?);
END_FUNCTION;

(* "factor1" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION factor1(tspace : tuple_space) : maths_space;
LOCAL
  typenames : SET OF STRING := TYPEOF(tspace);
END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames
  THEN
    RETURN(tspace\uniform_product_space.base);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames
  THEN
    RETURN(tspace\listed_product_space.factors[1]);
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames
  THEN
    RETURN(factor1(tspace\extended_tuple_space.base));
  END_IF;
  -- Should not be reachable.
  RETURN(?);
END_FUNCTION;

(* "first_proj_axis" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION first_proj_axis(z_axis : direction;
                         arg : direction) : direction;
LOCAL
  x_axis : direction;
  v      : direction;
  z      : direction;
  x_vec  : vector;
END_LOCAL;
  IF (NOT EXISTS(z_axis))
  THEN
    RETURN(?);
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg)
    THEN
      IF ((z.direction_ratios <> [1.0,0.0,0.0]) AND (z.direction_ratios <> [-1.0,0.0,0.0]))
      THEN
        v := dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF (arg.dim <> 3)
      THEN
        RETURN(?);
      END_IF;
      IF ((cross_product(arg, z).magnitude) = 0.0)
      THEN
        RETURN(?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);
END_FUNCTION;

(* "free_variables_of" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION free_variables_of(expr : generic_expression) : SET OF generic_variable;
LOCAL
  typenames : SET OF STRING              := stripped_typeof(expr);
  result    : SET OF generic_variable    := [];
  exprs     : LIST OF generic_expression := [];
END_LOCAL;
  IF 'GENERIC_LITERAL' IN typenames
  THEN
    RETURN(result);
  END_IF;
  IF 'GENERIC_VARIABLE' IN typenames
  THEN
    result := result + expr;
    RETURN(result);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN typenames
  THEN
    exprs := QUERY(ge
                   <* expr\multiple_arity_generic_expression.operands
                   | NOT (ge IN expr\quantifier_expression.variables));
    REPEAT i := 1 TO SIZEOF(exprs);
      result := result + free_variables_of(exprs[i]);
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(expr\quantifier_expression.variables);
      result := result - expr\quantifier_expression.variables[i];
    END_REPEAT;
    RETURN(result);
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN typenames
  THEN
    RETURN(free_variables_of(expr\unary_generic_expression.operand));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN typenames
  THEN
    result := free_variables_of(expr\binary_generic_expression.operands[1]);
    RETURN(result + free_variables_of(expr\binary_generic_expression.operands[2]));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN typenames
  THEN
    REPEAT i := 1 TO SIZEOF(expr\multiple_arity_generic_expression.operands);
      result := result + free_variables_of(expr\multiple_arity_generic_expression.operands[i]);
    END_REPEAT;
    RETURN(result);
  END_IF;
  -- In this case the subtype shall not contain any variable (see IP1 in
  -- generic_expression).
  RETURN(result);
END_FUNCTION;

(* "function_applicability" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION function_applicability(func : maths_function_select;
                                arguments : LIST [1 : ?] OF maths_value) : BOOLEAN;
LOCAL
  domain       : tuple_space        := convert_to_maths_function(func).domain;
  domain_types : SET OF STRING      := TYPEOF(domain);
  narg         : positive_integer   := SIZEOF(arguments);
  arg          : generic_expression;
END_LOCAL;
  IF (schema_prefix + 'PRODUCT_SPACE') IN domain_types
  THEN
    IF space_dimension(domain) <> narg
    THEN
      RETURN(FALSE);
    END_IF;
  ELSE
    IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN domain_types
    THEN
      IF space_dimension(domain) > narg
      THEN
        RETURN(FALSE);
      END_IF;
    ELSE
      RETURN(FALSE);
    END_IF;
  END_IF;
  REPEAT i := 1 TO narg;
    arg := convert_to_operand(arguments[i]);
    IF NOT has_values_space(arg)
    THEN
      RETURN(FALSE);
    END_IF;
    IF NOT compatible_spaces(factor_space(domain, i), values_space_of(arg))
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "function_is_1d_array" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION function_is_1d_array(func : maths_function) : BOOLEAN;
LOCAL
  temp : maths_space;
END_LOCAL;
  IF NOT EXISTS(func)
  THEN
    RETURN(FALSE);
  END_IF;
  IF space_dimension(func.domain) <> 1
  THEN
    RETURN(FALSE);
  END_IF;
  temp := factor1(func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF(temp)
  THEN
    IF space_dimension(temp) <> 1
    THEN
      RETURN(FALSE);
    END_IF;
    temp := factor1(temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp)
  THEN
    RETURN(TRUE);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "function_is_1d_table" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION function_is_1d_table(func : maths_function) : BOOLEAN;
LOCAL
  temp : maths_space;
  itvl : finite_integer_interval;
END_LOCAL;
  IF NOT EXISTS(func)
  THEN
    RETURN(FALSE);
  END_IF;
  IF space_dimension(func.domain) <> 1
  THEN
    RETURN(FALSE);
  END_IF;
  temp := factor1(func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF(temp)
  THEN
    IF space_dimension(temp) <> 1
    THEN
      RETURN(FALSE);
    END_IF;
    temp := factor1(temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp)
  THEN
    itvl := temp;
    RETURN(bool((itvl.min = 0) OR (itvl.min = 1)));
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "function_is_2d_table" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION function_is_2d_table(func : maths_function) : BOOLEAN;
LOCAL
  temp   : maths_space;
  pspace : product_space;
  itvl1  : finite_integer_interval;
  itvl2  : finite_integer_interval;
END_LOCAL;
  IF NOT EXISTS(func)
  THEN
    RETURN(FALSE);
  END_IF;
  IF space_dimension(func.domain) <> 1
  THEN
    RETURN(FALSE);
  END_IF;
  temp := factor1(func.domain);
  IF NOT ('PRODUCT_SPACE' IN stripped_typeof(temp))
  THEN
    RETURN(FALSE);
  END_IF;
  pspace := temp;
  IF space_dimension(pspace) <> 2
  THEN
    RETURN(FALSE);
  END_IF;
  temp := factor1(pspace);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp))
  THEN
    RETURN(FALSE);
  END_IF;
  itvl1 := temp;
  temp := factor_space(pspace, 2);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp))
  THEN
    RETURN(FALSE);
  END_IF;
  itvl2 := temp;
  RETURN(bool((itvl1.min = itvl2.min) AND ((itvl1.min = 0) OR (itvl1.min = 1))));
END_FUNCTION;

(* "function_is_array" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION function_is_array(func : maths_function) : BOOLEAN;
LOCAL
  tspace : tuple_space;
  temp   : maths_space;
END_LOCAL;
  IF NOT EXISTS(func)
  THEN
    RETURN(FALSE);
  END_IF;
  tspace := func.domain;
  IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(tspace)))
  THEN
    tspace := factor1(tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF(tspace))
  THEN
    RETURN(FALSE);
  END_IF;
  REPEAT i := 1 TO space_dimension(tspace);
    temp := factor_space(tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "function_is_table" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION function_is_table(func : maths_function) : BOOLEAN;
LOCAL
  tspace : tuple_space;
  temp   : maths_space;
  base   : INTEGER;
END_LOCAL;
  IF NOT EXISTS(func)
  THEN
    RETURN(FALSE);
  END_IF;
  tspace := func.domain;
  IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(tspace)))
  THEN
    tspace := factor1(tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF(tspace))
  THEN
    RETURN(FALSE);
  END_IF;
  temp := factor1(tspace);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
  THEN
    RETURN(FALSE);
  END_IF;
  base := temp\finite_integer_interval.min;
  IF (base <> 0) AND (base <> 1)
  THEN
    RETURN(FALSE);
  END_IF;
  REPEAT i := 2 TO space_dimension(tspace);
    temp := factor_space(tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
    THEN
      RETURN(FALSE);
    END_IF;
    IF temp\finite_integer_interval.min <> base
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "gbsf_check_curve" IMPLICIT from SCHEMA aic_geometrically_bounded_surface *)
FUNCTION gbsf_check_curve(cv : representation_item) : BOOLEAN;
  IF SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BOUNDED_CURVE',
             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONIC',
             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE_REPLICA',
             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LINE',
             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OFFSET_CURVE_3D'] *
            TYPEOF(cv)) >
     1
  THEN
    RETURN(FALSE);
  END_IF;
  IF SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CIRCLE',
             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ELLIPSE',
             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TRIMMED_CURVE'] *
            TYPEOF(cv)) =
     1
  THEN
    RETURN(TRUE);
  ELSE
    IF (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.B_SPLINE_CURVE' IN TYPEOF(cv)) AND
        (cv\b_spline_curve.self_intersect = FALSE) OR
        (cv\b_spline_curve.self_intersect = UNKNOWN))
    THEN
      RETURN(TRUE);
    ELSE
      IF (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.COMPOSITE_CURVE' IN TYPEOF(cv)) AND
          (cv\composite_curve.self_intersect = FALSE) OR
          (cv\composite_curve.self_intersect = UNKNOWN))
      THEN
        RETURN(SIZEOF(QUERY(seg <* cv\composite_curve.segments | NOT (gbsf_check_curve(seg.parent_curve)))) = 0);
      ELSE
        IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE_REPLICA' IN TYPEOF(cv)
        THEN
          RETURN(gbsf_check_curve(cv\curve_replica.parent_curve));
        ELSE
          IF (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND
              ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\offset_curve_3d.self_intersect = UNKNOWN)) AND
              (NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLYLINE' IN
                    TYPEOF(cv\offset_curve_3d.basis_curve))))
          THEN
            RETURN(gbsf_check_curve(cv\offset_curve_3d.basis_curve));
          ELSE
            IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PCURVE' IN TYPEOF(cv)
            THEN
              RETURN((gbsf_check_curve(cv\pcurve.reference_to_curve\representation.items[1])) AND
                     (gbsf_check_surface(cv\pcurve.basis_surface)));
            ELSE
              IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLYLINE' IN TYPEOF(cv)
              THEN
                IF (SIZEOF(cv\polyline.points) >= 3)
                THEN
                  RETURN(TRUE);
                END_IF;
              ELSE
                IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_CURVE' IN TYPEOF(cv)
                THEN
                  IF gbsf_check_curve(cv\surface_curve.curve_3d)
                  THEN
                    REPEAT i := 1 TO SIZEOF(cv\surface_curve.associated_geometry);
                      IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE' IN
                         TYPEOF(cv\surface_curve.associated_geometry[i])
                      THEN
                        IF NOT gbsf_check_surface(cv\surface_curve.associated_geometry[i])
                        THEN
                          RETURN(FALSE);
                        END_IF;
                      ELSE
                        IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PCURVE' IN
                           TYPEOF(cv\surface_curve.associated_geometry[i])
                        THEN
                          IF NOT gbsf_check_curve(cv\surface_curve.associated_geometry[i])
                          THEN
                            RETURN(FALSE);
                          END_IF;
                        END_IF;
                      END_IF;
                    END_REPEAT;
                    RETURN(TRUE);
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "gbsf_check_point" IMPLICIT from SCHEMA aic_geometrically_bounded_surface *)
FUNCTION gbsf_check_point(pnt : point) : BOOLEAN;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CARTESIAN_POINT' IN TYPEOF(pnt)
  THEN
    RETURN(TRUE);
  ELSE
    IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT_ON_CURVE' IN TYPEOF(pnt)
    THEN
      RETURN(gbsf_check_curve(pnt\point_on_curve.basis_curve));
    ELSE
      IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT_ON_SURFACE' IN TYPEOF(pnt)
      THEN
        RETURN(gbsf_check_surface(pnt\point_on_surface.basis_surface));
      ELSE
        IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DEGENERATE_PCURVE' IN TYPEOF(pnt)
        THEN
          RETURN((gbsf_check_curve(pnt\degenerate_pcurve.reference_to_curve\representation.items[1])) AND
                 (gbsf_check_surface(pnt\degenerate_pcurve.basis_surface)));
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "gbsf_check_surface" IMPLICIT from SCHEMA aic_geometrically_bounded_surface *)
FUNCTION gbsf_check_surface(sf : surface) : BOOLEAN;
  IF (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF(sf)) AND
      (sf\b_spline_surface.self_intersect = FALSE) OR
      (sf\b_spline_surface.self_intersect = UNKNOWN))
  THEN
    RETURN(TRUE);
  ELSE
    IF SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SPHERICAL_SURFACE',
               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TOROIDAL_SURFACE',
               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE_BOUNDED_SURFACE',
               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.RECTANGULAR_TRIMMED_SURFACE'] *
              TYPEOF(sf)) =
       1
    THEN
      RETURN(TRUE);
    ELSE
      IF (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OFFSET_SURFACE' IN TYPEOF(sf)) AND
          (sf\offset_surface.self_intersect = FALSE) OR
          (sf\offset_surface.self_intersect = UNKNOWN))
      THEN
        RETURN(gbsf_check_surface(sf\offset_surface.basis_surface));
      ELSE
        IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.RECTANGULAR_COMPOSITE_SURFACE' IN TYPEOF(sf)
        THEN
          REPEAT i := 1 TO SIZEOF(sf\rectangular_composite_surface.segments);
            REPEAT j := 1 TO SIZEOF(sf\rectangular_composite_surface.segments[i]);
              IF NOT (gbsf_check_surface(sf\rectangular_composite_surface.segments[i][j].parent_surface))
              THEN
                RETURN(FALSE);
              END_IF;
            END_REPEAT;
          END_REPEAT;
          RETURN(TRUE);
        ELSE
          IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_REPLICA' IN TYPEOF(sf)
          THEN
            RETURN(gbsf_check_surface(sf\surface_replica.parent_surface));
          ELSE
            IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_OF_REVOLUTION' IN TYPEOF(sf)
            THEN
              RETURN(gbsf_check_curve(sf\swept_surface.swept_curve));
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "geometric_dimensionalities_in_contexts" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION geometric_dimensionalities_in_contexts(grcs : SET [1 : ?] OF geometric_representation_context) : INTEGER;
LOCAL
  grcs_1d : INTEGER := 0;
  grcs_2d : INTEGER := 0;
  grcs_3d : INTEGER := 0;
END_LOCAL;
  IF (SIZEOF(grcs) = 1)
  THEN
    RETURN(grcs[1]\geometric_representation_context.coordinate_space_dimension);
  ELSE
    REPEAT i := 1 TO HIINDEX(grcs);
      IF (grcs[i]\geometric_representation_context.coordinate_space_dimension = 1)
      THEN
        grcs_1d := grcs_1d + 1;
      ELSE
        IF (grcs[i]\geometric_representation_context.coordinate_space_dimension = 2)
        THEN
          grcs_2d := grcs_2d + 1;
        ELSE
          IF (grcs[i]\geometric_representation_context.coordinate_space_dimension = 3)
          THEN
            grcs_3d := grcs_3d + 1;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
  END_IF;
  IF (grcs_1d + grcs_2d = 0)
  THEN
    RETURN(3);
  ELSE
    IF (grcs_1d + grcs_3d = 0)
    THEN
      RETURN(2);
    ELSE
      IF (grcs_2d + grcs_3d = 0)
      THEN
        RETURN(1);
      ELSE
        RETURN(0);
      END_IF;
    END_IF;
  END_IF;
END_FUNCTION;

(* "get_aggregate_id_value" IMPLICIT from SCHEMA basic_attribute_schema *)
FUNCTION get_aggregate_id_value(obj : id_attribute_select) : identifier;
LOCAL
  aggregate_id_bag : BAG OF aggregate_id_attribute := (USEDIN(obj,
                                                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AGGREGATE_ID_ATTRIBUTE.IDENTIFIED_ITEM'));
END_LOCAL;
  IF SIZEOF(aggregate_id_bag) = 1
  THEN
    RETURN(aggregate_id_bag[1].attribute_value);
  ELSE
    RETURN(?);
  END_IF;
END_FUNCTION;

(* "get_basis_surface" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION get_basis_surface(c : curve_on_surface) : SET [0 : 2] OF surface;
LOCAL
  surfs : SET [0 : 2] OF surface;
  n     : INTEGER;
END_LOCAL;
  surfs := [];
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PCURVE' IN TYPEOF(c)
  THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_CURVE' IN TYPEOF(c)
    THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n;
        surfs := surfs + associated_surface(c\surface_curve.associated_geometry[i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c)
  THEN
    n := SIZEOF(c\composite_curve.segments);
    surfs := get_basis_surface(c\composite_curve.segments[1].parent_curve);
    IF n > 1
    THEN
      REPEAT i := 2 TO n;
        surfs := surfs * get_basis_surface(c\composite_curve.segments[i].parent_curve);
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN(surfs);
END_FUNCTION;

(* "get_descendant_occurrences" IMPLICIT from SCHEMA product_structure_schema *)
FUNCTION get_descendant_occurrences(input : product_definition_occurrence) : SET [0 : ?] OF product_definition_specified_occurrence;
LOCAL
  result : SET OF product_definition_specified_occurrence := input.child_occurrences;
END_LOCAL;
  REPEAT i := 1 TO HIINDEX(input.child_occurrences) BY 1;
    result := result + get_descendant_occurrences(input.child_occurrences[i]);
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

(* "get_description_value" IMPLICIT from SCHEMA basic_attribute_schema *)
FUNCTION get_description_value(obj : description_attribute_select) : text;
LOCAL
  description_bag : BAG OF description_attribute := (USEDIN(obj,
                                                            'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'));
END_LOCAL;
  IF SIZEOF(description_bag) = 1
  THEN
    RETURN(description_bag[1].attribute_value);
  ELSE
    RETURN(?);
  END_IF;
END_FUNCTION;

(* "get_directed_link" IMPLICIT from SCHEMA product_property_representation_schema *)
FUNCTION get_directed_link(nodes : LIST OF representation;
                           undirected_link : LIST OF chained_representation_link) : LIST OF representation_relationship;
LOCAL
  directed_link : LIST OF representation_relationship := [];
END_LOCAL;
  IF (SIZEOF(nodes) <> SIZEOF(undirected_link) + 1) OR (VALUE_UNIQUE(nodes) = FALSE)
  THEN
    RETURN(?);
  END_IF;
  REPEAT i := 1 TO SIZEOF(undirected_link);
    CASE TRUE OF
      ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REPRESENTATION_CONTEXT' IN
       TYPEOF(undirected_link[i])) : BEGIN  
                                            IF ((nodes[i]\representation.context_of_items :=: undirected_link[i]) AND
                                                (nodes[i + 1]\representation.context_of_items :=: undirected_link[i]))
                                            THEN
                                              INSERT(directed_link,
                                                     representation_relationship('', '', nodes[i + 1], nodes[i]),
                                                     (i - 1));
                                            ELSE
                                              RETURN(?);
                                            END_IF;
      END;
      ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REPRESENTATION_RELATIONSHIP' IN
       TYPEOF(undirected_link[i])) : BEGIN  
                                            IF (((nodes[i] :=:
                                                  undirected_link[i]\representation_relationship.rep_1) AND
                                                 (nodes[i + 1] :=:
                                                  undirected_link[i]\representation_relationship.rep_2)) OR
                                                ((nodes[i] :=:
                                                  undirected_link[i]\representation_relationship.rep_2) AND
                                                 (nodes[i + 1] :=:
                                                  undirected_link[i]\representation_relationship.rep_1)))
                                            THEN
                                              INSERT(directed_link,
                                                     representation_relationship('', '', nodes[i + 1], nodes[i]),
                                                     (i - 1));
                                            ELSE
                                              RETURN(?);
                                            END_IF;
      END;
      ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAPPED_ITEM' IN TYPEOF(undirected_link[i])) : BEGIN  
                                                                                                                IF ((nodes[i] IN
                                                                                                                     using_representations(undirected_link[i])) AND
                                                                                                                    (nodes[i +
                                                                                                                           1] :=:
                                                                                                                     undirected_link[i]\mapped_item.mapping_source\representation_map.mapped_representation))
                                                                                                                THEN
                                                                                                                  INSERT(directed_link,
                                                                                                                         representation_relationship('',
                                                                                                                                                     '',
                                                                                                                                                     nodes[i +
                                                                                                                                                           1],
                                                                                                                                                     nodes[i]),
                                                                                                                         (i -
                                                                                                                          1));
                                                                                                                ELSE
                                                                                                                  RETURN(?);
                                                                                                                END_IF;
      END;
      OTHERWISE: RETURN(?);
    END_CASE;
  END_REPEAT;
  IF (VALUE_UNIQUE(directed_link) = FALSE)
  THEN
    RETURN(?);
  END_IF;
  RETURN(directed_link);
END_FUNCTION;

(* "get_id_value" IMPLICIT from SCHEMA basic_attribute_schema *)
FUNCTION get_id_value(obj : id_attribute_select) : identifier;
LOCAL
  id_bag : BAG OF id_attribute := (USEDIN(obj,
                                          'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM'));
END_LOCAL;
  IF SIZEOF(id_bag) = 1
  THEN
    RETURN(id_bag[1].attribute_value);
  ELSE
    RETURN(?);
  END_IF;
END_FUNCTION;

(* "get_name_value" IMPLICIT from SCHEMA basic_attribute_schema *)
FUNCTION get_name_value(obj : name_attribute_select) : label;
LOCAL
  name_bag : BAG OF name_attribute := (USEDIN(obj,
                                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM'));
END_LOCAL;
  IF SIZEOF(name_bag) = 1
  THEN
    RETURN(name_bag[1].attribute_value);
  ELSE
    RETURN(?);
  END_IF;
END_FUNCTION;

(* "get_representations_for_items" IMPLICIT from SCHEMA representation_schema *)
FUNCTION get_representations_for_items(input : SET OF founded_item_select) : SET OF representation;
LOCAL
  r_set : SET OF representation := [];
END_LOCAL;
  REPEAT i := LOINDEX(input) TO HIINDEX(input);
    r_set := r_set + using_representations(input[i]);
  END_REPEAT;
  RETURN(r_set);
END_FUNCTION;

(* "get_role" IMPLICIT from SCHEMA basic_attribute_schema *)
FUNCTION get_role(obj : role_select) : object_role;
LOCAL
  role_bag : BAG OF role_association := (USEDIN(obj,
                                                'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE'));
END_LOCAL;
  IF SIZEOF(role_bag) = 1
  THEN
    RETURN(role_bag[1].role);
  ELSE
    RETURN(?);
  END_IF;
END_FUNCTION;

(* "get_tri_for_pd" IMPLICIT from SCHEMA mechanical_design_schema *)
FUNCTION get_tri_for_pd(def_instance : product_definition) : SET OF topological_representation_item;
LOCAL
  pd1_set : SET OF property_definition                := bag_to_set(USEDIN(def_instance,
                                                                           'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PROPERTY_DEFINITION.DEFINITION'));
  pd2_set : SET OF property_definition                := [];
  pdr_set : SET OF property_definition_representation := [];
  pds_set : SET OF product_definition_shape           := [];
  r_set   : SET OF representation                     := [];
  sa_set  : SET OF shape_aspect                       := [];
  tri_set : SET OF topological_representation_item    := [];
END_LOCAL;
  IF (SIZEOF(pd1_set) < 1)
  THEN
    RETURN(?);
  END_IF;
  REPEAT i := LOINDEX(pd1_set) TO HIINDEX(pd1_set);
    pdr_set := pdr_set +
               bag_to_set(USEDIN(pd1_set[i],
                                 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd1_set[i])
    THEN
      pds_set := pds_set + pd1_set[i];
    END_IF;
  END_REPEAT;
  REPEAT i := LOINDEX(pds_set) TO HIINDEX(pds_set);
    sa_set := sa_set +
              bag_to_set(USEDIN(pds_set[i],
                                'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHAPE_ASPECT.OF_SHAPE'));
  END_REPEAT;
  REPEAT i := LOINDEX(sa_set) TO HIINDEX(sa_set);
    pd2_set := pd2_set +
               bag_to_set(USEDIN(sa_set[i],
                                 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PROPERTY_DEFINITION.DEFINITION'));
  END_REPEAT;
  IF (SIZEOF(pd2_set) > 0)
  THEN
    BEGIN  
           REPEAT i := LOINDEX(pd2_set) TO HIINDEX(pd2_set);
             pdr_set := pdr_set +
                        bag_to_set(USEDIN(pd2_set[i],
                                          'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
           END_REPEAT;
    END;
  END_IF;
  IF (SIZEOF(pdr_set) < 1)
  THEN
    RETURN(?);
  END_IF;
  REPEAT i := LOINDEX(pdr_set) TO HIINDEX(pdr_set);
    r_set := r_set + pdr_set[i]\property_definition_representation.used_representation;
  END_REPEAT;
  IF (SIZEOF(r_set) < 1)
  THEN
    RETURN(?);
  END_IF;
  REPEAT i := LOINDEX(r_set) TO HIINDEX(r_set);
    REPEAT j := LOINDEX(r_set[i]\representation.items) TO HIINDEX(r_set[i]\representation.items);
      IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TOPOLOGICAL_REPRESENTATION_ITEM' IN
          TYPEOF(r_set[i]\representation.items[j]))
      THEN
        tri_set := tri_set + r_set[i]\representation.items[j];
      END_IF;
    END_REPEAT;
  END_REPEAT;
  RETURN(tri_set);
END_FUNCTION;

(* "get_tri_in_representations" IMPLICIT from SCHEMA topology_schema *)
FUNCTION get_tri_in_representations(members : SET OF representation) : SET OF topological_representation_item;
LOCAL
  tri_set : SET OF topological_representation_item := [];
END_LOCAL;
  IF SIZEOF(members) = 0
  THEN
    RETURN(?);
  END_IF;
  REPEAT i := LOINDEX(members) TO HIINDEX(members);
    REPEAT j := LOINDEX(members[i]\representation.items) TO HIINDEX(members[i]\representation.items);
      IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TOPOLOGICAL_REPRESENTATION_ITEM' IN
         TYPEOF(members[i]\representation.items[j])
      THEN
        tri_set := tri_set + members[i]\representation.items[j];
      END_IF;
    END_REPEAT;
  END_REPEAT;
  RETURN(tri_set);
END_FUNCTION;

(* "has_values_space" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION has_values_space(expr : generic_expression) : BOOLEAN;
LOCAL
  typenames : SET OF STRING := stripped_typeof(expr);
END_LOCAL;
  IF 'EXPRESSION' IN typenames
  THEN
    RETURN(bool(('NUMERIC_EXPRESSION' IN typenames) OR ('STRING_EXPRESSION' IN typenames) OR
                ('BOOLEAN_EXPRESSION' IN typenames)));
  END_IF;
  IF 'MATHS_FUNCTION' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'FUNCTION_APPLICATION' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'MATHS_SPACE' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'MATHS_VARIABLE' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'DEPENDENT_VARIABLE_DEFINITION' IN typenames
  THEN
    RETURN(has_values_space(expr\unary_generic_expression.operand));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'LOGICAL_LITERAL' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'BINARY_LITERAL' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_EXPRESSION' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'DEFINITE_INTEGRAL_EXPRESSION' IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "is_acyclic" IMPLICIT from SCHEMA iso13584_generic_expressions_schema *)
FUNCTION is_acyclic(arg : generic_expression) : BOOLEAN;
  RETURN(acyclic(arg, []));
END_FUNCTION;

(* "is_int_expr" IMPLICIT from SCHEMA iso13584_expressions_schema *)
FUNCTION is_int_expr(arg : numeric_expression) : BOOLEAN;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.INT_LITERAL' IN TYPEOF(arg)
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REAL_LITERAL' IN TYPEOF(arg)
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.INT_NUMERIC_VARIABLE' IN TYPEOF(arg)
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REAL_NUMERIC_VARIABLE' IN TYPEOF(arg)
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ABS_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(is_int_expr(arg\unary_numeric_expression.operand));
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MINUS_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(is_int_expr(arg\unary_numeric_expression.operand));
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SIN_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.COS_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TAN_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ASIN_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ACOS_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ATAN_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EXP_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LOG_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LOG2_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LOG10_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SQUARE_ROOT_FUNCTION' IN TYPEOF(arg))
  THEN
    RETURN(FALSE);
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PLUS_EXPRESSION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MULT_EXPRESSION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAXIMUM_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MINIMUM_FUNCTION' IN TYPEOF(arg))
  THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_numeric_expression.operands);
      IF NOT is_int_expr(arg\multiple_arity_numeric_expression.operands[i])
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MINUS_EXPRESSION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POWER_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(is_int_expr(arg\binary_numeric_expression.operands[1]) AND
           is_int_expr(arg\binary_numeric_expression.operands[2]));
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIV_EXPRESSION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MOD_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SLASH_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LENGTH_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VALUE_FUNCTION' IN TYPEOF(arg)
  THEN
    IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.INT_VALUE_FUNCTION' IN TYPEOF(arg)
    THEN
      RETURN(TRUE);
    ELSE
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.INTEGER_DEFINED_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REAL_DEFINED_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BOOLEAN_DEFINED_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.STRING_DEFINED_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(FALSE);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "is_sql_mappable" IMPLICIT from SCHEMA iso13584_expressions_schema *)
FUNCTION is_sql_mappable(arg : expression) : BOOLEAN;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SIMPLE_NUMERIC_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SQL_MAPPABLE_DEFINED_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MINUS_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(is_sql_mappable(arg\unary_numeric_expression.operand));
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ABS_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SIN_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.COS_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TAN_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ASIN_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ACOS_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ATAN_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EXP_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LOG_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LOG2_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LOG10_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SQUARE_ROOT_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VALUE_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LENGTH_FUNCTION' IN TYPEOF(arg))
  THEN
    RETURN(FALSE);
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PLUS_EXPRESSION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MULT_EXPRESSION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAXIMUM_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MINIMUM_FUNCTION' IN TYPEOF(arg))
  THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_numeric_expression.operands);
      IF NOT is_sql_mappable(arg\multiple_arity_numeric_expression.operands[i])
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MINUS_EXPRESSION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SLASH_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(is_sql_mappable(arg\binary_numeric_expression.operands[1]) AND
           is_sql_mappable(arg\binary_numeric_expression.operands[2]));
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIV_EXPRESSION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MOD_EXPRESSION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POWER_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SIMPLE_BOOLEAN_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NOT_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(is_sql_mappable(arg\unary_generic_expression.operand));
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ODD_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.XOR_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(FALSE);
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AND_EXPRESSION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OR_EXPRESSION' IN TYPEOF(arg))
  THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_boolean_expression.operands);
      IF NOT is_sql_mappable(arg\multiple_arity_boolean_expression.operands[i])
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EQUALS_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(is_sql_mappable(arg\binary_generic_expression.operands[1]) AND
           is_sql_mappable(arg\binary_generic_expression.operands[2]));
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.COMPARISON_EQUAL' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.COMPARISON_GREATER' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.COMPARISON_GREATER_EQUAL' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.COMPARISON_LESS' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.COMPARISON_LESS_EQUAL' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.COMPARISON_NOT_EQUAL' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LIKE_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(is_sql_mappable(arg\comparison_expression.operands[1]) AND
           is_sql_mappable(arg\comparison_expression.operands[2]));
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.INTERVAL_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(is_sql_mappable(arg\interval_expression.interval_low) AND
           is_sql_mappable(arg\interval_expression.interval_high) AND
           is_sql_mappable(arg\interval_expression.interval_item));
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.NUMERIC_DEFINED_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BOOLEAN_DEFINED_FUNCTION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.STRING_DEFINED_FUNCTION' IN TYPEOF(arg))
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SIMPLE_STRING_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(TRUE);
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.INDEX_EXPRESSION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SUBSTRING_EXPRESSION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONCAT_EXPRESSION' IN TYPEOF(arg)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FORMAT_FUNCTION' IN TYPEOF(arg))
  THEN
    RETURN(FALSE);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "item_in_context" IMPLICIT from SCHEMA representation_schema *)
FUNCTION item_in_context(item : representation_item;
                         cntxt : representation_context) : BOOLEAN;
LOCAL
  y : BAG OF representation_item;
END_LOCAL;
  -- If there is one or more representation using both the item
  -- and cntxt return true.
  IF SIZEOF(USEDIN(item, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REPRESENTATION.ITEMS') *
            cntxt.representations_in_context) >
     0
  THEN
    RETURN(TRUE);
  ELSE
    y := QUERY(z
               <* USEDIN(item, '')
               | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
    IF SIZEOF(y) > 0
    THEN
      REPEAT i := 1 TO HIINDEX(y);
        IF item_in_context(y[i], cntxt)
        THEN
          RETURN(TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  -- Return false when all possible branches have been checked
  -- with no success.
  RETURN(FALSE);
END_FUNCTION;

(* "leap_year" IMPLICIT from SCHEMA date_time_schema *)
FUNCTION leap_year(year : year_number) : BOOLEAN;
  IF ((((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) = 0))
  THEN
    RETURN(TRUE);
  ELSE
    RETURN(FALSE);
  END_IF;
END_FUNCTION;

(* "list_face_loops" IMPLICIT from SCHEMA topology_schema *)
FUNCTION list_face_loops(f : face) : LIST [0 : ?] OF loop;
LOCAL
  loops : LIST [0 : ?] OF loop := [];
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(f.bounds);
    loops := loops + (f.bounds[i].bound);
  END_REPEAT;
  RETURN(loops);
END_FUNCTION;

(* "list_of_topology_reversed" IMPLICIT from SCHEMA topology_schema *)
FUNCTION list_of_topology_reversed(a_list : list_of_reversible_topology_item) : list_of_reversible_topology_item;
LOCAL
  the_reverse : list_of_reversible_topology_item;
END_LOCAL;
  the_reverse := [];
  REPEAT i := 1 TO SIZEOF(a_list);
    the_reverse := topology_reversed(a_list[i]) + the_reverse;
  END_REPEAT;
  RETURN(the_reverse);
END_FUNCTION;

(* "list_selected_components" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION list_selected_components(aggr : AGGREGATE OF LIST OF maths_value;
                                  k : positive_integer) : LIST OF maths_value;
LOCAL
  result : LIST OF maths_value := [];
  j      : INTEGER             := 0;
END_LOCAL;
  REPEAT i := LOINDEX(aggr) TO HIINDEX(aggr);
    IF k <= SIZEOF(aggr[i])
    THEN
      INSERT(result, aggr[i][k], j);
      j := j + 1;
    END_IF;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

(* "list_to_array" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION list_to_array(lis : LIST [0 : ?] OF GENERIC : T;
                       low : INTEGER;
                       u : INTEGER) : ARRAY [low : u] OF GENERIC : T;
LOCAL
  n   : INTEGER;
  res : ARRAY [low : u] OF GENERIC : T;
END_LOCAL;
  n := SIZEOF(lis);
  IF (n <> (u - low + 1))
  THEN
    RETURN(?);
  ELSE
    res := [lis[1]:n];
    REPEAT i := 2 TO n;
      res[low + i - 1] := lis[i];
    END_REPEAT;
    RETURN(res);
  END_IF;
END_FUNCTION;

(* "list_to_set" IMPLICIT from SCHEMA topology_schema *)
FUNCTION list_to_set(l : LIST [0 : ?] OF GENERIC : T) : SET OF GENERIC : T;
LOCAL
  s : SET OF GENERIC : T := [];
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(l);
    s := s + l[i];
  END_REPEAT;
  RETURN(s);
END_FUNCTION;

(* "make_array_of_array" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION make_array_of_array(lis : LIST [1 : ?] OF LIST [1 : ?] OF GENERIC : T;
                             low1 : INTEGER;
                             u1 : INTEGER;
                             low2 : INTEGER;
                             u2 : INTEGER) : ARRAY [low1 : u1] OF ARRAY [low2 : u2] OF GENERIC : T;
LOCAL
  res : ARRAY [low1 : u1] OF ARRAY [low2 : u2] OF GENERIC : T;
END_LOCAL;
  (* Check input dimensions for consistency *)
  IF (u1 - low1 + 1) <> SIZEOF(lis)
  THEN
    RETURN(?);
  END_IF;
  IF (u2 - low2 + 1) <> SIZEOF(lis[1])
  THEN
    RETURN(?);
  END_IF;
  (* Initialise res with values from lis[1] *)
  res := [list_to_array(lis[1], low2, u2):(u1 - low1 + 1)];
  REPEAT i := 2 TO HIINDEX(lis);
    IF (u2 - low2 + 1) <> SIZEOF(lis[i])
    THEN
      RETURN(?);
    END_IF;
    res[low1 + i - 1] := list_to_array(lis[i], low2, u2);
  END_REPEAT;
  RETURN(res);
END_FUNCTION;

(* "make_atom_based_literal" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_atom_based_literal(lit_value : atom_based_value) : atom_based_literal;
  RETURN(atom_based_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
END_FUNCTION;

(* "make_binary_literal" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_binary_literal(lit_value : BINARY) : binary_literal;
  RETURN(binary_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
END_FUNCTION;

(* "make_boolean_literal" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_boolean_literal(lit_value : BOOLEAN) : boolean_literal;
  RETURN(boolean_literal(lit_value) || simple_boolean_expression() || boolean_expression() || expression() ||
         generic_expression() || simple_generic_expression() || generic_literal());
END_FUNCTION;

(* "make_cartesian_complex_number_region" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_cartesian_complex_number_region(real_constraint : real_interval;
                                              imag_constraint : real_interval) : cartesian_complex_number_region;
  RETURN(cartesian_complex_number_region(real_constraint, imag_constraint) || maths_space() || generic_expression() ||
         generic_literal() || simple_generic_expression());
END_FUNCTION;

(* "make_complex_number_literal" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_complex_number_literal(rpart : REAL;
                                     ipart : REAL) : complex_number_literal;
  RETURN(complex_number_literal(rpart, ipart) || generic_literal() || simple_generic_expression() ||
         generic_expression());
END_FUNCTION;

(* "make_elementary_function" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_elementary_function(func_id : elementary_function_enumerators) : elementary_function;
  RETURN(elementary_function(func_id) || maths_function() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

(* "make_elementary_space" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_elementary_space(space_id : elementary_space_enumerators) : elementary_space;
  RETURN(elementary_space(space_id) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

(* "make_extended_tuple_space" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_extended_tuple_space(base : tuple_space;
                                   extender : maths_space) : extended_tuple_space;
  RETURN(extended_tuple_space(base, extender) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

(* "make_finite_integer_interval" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_finite_integer_interval(min : INTEGER;
                                      max : INTEGER) : finite_integer_interval;
  RETURN(finite_integer_interval(min, max) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

(* "make_finite_real_interval" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_finite_real_interval(min : REAL;
                                   minclo : open_closed;
                                   max : REAL;
                                   maxclo : open_closed) : finite_real_interval;
  RETURN(finite_real_interval(min, minclo, max, maxclo) || maths_space() || generic_expression() ||
         generic_literal() || simple_generic_expression());
END_FUNCTION;

(* "make_finite_space" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_finite_space(members : SET OF maths_value) : finite_space;
  RETURN(finite_space(members) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

(* "make_function_application" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_function_application(afunction : maths_function_select;
                                   arguments : LIST [1 : ?] OF maths_value) : function_application;
  RETURN(function_application(afunction, arguments) ||
         multiple_arity_generic_expression(convert_to_maths_function(afunction) + convert_to_operands(arguments)) ||
         generic_expression());
END_FUNCTION;

(* "make_function_space" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_function_space(domain_constraint : space_constraint_type;
                             domain_argument : maths_space;
                             range_constraint : space_constraint_type;
                             range_argument : maths_space) : function_space;
  RETURN(function_space(domain_constraint, domain_argument, range_constraint, range_argument) || maths_space() ||
         generic_expression() || generic_literal() || simple_generic_expression());
END_FUNCTION;

(* "make_int_literal" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_int_literal(lit_value : INTEGER) : int_literal;
  RETURN(int_literal() || literal_number(lit_value) || simple_numeric_expression() || numeric_expression() ||
         expression() || generic_expression() || simple_generic_expression() || generic_literal());
END_FUNCTION;

(* "make_listed_product_space" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_listed_product_space(factors : LIST OF maths_space) : listed_product_space;
  RETURN(listed_product_space(factors) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

(* "make_logical_literal" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_logical_literal(lit_value : LOGICAL) : logical_literal;
  RETURN(logical_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
END_FUNCTION;

(* "make_maths_enum_literal" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_maths_enum_literal(lit_value : maths_enum_atom) : maths_enum_literal;
  RETURN(maths_enum_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
END_FUNCTION;

(* "make_maths_tuple_literal" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_maths_tuple_literal(lit_value : LIST OF maths_value) : maths_tuple_literal;
  RETURN(maths_tuple_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
END_FUNCTION;

(* "make_parallel_composed_function" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_parallel_composed_function(srcdom : maths_space_or_function;
                                         prepfuncs : LIST [2 : ?] OF maths_function;
                                         finfunc : maths_function_select) : parallel_composed_function;
  RETURN(parallel_composed_function(srcdom, prepfuncs, finfunc) || maths_function() || generic_expression() ||
         multiple_arity_generic_expression(convert_to_operands_prcmfn(srcdom, prepfuncs, finfunc)));
END_FUNCTION;

(* "make_polar_complex_number_region" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_polar_complex_number_region(centre : complex_number_literal;
                                          dis_constraint : real_interval;
                                          dir_constraint : finite_real_interval) : polar_complex_number_region;
  RETURN(polar_complex_number_region(centre, dis_constraint, dir_constraint) || maths_space() ||
         generic_expression() || generic_literal() || simple_generic_expression());
END_FUNCTION;

(* "make_real_interval_from_min" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_real_interval_from_min(min : REAL;
                                     minclo : open_closed) : real_interval_from_min;
  RETURN(real_interval_from_min(min, minclo) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

(* "make_real_interval_to_max" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_real_interval_to_max(max : REAL;
                                   maxclo : open_closed) : real_interval_to_max;
  RETURN(real_interval_to_max(max, maxclo) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

(* "make_real_literal" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_real_literal(lit_value : REAL) : real_literal;
  RETURN(real_literal() || literal_number(lit_value) || simple_numeric_expression() || numeric_expression() ||
         expression() || generic_expression() || simple_generic_expression() || generic_literal());
END_FUNCTION;

(* "make_string_literal" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_string_literal(lit_value : STRING) : string_literal;
  RETURN(string_literal(lit_value) || simple_string_expression() || string_expression() || expression() ||
         generic_expression() || simple_generic_expression() || generic_literal());
END_FUNCTION;

(* "make_uniform_product_space" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION make_uniform_product_space(base : maths_space;
                                    exponent : positive_integer) : uniform_product_space;
  RETURN(uniform_product_space(base, exponent) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

(* "max_exists" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION max_exists(spc : maths_space) : BOOLEAN;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  RETURN(bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
              ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) OR
              ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
              ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types)));
END_FUNCTION;

(* "max_included" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION max_included(spc : maths_space) : BOOLEAN;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types)
  THEN
    RETURN(TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types)
  THEN
    RETURN(bool(spc\finite_real_interval.max_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types)
  THEN
    RETURN(bool(spc\real_interval_to_max.max_closure = closed));
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "md_pmi_name_and_type_correlation" IMPLICIT from SCHEMA mechanical_design_schema *)
FUNCTION md_pmi_name_and_type_correlation(input : annotation_placeholder_occurrence) : BOOLEAN;
LOCAL
  pmi_role : STRING                                                    := input\annotation_placeholder_occurrence.item\representation_item.name;
  dmiawps  : SET OF draughting_model_item_association_with_placeholder := input\annotation_placeholder_occurrence.the_draughting_model_item_association_with_placeholders;
  v        : SET OF STRING                                             := [];
END_LOCAL;
  IF (SIZEOF(dmiawps) = 1)
  THEN
    v := TYPEOF(dmiawps[1]\draughting_model_item_association.definition);
  ELSE
    RETURN(FALSE);
  END_IF;
  IF NOT (pmi_role IN
          ['angular dimension',
           'angularity',
           'circular runout',
           'circularity',
           'coaxiality',
           'concentricity',
           'curve dimension',
           'cylindricity',
           'datum',
           'datum target',
           'diameter dimension',
           'flatness',
           'general dimension',
           'general note',
           'general tolerance',
           'label',
           'linear dimension',
           'note',
           'ordinate dimension',
           'parallelism',
           'perpendicularity',
           'position',
           'profile of line',
           'profile of surface',
           'radial dimension',
           'roundness',
           'runout',
           'straightness',
           'surface roughness',
           'symmetry',
           'total runout'])
  THEN
    RETURN(?);
  END_IF;
  CASE pmi_role OF
    'angular dimension' : IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ANGULAR_LOCATION' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'angularity' : IF 'SHAPE_TOLERANCE_SCHEMA.ANGULARITY_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'circular runout' : IF 'SHAPE_TOLERANCE_SCHEMA.CIRCULAR_RUNOUT_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'circularity' : IF 'SHAPE_TOLERANCE_SCHEMA.ROUNDNESS_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'coaxiality' : IF 'SHAPE_TOLERANCE_SCHEMA.COAXIALITY_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'concentricity' : IF 'SHAPE_TOLERANCE_SCHEMA.CONCENTRICITY_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'curve dimension' : IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSIONAL_SIZE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'cylindricity' : IF 'SHAPE_TOLERANCE_SCHEMA.CYLINDRICITY_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'datum' : IF 'SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'datum target' : IF 'SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM_TARGET' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'diameter dimension' : IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSIONAL_SIZE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'flatness' : IF 'SHAPE_TOLERANCE_SCHEMA.FLATNESS_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'general dimension' : IF (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSIONAL_SIZE',
                                      'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSIONAL_LOCATION'] *
                                     v) =
                              1)
    THEN
      RETURN(TRUE);
    END_IF;
    'general note' : IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PROPERTY_DEFINITION' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'general tolerance' : IF 'SHAPE_TOLERANCE_SCHEMA.GEOMETRIC_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'label' : IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PROPERTY_DEFINITION' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'linear dimension' : IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSIONAL_SIZE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'note' : IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PROPERTY_DEFINITION' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'ordinate dimension' : IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSIONAL_SIZE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'parallelism' : IF 'SHAPE_TOLERANCE_SCHEMA.PARALLELISM_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'perpendicularity' : IF 'SHAPE_TOLERANCE_SCHEMA.PERPENDICULARITY_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'position' : IF 'SHAPE_TOLERANCE_SCHEMA.POSITION_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'profile of line' : IF 'SHAPE_TOLERANCE_SCHEMA.LINE_PROFILE_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'profile of surface' : IF 'SHAPE_TOLERANCE_SCHEMA.SURFACE_PROFILE_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'radial dimension' : IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DIMENSIONAL_SIZE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'roundness' : IF 'SHAPE_TOLERANCE_SCHEMA.ROUNDNESS_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'runout' : IF 'SHAPE_TOLERANCE_SCHEMA.TOTAL_RUNOUT_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'straightness' : IF 'SHAPE_TOLERANCE_SCHEMA.STRAIGHTNESS_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'surface roughness' : IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PROPERTY_DEFINITION' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'symmetry' : IF 'SHAPE_TOLERANCE_SCHEMA.SYMMETRY_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    'total runout' : IF 'SHAPE_TOLERANCE_SCHEMA.TOTAL_RUNOUT_TOLERANCE' IN v
    THEN
      RETURN(TRUE);
    END_IF;
    OTHERWISE: RETURN(FALSE);
  END_CASE;
END_FUNCTION;

(* "md_valid_content_in_geometric_set_for_placeholder" IMPLICIT from SCHEMA mechanical_design_schema *)
FUNCTION md_valid_content_in_geometric_set_for_placeholder(input : geometric_set) : BOOLEAN;
LOCAL
  pass       : BOOLEAN                := TRUE;
  boxes      : BAG OF planar_box      := [];
  texts      : BAG OF annotation_text := [];
  placements : BAG OF placement       := [];
  points     : BAG OF point           := [];
END_LOCAL;
  -- Iterate over the input, ensuring the points that are in the set are the subtypes we want.
  REPEAT i := LOINDEX(input\geometric_set.elements) TO HIINDEX(input\geometric_set.elements);
    IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT' IN TYPEOF(input\geometric_set.elements[i])) AND
       NOT (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CARTESIAN_POINT',
                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT_ON_CURVE',
                    'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT_ON_SURFACE'] *
                   TYPEOF(input\geometric_set.elements[i])) =
            1)
    THEN
      pass := FALSE;
    ELSE
      points := points + input\geometric_set.elements[i];
    END_IF;
    IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PLANAR_BOX' IN TYPEOF(input\geometric_set.elements[i])
    THEN
      boxes := boxes + input\geometric_set.elements[i];
    END_IF;
    IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ANNOTATION_TEXT' IN TYPEOF(input\geometric_set.elements[i])
    THEN
      texts := texts + input\geometric_set.elements[i];
    END_IF;
    IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PLACEMENT' IN TYPEOF(input\geometric_set.elements[i])
    THEN
      placements := placements + input\geometric_set.elements[i];
    END_IF;
  END_REPEAT;
  IF SIZEOF(boxes) > 1
  THEN
    pass := FALSE;
  END_IF;
  IF SIZEOF(texts) > 1
  THEN
    pass := FALSE;
  END_IF;
  IF SIZEOF(placements) <> 1
  THEN
    pass := FALSE;
  END_IF;
  RETURN(pass);
END_FUNCTION;

(* "member_of" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION member_of(val : GENERIC : G;
                   spc : maths_space) : LOGICAL;
FUNCTION fedex(val : AGGREGATE OF GENERIC : X;
               i : INTEGER) : GENERIC : X;
  RETURN(val[i]);
END_FUNCTION;
LOCAL
  v         : maths_value            := simplify_maths_value(convert_to_maths_value(val));
  vtypes    : SET OF STRING          := stripped_typeof(v);
  s         : maths_space            := simplify_maths_space(spc);
  stypes    : SET OF STRING          := stripped_typeof(s);
  tmp_int   : INTEGER;
  tmp_real  : REAL;
  tmp_cmplx : complex_number_literal;
  lgcl      : LOGICAL;
  cum       : LOGICAL;
  vspc      : maths_space;
  sspc      : maths_space;
  smem      : SET OF maths_value;
  factors   : LIST OF maths_space;
END_LOCAL;
  IF NOT EXISTS(s)
  THEN
    RETURN(FALSE);
  END_IF;
  IF NOT EXISTS(v)
  THEN
    RETURN(s = the_generics);
  END_IF;
  IF ('GENERIC_EXPRESSION' IN vtypes) AND
     NOT ('MATHS_SPACE' IN vtypes) AND NOT ('MATHS_FUNCTION' IN vtypes) AND NOT ('COMPLEX_NUMBER_LITERAL' IN vtypes)
  THEN
    IF has_values_space(v)
    THEN
      vspc := values_space_of(v);
      IF subspace_of(vspc, s)
      THEN
        RETURN(TRUE);
      END_IF;
      IF NOT compatible_spaces(vspc, s)
      THEN
        RETURN(FALSE);
      END_IF;
      RETURN(UNKNOWN);
    END_IF;
    RETURN(UNKNOWN);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN stypes
  THEN
    CASE s\elementary_space.space_id OF
      es_numbers : RETURN(('NUMBER' IN vtypes) OR ('COMPLEX_NUMBER_LITERAL' IN vtypes));
      es_complex_numbers : RETURN('COMPLEX_NUMBER_LITERAL' IN vtypes);
      es_reals : RETURN(('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes));
      es_integers : RETURN('INTEGER' IN vtypes);
      es_logicals : RETURN('LOGICAL' IN vtypes);
      es_booleans : RETURN('BOOLEAN' IN vtypes);
      es_strings : RETURN('STRING' IN vtypes);
      es_binarys : RETURN('BINARY' IN vtypes);
      es_maths_spaces : RETURN('MATHS_SPACE' IN vtypes);
      es_maths_functions : RETURN('MATHS_FUNCTION' IN vtypes);
      es_generics : RETURN(TRUE);
    END_CASE;
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN stypes
  THEN
    IF 'INTEGER' IN vtypes
    THEN
      tmp_int := v;
      RETURN({s\finite_integer_interval.min <= tmp_int <= s\finite_integer_interval.max});
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN stypes
  THEN
    IF 'INTEGER' IN vtypes
    THEN
      tmp_int := v;
      RETURN(s\integer_interval_from_min.min <= tmp_int);
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN stypes
  THEN
    IF 'INTEGER' IN vtypes
    THEN
      tmp_int := v;
      RETURN(tmp_int <= s\integer_interval_to_max.max);
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN stypes
  THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes)
    THEN
      tmp_real := v;
      IF s\finite_real_interval.min_closure = closed
      THEN
        IF s\finite_real_interval.max_closure = closed
        THEN
          RETURN({s\finite_real_interval.min <= tmp_real <= s\finite_real_interval.max});
        ELSE
          RETURN({s\finite_real_interval.min <= tmp_real < s\finite_real_interval.max});
        END_IF;
      ELSE
        IF s\finite_real_interval.max_closure = closed
        THEN
          RETURN({s\finite_real_interval.min < tmp_real <= s\finite_real_interval.max});
        ELSE
          RETURN({s\finite_real_interval.min < tmp_real < s\finite_real_interval.max});
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN stypes
  THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes)
    THEN
      tmp_real := v;
      IF s\real_interval_from_min.min_closure = closed
      THEN
        RETURN(s\real_interval_from_min.min <= tmp_real);
      ELSE
        RETURN(s\real_interval_from_min.min < tmp_real);
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN stypes
  THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes)
    THEN
      tmp_real := v;
      IF s\real_interval_to_max.max_closure = closed
      THEN
        RETURN(tmp_real <= s\real_interval_to_max.max);
      ELSE
        RETURN(tmp_real < s\real_interval_to_max.max);
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN stypes
  THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes
    THEN
      RETURN(member_of(v\complex_number_literal.real_part, s\cartesian_complex_number_region.real_constraint) AND
             member_of(v\complex_number_literal.imag_part, s\cartesian_complex_number_region.imag_constraint));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN stypes
  THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes
    THEN
      tmp_cmplx := v;
      tmp_cmplx.real_part := tmp_cmplx.real_part - s\polar_complex_number_region.centre.real_part;
      tmp_cmplx.imag_part := tmp_cmplx.imag_part - s\polar_complex_number_region.centre.imag_part;
      tmp_real := SQRT(tmp_cmplx.real_part ** 2 + tmp_cmplx.imag_part ** 2);
      IF NOT member_of(tmp_real, s\polar_complex_number_region.distance_constraint)
      THEN
        RETURN(FALSE);
      END_IF;
      IF tmp_real = 0.0
      THEN
        RETURN(TRUE);
      END_IF;
      tmp_real := atan2(tmp_cmplx.imag_part, tmp_cmplx.real_part);
      RETURN(member_of(tmp_real, s\polar_complex_number_region.direction_constraint) OR
             member_of(tmp_real + 2.0 * PI, s\polar_complex_number_region.direction_constraint));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN stypes
  THEN
    smem := s\finite_space.members;
    cum := FALSE;
    REPEAT i := 1 TO SIZEOF(smem);
      cum := cum OR equal_maths_values(v, smem[i]);
      IF cum = TRUE
      THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
    RETURN(cum);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes
  THEN
    IF 'LIST' IN vtypes
    THEN
      IF SIZEOF(v) = s\uniform_product_space.exponent
      THEN
        sspc := s\uniform_product_space.base;
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF(v);
          cum := cum AND member_of(v[i], sspc);
          IF cum = FALSE
          THEN
            RETURN(FALSE);
          END_IF;
        END_REPEAT;
        RETURN(cum);
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes
  THEN
    IF 'LIST' IN vtypes
    THEN
      factors := s\listed_product_space.factors;
      IF SIZEOF(v) = SIZEOF(factors)
      THEN
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF(v);
          cum := cum AND member_of(v[i], factors[i]);
          IF cum = FALSE
          THEN
            RETURN(FALSE);
          END_IF;
        END_REPEAT;
        RETURN(cum);
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes
  THEN
    IF 'LIST' IN vtypes
    THEN
      sspc := s\extended_tuple_space.base;
      tmp_int := space_dimension(sspc);
      IF SIZEOF(v) >= tmp_int
      THEN
        cum := TRUE;
        REPEAT i := 1 TO tmp_int;
          cum := cum AND member_of(v[i], factor_space(sspc, i));
          IF cum = FALSE
          THEN
            RETURN(FALSE);
          END_IF;
        END_REPEAT;
        sspc := s\extended_tuple_space.extender;
        REPEAT i := tmp_int + 1 TO SIZEOF(v);
          cum := cum AND member_of(v[i], sspc);
          IF cum = FALSE
          THEN
            RETURN(FALSE);
          END_IF;
        END_REPEAT;
        RETURN(cum);
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes
  THEN
    IF 'MATHS_FUNCTION' IN vtypes
    THEN
      vspc := v\maths_function.domain;
      sspc := s\function_space.domain_argument;
      CASE s\function_space.domain_constraint OF
        sc_equal : cum := equal_maths_spaces(vspc, sspc);
        sc_subspace : cum := subspace_of(vspc, sspc);
        sc_member : cum := member_of(vspc, sspc);
      END_CASE;
      IF cum = FALSE
      THEN
        RETURN(FALSE);
      END_IF;
      vspc := v\maths_function.range;
      sspc := s\function_space.range_argument;
      CASE s\function_space.range_constraint OF
        sc_equal : cum := cum AND equal_maths_spaces(vspc, sspc);
        sc_subspace : cum := cum AND subspace_of(vspc, sspc);
        sc_member : cum := cum AND member_of(vspc, sspc);
      END_CASE;
      RETURN(cum);
    END_IF;
    RETURN(FALSE);
  END_IF;
  -- Should be unreachable
  RETURN(UNKNOWN);
END_FUNCTION;

(* "min_exists" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION min_exists(spc : maths_space) : BOOLEAN;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  RETURN(bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
              ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) OR
              ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
              ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types)));
END_FUNCTION;

(* "min_included" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION min_included(spc : maths_space) : BOOLEAN;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types)
  THEN
    RETURN(TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types)
  THEN
    RETURN(bool(spc\finite_real_interval.min_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types)
  THEN
    RETURN(bool(spc\real_interval_from_min.min_closure = closed));
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "mixed_loop_type_set" IMPLICIT from SCHEMA topology_schema *)
FUNCTION mixed_loop_type_set(l : SET [0 : ?] OF loop) : LOGICAL;
LOCAL
  poly_loop_type : LOGICAL;
END_LOCAL;
  IF (SIZEOF(l) <= 1)
  THEN
    RETURN(FALSE);
  END_IF;
  poly_loop_type := ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLY_LOOP' IN TYPEOF(l[1]));
  REPEAT i := 2 TO SIZEOF(l);
    IF (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLY_LOOP' IN TYPEOF(l[i])) <> poly_loop_type)
    THEN
      RETURN(TRUE);
    END_IF;
  END_REPEAT;
  RETURN(FALSE);
END_FUNCTION;

(* "msb_shells" IMPLICIT from SCHEMA geometric_model_schema *)
FUNCTION msb_shells(brep : manifold_solid_brep) : SET [1 : ?] OF closed_shell;
LOCAL
  return_set : SET [1 : ?] OF closed_shell := [brep.outer];
END_LOCAL;
  IF SIZEOF(QUERY(msbtype <* TYPEOF(brep) | msbtype LIKE '*BREP_WITH_VOIDS')) >= 1
  THEN
    return_set := return_set + brep\brep_with_voids.voids;
  END_IF;
  RETURN(return_set);
END_FUNCTION;

(* "msf_curve_check" IMPLICIT from SCHEMA aic_manifold_surface *)
FUNCTION msf_curve_check(cv : representation_item) : BOOLEAN;
  (* This function varifies the validity of a curve in the context of a
     manifold surface model. Representation_items are
     valid input, however, they are supposed to be curves; otherwise
     this function will return false.
      *)
  (* complex subtypes of curve that are both bounded_curve and
     oneof conic, curve_replica, line, or offset_curve_3d are not
     valid
      *)
  IF SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.BOUNDED_CURVE',
             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONIC',
             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE_REPLICA',
             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LINE',
             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OFFSET_CURVE_3D'] *
            TYPEOF(cv)) >
     1
  THEN
    RETURN(FALSE);
  END_IF;
  (* b_spline_curves shall not self-intersect
      *)
  IF (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.B_SPLINE_CURVE' IN TYPEOF(cv)) AND
      (cv\b_spline_curve.self_intersect = FALSE) OR
      (cv\b_spline_curve.self_intersect = UNKNOWN))
  THEN
    RETURN(TRUE);
  ELSE
    IF SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONIC',
               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LINE'] *
              TYPEOF(cv)) =
       1
    THEN
      RETURN(TRUE);
    ELSE
      IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE_REPLICA' IN TYPEOF(cv)
      THEN
        RETURN(msf_curve_check(cv\curve_replica.parent_curve));
      ELSE
        IF (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND
            ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\offset_curve_3d.self_intersect = UNKNOWN)) AND
            (NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLYLINE' IN
                  TYPEOF(cv\offset_curve_3d.basis_curve))))
        THEN
          RETURN(msf_curve_check(cv\offset_curve_3d.basis_curve));
        ELSE
          IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PCURVE' IN TYPEOF(cv)
          THEN
            RETURN((msf_curve_check(cv\pcurve.reference_to_curve\representation.items[1])) AND
                   (msf_surface_check(cv\pcurve.basis_surface)));
          ELSE
            IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_CURVE' IN TYPEOF(cv)
            THEN
              IF msf_curve_check(cv\surface_curve.curve_3d)
              THEN
                REPEAT i := 1 TO SIZEOF(cv\surface_curve.associated_geometry);
                  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE' IN
                     TYPEOF(cv\surface_curve.associated_geometry[i])
                  THEN
                    IF NOT msf_surface_check(cv\surface_curve.associated_geometry[i])
                    THEN
                      RETURN(FALSE);
                    END_IF;
                  ELSE
                    IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PCURVE' IN
                       TYPEOF(cv\surface_curve.associated_geometry[i])
                    THEN
                      IF NOT msf_curve_check(cv\surface_curve.associated_geometry[i])
                      THEN
                        RETURN(FALSE);
                      END_IF;
                    END_IF;
                  END_IF;
                END_REPEAT;
                RETURN(TRUE);
              END_IF;
            ELSE
              IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLYLINE' IN TYPEOF(cv)
              THEN
                IF (SIZEOF(cv\polyline.points) >= 3)
                THEN
                  RETURN(TRUE);
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  (* FALSE is returned if the input parameter cv is not a valid curve.
      *)
  RETURN(FALSE);
END_FUNCTION;

(* "msf_surface_check" IMPLICIT from SCHEMA aic_manifold_surface *)
FUNCTION msf_surface_check(surf : surface) : BOOLEAN;
  (* This function varifies the validity of a surface in the
     context of a manifold surface model.
      *)
  (* elementary_surfaces are valid surface types
      *)
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ELEMENTARY_SURFACE' IN TYPEOF(surf)
  THEN
    RETURN(TRUE);
  ELSE
    IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SWEPT_SURFACE' IN TYPEOF(surf)
    THEN
      RETURN(msf_curve_check(surf\swept_surface.swept_curve));
    ELSE
      IF (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OFFSET_SURFACE' IN TYPEOF(surf)) AND
          (surf\offset_surface.self_intersect = FALSE) OR
          (surf\offset_surface.self_intersect = UNKNOWN))
      THEN
        RETURN(msf_surface_check(surf\offset_surface.basis_surface));
      ELSE
        IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SURFACE_REPLICA' IN TYPEOF(surf)
        THEN
          RETURN(msf_surface_check(surf\surface_replica.parent_surface));
        ELSE
          IF (('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF(surf)) AND
              (surf\b_spline_surface.self_intersect = FALSE) OR
              (surf\b_spline_surface.self_intersect = UNKNOWN))
          THEN
            RETURN(TRUE);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "no_cyclic_domain_reference" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION no_cyclic_domain_reference(ref : maths_space_or_function;
                                    used : SET OF maths_function) : BOOLEAN;
LOCAL
  typenames : SET OF STRING  := TYPEOF(ref);
  func      : maths_function;
END_LOCAL;
  IF (NOT EXISTS(ref)) OR (NOT EXISTS(used))
  THEN
    RETURN(FALSE);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames
  THEN
    RETURN(TRUE);
  END_IF;
  func := ref;
  IF func IN used
  THEN
    RETURN(FALSE);
  END_IF;
  IF (schema_prefix + 'CONSTANT_FUNCTION') IN typenames
  THEN
    RETURN(no_cyclic_domain_reference(func\constant_function.source_of_domain, used + [func]));
  END_IF;
  IF (schema_prefix + 'SELECTOR_FUNCTION') IN typenames
  THEN
    RETURN(no_cyclic_domain_reference(func\selector_function.source_of_domain, used + [func]));
  END_IF;
  IF (schema_prefix + 'PARALLEL_COMPOSED_FUNCTION') IN typenames
  THEN
    RETURN(no_cyclic_domain_reference(func\parallel_composed_function.source_of_domain, used + [func]));
  END_IF;
  RETURN(TRUE);
END_FUNCTION;

(* "no_cyclic_space_reference" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION no_cyclic_space_reference(spc : maths_space;
                                   refs : SET OF maths_space) : BOOLEAN;
LOCAL
  types     : SET OF STRING;
  refs_plus : SET OF maths_space;
END_LOCAL;
  IF (spc IN refs)
  THEN
    RETURN(FALSE);
  END_IF;
  types := TYPEOF(spc);
  refs_plus := refs + spc;
  IF (schema_prefix + 'FINITE_SPACE') IN types
  THEN
    RETURN(bool(SIZEOF(QUERY(sp
                             <* QUERY(mem <* spc\finite_space.members | (schema_prefix + 'MATHS_SPACE') IN TYPEOF(mem))
                             | NOT no_cyclic_space_reference(sp, refs_plus))) =
                0));
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types
  THEN
    RETURN(no_cyclic_space_reference(spc\uniform_product_space.base, refs_plus));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types
  THEN
    RETURN(bool(SIZEOF(QUERY(fac
                             <* spc\listed_product_space.factors
                             | NOT no_cyclic_space_reference(fac, refs_plus))) =
                0));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types
  THEN
    RETURN(no_cyclic_space_reference(spc\extended_tuple_space.base, refs_plus) AND
           no_cyclic_space_reference(spc\extended_tuple_space.extender, refs_plus));
  END_IF;
  -- spc contains no references to other spaces
  RETURN(TRUE);
END_FUNCTION;

(* "nondecreasing" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION nondecreasing(lr : LIST OF REAL) : BOOLEAN;
  IF NOT EXISTS(lr)
  THEN
    RETURN(FALSE);
  END_IF;
  REPEAT j := 2 TO SIZEOF(lr);
    IF lr[j] < lr[j - 1]
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "normalise" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION normalise(arg : vector_or_direction) : vector_or_direction;
LOCAL
  ndim   : INTEGER;
  v      : direction           := dummy_gri || direction([1.0,0.0,0.0]);
  result : vector_or_direction;
  vec    : vector              := dummy_gri || vector(v, 1.0);
  mag    : REAL;
END_LOCAL;
  IF NOT EXISTS(arg)
  THEN
    result := ?;
  ELSE
    ndim := arg.dim;
    IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VECTOR' IN TYPEOF(arg)
    THEN
      BEGIN  
             v := dummy_gri || direction(arg\vector.orientation.direction_ratios);
             IF arg\vector.magnitude = 0.0
             THEN
               RETURN(?);
             ELSE
               vec := dummy_gri || vector(v, 1.0);
             END_IF;
      END;
    ELSE
      v := dummy_gri || direction(arg.direction_ratios);
    END_IF;
    mag := 0.0;
    REPEAT i := 1 TO ndim;
      mag := mag + v.direction_ratios[i] * v.direction_ratios[i];
    END_REPEAT;
    IF mag > 0.0
    THEN
      mag := SQRT(mag);
      REPEAT i := 1 TO ndim;
        v.direction_ratios[i] := v.direction_ratios[i] / mag;
      END_REPEAT;
      IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VECTOR' IN TYPEOF(arg)
      THEN
        vec.orientation := v;
        result := vec;
      ELSE
        result := v;
      END_IF;
    ELSE
      RETURN(?);
    END_IF;
  END_IF;
  RETURN(result);
END_FUNCTION;

(* "number_superspace_of" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION number_superspace_of(spc : maths_space) : elementary_space;
  IF subspace_of_es(spc, es_integers)
  THEN
    RETURN(the_integers);
  END_IF;
  IF subspace_of_es(spc, es_reals)
  THEN
    RETURN(the_reals);
  END_IF;
  IF subspace_of_es(spc, es_complex_numbers)
  THEN
    RETURN(the_complex_numbers);
  END_IF;
  IF subspace_of_es(spc, es_numbers)
  THEN
    RETURN(the_numbers);
  END_IF;
  RETURN(?);
END_FUNCTION;

(* "number_tuple_subspace_check" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION number_tuple_subspace_check(spc : maths_space) : LOGICAL;
LOCAL
  types   : SET OF STRING       := stripped_typeof(spc);
  factors : LIST OF maths_space;
  cum     : LOGICAL             := TRUE;
END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN types
  THEN
    RETURN(subspace_of_es(spc\uniform_product_space.base, es_numbers));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types
  THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF(factors);
      cum := cum AND subspace_of_es(factors[i], es_numbers);
    END_REPEAT;
    RETURN(cum);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types
  THEN
    cum := subspace_of_es(spc\extended_tuple_space.extender, es_numbers);
    cum := cum AND number_tuple_subspace_check(spc\extended_tuple_space.base);
    RETURN(cum);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "one_tuples_of" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION one_tuples_of(spc : maths_space) : tuple_space;
  RETURN(make_uniform_product_space(spc, 1));
END_FUNCTION;

(* "open_shell_reversed" IMPLICIT from SCHEMA topology_schema *)
FUNCTION open_shell_reversed(a_shell : open_shell) : oriented_open_shell;
LOCAL
  the_reverse : oriented_open_shell;
END_LOCAL;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell))
  THEN
    the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || open_shell() ||
                   oriented_open_shell(a_shell\oriented_open_shell.open_shell_element,
                                       (NOT (a_shell\oriented_open_shell.orientation)));
  ELSE
    the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || open_shell() ||
                   oriented_open_shell(a_shell, FALSE);
  END_IF;
  RETURN(the_reverse);
END_FUNCTION;

(* "orthogonal_complement" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION orthogonal_complement(vec : direction) : direction;
LOCAL
  result : direction;
END_LOCAL;
  IF (vec.dim <> 2) OR NOT EXISTS(vec)
  THEN
    RETURN(?);
  ELSE
    result := dummy_gri || direction([-vec.direction_ratios[2],vec.direction_ratios[1]]);
    RETURN(result);
  END_IF;
END_FUNCTION;

(* "parallel_composed_function_composability_check" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION parallel_composed_function_composability_check(funcs : LIST OF maths_function;
                                                        final : maths_function_select) : BOOLEAN;
LOCAL
  tplsp  : tuple_space    := the_zero_tuple_space;
  finfun : maths_function := convert_to_maths_function(final);
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(funcs);
    tplsp := assoc_product_space(tplsp, funcs[i].range);
  END_REPEAT;
  RETURN(compatible_spaces(tplsp, finfun.domain));
END_FUNCTION;

(* "parallel_composed_function_domain_check" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION parallel_composed_function_domain_check(comdom : tuple_space;
                                                 funcs : LIST OF maths_function) : BOOLEAN;
  REPEAT i := 1 TO SIZEOF(funcs);
    IF NOT (compatible_spaces(comdom, funcs[i].domain))
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "parse_express_identifier" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION parse_express_identifier(s : STRING;
                                  i : positive_integer) : positive_integer;
LOCAL
  k : positive_integer;
END_LOCAL;
  k := i;
  IF i <= LENGTH(s)
  THEN
    IF (s[i] LIKE '@')
    THEN
      REPEAT UNTIL (k > LENGTH(s)) OR ((s[k] <> '_') AND NOT (s[k] LIKE '@') AND NOT (s[k] LIKE '#'));
        k := k + 1;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN(k);
END_FUNCTION;

(* "partial_derivative_check" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION partial_derivative_check(domain : tuple_space;
                                  d_vars : LIST [1 : ?] OF input_selector) : BOOLEAN;
LOCAL
  domn : tuple_space := domain;
  fspc : maths_space;
  dim  : INTEGER;
  k    : INTEGER;
END_LOCAL;
  IF (space_dimension(domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(domain)))
  THEN
    domn := factor1(domain);
  END_IF;
  dim := space_dimension(domn);
  REPEAT i := 1 TO SIZEOF(d_vars);
    k := d_vars[i];
    IF k > dim
    THEN
      RETURN(FALSE);
    END_IF;
    fspc := factor_space(domn, k);
    IF (NOT subspace_of_es(fspc, es_reals)) AND (NOT subspace_of_es(fspc, es_complex_numbers))
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "path_head_to_tail" IMPLICIT from SCHEMA topology_schema *)
FUNCTION path_head_to_tail(a_path : path) : LOGICAL;
LOCAL
  n : INTEGER;
  p : LOGICAL := TRUE;
END_LOCAL;
  n := SIZEOF(a_path.edge_list);
  REPEAT i := 2 TO n;
    p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i].edge_start);
  END_REPEAT;
  RETURN(p);
END_FUNCTION;

(* "path_reversed" IMPLICIT from SCHEMA topology_schema *)
FUNCTION path_reversed(a_path : path) : oriented_path;
LOCAL
  the_reverse : oriented_path;
END_LOCAL;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ORIENTED_PATH' IN TYPEOF(a_path))
  THEN
    the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.edge_list)) ||
                   oriented_path(a_path\oriented_path.path_element, NOT (a_path\oriented_path.orientation));
  ELSE
    the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.edge_list)) || oriented_path(a_path, FALSE);
  END_IF;
  RETURN(the_reverse);
END_FUNCTION;

(* "real_max" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION real_max(spc : maths_space) : REAL;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types)
  THEN
    RETURN(spc\finite_integer_interval.max);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types)
  THEN
    RETURN(spc\integer_interval_to_max.max);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types)
  THEN
    RETURN(spc\finite_real_interval.max);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types)
  THEN
    RETURN(spc\real_interval_to_max.max);
  END_IF;
  RETURN(?);
END_FUNCTION;

(* "real_min" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION real_min(spc : maths_space) : REAL;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types)
  THEN
    RETURN(spc\finite_integer_interval.min);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types)
  THEN
    RETURN(spc\integer_interval_from_min.min);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types)
  THEN
    RETURN(spc\finite_real_interval.min);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types)
  THEN
    RETURN(spc\real_interval_from_min.min);
  END_IF;
  RETURN(?);
END_FUNCTION;

(* "regular_indexing" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION regular_indexing(sub : LIST OF INTEGER;
                          base : zero_or_one;
                          shape : LIST [1 : ?] OF positive_integer;
                          inc : LIST [1 : ?] OF INTEGER;
                          first : INTEGER) : INTEGER;
LOCAL
  k     : INTEGER;
  index : INTEGER;
END_LOCAL;
  IF NOT EXISTS(sub) OR NOT EXISTS(base) OR NOT EXISTS(shape) OR NOT EXISTS(inc) OR NOT EXISTS(first)
  THEN
    RETURN(?);
  END_IF;
  IF (SIZEOF(sub) <> SIZEOF(inc)) OR (SIZEOF(sub) <> SIZEOF(shape))
  THEN
    RETURN(?);
  END_IF;
  index := first;
  REPEAT j := 1 TO SIZEOF(sub);
    IF NOT EXISTS(sub[j]) OR NOT EXISTS(inc[j])
    THEN
      RETURN(?);
    END_IF;
    k := sub[j] - base;
    IF NOT ({0 <= k < shape[j]})
    THEN
      RETURN(?);
    END_IF;
    index := index + k * inc[j];
  END_REPEAT;
  RETURN(index);
END_FUNCTION;

(* "remove_first" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION remove_first(alist : LIST OF GENERIC : GEN) : LIST OF GENERIC : GEN;
LOCAL
  blist : LIST OF GENERIC : GEN := alist;
END_LOCAL;
  IF SIZEOF(blist) > 0
  THEN
    REMOVE(blist, 1);
  END_IF;
  RETURN(blist);
END_FUNCTION;

(* "repackage" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION repackage(tspace : tuple_space;
                   repckg : repackage_options) : tuple_space;
  CASE repckg OF
    ro_nochange : RETURN(tspace);
    ro_wrap_as_tuple : RETURN(one_tuples_of(tspace));
    ro_unwrap_tuple : RETURN(factor1(tspace));
    OTHERWISE: RETURN(?);
  END_CASE;
END_FUNCTION;

(* "same_side" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION same_side(plane_pts : LIST [3 : 3] OF cartesian_point;
                   test_points : LIST [2 : ?] OF cartesian_point) : BOOLEAN;
LOCAL
  val1 : REAL;
  val2 : REAL;
  n    : INTEGER;
END_LOCAL;
  IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2)
  THEN
    RETURN(?);
  END_IF;
  n := SIZEOF(test_points);
  val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3], test_points[1]);
  REPEAT i := 2 TO n;
    val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3], test_points[i]);
    IF (val1 * val2 <= 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "scalar_times_vector" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION scalar_times_vector(scalar : REAL;
                             vec : vector_or_direction) : vector;
LOCAL
  v      : direction;
  mag    : REAL;
  result : vector;
END_LOCAL;
  IF NOT EXISTS(scalar) OR NOT EXISTS(vec)
  THEN
    RETURN(?);
  ELSE
    IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VECTOR' IN TYPEOF(vec)
    THEN
      v := dummy_gri || direction(vec\vector.orientation.direction_ratios);
      mag := scalar * vec\vector.magnitude;
    ELSE
      v := dummy_gri || direction(vec.direction_ratios);
      mag := scalar;
    END_IF;
    IF (mag < 0.0)
    THEN
      REPEAT i := 1 TO SIZEOF(v.direction_ratios);
        v.direction_ratios[i] := -v.direction_ratios[i];
      END_REPEAT;
      mag := -mag;
    END_IF;
    result := dummy_gri || vector(normalise(v), mag);
  END_IF;
  RETURN(result);
END_FUNCTION;

(* "second_proj_axis" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION second_proj_axis(z_axis : direction;
                          x_axis : direction;
                          arg : direction) : direction;
LOCAL
  y_axis : vector;
  v      : direction;
  temp   : vector;
END_LOCAL;
  IF NOT EXISTS(arg)
  THEN
    v := dummy_gri || direction([0.0,1.0,0.0]);
  ELSE
    v := arg;
  END_IF;
  temp := scalar_times_vector(dot_product(v, z_axis), z_axis);
  y_axis := vector_difference(v, temp);
  temp := scalar_times_vector(dot_product(v, x_axis), x_axis);
  y_axis := vector_difference(y_axis, temp);
  y_axis := normalise(y_axis);
  RETURN(y_axis.orientation);
END_FUNCTION;

(* "set_of_topology_reversed" IMPLICIT from SCHEMA topology_schema *)
FUNCTION set_of_topology_reversed(a_set : set_of_reversible_topology_item) : set_of_reversible_topology_item;
LOCAL
  the_reverse : set_of_reversible_topology_item;
END_LOCAL;
  the_reverse := [];
  REPEAT i := 1 TO SIZEOF(a_set);
    the_reverse := the_reverse + topology_reversed(a_set[i]);
  END_REPEAT;
  RETURN(the_reverse);
END_FUNCTION;

(* "shape_of_array" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION shape_of_array(func : maths_function) : LIST OF positive_integer;
LOCAL
  tspace : tuple_space;
  temp   : maths_space;
  result : LIST OF positive_integer := [];
END_LOCAL;
  IF (schema_prefix + 'EXPLICIT_TABLE_FUNCTION') IN TYPEOF(func)
  THEN
    RETURN(func\explicit_table_function.shape);
  END_IF;
  tspace := func.domain;
  IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(tspace)))
  THEN
    tspace := factor1(tspace);
  END_IF;
  REPEAT i := 1 TO space_dimension(tspace);
    temp := factor_space(tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
    THEN
      RETURN(?);
    END_IF;
    INSERT(result, temp\finite_integer_interval.size, i - 1);
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

(* "shell_reversed" IMPLICIT from SCHEMA topology_schema *)
FUNCTION shell_reversed(a_shell : shell) : shell;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OPEN_SHELL' IN TYPEOF(a_shell))
  THEN
    RETURN(open_shell_reversed(a_shell));
  ELSE
    IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CLOSED_SHELL' IN TYPEOF(a_shell))
    THEN
      RETURN(closed_shell_reversed(a_shell));
    ELSE
      RETURN(?);
    END_IF;
  END_IF;
END_FUNCTION;

(* "simplify_function_application" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION simplify_function_application(expr : function_application) : maths_value;
FUNCTION ctmv(x : GENERIC : G) : maths_value;
  RETURN(convert_to_maths_value(x));
END_FUNCTION;
PROCEDURE parts(c : complex_number_literal; VAR x : REAL; VAR y : REAL);
  x := c.real_part;
  y := c.imag_part;
END_PROCEDURE;
FUNCTION makec(x : REAL;
               y : REAL) : complex_number_literal;
  RETURN(make_complex_number_literal(x, y));
END_FUNCTION;
FUNCTION good_t(v : maths_value;
                tn : STRING) : BOOLEAN;
LOCAL
  tpl : LIST OF maths_value;
END_LOCAL;
  IF 'LIST' IN TYPEOF(v)
  THEN
    tpl := v;
    REPEAT i := 1 TO SIZEOF(tpl);
      IF NOT (tn IN TYPEOF(tpl[i]))
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

CONSTANT
  cnlit : STRING := schema_prefix + 'COMPLEX_NUMBER_LITERAL';
END_CONSTANT;
LOCAL
  types         : SET OF STRING                              := stripped_typeof(expr.func);
  ef_val        : elementary_function_enumerators;
  is_elementary : BOOLEAN                                    := FALSE;
  v             : maths_value;
  v1            : maths_value;
  v2            : maths_value;
  v3            : maths_value;
  vlist         : LIST OF maths_value                        := [];
  gexpr         : generic_expression;
  pairs         : SET [1 : ?] OF LIST [2 : 2] OF maths_value;
  boo           : BOOLEAN;
  lgc           : LOGICAL;
  cum           : LOGICAL;
  j             : INTEGER;
  k             : INTEGER;
  n             : INTEGER;
  p             : REAL;
  q             : REAL;
  r             : REAL;
  s             : REAL;
  t             : REAL;
  u             : REAL;
  str           : STRING;
  st2           : STRING;
  bin           : BINARY;
  bi2           : BINARY;
  tpl           : LIST OF maths_value;
  tp2           : LIST OF maths_value;
  mem           : SET OF maths_value                         := [];
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(expr.arguments);
    v := simplify_maths_value(expr.arguments[i]);
    INSERT(vlist, v, i - 1);
  END_REPEAT;
  IF SIZEOF(vlist) >= 1
  THEN
    v1 := vlist[1];
  END_IF;
  IF SIZEOF(vlist) >= 2
  THEN
    v2 := vlist[2];
  END_IF;
  IF SIZEOF(vlist) >= 3
  THEN
    v3 := vlist[3];
  END_IF;
  IF 'ELEMENTARY_FUNCTION_ENUMERATORS' IN types
  THEN
    ef_val := expr.func;
    is_elementary := TRUE;
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN types
  THEN
    ef_val := expr.func\elementary_function.func_id;
    is_elementary := TRUE;
  END_IF;
  IF is_elementary
  THEN
    CASE ef_val OF
      ef_and : BEGIN  
                      cum := TRUE;
                      REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF 'LOGICAL' IN TYPEOF(vlist[i])
                        THEN
                          lgc := vlist[i];
                          cum := cum AND lgc;
                          IF lgc = FALSE
                          THEN
                            RETURN(ctmv(FALSE));
                          END_IF;
                          REMOVE(vlist, i);
                        END_IF;
                      END_REPEAT;
                      IF SIZEOF(vlist) = 0
                      THEN
                        RETURN(ctmv(cum));
                      END_IF;
                      IF cum <> TRUE
                      THEN
                        INSERT(vlist, ctmv(cum), 0);
                      END_IF;
                      IF SIZEOF(vlist) = 1
                      THEN
                        RETURN(vlist[1]);
                      END_IF;
      END;
      ef_or : BEGIN  
                     cum := FALSE;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                       IF 'LOGICAL' IN TYPEOF(vlist[i])
                       THEN
                         lgc := vlist[i];
                         cum := cum OR lgc;
                         IF lgc = TRUE
                         THEN
                           RETURN(ctmv(TRUE));
                         END_IF;
                         REMOVE(vlist, i);
                       END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0
                     THEN
                       RETURN(ctmv(cum));
                     END_IF;
                     IF cum <> FALSE
                     THEN
                       INSERT(vlist, ctmv(cum), 0);
                     END_IF;
                     IF SIZEOF(vlist) = 1
                     THEN
                       RETURN(vlist[1]);
                     END_IF;
      END;
      ef_not : IF 'LOGICAL' IN TYPEOF(v1)
      THEN
        lgc := v1;
        RETURN(ctmv(NOT lgc));
      END_IF;
      ef_xor : BEGIN  
                      IF 'LOGICAL' IN TYPEOF(v1)
                      THEN
                        lgc := v1;
                        IF 'LOGICAL' IN TYPEOF(v2)
                        THEN
                          cum := v2;
                          RETURN(ctmv(lgc XOR cum));
                        ELSE
                          IF lgc = FALSE
                          THEN
                            RETURN(ctmv(v2));
                          ELSE
                            IF lgc = UNKNOWN
                            THEN
                              RETURN(ctmv(UNKNOWN));
                            ELSE
                              RETURN(make_function_application(ef_not, [v2]));
                            END_IF;
                          END_IF;
                        END_IF;
                      ELSE
                        IF 'LOGICAL' IN TYPEOF(v2)
                        THEN
                          lgc := v2;
                          IF lgc = FALSE
                          THEN
                            RETURN(ctmv(v1));
                          ELSE
                            IF lgc = UNKNOWN
                            THEN
                              RETURN(ctmv(UNKNOWN));
                            ELSE
                              RETURN(make_function_application(ef_not, [v1]));
                            END_IF;
                          END_IF;
                        END_IF;
                      END_IF;
      END;
      ef_negate_i : IF 'INTEGER' IN TYPEOF(v1)
      THEN
        j := v1;
        RETURN(ctmv(-j));
      END_IF;
      ef_add_i : BEGIN  
                        j := 0;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'INTEGER' IN TYPEOF(vlist[i])
                          THEN
                            k := vlist[i];
                            j := j + k;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(j));
                        END_IF;
                        IF j <> 0
                        THEN
                          INSERT(vlist, ctmv(j), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_subtract_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j - k));
      END_IF;
      ef_multiply_i : BEGIN  
                             j := 1;
                             REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                               IF 'INTEGER' IN TYPEOF(vlist[i])
                               THEN
                                 k := vlist[i];
                                 j := j * k;
                                 REMOVE(vlist, i);
                               END_IF;
                             END_REPEAT;
                             IF SIZEOF(vlist) = 0
                             THEN
                               RETURN(ctmv(j));
                             END_IF;
                             IF j <> 1
                             THEN
                               INSERT(vlist, ctmv(j), 0);
                             END_IF;
                             IF SIZEOF(vlist) = 1
                             THEN
                               RETURN(vlist[1]);
                             END_IF;
      END;
      ef_divide_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j DIV k));
      END_IF;
      ef_mod_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j MOD k));
      END_IF;
      ef_exponentiate_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        n := 1;
        REPEAT i := 1 TO ABS(k);
          n := n * j;
        END_REPEAT;
        IF k < 0
        THEN
          n := 1 DIV n;
        END_IF;
        RETURN(ctmv(n));
      END_IF;
      ef_eq_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j = k));
      END_IF;
      ef_ne_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j <> k));
      END_IF;
      ef_gt_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j > k));
      END_IF;
      ef_lt_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j < k));
      END_IF;
      ef_ge_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j >= k));
      END_IF;
      ef_le_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j <= k));
      END_IF;
      ef_abs_i : IF 'INTEGER' IN TYPEOF(v1)
      THEN
        j := v1;
        RETURN(ctmv(ABS(j)));
      END_IF;
      ef_max_i : BEGIN  
                        boo := FALSE;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'INTEGER' IN TYPEOF(vlist[i])
                          THEN
                            IF boo
                            THEN
                              k := vlist[i];
                              IF k > j
                              THEN
                                j := k;
                              END_IF;
                            ELSE
                              j := vlist[i];
                              boo := TRUE;
                            END_IF;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(j));
                        END_IF;
                        IF boo
                        THEN
                          INSERT(vlist, ctmv(j), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_min_i : BEGIN  
                        boo := FALSE;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'INTEGER' IN TYPEOF(vlist[i])
                          THEN
                            IF boo
                            THEN
                              k := vlist[i];
                              IF k < j
                              THEN
                                j := k;
                              END_IF;
                            ELSE
                              j := vlist[i];
                              boo := TRUE;
                            END_IF;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(j));
                        END_IF;
                        IF boo
                        THEN
                          INSERT(vlist, ctmv(j), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_negate_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(-r));
      END_IF;
      ef_reciprocal_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(1.0 / r));
      END_IF;
      ef_add_r : BEGIN  
                        r := 0.0;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'REAL' IN TYPEOF(vlist[i])
                          THEN
                            s := vlist[i];
                            r := r + s;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(r));
                        END_IF;
                        IF r <> 0.0
                        THEN
                          INSERT(vlist, ctmv(r), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_subtract_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r - s));
      END_IF;
      ef_multiply_r : BEGIN  
                             r := 1.0;
                             REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                               IF 'REAL' IN TYPEOF(vlist[i])
                               THEN
                                 s := vlist[i];
                                 r := r * s;
                                 REMOVE(vlist, i);
                               END_IF;
                             END_REPEAT;
                             IF SIZEOF(vlist) = 0
                             THEN
                               RETURN(ctmv(r));
                             END_IF;
                             IF r <> 1.0
                             THEN
                               INSERT(vlist, ctmv(r), 0);
                             END_IF;
                             IF SIZEOF(vlist) = 1
                             THEN
                               RETURN(vlist[1]);
                             END_IF;
      END;
      ef_divide_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r / s));
      END_IF;
      ef_mod_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        t := r / s;
        j := t DIV 1;
        IF (t < 0.0) AND (j <> t)
        THEN
          j := j - 1;
        END_IF;
        RETURN(ctmv(r - j * s));
      END_IF;
      ef_exponentiate_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r ** s));
      END_IF;
      ef_exponentiate_ri : IF ('REAL' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        r := v1;
        k := v2;
        t := 1.0;
        REPEAT i := 1 TO ABS(k);
          t := t * r;
        END_REPEAT;
        IF k < 0
        THEN
          t := 1.0 / t;
        END_IF;
        RETURN(ctmv(t));
      END_IF;
      ef_eq_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r = s));
      END_IF;
      ef_ne_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r <> s));
      END_IF;
      ef_gt_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r > s));
      END_IF;
      ef_lt_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r < s));
      END_IF;
      ef_ge_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r >= s));
      END_IF;
      ef_le_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r <= s));
      END_IF;
      ef_abs_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(ABS(r)));
      END_IF;
      ef_max_r : BEGIN  
                        boo := FALSE;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'REAL' IN TYPEOF(vlist[i])
                          THEN
                            IF boo
                            THEN
                              s := vlist[i];
                              IF s > r
                              THEN
                                r := s;
                              END_IF;
                            ELSE
                              r := vlist[i];
                              boo := TRUE;
                            END_IF;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(r));
                        END_IF;
                        IF boo
                        THEN
                          INSERT(vlist, ctmv(r), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_min_r : BEGIN  
                        boo := FALSE;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'REAL' IN TYPEOF(vlist[i])
                          THEN
                            IF boo
                            THEN
                              s := vlist[i];
                              IF s < r
                              THEN
                                r := s;
                              END_IF;
                            ELSE
                              r := vlist[i];
                              boo := TRUE;
                            END_IF;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(r));
                        END_IF;
                        IF boo
                        THEN
                          INSERT(vlist, ctmv(r), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_acos_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(ACOS(r)));
      END_IF;
      ef_asin_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(ASIN(r)));
      END_IF;
      ef_atan2_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(atan2(r, s)));
      END_IF;
      ef_cos_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(COS(r)));
      END_IF;
      ef_exp_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(EXP(r)));
      END_IF;
      ef_ln_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(LOG(r)));
      END_IF;
      ef_log2_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(LOG2(r)));
      END_IF;
      ef_log10_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(LOG10(r)));
      END_IF;
      ef_sin_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(SIN(r)));
      END_IF;
      ef_sqrt_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(SQRT(r)));
      END_IF;
      ef_tan_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(TAN(r)));
      END_IF;
      ef_form_c : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(makec(r, s));
      END_IF;
      ef_rpart_c : IF cnlit IN TYPEOF(v1)
      THEN
        RETURN(ctmv(v1\complex_number_literal.real_part));
      END_IF;
      ef_ipart_c : IF cnlit IN TYPEOF(v1)
      THEN
        RETURN(ctmv(v1\complex_number_literal.imag_part));
      END_IF;
      ef_negate_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(makec(-p, -q));
      END_IF;
      ef_reciprocal_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        t := p * p + q * q;
        RETURN(makec(p / t, -q / t));
      END_IF;
      ef_add_c : BEGIN  
                        p := 0.0;
                        q := 0.0;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF cnlit IN TYPEOF(vlist[i])
                          THEN
                            parts(vlist[i], r, s);
                            p := p + r;
                            q := q + s;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(makec(p, q));
                        END_IF;
                        IF p * p + q * q <> 0.0
                        THEN
                          INSERT(vlist, makec(p, q), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_subtract_c : IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        parts(v2, r, s);
        RETURN(makec(p - r, q - s));
      END_IF;
      ef_multiply_c : BEGIN  
                             p := 1.0;
                             q := 0.0;
                             REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                               IF cnlit IN TYPEOF(vlist[i])
                               THEN
                                 parts(vlist[i], r, s);
                                 p := p * r - q * s;
                                 q := p * s + q * r;
                                 REMOVE(vlist, i);
                               END_IF;
                             END_REPEAT;
                             IF SIZEOF(vlist) = 0
                             THEN
                               RETURN(makec(p, q));
                             END_IF;
                             IF (p <> 1.0) OR (q <> 0.0)
                             THEN
                               INSERT(vlist, makec(p, q), 0);
                             END_IF;
                             IF SIZEOF(vlist) = 1
                             THEN
                               RETURN(vlist[1]);
                             END_IF;
      END;
      ef_divide_c : IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        parts(v2, r, s);
        t := r * r + s * s;
        RETURN(makec((p * r + q * s) / t, (q * r - p * s) / t));
      END_IF;
      ef_exponentiate_c : IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        parts(v2, r, s);
        t := 0.5 * LOG(p * p + q * q);
        u := atan2(q, p);
        p := r * t - s * u;
        q := r * u + s * t;
        r := EXP(p);
        RETURN(makec(r * COS(q), r * SIN(q)));
      END_IF;
      ef_exponentiate_ci : IF (cnlit IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        k := v2;
        r := 1.0;
        s := 0.0;
        REPEAT i := 1 TO ABS(k);
          r := p * r - q * s;
          s := p * s + q * r;
        END_REPEAT;
        IF k < 0
        THEN
          t := r * r + s * s;
          r := r / t;
          s := -s / t;
        END_IF;
        RETURN(makec(r, s));
      END_IF;
      ef_eq_c : IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        parts(v2, r, s);
        RETURN(ctmv((p = r) AND (q = s)));
      END_IF;
      ef_ne_c : IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        parts(v2, r, s);
        RETURN(ctmv((p <> r) OR (q <> s)));
      END_IF;
      ef_conjugate_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(makec(p, -q));
      END_IF;
      ef_abs_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(ctmv(SQRT(p * p + q * q)));
      END_IF;
      ef_arg_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(ctmv(atan2(q, p)));
      END_IF;
      ef_cos_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        t := 0.5 * EXP(-q);
        u := 0.5 * EXP(q);
        RETURN(makec((t + u) * COS(p), (t - u) * SIN(p)));
      END_IF;
      ef_exp_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(makec(EXP(p) * COS(q), EXP(p) * SIN(q)));
      END_IF;
      ef_ln_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(makec(0.5 * LOG(p * p + q * q), atan2(q, p)));
      END_IF;
      ef_sin_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        t := 0.5 * EXP(-q);
        u := 0.5 * EXP(q);
        RETURN(makec((t + u) * SIN(p), (u - t) * COS(p)));
      END_IF;
      ef_sqrt_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        t := SQRT(SQRT(p * p + q * q));
        u := 0.5 * atan2(q, p);
        RETURN(makec(t * COS(u), t * SIN(u)));
      END_IF;
      ef_tan_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        t := EXP(2.0 * q) + EXP(-2.0 * q) + 2.0 * COS(2.0 * p);
        RETURN(makec(2.0 * SIN(2.0 * p) / t, (EXP(-2.0 * q) - EXP(2.0 * q)) / t));
      END_IF;
      ef_subscript_s : IF ('STRING' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        str := v1;
        k := v2;
        RETURN(ctmv(str[k]));
      END_IF;
      ef_eq_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str = st2));
      END_IF;
      ef_ne_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str <> st2));
      END_IF;
      ef_gt_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str > st2));
      END_IF;
      ef_lt_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str < st2));
      END_IF;
      ef_ge_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str >= st2));
      END_IF;
      ef_le_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str <= st2));
      END_IF;
      ef_subsequence_s : IF ('STRING' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) AND ('INTEGER' IN TYPEOF(v3))
      THEN
        str := v1;
        j := v2;
        k := v3;
        RETURN(ctmv(str[j:k]));
      END_IF;
      ef_concat_s : BEGIN  
                           str := '';
                           REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                             IF 'STRING' IN TYPEOF(vlist[i])
                             THEN
                               st2 := vlist[i];
                               str := str + st2;
                               REMOVE(vlist, i);
                             ELSE
                               IF str <> ''
                               THEN
                                 INSERT(vlist, ctmv(str), i);
                                 str := '';
                               END_IF;
                             END_IF;
                           END_REPEAT;
                           IF SIZEOF(vlist) = 0
                           THEN
                             RETURN(ctmv(str));
                           END_IF;
                           IF str <> ''
                           THEN
                             INSERT(vlist, ctmv(str), 0);
                           END_IF;
                           IF SIZEOF(vlist) = 1
                           THEN
                             RETURN(vlist[1]);
                           END_IF;
      END;
      ef_size_s : IF 'STRING' IN TYPEOF(v1)
      THEN
        str := v1;
        RETURN(ctmv(LENGTH(str)));
      END_IF;
      ef_format : IF ('NUMBER' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        RETURN(ctmv(FORMAT(v1, v2)));
      END_IF;
      ef_value : IF 'STRING' IN TYPEOF(v1)
      THEN
        str := v1;
        RETURN(ctmv(VALUE(str)));
      END_IF;
      ef_like : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        RETURN(ctmv(v1 LIKE v2));
      END_IF;
      ef_subscript_b : IF ('BINARY' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        bin := v1;
        k := v2;
        RETURN(ctmv(bin[k]));
      END_IF;
      ef_eq_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin = bi2));
      END_IF;
      ef_ne_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin <> bi2));
      END_IF;
      ef_gt_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin > bi2));
      END_IF;
      ef_lt_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin < bi2));
      END_IF;
      ef_ge_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin >= bi2));
      END_IF;
      ef_le_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin <= bi2));
      END_IF;
      ef_subsequence_b : IF ('BINARY' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) AND ('INTEGER' IN TYPEOF(v3))
      THEN
        bin := v1;
        j := v2;
        k := v3;
        RETURN(ctmv(bin[j:k]));
      END_IF;
      ef_concat_b : BEGIN  
                           boo := FALSE;
                           REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                             IF 'BINARY' IN TYPEOF(vlist[i])
                             THEN
                               IF boo
                               THEN
                                 bi2 := vlist[i];
                                 bin := bin + bi2;
                               ELSE
                                 bin := vlist[i];
                                 boo := TRUE;
                               END_IF;
                               REMOVE(vlist, i);
                             ELSE
                               IF boo
                               THEN
                                 INSERT(vlist, ctmv(bin), i);
                                 boo := FALSE;
                               END_IF;
                             END_IF;
                           END_REPEAT;
                           IF SIZEOF(vlist) = 0
                           THEN
                             RETURN(ctmv(bin));
                           END_IF;
                           IF boo
                           THEN
                             INSERT(vlist, ctmv(bin), 0);
                           END_IF;
                           IF SIZEOF(vlist) = 1
                           THEN
                             RETURN(vlist[1]);
                           END_IF;
      END;
      ef_size_b : IF 'BINARY' IN TYPEOF(v1)
      THEN
        bin := v1;
        RETURN(ctmv(BLENGTH(bin)));
      END_IF;
      ef_subscript_t : IF ('LIST' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        tpl := v1;
        k := v2;
        RETURN(ctmv(tpl[k]));
      END_IF;
      ef_eq_t : IF ('LIST' IN TYPEOF(v1)) AND ('LIST' IN TYPEOF(v2))
      THEN
        lgc := equal_maths_values(v1, v2);
        IF lgc <> UNKNOWN
        THEN
          RETURN(ctmv(lgc));
        END_IF;
      END_IF;
      ef_ne_t : IF ('LIST' IN TYPEOF(v1)) AND ('LIST' IN TYPEOF(v2))
      THEN
        lgc := equal_maths_values(v1, v2);
        IF lgc <> UNKNOWN
        THEN
          RETURN(ctmv(NOT lgc));
        END_IF;
      END_IF;
      ef_concat_t : BEGIN  
                           tpl := [];
                           REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                             IF 'STRING' IN TYPEOF(vlist[i])
                             THEN
                               tp2 := vlist[i];
                               tpl := tpl + tp2;
                               REMOVE(vlist, i);
                             ELSE
                               IF SIZEOF(tpl) <> 0
                               THEN
                                 INSERT(vlist, ctmv(tpl), i);
                                 tpl := [];
                               END_IF;
                             END_IF;
                           END_REPEAT;
                           IF SIZEOF(vlist) = 0
                           THEN
                             RETURN(ctmv(tpl));
                           END_IF;
                           IF SIZEOF(tpl) <> 0
                           THEN
                             INSERT(vlist, ctmv(tpl), 0);
                           END_IF;
                           IF SIZEOF(vlist) = 1
                           THEN
                             RETURN(vlist[1]);
                           END_IF;
      END;
      ef_size_t : IF 'LIST' IN TYPEOF(v1)
      THEN
        tpl := v1;
        RETURN(ctmv(SIZEOF(tpl)));
      END_IF;
      ef_entuple : RETURN(ctmv(vlist));
      ef_detuple : IF 'LIST' IN TYPEOF(v1)
      THEN
        tpl := v1;
        RETURN(ctmv(tpl[1]));
      END_IF;
      ef_insert : IF ('LIST' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v3))
      THEN
        tpl := v1;
        k := v3;
        INSERT(tpl, v2, k);
        RETURN(ctmv(tpl));
      END_IF;
      ef_remove : IF ('LIST' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        tpl := v1;
        k := v2;
        REMOVE(tpl, k);
        RETURN(ctmv(tpl));
      END_IF;
      ef_sum_it : IF good_t(v1, 'INTEGER')
      THEN
        tpl := v1;
        j := 0;
        REPEAT i := 1 TO SIZEOF(tpl);
          j := j + tpl[i];
        END_REPEAT;
        RETURN(ctmv(j));
      END_IF;
      ef_product_it : IF good_t(v1, 'INTEGER')
      THEN
        tpl := v1;
        j := 1;
        REPEAT i := 1 TO SIZEOF(tpl);
          j := j * tpl[i];
        END_REPEAT;
        RETURN(ctmv(j));
      END_IF;
      ef_add_it : BEGIN  
                         boo := FALSE;
                         REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                           IF good_t(vlist[i], 'INTEGER')
                           THEN
                             IF NOT boo
                             THEN
                               tpl := vlist[i];
                               boo := TRUE;
                             ELSE
                               tp2 := vlist[i];
                               IF SIZEOF(tpl) <> SIZEOF(tp2)
                               THEN
                                 RETURN(?);
                               END_IF;
                               REPEAT l := 1 TO SIZEOF(tpl);
                                 tpl[j] := tpl[j] + tp2[j];
                               END_REPEAT;
                             END_IF;
                             REMOVE(vlist, i);
                           END_IF;
                         END_REPEAT;
                         IF SIZEOF(vlist) = 0
                         THEN
                           RETURN(ctmv(tpl));
                         END_IF;
                         IF boo
                         THEN
                           INSERT(vlist, ctmv(tpl), 0);
                         END_IF;
                         IF SIZEOF(vlist) = 1
                         THEN
                           RETURN(vlist[1]);
                         END_IF;
      END;
      ef_subtract_it : IF good_t(v1, 'INTEGER') AND good_t(v2, 'INTEGER')
      THEN
        tpl := v1;
        tp2 := v2;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          tpl[i] := tpl[i] - tp2[i];
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_scalar_mult_it : IF ('INTEGER' IN TYPEOF(v1)) AND good_t(v2, 'INTEGER')
      THEN
        j := v1;
        tpl := v2;
        REPEAT i := 1 TO SIZEOF(tpl);
          tpl[i] := j * tpl[i];
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_dot_prod_it : IF good_t(v1, 'INTEGER') AND good_t(v2, 'INTEGER')
      THEN
        tpl := v1;
        tp2 := v2;
        j := 0;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          j := j + tpl[i] * tp2[i];
        END_REPEAT;
        RETURN(ctmv(j));
      END_IF;
      ef_sum_rt : IF good_t(v1, 'REAL')
      THEN
        tpl := v1;
        r := 0.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          r := r + tpl[i];
        END_REPEAT;
        RETURN(ctmv(r));
      END_IF;
      ef_product_rt : IF good_t(v1, 'REAL')
      THEN
        tpl := v1;
        r := 1.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          r := r * tpl[i];
        END_REPEAT;
        RETURN(ctmv(r));
      END_IF;
      ef_add_rt : BEGIN  
                         boo := FALSE;
                         REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                           IF good_t(vlist[i], 'REAL')
                           THEN
                             IF NOT boo
                             THEN
                               tpl := vlist[i];
                               boo := TRUE;
                             ELSE
                               tp2 := vlist[i];
                               IF SIZEOF(tpl) <> SIZEOF(tp2)
                               THEN
                                 RETURN(?);
                               END_IF;
                               REPEAT l := 1 TO SIZEOF(tpl);
                                 tpl[j] := tpl[j] + tp2[j];
                               END_REPEAT;
                             END_IF;
                             REMOVE(vlist, i);
                           END_IF;
                         END_REPEAT;
                         IF SIZEOF(vlist) = 0
                         THEN
                           RETURN(ctmv(tpl));
                         END_IF;
                         IF boo
                         THEN
                           INSERT(vlist, ctmv(tpl), 0);
                         END_IF;
                         IF SIZEOF(vlist) = 1
                         THEN
                           RETURN(vlist[1]);
                         END_IF;
      END;
      ef_subtract_rt : IF good_t(v1, 'REAL') AND good_t(v2, 'REAL')
      THEN
        tpl := v1;
        tp2 := v2;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          tpl[i] := tpl[i] - tp2[i];
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_scalar_mult_rt : IF ('REAL' IN TYPEOF(v1)) AND good_t(v2, 'REAL')
      THEN
        r := v1;
        tpl := v2;
        REPEAT i := 1 TO SIZEOF(tpl);
          tpl[i] := r * tpl[i];
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_dot_prod_rt : IF good_t(v1, 'REAL') AND good_t(v2, 'REAL')
      THEN
        tpl := v1;
        tp2 := v2;
        r := 0;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          r := r + tpl[i] * tp2[i];
        END_REPEAT;
        RETURN(ctmv(r));
      END_IF;
      ef_norm_rt : IF good_t(v1, 'REAL')
      THEN
        tpl := v1;
        r := 0.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          r := r + tpl[i] * tpl[i];
        END_REPEAT;
        RETURN(ctmv(SQRT(r)));
      END_IF;
      ef_sum_ct : IF good_t(v1, cnlit)
      THEN
        tpl := v1;
        p := 0.0;
        q := 0.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], r, s);
          p := p + r;
          q := q + s;
        END_REPEAT;
        RETURN(makec(p, q));
      END_IF;
      ef_product_ct : IF good_t(v1, cnlit)
      THEN
        tpl := v1;
        p := 1.0;
        q := 0.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], r, s);
          p := p * r - q * s;
          q := p * s + q * r;
        END_REPEAT;
        RETURN(makec(p, q));
      END_IF;
      ef_add_ct : BEGIN  
                         boo := FALSE;
                         REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                           IF good_t(vlist[i], cnlit)
                           THEN
                             IF NOT boo
                             THEN
                               tpl := vlist[i];
                               boo := TRUE;
                             ELSE
                               tp2 := vlist[i];
                               IF SIZEOF(tpl) <> SIZEOF(tp2)
                               THEN
                                 RETURN(?);
                               END_IF;
                               REPEAT l := 1 TO SIZEOF(tpl);
                                 parts(tpl[j], p, q);
                                 parts(tp2[j], r, s);
                                 tpl[j] := makec(p + r, q + s);
                               END_REPEAT;
                             END_IF;
                             REMOVE(vlist, i);
                           END_IF;
                         END_REPEAT;
                         IF SIZEOF(vlist) = 0
                         THEN
                           RETURN(ctmv(tpl));
                         END_IF;
                         IF boo
                         THEN
                           INSERT(vlist, ctmv(tpl), 0);
                         END_IF;
                         IF SIZEOF(vlist) = 1
                         THEN
                           RETURN(vlist[1]);
                         END_IF;
      END;
      ef_subtract_ct : IF good_t(v1, cnlit) AND good_t(v2, cnlit)
      THEN
        tpl := v1;
        tp2 := v2;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], p, q);
          parts(tp2[i], r, s);
          tpl[i] := makec(p - r, q - s);
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_scalar_mult_ct : IF (cnlit IN TYPEOF(v1)) AND good_t(v2, cnlit)
      THEN
        parts(v1, p, q);
        tpl := v2;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], r, s);
          tpl[i] := makec(p * r - q * s, p * s + q * r);
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_dot_prod_ct : IF good_t(v1, cnlit) AND good_t(v2, cnlit)
      THEN
        tpl := v1;
        tp2 := v2;
        t := 0.0;
        u := 0.0;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], p, q);
          parts(tp2[i], r, s);
          t := t + p * r + q * s;
          u := u + q * r - p * s;
        END_REPEAT;
        RETURN(makec(t, u));
      END_IF;
      ef_norm_ct : IF good_t(v1, cnlit)
      THEN
        tpl := v1;
        r := 0.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], p, q);
          r := r + p * p + q * q;
        END_REPEAT;
        RETURN(ctmv(SQRT(r)));
      END_IF;
      ef_if, ef_if_i, ef_if_r, ef_if_c, ef_if_s, ef_if_b, ef_if_t : IF 'LOGICAL' IN TYPEOF(v1)
      THEN
        lgc := v1;
        IF lgc
        THEN
          RETURN(v2);
        ELSE
          RETURN(v3);
        END_IF;
      END_IF;
      ef_ensemble : RETURN(make_finite_space(mem + vlist));
      ef_member_of : IF (schema_prefix + 'MATHS_SPACE') IN TYPEOF(v2)
      THEN
        lgc := member_of(v1, v2);
        IF lgc <> UNKNOWN
        THEN
          RETURN(ctmv(lgc));
        END_IF;
      END_IF;
    END_CASE;
    RETURN(make_function_application(expr.func, vlist));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN types
  THEN
    gexpr := substitute(expr.func\abstracted_expression_function.expr, expr.func\quantifier_expression.variables,
                        vlist);
    RETURN(simplify_generic_expression(gexpr));
  END_IF;
  IF 'FINITE_FUNCTION' IN types
  THEN
    pairs := expr.func\finite_function.pairs;
    REPEAT i := 1 TO SIZEOF(pairs);
      IF equal_maths_values(vlist[1], pairs[i][1])
      THEN
        RETURN(simplify_maths_value(pairs[i][2]));
      END_IF;
    END_REPEAT;
    RETURN(make_function_application(expr.func, vlist));
  END_IF;
  RETURN(expr);
END_FUNCTION;

(* "simplify_generic_expression" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION simplify_generic_expression(expr : generic_expression) : maths_value;
FUNCTION restore_unary(expr : unary_generic_expression;
                       opnd : generic_expression) : generic_expression;
  expr.operand := opnd;
  RETURN(expr);
END_FUNCTION;
FUNCTION restore_binary(expr : binary_generic_expression;
                        opd1 : generic_expression;
                        opd2 : generic_expression) : generic_expression;
  expr.operands[1] := opd1;
  expr.operands[2] := opd2;
  RETURN(expr);
END_FUNCTION;
FUNCTION restore_mulary(expr : multiple_arity_generic_expression;
                        ops : LIST OF generic_expression) : generic_expression;
  expr.operands := ops;
  RETURN(expr);
END_FUNCTION;
FUNCTION make_number_literal(nmb : NUMBER) : generic_literal;
  IF 'INTEGER' IN TYPEOF(nmb)
  THEN
    RETURN(make_int_literal(nmb));
  END_IF;
  RETURN(make_real_literal(nmb));
END_FUNCTION;
LOCAL
  types  : SET OF STRING                      := stripped_typeof(expr);
  v1     : maths_value;
  v2     : maths_value;
  vlist  : LIST OF maths_value                := [];
  op1    : generic_expression;
  op2    : generic_expression;
  oplist : LIST OF generic_expression         := [];
  opnds  : LIST [2 : ?] OF generic_expression;
  n      : INTEGER;
  m      : INTEGER;
  finfun : maths_function_select;
  boo    : BOOLEAN;
  str    : STRING;
  nmb    : NUMBER;
END_LOCAL;
  -- Unwrap the elementary kinds of literals
  IF 'INT_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\int_literal.the_value));
  END_IF;
  IF 'REAL_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\real_literal.the_value));
  END_IF;
  IF 'BOOLEAN_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\boolean_literal.the_value));
  END_IF;
  IF 'STRING_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\string_literal.the_value));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN types
  THEN
    RETURN(expr);
  END_IF;
  IF 'LOGICAL_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\logical_literal.lit_value));
  END_IF;
  IF 'BINARY_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\binary_literal.lit_value));
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN types
  THEN
    RETURN(expr\maths_enum_literal.lit_value);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\real_tuple_literal.lit_value));
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\integer_tuple_literal.lit_value));
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN types
  THEN
    RETURN(expr\atom_based_literal.lit_value);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\maths_tuple_literal.lit_value));
  END_IF;
  -- Simplify one special class of literals
  IF 'MATHS_SPACE' IN types
  THEN
    RETURN(simplify_maths_space(expr));
  END_IF;
  -- Simplify one special kind of expression
  IF 'FUNCTION_APPLICATION' IN types
  THEN
    RETURN(simplify_function_application(expr));
  END_IF;
  -- Separate and simplify the operands
  IF 'UNARY_GENERIC_EXPRESSION' IN types
  THEN
    v1 := simplify_generic_expression(expr\unary_generic_expression.operand);
    op1 := convert_to_operand(v1);
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types
  THEN
    v1 := simplify_generic_expression(expr\binary_generic_expression.operands[1]);
    op1 := convert_to_operand(v1);
    v2 := simplify_generic_expression(expr\binary_generic_expression.operands[2]);
    op2 := convert_to_operand(v2);
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types
  THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF(opnds);
      v1 := simplify_generic_expression(opnds[i]);
      INSERT(vlist, v1, i - 1);
      INSERT(oplist, convert_to_operand(v1), i - 1);
    END_REPEAT;
  END_IF;
  -- Simplify the one kind of maths_function which derives its operands.
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types
  THEN
    v1 := vlist[1];
    n := SIZEOF(vlist);
    finfun := vlist[n];
    REMOVE(vlist, n);
    REMOVE(vlist, 1);
    RETURN(make_parallel_composed_function(v1, vlist, finfun));
  END_IF;
  -- Simplify individual kinds of expressions.  It is not necessary to cover all cases.
  IF ('ABS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(ABS(v1)));
  END_IF;
  IF ('ACOS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(ACOS(v1)));
  END_IF;
  IF 'AND_EXPRESSION' IN types
  THEN
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF(vlist[i])
      THEN
        boo := vlist[i];
        IF NOT boo
        THEN
          RETURN(convert_to_maths_value(FALSE));
        END_IF;
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(TRUE));
    END_IF;
    IF SIZEOF(oplist) = 1
    THEN
      RETURN(oplist[1]);
    END_IF;
  END_IF;
  IF ('ASIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(ASIN(v1)));
  END_IF;
  IF ('ATAN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(ATAN(v1, v2)));
  END_IF;
  IF ('COMPARISON_EXPRESSION' IN types) AND
     ((('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))) OR
      (('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))) OR
      (('BOOLEAN' IN TYPEOF(v1)) AND ('BOOLEAN' IN TYPEOF(v2))))
  THEN
    IF 'COMPARISON_EQUAL' IN types
    THEN
      boo := bool(v1 = v2);
    ELSE
      IF 'COMPARISON_GREATER' IN types
      THEN
        boo := bool(v1 > v2);
      ELSE
        IF 'COMPARISON_GREATER_EQUAL' IN types
        THEN
          boo := bool(v1 >= v2);
        ELSE
          IF 'COMPARISON_LESS' IN types
          THEN
            boo := bool(v1 < v2);
          ELSE
            IF 'COMPARISON_LESS_EQUAL' IN types
            THEN
              boo := bool(v1 <= v2);
            ELSE
              IF 'COMPARISON_NOT_EQUAL' IN types
              THEN
                boo := bool(v1 <> v2);
              ELSE
                IF 'LIKE_EXPRESSION' IN types
                THEN
                  boo := bool(v1 LIKE v2);
                ELSE
                  RETURN(?);
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(convert_to_maths_value(boo));
  END_IF;
  IF 'CONCAT_EXPRESSION' IN types
  THEN
    str := '';
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'STRING' IN TYPEOF(vlist[i])
      THEN
        str := vlist[i] + str;
        REMOVE(oplist, i);
      ELSE
        IF LENGTH(str) > 0
        THEN
          INSERT(oplist, make_string_literal(str), i);
          str := '';
        END_IF;
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(str));
    END_IF;
    IF LENGTH(str) > 0
    THEN
      INSERT(oplist, make_string_literal(str), 0);
    END_IF;
    IF SIZEOF(oplist) = 1
    THEN
      RETURN(oplist[1]);
    END_IF;
  END_IF;
  IF ('COS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(COS(v1)));
  END_IF;
  IF ('DIV_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 DIV v2));
  END_IF;
  IF 'EQUALS_EXPRESSION' IN types
  THEN
    opnds := expr\binary_generic_expression.operands;
    RETURN(convert_to_maths_value(opnds[1] :=: opnds[2]));
  END_IF;
  IF ('EXP_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(EXP(v1)));
  END_IF;
  IF ('FORMAT_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(FORMAT(v1, v2)));
  END_IF;
  IF ('INDEX_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    str := v1;
    n := v2;
    RETURN(convert_to_maths_value(str[n]));
  END_IF;
  IF ('INT_VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(VALUE(v1)));
  END_IF;
  IF 'INTERVAL_EXPRESSION' IN types
  THEN
    str := '';
    IF 'NUMBER' IN TYPEOF(vlist[1])
    THEN
      str := 'NUMBER';
    END_IF;
    IF 'STRING' IN TYPEOF(vlist[1])
    THEN
      str := 'STRING';
    END_IF;
    IF 'BOOLEAN' IN TYPEOF(vlist[1])
    THEN
      str := 'BOOLEAN';
    END_IF;
    IF (LENGTH(str) > 0) AND (str IN TYPEOF(vlist[2])) AND (str IN TYPEOF(vlist[3]))
    THEN
      RETURN(convert_to_maths_value({vlist[1] <= vlist[2] <= vlist[3]}));
    END_IF;
  END_IF;
  IF ('LENGTH_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(LENGTH(v1)));
  END_IF;
  IF ('LOG_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(LOG(v1)));
  END_IF;
  IF ('LOG10_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(LOG10(v1)));
  END_IF;
  IF ('LOG2_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(LOG2(v1)));
  END_IF;
  IF 'MAXIMUM_EXPRESSION' IN types
  THEN
    boo := FALSE;
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF(vlist[i])
      THEN
        IF boo
        THEN
          IF nmb < vlist[i]
          THEN
            nmb := vlist[i];
          END_IF;
        ELSE
          nmb := vlist[i];
          boo := TRUE;
        END_IF;
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(nmb));
    END_IF;
    IF boo
    THEN
      INSERT(oplist, make_number_literal(nmb), 0);
    END_IF;
  END_IF;
  IF 'MINIMUM_EXPRESSION' IN types
  THEN
    boo := FALSE;
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF(vlist[i])
      THEN
        IF boo
        THEN
          IF nmb > vlist[i]
          THEN
            nmb := vlist[i];
          END_IF;
        ELSE
          nmb := vlist[i];
          boo := TRUE;
        END_IF;
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(nmb));
    END_IF;
    IF boo
    THEN
      INSERT(oplist, make_number_literal(nmb), 0);
    END_IF;
  END_IF;
  IF ('MINUS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 - v2));
  END_IF;
  IF ('MOD_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 MOD v2));
  END_IF;
  IF 'MULT_EXPRESSION' IN types
  THEN
    nmb := 1;
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF(vlist[i])
      THEN
        nmb := nmb * vlist[i];
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(nmb));
    END_IF;
    IF nmb <> 1
    THEN
      INSERT(oplist, make_number_literal(nmb), 0);
    END_IF;
    IF SIZEOF(oplist) = 1
    THEN
      RETURN(oplist[1]);
    END_IF;
  END_IF;
  IF ('NOT_EXPRESSION' IN types) AND ('BOOLEAN' IN TYPEOF(v1))
  THEN
    boo := v1;
    RETURN(convert_to_maths_value(NOT (boo)));
  END_IF;
  IF ('ODD_EXPRESSION' IN types) AND ('INTEGER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(ODD(v1)));
  END_IF;
  IF 'OR_EXPRESSION' IN types
  THEN
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF(vlist[i])
      THEN
        boo := vlist[i];
        IF boo
        THEN
          RETURN(convert_to_maths_value(TRUE));
        END_IF;
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(FALSE));
    END_IF;
    IF SIZEOF(oplist) = 1
    THEN
      RETURN(oplist[1]);
    END_IF;
  END_IF;
  IF 'PLUS_EXPRESSION' IN types
  THEN
    nmb := 0;
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF(vlist[i])
      THEN
        nmb := nmb + vlist[i];
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(nmb));
    END_IF;
    IF nmb <> 0
    THEN
      INSERT(oplist, make_number_literal(nmb), 0);
    END_IF;
    IF SIZEOF(oplist) = 1
    THEN
      RETURN(oplist[1]);
    END_IF;
  END_IF;
  IF ('POWER_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 ** v2));
  END_IF;
  IF ('SIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(SIN(v1)));
  END_IF;
  IF ('SLASH_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 / v2));
  END_IF;
  IF ('SQUARE_ROOT_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(SQRT(v1)));
  END_IF;
  IF ('SUBSTRING_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(vlist[1])) AND ('NUMBER' IN TYPEOF(vlist[2])) AND
     ('NUMBER' IN TYPEOF(vlist[3]))
  THEN
    str := vlist[1];
    n := vlist[2];
    m := vlist[3];
    RETURN(convert_to_maths_value(str[n:m]));
  END_IF;
  IF ('TAN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(TAN(v1)));
  END_IF;
  IF ('UNARY_MINUS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    nmb := v1;
    RETURN(convert_to_maths_value(-nmb));
  END_IF;
  IF ('VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(VALUE(v1)));
  END_IF;
  IF ('XOR_EXPRESSION' IN types) AND ('BOOLEAN' IN TYPEOF(v1)) AND ('BOOLEAN' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 XOR v2));
  END_IF;
  -- No special simplification defined, return same with simplified operands.
  IF 'UNARY_GENERIC_EXPRESSION' IN types
  THEN
    RETURN(restore_unary(expr, op1));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types
  THEN
    RETURN(restore_binary(expr, op1, op2));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types
  THEN
    RETURN(restore_mulary(expr, oplist));
  END_IF;
  -- Should be unreachable, but for safety, return unsimplified expression.
  RETURN(expr);
END_FUNCTION;

(* "simplify_maths_space" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION simplify_maths_space(spc : maths_space) : maths_space;
LOCAL
  stypes   : SET OF STRING       := stripped_typeof(spc);
  sset     : SET OF maths_value;
  zset     : SET OF maths_value  := [];
  zval     : maths_value;
  zspc     : maths_space;
  zallint  : BOOLEAN             := TRUE;
  zint     : INTEGER;
  zmin     : INTEGER;
  zmax     : INTEGER;
  factors  : LIST OF maths_space;
  zfactors : LIST OF maths_space := [];
  rspc     : maths_space;
END_LOCAL;
  IF 'FINITE_SPACE' IN stypes
  THEN
    sset := spc\finite_space.members;
    REPEAT i := 1 TO SIZEOF(sset);
      zval := simplify_maths_value(sset[i]);
      zset := zset + [zval];
      IF zallint AND ('INTEGER' IN TYPEOF(zval))
      THEN
        zint := zval;
        IF i = 1
        THEN
          zmin := zint;
          zmax := zint;
        ELSE
          IF zint < zmin
          THEN
            zmin := zint;
          END_IF;
          IF zint > zmax
          THEN
            zmax := zint;
          END_IF;
        END_IF;
      ELSE
        zallint := FALSE;
      END_IF;
    END_REPEAT;
    IF zallint AND (SIZEOF(zset) = zmax - zmin + 1)
    THEN
      RETURN(make_finite_integer_interval(zmin, zmax));
    END_IF;
    RETURN(make_finite_space(zset));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes
  THEN
    zspc := simplify_maths_space(spc\uniform_product_space.base);
    RETURN(make_uniform_product_space(zspc, spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes
  THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF(factors);
      INSERT(zfactors, simplify_maths_space(factors[i]), i - 1);
    END_REPEAT;
    RETURN(make_listed_product_space(zfactors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes
  THEN
    zspc := simplify_maths_space(spc\extended_tuple_space.base);
    rspc := simplify_maths_space(spc\extended_tuple_space.extender);
    RETURN(make_extended_tuple_space(zspc, rspc));
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes
  THEN
    zspc := simplify_maths_space(spc\function_space.domain_argument);
    rspc := simplify_maths_space(spc\function_space.range_argument);
    RETURN(make_function_space(spc\function_space.domain_constraint, zspc, spc\function_space.range_constraint, rspc));
  END_IF;
  RETURN(spc);
END_FUNCTION;

(* "simplify_maths_value" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION simplify_maths_value(val : maths_value) : maths_value;
LOCAL
  vtypes : SET OF STRING       := stripped_typeof(val);
  vlist  : LIST OF maths_value;
  nlist  : LIST OF maths_value := [];
END_LOCAL;
  IF 'GENERIC_EXPRESSION' IN vtypes
  THEN
    RETURN(simplify_generic_expression(val));
  END_IF;
  IF 'LIST' IN vtypes
  THEN
    vlist := val;
    REPEAT i := 1 TO SIZEOF(vlist);
      INSERT(nlist, simplify_maths_value(vlist[i]), i - 1);
    END_REPEAT;
    RETURN(convert_to_maths_value(nlist));
  END_IF;
  RETURN(val);
END_FUNCTION;

(* "singleton_member_of" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION singleton_member_of(spc : maths_space) : maths_value;
LOCAL
  types : SET OF STRING := stripped_typeof(spc);
END_LOCAL;
  IF 'FINITE_SPACE' IN types
  THEN
    IF SIZEOF(spc\finite_space.members) = 1
    THEN
      RETURN(spc\finite_space.members[1]);
    END_IF;
    RETURN(?);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types
  THEN
    IF spc\finite_integer_interval.size = 1
    THEN
      RETURN(spc\finite_integer_interval.min);
    END_IF;
    RETURN(?);
  END_IF;
  RETURN(?);
END_FUNCTION;

(* "space_dimension" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION space_dimension(tspace : tuple_space) : nonnegative_integer;
LOCAL
  types : SET OF STRING := TYPEOF(tspace);
END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types
  THEN
    RETURN(tspace\uniform_product_space.exponent);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types
  THEN
    RETURN(SIZEOF(tspace\listed_product_space.factors));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types
  THEN
    RETURN(space_dimension(tspace\extended_tuple_space.base));
  END_IF;
  -- Should be unreachable
  RETURN(?);
END_FUNCTION;

(* "space_is_continuum" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION space_is_continuum(space : maths_space) : BOOLEAN;
LOCAL
  typenames : SET OF STRING       := TYPEOF(space);
  factors   : LIST OF maths_space;
END_LOCAL;
  IF NOT EXISTS(space)
  THEN
    RETURN(FALSE);
  END_IF;
  IF subspace_of_es(space, es_reals) OR subspace_of_es(space, es_complex_numbers)
  THEN
    RETURN(TRUE);
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames
  THEN
    RETURN(space_is_continuum(space\uniform_product_space.base));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames
  THEN
    factors := space\listed_product_space.factors;
    IF SIZEOF(factors) = 0
    THEN
      RETURN(FALSE);
    END_IF;
    REPEAT i := 1 TO SIZEOF(factors);
      IF NOT space_is_continuum(factors[i])
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "space_is_singleton" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION space_is_singleton(spc : maths_space) : BOOLEAN;
LOCAL
  types : SET OF STRING := stripped_typeof(spc);
END_LOCAL;
  IF 'FINITE_SPACE' IN types
  THEN
    RETURN(bool(SIZEOF(spc\finite_space.members) = 1));
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types
  THEN
    RETURN(bool(spc\finite_integer_interval.size = 1));
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "stripped_typeof" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION stripped_typeof(arg : GENERIC : G) : SET OF STRING;
LOCAL
  types  : SET OF STRING := TYPEOF(arg);
  stypes : SET OF STRING := [];
  n      : INTEGER       := LENGTH(schema_prefix);
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(types);
    IF types[i][1:n] = schema_prefix
    THEN
      stypes := stypes + types[i][n + 1:LENGTH(types[i])];
    ELSE
      stypes := stypes + types[i];
    END_IF;
  END_REPEAT;
  RETURN(stypes);
END_FUNCTION;

(* "subspace_of" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION subspace_of(space1 : maths_space;
                     space2 : maths_space) : LOGICAL;
LOCAL
  spc1   : maths_space                  := simplify_maths_space(space1);
  spc2   : maths_space                  := simplify_maths_space(space2);
  types1 : SET OF STRING                := stripped_typeof(spc1);
  types2 : SET OF STRING                := stripped_typeof(spc2);
  lgcl   : LOGICAL;
  cum    : LOGICAL;
  es_val : elementary_space_enumerators;
  bnd1   : REAL;
  bnd2   : REAL;
  n      : INTEGER;
  sp1    : maths_space;
  sp2    : maths_space;
  prgn1  : polar_complex_number_region;
  prgn2  : polar_complex_number_region;
  aitv   : finite_real_interval;
END_LOCAL;
  IF NOT EXISTS(spc1) OR NOT EXISTS(spc2)
  THEN
    RETURN(FALSE);
  END_IF;
  IF spc2 = the_generics
  THEN
    RETURN(TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1
  THEN
    IF NOT ('ELEMENTARY_SPACE' IN types2)
    THEN
      RETURN(FALSE);
    END_IF;
    es_val := spc2\elementary_space.space_id;
    IF spc1\elementary_space.space_id = es_val
    THEN
      RETURN(TRUE);
    END_IF;
    CASE spc1\elementary_space.space_id OF
      es_numbers : RETURN(FALSE);
      es_complex_numbers : RETURN(es_val = es_numbers);
      es_reals : RETURN(es_val = es_numbers);
      es_integers : RETURN(es_val = es_numbers);
      es_logicals : RETURN(FALSE);
      es_booleans : RETURN(es_val = es_logicals);
      es_strings : RETURN(FALSE);
      es_binarys : RETURN(FALSE);
      es_maths_spaces : RETURN(FALSE);
      es_maths_functions : RETURN(FALSE);
      es_generics : RETURN(FALSE);
    END_CASE;
    RETURN(UNKNOWN);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types1
  THEN
    cum := TRUE;
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      cum := cum AND member_of(i, spc2);
      IF cum = FALSE
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(cum);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_FROM_MIN' IN types2
    THEN
      RETURN(spc1\integer_interval_from_min.min >= spc2\integer_interval_from_min.min);
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_TO_MAX' IN types2
    THEN
      RETURN(spc1\integer_interval_to_max.max <= spc2\integer_interval_to_max.max);
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR ('REAL_INTERVAL_FROM_MIN' IN types2) OR ('REAL_INTERVAL_TO_MAX' IN types2)
    THEN
      IF min_exists(spc2)
      THEN
        bnd1 := spc1\finite_real_interval.min;
        bnd2 := real_min(spc2);
        IF (bnd1 < bnd2) OR ((bnd1 = bnd2) AND min_included(spc1) AND NOT min_included(spc2))
        THEN
          RETURN(FALSE);
        END_IF;
      END_IF;
      IF max_exists(spc2)
      THEN
        bnd1 := spc1\finite_real_interval.max;
        bnd2 := real_max(spc2);
        IF (bnd1 > bnd2) OR ((bnd1 = bnd2) AND max_included(spc1) AND NOT max_included(spc2))
        THEN
          RETURN(FALSE);
        END_IF;
      END_IF;
      RETURN(TRUE);
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_FROM_MIN' IN types2
    THEN
      bnd1 := spc1\real_interval_from_min.min;
      bnd2 := spc2\real_interval_from_min.min;
      RETURN((bnd2 < bnd1) OR ((bnd2 = bnd1) AND (min_included(spc2) OR NOT min_included(spc1))));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_TO_MAX' IN types2
    THEN
      bnd1 := spc1\real_interval_to_max.max;
      bnd2 := spc2\real_interval_to_max.max;
      RETURN((bnd2 > bnd1) OR ((bnd2 = bnd1) AND (max_included(spc2) OR NOT max_included(spc1))));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2
    THEN
      RETURN(subspace_of(spc1\cartesian_complex_number_region.real_constraint,
                         spc2\cartesian_complex_number_region.real_constraint) AND
             subspace_of(spc1\cartesian_complex_number_region.imag_constraint,
                         spc2\cartesian_complex_number_region.imag_constraint));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2
    THEN
      RETURN(subspace_of(enclose_cregion_in_pregion(spc1, spc2\polar_complex_number_region.centre), spc2));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2
    THEN
      RETURN(subspace_of(enclose_pregion_in_cregion(spc1), spc2));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2
    THEN
      prgn1 := spc1;
      prgn2 := spc2;
      IF prgn1.centre = prgn2.centre
      THEN
        IF prgn2.direction_constraint.max > PI
        THEN
          aitv := make_finite_real_interval(-PI, open, prgn2.direction_constraint.max - 2.0 * PI,
                                            prgn2.direction_constraint.max_closure);
          RETURN(subspace_of(prgn1.distance_constraint, prgn2.distance_constraint) AND
                 (subspace_of(prgn1.direction_constraint, prgn2.direction_constraint) OR
                  subspace_of(prgn1.direction_constraint, aitv)));
        ELSE
          RETURN(subspace_of(prgn1.distance_constraint, prgn2.distance_constraint) AND
                 subspace_of(prgn1.direction_constraint, prgn2.direction_constraint));
        END_IF;
      END_IF;
      RETURN(subspace_of(enclose_pregion_in_pregion(prgn1, prgn2.centre), prgn2));
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types1
  THEN
    cum := TRUE;
    REPEAT i := 1 TO SIZEOF(spc1\finite_space.members);
      cum := cum AND member_of(spc1\finite_space.members[i], spc2);
      IF cum = FALSE
      THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(cum);
  END_IF;
  IF 'PRODUCT_SPACE' IN types1
  THEN
    IF 'PRODUCT_SPACE' IN types2
    THEN
      IF space_dimension(spc1) = space_dimension(spc2)
      THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension(spc1);
          cum := cum AND subspace_of(factor_space(spc1, i), factor_space(spc2, i));
          IF cum = FALSE
          THEN
            RETURN(FALSE);
          END_IF;
        END_REPEAT;
        RETURN(cum);
      END_IF;
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2
    THEN
      IF space_dimension(spc1) >= space_dimension(spc2)
      THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension(spc1);
          cum := cum AND subspace_of(factor_space(spc1, i), factor_space(spc2, i));
          IF cum = FALSE
          THEN
            RETURN(FALSE);
          END_IF;
        END_REPEAT;
        RETURN(cum);
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1
  THEN
    IF 'EXTENDED_TUPLE_SPACE' IN types2
    THEN
      n := space_dimension(spc1);
      IF n < space_dimension(spc2)
      THEN
        n := space_dimension(spc2);
      END_IF;
      cum := TRUE;
      REPEAT i := 1 TO n + 1;
        cum := cum AND subspace_of(factor_space(spc1, i), factor_space(spc2, i));
        IF cum = FALSE
        THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(cum);
    END_IF;
    RETURN(FALSE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      RETURN(spc2\elementary_space.space_id = es_maths_functions);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2
    THEN
      cum := TRUE;
      sp1 := spc1\function_space.domain_argument;
      sp2 := spc2\function_space.domain_argument;
      CASE spc1\function_space.domain_constraint OF
        sc_equal : BEGIN  
                          CASE spc2\function_space.domain_constraint OF
                            sc_equal : cum := cum AND equal_maths_spaces(sp1, sp2);
                            sc_subspace : cum := cum AND subspace_of(sp1, sp2);
                            sc_member : cum := cum AND member_of(sp1, sp2);
                          END_CASE;
        END;
        sc_subspace : BEGIN  
                             CASE spc2\function_space.domain_constraint OF
                               sc_equal : RETURN(FALSE);
                               sc_subspace : cum := cum AND subspace_of(sp1, sp2);
                               sc_member : BEGIN  
                                                  IF NOT member_of(sp1, sp2)
                                                  THEN
                                                    RETURN(FALSE);
                                                  END_IF;
                                                  cum := UNKNOWN;
                               END;
                             END_CASE;
        END;
        sc_member : BEGIN  
                           CASE spc2\function_space.domain_constraint OF
                             sc_equal : cum := cum AND space_is_singleton(sp1) AND
                                               equal_maths_spaces(singleton_member_of(sp1), sp2);
                             sc_subspace : BEGIN  
                                                  IF NOT member_of(sp2, sp1)
                                                  THEN
                                                    RETURN(FALSE);
                                                  END_IF;
                                                  cum := UNKNOWN;
                             END;
                             sc_member : cum := cum AND (subspace_of(sp1, sp2));
                           END_CASE;
        END;
      END_CASE;
      IF cum = FALSE
      THEN
        RETURN(FALSE);
      END_IF;
      sp1 := spc1\function_space.range_argument;
      sp2 := spc2\function_space.range_argument;
      CASE spc1\function_space.range_constraint OF
        sc_equal : BEGIN  
                          CASE spc2\function_space.range_constraint OF
                            sc_equal : cum := cum AND equal_maths_spaces(sp1, sp2);
                            sc_subspace : cum := cum AND subspace_of(sp1, sp2);
                            sc_member : cum := cum AND member_of(sp1, sp2);
                          END_CASE;
        END;
        sc_subspace : BEGIN  
                             CASE spc2\function_space.domain_constraint OF
                               sc_equal : RETURN(FALSE);
                               sc_subspace : cum := cum AND subspace_of(sp1, sp2);
                               sc_member : BEGIN  
                                                  IF NOT member_of(sp1, sp2)
                                                  THEN
                                                    RETURN(FALSE);
                                                  END_IF;
                                                  cum := UNKNOWN;
                               END;
                             END_CASE;
        END;
        sc_member : BEGIN  
                           CASE spc2\function_space.domain_constraint OF
                             sc_equal : cum := cum AND space_is_singleton(sp1) AND
                                               equal_maths_spaces(singleton_member_of(sp1), sp2);
                             sc_subspace : BEGIN  
                                                  IF NOT member_of(sp2, sp1)
                                                  THEN
                                                    RETURN(FALSE);
                                                  END_IF;
                                                  cum := UNKNOWN;
                             END;
                             sc_member : cum := cum AND subspace_of(sp1, sp2);
                           END_CASE;
        END;
      END_CASE;
      RETURN(cum);
    END_IF;
    RETURN(FALSE);
  END_IF;
  -- Should be unreachable
  RETURN(UNKNOWN);
END_FUNCTION;

(* "subspace_of_es" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION subspace_of_es(spc : maths_space;
                        es : elementary_space_enumerators) : LOGICAL;
LOCAL
  types : SET OF STRING := stripped_typeof(spc);
END_LOCAL;
  IF NOT EXISTS(spc) OR NOT EXISTS(es)
  THEN
    RETURN(FALSE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types
  THEN
    RETURN(es_subspace_of_es(spc\elementary_space.space_id, es));
  END_IF;
  IF 'FINITE_SPACE' IN types
  THEN
    RETURN(all_members_of_es(spc\finite_space.members, es));
  END_IF;
  CASE es OF
    es_numbers : RETURN(('FINITE_INTEGER_INTERVAL' IN types) OR ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
                        ('INTEGER_INTERVAL_TO_MAX' IN types) OR ('FINITE_REAL_INTERVAL' IN types) OR
                        ('REAL_INTERVAL_FROM_MIN' IN types) OR ('REAL_INTERVAL_TO_MAX' IN types) OR
                        ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR ('POLAR_COMPLEX_NUMBER_REGION' IN types));
    es_complex_numbers : RETURN(('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR
                                ('POLAR_COMPLEX_NUMBER_REGION' IN types));
    es_reals : RETURN(('FINITE_REAL_INTERVAL' IN types) OR ('REAL_INTERVAL_FROM_MIN' IN types) OR
                      ('REAL_INTERVAL_TO_MAX' IN types));
    es_integers : RETURN(('FINITE_INTEGER_INTERVAL' IN types) OR ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
                         ('INTEGER_INTERVAL_TO_MAX' IN types));
    es_logicals : RETURN(FALSE);
    es_booleans : RETURN(FALSE);
    es_strings : RETURN(FALSE);
    es_binarys : RETURN(FALSE);
    es_maths_spaces : RETURN(FALSE);
    es_maths_functions : RETURN('FUNCTION_SPACE' IN types);
    es_generics : RETURN(TRUE);
  END_CASE;
  RETURN(UNKNOWN);
END_FUNCTION;

(* "substitute" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION substitute(expr : generic_expression;
                    vars : LIST [1 : ?] OF generic_variable;
                    vals : LIST [1 : ?] OF maths_value) : generic_expression;
LOCAL
  types  : SET OF STRING                  := stripped_typeof(expr);
  opnds  : LIST OF generic_expression;
  op1    : generic_expression;
  op2    : generic_expression;
  qvars  : LIST OF generic_variable;
  srcdom : maths_space_or_function;
  prpfun : LIST [1 : ?] OF maths_function;
  finfun : maths_function_select;
END_LOCAL;
  IF SIZEOF(vars) <> SIZEOF(vals)
  THEN
    RETURN(?);
  END_IF;
  IF 'GENERIC_LITERAL' IN types
  THEN
    RETURN(expr);
  END_IF;
  IF 'GENERIC_VARIABLE' IN types
  THEN
    REPEAT i := 1 TO SIZEOF(vars);
      IF expr :=: vars[i]
      THEN
        RETURN(vals[i]);
      END_IF;
    END_REPEAT;
    RETURN(expr);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN types
  THEN
    qvars := expr\quantifier_expression.variables;
    REPEAT i := SIZEOF(vars) TO 1 BY -1;
      IF vars[i] IN qvars
      THEN
        REMOVE(vars, i);
        REMOVE(vals, i);
      END_IF;
    END_REPEAT;
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF(opnds);
      IF NOT (opnds[i] IN qvars)
      THEN
        expr\multiple_arity_generic_expression.operands[i] := substitute(opnds[i], vars, vals);
      END_IF;
    END_REPEAT;
    RETURN(expr);
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN types
  THEN
    op1 := expr\unary_generic_expression.operand;
    expr\unary_generic_expression.operand := substitute(op1, vars, vals);
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types
  THEN
    op1 := expr\binary_generic_expression.operands[1];
    expr\binary_generic_expression.operands[1] := substitute(op1, vars, vals);
    op2 := expr\binary_generic_expression.operands[2];
    expr\binary_generic_expression.operands[2] := substitute(op2, vars, vals);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types
  THEN
    srcdom := expr\parallel_composed_function.source_of_domain;
    prpfun := expr\parallel_composed_function.prep_functions;
    finfun := expr\parallel_composed_function.final_function;
    srcdom := substitute(srcdom, vars, vals);
    REPEAT i := 1 TO SIZEOF(prpfun);
      prpfun[i] := substitute(prpfun[i], vars, vals);
    END_REPEAT;
    IF 'MATHS_FUNCTION' IN stripped_typeof(finfun)
    THEN
      finfun := substitute(finfun, vars, vals);
    END_IF;
    RETURN(make_parallel_composed_function(srcdom, prpfun, finfun));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types
  THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF(opnds);
      expr\multiple_arity_generic_expression.operands[i] := substitute(opnds[i], vars, vals);
    END_REPEAT;
  END_IF;
  RETURN(expr);
END_FUNCTION;

(* "surface_weights_positive" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION surface_weights_positive(b : rational_b_spline_surface) : BOOLEAN;
LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
  REPEAT i := 0 TO b.u_upper;
    REPEAT j := 0 TO b.v_upper;
      IF (b.weights[i][j] <= 0.0)
      THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

(* "topology_reversed" IMPLICIT from SCHEMA topology_schema *)
FUNCTION topology_reversed(an_item : reversible_topology) : reversible_topology;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EDGE' IN TYPEOF(an_item))
  THEN
    RETURN(edge_reversed(an_item));
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PATH' IN TYPEOF(an_item))
  THEN
    RETURN(path_reversed(an_item));
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FACE_BOUND' IN TYPEOF(an_item))
  THEN
    RETURN(face_bound_reversed(an_item));
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FACE' IN TYPEOF(an_item))
  THEN
    RETURN(face_reversed(an_item));
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SHELL' IN TYPEOF(an_item))
  THEN
    RETURN(shell_reversed(an_item));
  END_IF;
  IF ('SET' IN TYPEOF(an_item))
  THEN
    RETURN(set_of_topology_reversed(an_item));
  END_IF;
  IF ('LIST' IN TYPEOF(an_item))
  THEN
    RETURN(list_of_topology_reversed(an_item));
  END_IF;
  RETURN(?);
END_FUNCTION;

(* "type_check_function" IMPLICIT from SCHEMA support_resource_schema *)
FUNCTION type_check_function(the_type : GENERIC;
                             sub_names : SET OF STRING;
                             criterion : INTEGER) : LOGICAL;
  IF ((NOT EXISTS(the_type)) OR (SIZEOF(sub_names) = 0))
  THEN
    RETURN(UNKNOWN);
  ELSE
    CASE criterion OF
      0 : RETURN(SIZEOF(sub_names * TYPEOF(the_type)) > 0);
      1 : RETURN(SIZEOF(sub_names * TYPEOF(the_type)) = 0);
      2 : RETURN(SIZEOF(sub_names * TYPEOF(the_type)) = 1);
      3 : RETURN(SIZEOF(sub_names * TYPEOF(the_type)) <= 1);
      OTHERWISE: RETURN(UNKNOWN);
    END_CASE;
  END_IF;
END_FUNCTION;

(* "unambiguously_specified_multi_level_reference_designator" IMPLICIT from SCHEMA product_structure_schema *)
FUNCTION unambiguously_specified_multi_level_reference_designator(links : LIST [1 : ?] OF next_assembly_usage_occurrence) : BOOLEAN;
  REPEAT i := 1 TO SIZEOF(links) - 1;
    CASE TRUE OF
      ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION' IN
       TYPEOF(links[i]\product_definition_relationship.relating_product_definition)) AND
      ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION' IN
       TYPEOF(links[i]\product_definition_relationship.related_product_definition)) AND
      ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION' IN
       TYPEOF(links[i + 1]\product_definition_relationship.relating_product_definition)) : BEGIN  
                                                                                                  IF NOT ((links[i]\product_definition_relationship.related_product_definition :=:
                                                                                                           links[i +
                                                                                                                 1]\product_definition_relationship.relating_product_definition) OR
                                                                                                          ((SIZEOF(QUERY(pdr
                                                                                                                         <* USEDIN(links[i]\product_definition_relationship.related_product_definition,
                                                                                                                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                                                                                                                         | pdr\product_definition_relationship.relating_product_definition :=:
                                                                                                                           links[i +
                                                                                                                                 1]\product_definition_relationship.relating_product_definition)) =
                                                                                                            1) AND
                                                                                                           (links[i]\product_definition_relationship.related_product_definition\product_definition.formation\product_definition_formation.of_product :=:
                                                                                                            links[i +
                                                                                                                  1]\product_definition_relationship.relating_product_definition\product_definition.formation\product_definition_formation.of_product)))
                                                                                                  THEN
                                                                                                    RETURN(FALSE);
                                                                                                  END_IF;
      END;
      ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION_REFERENCE' IN
       TYPEOF(links[i]\product_definition_relationship.related_product_definition)) AND
      ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION_REFERENCE' IN
       TYPEOF(links[i + 1]\product_definition_relationship.relating_product_definition)) : BEGIN  
                                                                                                  IF NOT ((links[i]\product_definition_relationship.related_product_definition :=:
                                                                                                           links[i +
                                                                                                                 1]\product_definition_relationship.relating_product_definition) OR
                                                                                                          ((SIZEOF(QUERY(pdr
                                                                                                                         <* USEDIN(links[i]\product_definition_relationship.related_product_definition,
                                                                                                                                   'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                                                                                                                         | pdr\product_definition_relationship.relating_product_definition :=:
                                                                                                                           links[i +
                                                                                                                                 1]\product_definition_relationship.relating_product_definition)) =
                                                                                                            1) AND
                                                                                                           (links[i]\product_definition_relationship.related_product_definition\product_definition_reference.product_id =
                                                                                                            links[i +
                                                                                                                  1]\product_definition_relationship.relating_product_definition\product_definition_reference.product_id) AND
                                                                                                           (links[i]\product_definition_relationship.related_product_definition\product_definition_reference.id_owning_organization_name =
                                                                                                            links[i +
                                                                                                                  1]\product_definition_relationship.relating_product_definition\product_definition_reference.id_owning_organization_name) AND
                                                                                                           (links[i]\product_definition_relationship.related_product_definition\product_definition_reference.product_definition_id <>
                                                                                                            links[i +
                                                                                                                  1]\product_definition_relationship.relating_product_definition\product_definition_reference.product_definition_id)))
                                                                                                  THEN
                                                                                                    RETURN(FALSE);
                                                                                                  END_IF;
      END;
      ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION_REFERENCE' IN
       TYPEOF(links[i]\product_definition_relationship.relating_product_definition)) AND
      ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_DEFINITION' IN
       TYPEOF(links[i]\product_definition_relationship.related_product_definition)) : RETURN(FALSE);
      OTHERWISE: RETURN(FALSE);
    END_CASE;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

(* "using_items" IMPLICIT from SCHEMA representation_schema *)
FUNCTION using_items(item : founded_item_select;
                     checked_items : SET OF founded_item_select) : SET OF founded_item_select;
LOCAL
  new_check_items : SET OF founded_item_select;
  result_items    : SET OF founded_item_select;
  next_items      : SET OF founded_item_select;
END_LOCAL;
  result_items := [];
  new_check_items := checked_items + item;
  -- Find the set of representation_items or founded_items
  -- in which item is used directly.
  next_items := QUERY(z
                      <* bag_to_set(USEDIN(item, ''))
                      | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
                        ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FOUNDED_ITEM' IN TYPEOF(z)));
  -- If the set of next_items is not empty;
  IF SIZEOF(next_items) > 0
  THEN
    REPEAT i := 1 TO HIINDEX(next_items);
      IF NOT (next_items[i] IN new_check_items)
      THEN
        result_items := result_items + next_items[i] + using_items(next_items[i], new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  -- return the set of representation_items or founded_items
  -- in which the input item is used directly and indirectly.
  RETURN(result_items);
END_FUNCTION;

(* "using_representations" IMPLICIT from SCHEMA representation_schema *)
FUNCTION using_representations(item : founded_item_select) : SET OF representation;
LOCAL
  results            : SET OF representation;
  result_bag         : BAG OF representation;
  intermediate_items : SET OF founded_item_select;
END_LOCAL;
  -- Find the representations in which the item is used and add to the
  -- results set.
  results := [];
  result_bag := USEDIN(item, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REPRESENTATION.ITEMS');
  IF SIZEOF(result_bag) > 0
  THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  -- Find all representation_items or founded_items
  -- by which item is referenced directly or indirectly.
  intermediate_items := using_items(item, []);
  -- If the set of intermediate items is not empty;
  IF SIZEOF(intermediate_items) > 0
  THEN
    REPEAT i := 1 TO HIINDEX(intermediate_items);
      result_bag := USEDIN(intermediate_items[i],
                           'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REPRESENTATION.ITEMS');
      IF SIZEOF(result_bag) > 0
      THEN
        REPEAT j := 1 TO HIINDEX(result_bag);
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return the set of representation in which the input item is
  -- used directly and indirectly (through intervening
  -- representation_items or founded items).
  RETURN(results);
END_FUNCTION;

(* "valid_calendar_date" IMPLICIT from SCHEMA date_time_schema *)
FUNCTION valid_calendar_date(date : calendar_date) : LOGICAL;
  CASE date.month_component OF
    1 : RETURN({1 <= date.day_component <= 31});
    2 : BEGIN  
               IF (leap_year(date.year_component))
               THEN
                 RETURN({1 <= date.day_component <= 29});
               ELSE
                 RETURN({1 <= date.day_component <= 28});
               END_IF;
    END;
    3 : RETURN({1 <= date.day_component <= 31});
    4 : RETURN({1 <= date.day_component <= 30});
    5 : RETURN({1 <= date.day_component <= 31});
    6 : RETURN({1 <= date.day_component <= 30});
    7 : RETURN({1 <= date.day_component <= 31});
    8 : RETURN({1 <= date.day_component <= 31});
    9 : RETURN({1 <= date.day_component <= 30});
    10 : RETURN({1 <= date.day_component <= 31});
    11 : RETURN({1 <= date.day_component <= 30});
    12 : RETURN({1 <= date.day_component <= 31});
  END_CASE;
  RETURN(FALSE);
END_FUNCTION;

(* "valid_geometrically_bounded_wf_curve" IMPLICIT from SCHEMA aic_geometrically_bounded_wireframe *)
FUNCTION valid_geometrically_bounded_wf_curve(crv : curve) : BOOLEAN;
  IF SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLYLINE',
             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.B_SPLINE_CURVE',
             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ELLIPSE',
             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CIRCLE'] *
            TYPEOF(crv)) =
     1
  THEN
    RETURN(TRUE);
  ELSE
    IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TRIMMED_CURVE' IN TYPEOF(crv)
    THEN
      IF SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LINE',
                 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PARABOLA',
                 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.HYPERBOLA'] *
                TYPEOF(crv\trimmed_curve.basis_curve)) =
         1
      THEN
        RETURN(TRUE);
      ELSE
        RETURN(valid_geometrically_bounded_wf_curve(crv\trimmed_curve.basis_curve));
      END_IF;
    ELSE
      IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF(crv)
      THEN
        RETURN(valid_geometrically_bounded_wf_curve(crv\offset_curve_3d.basis_curve));
      ELSE
        IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE_REPLICA' IN TYPEOF(crv)
        THEN
          RETURN(valid_geometrically_bounded_wf_curve(crv\curve_replica.parent_curve));
        ELSE
          IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.COMPOSITE_CURVE' IN TYPEOF(crv)
          THEN
            RETURN(SIZEOF(QUERY(ccs
                                <* crv\composite_curve.segments
                                | NOT valid_geometrically_bounded_wf_curve(ccs.parent_curve))) =
                   0);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "valid_geometrically_bounded_wf_point" IMPLICIT from SCHEMA aic_geometrically_bounded_wireframe *)
FUNCTION valid_geometrically_bounded_wf_point(pnt : point) : BOOLEAN;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CARTESIAN_POINT' IN TYPEOF(pnt)
  THEN
    RETURN(TRUE);
  ELSE
    IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT_ON_CURVE' IN TYPEOF(pnt)
    THEN
      RETURN(valid_geometrically_bounded_wf_curve(pnt\point_on_curve.basis_curve));
    ELSE
      IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT_REPLICA' IN TYPEOF(pnt)
      THEN
        RETURN(valid_geometrically_bounded_wf_point(pnt\point_replica.parent_pt));
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "valid_identified_item_in_representation" IMPLICIT from SCHEMA product_property_representation_schema *)
FUNCTION valid_identified_item_in_representation(identified_item : item_identified_representation_usage_select;
                                                 used_representation : representation) : BOOLEAN;
LOCAL
  i : INTEGER := 1;
END_LOCAL;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(identified_item)
  THEN
    RETURN(used_representation IN using_representations(identified_item));
  END_IF;
  IF ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LIST_REPRESENTATION_ITEM' IN TYPEOF(identified_item)) OR
     ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SET_REPRESENTATION_ITEM' IN TYPEOF(identified_item))
  THEN
    REPEAT WHILE (EXISTS(identified_item[i]));
      IF NOT (used_representation IN using_representations(identified_item[i]))
      THEN
        RETURN(FALSE);
      END_IF;
      i := i + 1;
    END_REPEAT;
    RETURN(TRUE);
  END_IF;
  RETURN(?);
END_FUNCTION;

(* "valid_measure_value" IMPLICIT from SCHEMA representation_schema *)
FUNCTION valid_measure_value(m : measure_value) : BOOLEAN;
  IF ('REAL' IN TYPEOF(m))
  THEN
    RETURN(m > 0.0);
  ELSE
    IF ('INTEGER' IN TYPEOF(m))
    THEN
      RETURN(m > 0);
    ELSE
      RETURN(TRUE);
    END_IF;
  END_IF;
END_FUNCTION;

(* "valid_time" IMPLICIT from SCHEMA date_time_schema *)
FUNCTION valid_time(time : local_time) : BOOLEAN;
  IF EXISTS(time.second_component)
  THEN
    RETURN(EXISTS(time.minute_component));
  ELSE
    RETURN(TRUE);
  END_IF;
END_FUNCTION;

(* "valid_tri_ids" IMPLICIT from SCHEMA topology_schema *)
FUNCTION valid_tri_ids(objs : SET OF topological_representation_item) : BOOLEAN;
LOCAL
  values : BAG OF identifier := [];
END_LOCAL;
  REPEAT i := LOINDEX(objs) TO HIINDEX(objs);
    IF NOT (EXISTS(objs[i]\topological_representation_item.permanent_id) OR
            EXISTS(objs[i]\topological_representation_item.permanent_aggregate_id))
    THEN
      RETURN(FALSE);
    END_IF;
    values := values + objs[i]\topological_representation_item.permanent_id +
              objs[i]\topological_representation_item.permanent_aggregate_id;
  END_REPEAT;
  -- ids are unique across both types
  IF SIZEOF(bag_to_set(values)) <> SIZEOF(values)
  THEN
    RETURN(FALSE);
  END_IF;
  RETURN(TRUE);
END_FUNCTION;

(* "valid_units" IMPLICIT from SCHEMA measure_schema *)
FUNCTION valid_units(m : measure_with_unit) : BOOLEAN;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LENGTH_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MASS_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TIME_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CELSIUS_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.SOLID_ANGLE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.AREA_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VOLUME_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.RATIO_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ACCELERATION_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CAPACITANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(-2.0, -1.0, 4.0, 2.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ELECTRIC_CHARGE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONDUCTANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ELECTRIC_POTENTIAL_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ENERGY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FORCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.FREQUENCY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ILLUMINANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.INDUCTANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LUMINOUS_FLUX_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAGNETIC_FLUX_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MAGNETIC_FLUX_DENSITY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POWER_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRESSURE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.RESISTANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VELOCITY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.RADIOACTIVITY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ABSORBED_DOSE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.DOSE_EQUIVALENT_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  RETURN(TRUE);
END_FUNCTION;

(* "valid_wireframe_edge_curve" IMPLICIT from SCHEMA aic_edge_based_wireframe *)
FUNCTION valid_wireframe_edge_curve(crv : curve) : BOOLEAN;
  IF SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.LINE',
             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONIC',
             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.B_SPLINE_CURVE',
             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POLYLINE'] *
            TYPEOF(crv)) =
     1
  THEN
    RETURN(TRUE);
  ELSE
    IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE_REPLICA' IN TYPEOF(crv)
    THEN
      RETURN(valid_wireframe_edge_curve(crv\curve_replica.parent_curve));
    ELSE
      IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF(crv)
      THEN
        RETURN(valid_wireframe_edge_curve(crv\offset_curve_3d.basis_curve));
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "valid_wireframe_vertex_point" IMPLICIT from SCHEMA aic_edge_based_wireframe *)
FUNCTION valid_wireframe_vertex_point(pnt : point) : BOOLEAN;
  IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CARTESIAN_POINT' IN TYPEOF(pnt)
  THEN
    RETURN(TRUE);
  ELSE
    IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.POINT_REPLICA' IN TYPEOF(pnt)
    THEN
      RETURN(valid_wireframe_vertex_point(pnt\point_replica.parent_pt));
    END_IF;
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

(* "value_range_wr1" IMPLICIT from SCHEMA extended_measure_representation_mim *)
FUNCTION value_range_wr1(agg : compound_item_definition) : BOOLEAN;
  BEGIN  
         IF (SIZEOF(agg) = 2) AND
            ((SIZEOF(QUERY(i1
                           <* agg
                           | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN
                              TYPEOF(i1)))) =
              2) OR
             (SIZEOF(QUERY(i2
                           <* agg
                           | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VALUE_REPRESENTATION_ITEM' IN
                              TYPEOF(i2)))) =
              2))
         THEN
           RETURN(TRUE);
         ELSE
           RETURN(FALSE);
         END_IF;
  END;
END_FUNCTION;

(* "value_range_wr2" IMPLICIT from SCHEMA extended_measure_representation_mim *)
FUNCTION value_range_wr2(agg : compound_item_definition) : BOOLEAN;
  BEGIN  
         IF ((SIZEOF(QUERY(i <* agg | (i\representation_item.name = 'upper limit'))) = 1) AND
             (SIZEOF(QUERY(i <* agg | (i\representation_item.name = 'lower limit'))) = 1))
         THEN
           RETURN(TRUE);
         ELSE
           RETURN(FALSE);
         END_IF;
  END;
END_FUNCTION;

(* "value_range_wr3" IMPLICIT from SCHEMA extended_measure_representation_mim *)
FUNCTION value_range_wr3(agg : compound_item_definition) : BOOLEAN;
  BEGIN  
         IF (SIZEOF(QUERY(i1
                          <* agg
                          | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN
                             TYPEOF(i1)) AND
                            (SIZEOF(QUERY(i2
                                          <* agg
                                          | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN
                                             TYPEOF(i2)) AND
                                            (i1 :<>: i2) AND
                                            (i1\measure_with_unit.unit_component :=:
                                             i2\measure_with_unit.unit_component))) =
                             1))) =
             2)
         THEN
           RETURN(TRUE);
         ELSE
           RETURN(FALSE);
         END_IF;
  END;
END_FUNCTION;

(* "values_space_of" IMPLICIT from SCHEMA mathematical_functions_schema *)
FUNCTION values_space_of(expr : generic_expression) : maths_space;
LOCAL
  e_prefix  : STRING        := 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.';
  typenames : SET OF STRING := TYPEOF(expr);
END_LOCAL;
  IF (schema_prefix + 'MATHS_VARIABLE') IN typenames
  THEN
    RETURN(expr\maths_variable.values_space);
  END_IF;
  IF (e_prefix + 'EXPRESSION') IN typenames
  THEN
    IF (e_prefix + 'NUMERIC_EXPRESSION') IN typenames
    THEN
      IF expr\numeric_expression.is_int
      THEN
        IF (e_prefix + 'INT_LITERAL') IN typenames
        THEN
          RETURN(make_finite_space([expr\int_literal.the_value]));
        ELSE
          RETURN(the_integers);
        END_IF;
      ELSE
        IF (e_prefix + 'REAL_LITERAL') IN typenames
        THEN
          RETURN(make_finite_space([expr\real_literal.the_value]));
        ELSE
          RETURN(the_reals);
        END_IF;
      END_IF;
    END_IF;
    IF (e_prefix + 'BOOLEAN_EXPRESSION') IN typenames
    THEN
      IF (e_prefix + 'BOOLEAN_LITERAL') IN typenames
      THEN
        RETURN(make_finite_space([expr\boolean_literal.the_value]));
      ELSE
        RETURN(the_booleans);
      END_IF;
    END_IF;
    IF (e_prefix + 'STRING_EXPRESSION') IN typenames
    THEN
      IF (e_prefix + 'STRING_LITERAL') IN typenames
      THEN
        RETURN(make_finite_space([expr\string_literal.the_value]));
      ELSE
        RETURN(the_strings);
      END_IF;
    END_IF;
    RETURN(?);
  END_IF;
  IF (schema_prefix + 'MATHS_FUNCTION') IN typenames
  THEN
    IF expression_is_constant(expr)
    THEN
      RETURN(make_finite_space([expr]));
    ELSE
      RETURN(make_function_space(sc_equal, expr\maths_function.domain, sc_equal, expr\maths_function.range));
    END_IF;
  END_IF;
  IF (schema_prefix + 'FUNCTION_APPLICATION') IN typenames
  THEN
    RETURN(expr\function_application.func.range);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames
  THEN
    IF expression_is_constant(expr)
    THEN
      RETURN(make_finite_space([expr]));
    ELSE
      RETURN(make_elementary_space(es_maths_spaces));
    END_IF;
  END_IF;
  IF (schema_prefix + 'DEPENDENT_VARIABLE_DEFINITION') IN typenames
  THEN
    RETURN(values_space_of(expr\unary_generic_expression.operand));
  END_IF;
  IF (schema_prefix + 'COMPLEX_NUMBER_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr]));
  END_IF;
  IF (schema_prefix + 'LOGICAL_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\logical_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'BINARY_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\binary_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_ENUM_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\maths_enum_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'REAL_TUPLE_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\real_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'INTEGER_TUPLE_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\integer_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'ATOM_BASED_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\atom_based_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_TUPLE_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\maths_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'PARTIAL_DERIVATIVE_EXPRESSION') IN typenames
  THEN
    RETURN(drop_numeric_constraints(values_space_of(expr\partial_derivative_expression.derivand)));
  END_IF;
  IF (schema_prefix + 'DEFINITE_INTEGRAL_EXPRESSION') IN typenames
  THEN
    RETURN(drop_numeric_constraints(values_space_of(expr\definite_integral_expression.integrand)));
  END_IF;
  RETURN(?);
END_FUNCTION;

(* "vector_difference" IMPLICIT from SCHEMA geometry_schema *)
FUNCTION vector_difference(arg1 : vector_or_direction;
                           arg2 : vector_or_direction) : vector;
LOCAL
  result : vector;
  res    : direction;
  vec1   : direction;
  vec2   : direction;
  mag    : REAL;
  mag1   : REAL;
  mag2   : REAL;
  ndim   : INTEGER;
END_LOCAL;
  IF ((NOT EXISTS(arg1)) OR (NOT EXISTS(arg2))) OR (arg1.dim <> arg2.dim)
  THEN
    RETURN(?);
  ELSE
    BEGIN  
           IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VECTOR' IN TYPEOF(arg1)
           THEN
             mag1 := arg1\vector.magnitude;
             vec1 := arg1\vector.orientation;
           ELSE
             mag1 := 1.0;
             vec1 := arg1;
           END_IF;
           IF 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VECTOR' IN TYPEOF(arg2)
           THEN
             mag2 := arg2\vector.magnitude;
             vec2 := arg2\vector.orientation;
           ELSE
             mag2 := 1.0;
             vec2 := arg2;
           END_IF;
           vec1 := normalise(vec1);
           vec2 := normalise(vec2);
           ndim := SIZEOF(vec1.direction_ratios);
           mag := 0.0;
           res := dummy_gri || direction(vec1.direction_ratios);
           REPEAT i := 1 TO ndim;
             res.direction_ratios[i] := mag1 * vec1.direction_ratios[i] - mag2 * vec2.direction_ratios[i];
             mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
           END_REPEAT;
           IF (mag > 0.0)
           THEN
             result := dummy_gri || vector(res, SQRT(mag));
           ELSE
             result := dummy_gri || vector(vec1, 0.0);
           END_IF;
    END;
  END_IF;
  RETURN(result);
END_FUNCTION;

RULE compatible_dimension FOR (cartesian_point, direction, geometric_representation_context);
WHERE
  WR1: ((SIZEOF(cartesian_point) = 0) AND (SIZEOF(direction) = 0) AND
        (SIZEOF(geometric_representation_context) = 0)) OR
       check_geometric_dimension(cartesian_point, direction, geometric_representation_context);
END_RULE;

RULE component_class_for_assembly_select FOR (composite_assembly_sequence_definition,
                                              next_assembly_usage_occurrence,
                                              product_related_product_category);
LOCAL
  i     : INTEGER := 0;
  j     : INTEGER := 0;
  k     : INTEGER := 0;
  dkuhr : LOGICAL := TRUE;
  nnauo : INTEGER := 0;
  nprpc : INTEGER := 0;
  rp    : product;
END_LOCAL;
  REPEAT i := LOINDEX(composite_assembly_sequence_definition) TO HIINDEX(composite_assembly_sequence_definition);
    nnauo := 0;
    REPEAT j := LOINDEX(next_assembly_usage_occurrence) TO HIINDEX(next_assembly_usage_occurrence);
      IF (composite_assembly_sequence_definition[i] = next_assembly_usage_occurrence[j].relating_product_definition)
      THEN
        rp := next_assembly_usage_occurrence[j].related_product_definition.formation.of_product;
        nprpc := 0;
        REPEAT k := LOINDEX(product_related_product_category) TO HIINDEX(product_related_product_category);
          IF ((rp IN product_related_product_category[k].products) AND
              (product_related_product_category[k].name IN
               ['ply','ply laminate','filament laminate','processed core','composite assembly']))
          THEN
            nprpc := nprpc + 1;
          END_IF;
        END_REPEAT;
        IF (nprpc = 1)
        THEN
          nnauo := nnauo + 1;
        ELSE
          dkuhr := FALSE;
          ESCAPE;
        END_IF;
      END_IF;
    END_REPEAT;
    IF (dkuhr = FALSE)
    THEN
      ESCAPE;
    END_IF;
    IF (nnauo = 0)
    THEN
      dkuhr := FALSE;
      ESCAPE;
    END_IF;
  END_REPEAT;
WHERE
  WR1: dkuhr;
END_RULE;

RULE consistent_uncertainty FOR (global_uncertainty_assigned_context,
                                 qualified_representation_item,
                                 uncertainty_assigned_representation);
WHERE
  WR1: SIZEOF(QUERY(guac
                    <* global_uncertainty_assigned_context
                    | SIZEOF(QUERY(u1
                                   <* guac.uncertainty
                                   | SIZEOF(QUERY(u2 <* guac.uncertainty | u2.name = u1.name)) > 1)) >
                      0)) =
       0;
  WR2: SIZEOF(QUERY(uar
                    <* uncertainty_assigned_representation
                    | SIZEOF(QUERY(u1
                                   <* uar.uncertainty
                                   | SIZEOF(QUERY(u2 <* uar.uncertainty | u2.name = u1.name)) > 1)) >
                      0)) =
       0;
  WR3: SIZEOF(QUERY(qri
                    <* qualified_representation_item
                    | SIZEOF(QUERY(u1
                                   <* qri.qualifiers
                                   | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.UNCERTAINTY_QUALIFIER' IN
                                      TYPEOF(u1)) AND
                                     (SIZEOF(QUERY(u2
                                                   <* qri.qualifiers
                                                   | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.UNCERTAINTY_QUALIFIER' IN
                                                      TYPEOF(u2)) AND
                                                     (u2\uncertainty_qualifier.measure_name =
                                                      u1\uncertainty_qualifier.measure_name))) >
                                      1))) >
                      0)) =
       0;
END_RULE;

RULE external_version_assignments_are_valid FOR (applied_external_identification_assignment);
WHERE
  WR1: SIZEOF(QUERY(aia
                    <* applied_external_identification_assignment
                    | NOT external_version_assignment_is_valid(aia))) =
       0;
END_RULE;

RULE plib_property_reference_requires_name_scope FOR (externally_defined_general_property);
LOCAL
  known_sourced_properties : SET OF externally_defined_general_property;
END_LOCAL;
  known_sourced_properties := QUERY(edc
                                    <* externally_defined_general_property
                                    | 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.KNOWN_SOURCE' IN
                                      TYPEOF(edc.source));
WHERE
  WR1: SIZEOF(QUERY(edgp
                    <* known_sourced_properties
                    | (SIZEOF(QUERY(edir
                                    <* USEDIN(edgp,
                                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.RELATING_ITEM')
                                    | (edir.name = 'name scope') AND
                                      ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.EXTERNALLY_DEFINED_CLASS' IN
                                       TYPEOF(edir.related_item)) AND
                                      ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.KNOWN_SOURCE' IN
                                       TYPEOF(edir.related_item.source)))) <>
                       1))) =
       0;
END_RULE;

RULE plib_property_reference_requires_version FOR (externally_defined_general_property);
LOCAL
  plib_properties : SET OF externally_defined_general_property := [];
END_LOCAL;
  plib_properties := QUERY(edgp
                           <* externally_defined_general_property
                           | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.KNOWN_SOURCE' IN
                              TYPEOF(edgp.source)) AND
                             ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.KNOWN_SOURCE.NAME' =
                              'ISO 13584 library'));
WHERE
  WR1: SIZEOF(QUERY(edgp
                    <* plib_properties
                    | (SIZEOF(QUERY(edir
                                    <* USEDIN(edgp,
                                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS')
                                    | (edir.role.name = 'version'))) <>
                       1))) =
       0;
END_RULE;

RULE ply_reference FOR (ply_laminate_sequence_definition,
                        next_assembly_usage_occurrence,
                        product_related_product_category);
LOCAL
  i     : INTEGER;
  j     : INTEGER;
  k     : INTEGER;
  dkuhr : LOGICAL := TRUE;
  nnauo : INTEGER;
  nprpc : INTEGER := 0;
  rp    : product;
END_LOCAL;
  REPEAT i := LOINDEX(ply_laminate_sequence_definition) TO HIINDEX(ply_laminate_sequence_definition);
    nnauo := 0;
    REPEAT j := LOINDEX(next_assembly_usage_occurrence) TO HIINDEX(next_assembly_usage_occurrence);
      IF (ply_laminate_sequence_definition[i] = next_assembly_usage_occurrence[j].relating_product_definition)
      THEN
        rp := next_assembly_usage_occurrence[j].related_product_definition.formation.of_product;
        nprpc := 0;
        REPEAT k := LOINDEX(product_related_product_category) TO HIINDEX(product_related_product_category);
          IF ((product_related_product_category[k].name = 'ply') AND
              (rp IN product_related_product_category[k].products))
          THEN
            nprpc := nprpc + 1;
          END_IF;
        END_REPEAT;
        IF (nprpc = 1)
        THEN
          nnauo := nnauo + 1;
        ELSE
          dkuhr := FALSE;
          ESCAPE;
        END_IF;
      END_IF;
    END_REPEAT;
    IF (dkuhr = FALSE)
    THEN
      ESCAPE;
    END_IF;
    IF (nnauo = 0)
    THEN
      dkuhr := FALSE;
      ESCAPE;
    END_IF;
  END_REPEAT;
WHERE
  WR1: dkuhr;
END_RULE;

RULE ply_stock_material_select FOR (product_related_product_category, make_from_usage_option);
LOCAL
  i     : INTEGER;
  j     : INTEGER;
  k     : INTEGER;
  kp    : INTEGER;
  dkuhr : LOGICAL;
  nmfuo : INTEGER;
  nprpc : INTEGER := 0;
  rp    : product;
END_LOCAL;
  dkuhr := TRUE;
  REPEAT kp := LOINDEX(product_related_product_category) TO HIINDEX(product_related_product_category);
    IF (product_related_product_category[kp].name = 'ply')
    THEN
      REPEAT i := LOINDEX(product_related_product_category[kp].products) TO HIINDEX(product_related_product_category[kp].products);
        nmfuo := 0;
        REPEAT j := LOINDEX(make_from_usage_option) TO HIINDEX(make_from_usage_option);
          rp := make_from_usage_option[j].related_product_definition.formation.of_product;
          IF (product_related_product_category[kp].products[i] = rp)
          THEN
            REPEAT k := LOINDEX(product_related_product_category) TO HIINDEX(product_related_product_category);
              IF ((rp IN product_related_product_category[k].products) AND
                  (product_related_product_category[k].name IN
                   ['isotropic material','filament assembly','discontinuous fiber assembly']))
              THEN
                nprpc := nprpc + 1;
              END_IF;
            END_REPEAT;
            IF (nprpc = 1)
            THEN
              nmfuo := nmfuo + 1;
            ELSE
              dkuhr := FALSE;
              ESCAPE;
            END_IF;
          END_IF;
        END_REPEAT;
        IF (dkuhr = FALSE)
        THEN
          ESCAPE;
        END_IF;
        IF (nmfuo <> 1)
        THEN
          dkuhr := FALSE;
          ESCAPE;
        END_IF;
      END_REPEAT;
    END_IF;
  END_REPEAT;
WHERE
  WR1: dkuhr;
END_RULE;

RULE product_concept_feature_requires_category FOR (product_concept_feature);
WHERE
  WR1: SIZEOF(QUERY(pcf
                    <* product_concept_feature
                    | (SIZEOF(['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.INCLUSION_PRODUCT_CONCEPT_FEATURE',
                               'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONDITIONAL_CONCEPT_FEATURE'] *
                              TYPEOF(pcf)) =
                       0) AND
                      (SIZEOF(QUERY(aga
                                    <* USEDIN(pcf,
                                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.APPLIED_GROUP_ASSIGNMENT.ITEMS')
                                    | (aga\group_assignment.role\object_role.name =
                                       'specification category member') AND
                                      ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN
                                       TYPEOF(aga.assigned_group)))) <>
                       1))) =
       0;
END_RULE;

RULE restrict_concept_feature_operator FOR (concept_feature_operator);
WHERE
  WR1: SIZEOF(QUERY(cfo <* concept_feature_operator | NOT (cfo.name IN ['and','or','oneof','not','implication']))) = 0;
  WR2: SIZEOF(QUERY(cfo
                    <* concept_feature_operator
                    | (cfo.name = 'implication') AND
                      (SIZEOF(QUERY(cfrwc
                                    <* USEDIN(cfo,
                                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.CONDITIONAL_OPERATOR')
                                    | SIZEOF(QUERY(ccf
                                                   <* USEDIN(cfrwc,
                                                             'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONDITIONAL_CONCEPT_FEATURE.CONDITION')
                                                   | NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.INCLUSION_PRODUCT_CONCEPT_FEATURE' IN
                                                          TYPEOF(ccf)))) >
                                      0)) >
                       0))) =
       0;
  WR3: SIZEOF(QUERY(cfo
                    <* concept_feature_operator
                    | (cfo.name = 'not') AND
                      (SIZEOF(QUERY(cfrwc
                                    <* USEDIN(cfo,
                                              'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.CONDITIONAL_OPERATOR')
                                    | cfrwc.related_product_concept_feature :<>:
                                      cfrwc.relating_product_concept_feature)) >
                       0))) =
       0;
END_RULE;

RULE restrict_group_relationship_for_specification_category FOR (group_relationship);
WHERE
  WR1: SIZEOF(QUERY(gr
                    <* group_relationship
                    | (gr.name = 'specification category hierarchy') AND
                      (NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN
                            TYPEOF(gr.related_group)) OR
                           NOT ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN
                                TYPEOF(gr.relating_group))))) =
       0;
END_RULE;

RULE restrict_language_assignment_per_attribute FOR (attribute_language_assignment);
WHERE
  WR1: SIZEOF(QUERY(ala1
                    <* attribute_language_assignment
                    | SIZEOF(QUERY(it
                                   <* ala1.items
                                   | SIZEOF(QUERY(ala2
                                                  <* USEDIN(it,
                                                            'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS')
                                                  | (ala1\attribute_classification_assignment.attribute_name =
                                                     ala2\attribute_classification_assignment.attribute_name) AND
                                                    (ala1\attribute_classification_assignment.assigned_class :=:
                                                     ala2\attribute_classification_assignment.assigned_class))) >
                                     1)) >
                      0)) =
       0;
END_RULE;

RULE styled_curve FOR (styled_item);
WHERE
  WR1: SIZEOF(QUERY(si
                    <* styled_item
                    | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE' IN TYPEOF(si.item)) AND
                      (SIZEOF(QUERY(psa
                                    <* si.styles
                                    | (SIZEOF(QUERY(cs
                                                    <* psa.styles
                                                    | ('LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.CURVE_STYLE' IN
                                                       TYPEOF(cs)))) >
                                       0))) <>
                       1))) =
       0;
END_RULE;

RULE subtype_exclusiveness_representation_item FOR (representation_item);
WHERE
  WR1: SIZEOF(QUERY(cri
                    <* representation_item
                    | NOT (type_check_function(cri,
                                               ['LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.MEASURE_REPRESENTATION_ITEM',
                                                'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.VALUE_REPRESENTATION_ITEM',
                                                'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.COMPOUND_REPRESENTATION_ITEM'],
                                               3)))) =
       0;
END_RULE;

RULE text_font_usage FOR (externally_defined_text_font, pre_defined_text_font);
WHERE
  WR1: SIZEOF(QUERY(pdtf
                    <* pre_defined_text_font
                    | SIZEOF(USEDIN(pdtf, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TEXT_LITERAL.FONT')) =
                      0)) =
       0;
  WR2: SIZEOF(QUERY(edtf
                    <* externally_defined_text_font
                    | SIZEOF(USEDIN(edtf, 'LIMITED_LENGTH_OR_AREA_INDICATOR_ASSIGNMENT_MIM_LF.TEXT_LITERAL.FONT')) =
                      0)) =
       0;
END_RULE;

RULE tri_identification_within_product_definition FOR (product_definition,
                                                       topological_representation_item,
                                                       representation);
LOCAL
  associated_representations : SET [1 : ?] OF representation                  := [];
  items                      : SET [1 : ?] OF topological_representation_item := [];
  pd_items                   : SET [1 : ?] OF topological_representation_item := [];
  pass                       : BOOLEAN                                        := TRUE;
END_LOCAL;
  REPEAT i := LOINDEX(product_definition) TO HIINDEX(product_definition)
  WHILE pass;
    pd_items := get_tri_for_pd(product_definition[i]);
    associated_representations := get_representations_for_items(pd_items);
    items := get_tri_in_representations(associated_representations) + pd_items;
    IF (SIZEOF(items) > 0)
    THEN
      IF (SIZEOF(QUERY(ai
                       <* items
                       | NOT (EXISTS(ai\topological_representation_item.permanent_id) OR
                              EXISTS(ai\topological_representation_item.permanent_aggregate_id)))) >
          0)
      THEN
        pass := valid_tri_ids(items);
      END_IF;
    END_IF;
  END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
END_SCHEMA;
