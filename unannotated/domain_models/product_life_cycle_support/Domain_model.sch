<?xml version="1.0" encoding="UTF-8"?>
<sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron"
            xmlns:sqf="http://www.schematron-quickfix.com/validator/process"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            queryBinding="xslt2"
            version="N11408;2024-02-14">
   <sch:ns uri="https://standards.iso.org/iso/ts/10303/-4439/ed-2/tech/xml-schema/domain_model"
           prefix="n0"/>
   <sch:ns uri="http://www.w3.org/2001/XMLSchema-instance" prefix="xsi"/>
   <sch:title>STEP AP239 Domain model schematron</sch:title>
   <sch:pattern id="Acknowledgement"><!--(Ref to S) Acknowledgement.Definition : ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Acknowledgement') or (self::Acknowledgement or (self::Acknowledge and substring-after(@xsi:type,':')='Acknowledgement')))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(Acknowledgement : <sch:value-of select="$uid"/>) The Acknowledgement.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ActivityAssignment"><!--(Ref to E) ActivityAssignment.AssignedActivity : Activity (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ActivityAssignment'))]/AssignedActivity">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Activity'] or //Activity[@uid = $uidRef]">(ActivityAssignment : <sch:value-of select="$uid"/>) The ActivityAssignment.AssignedActivity contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Activity.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ActivityAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=AssignmentObject.Role)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ActivityAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ActivityAssignment : <sch:value-of select="$uid"/>) The ActivityAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ActivityHappeningRelationship"><!--(Ref to E) ActivityHappeningRelationship.Related : ActualActivity (kind=SINGLE - redefined=ActivityRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityHappeningRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ActivityHappeningRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActualActivity'] or //Activity[@uid = $uidRef and contains(' ActualActivity ',substring-after(@xsi:type,':'))]">(ActivityHappeningRelationship : <sch:value-of select="$uid"/>) The ActivityHappeningRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActualActivity.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ActivityRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityHappeningRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ActivityHappeningRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ActivityHappeningRelationship : <sch:value-of select="$uid"/>) The ActivityHappeningRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ActivityMethod"/>
   <sch:pattern id="ActivityMethodAssignment"><!--(Ref to E) ActivityMethodAssignment.AssignedActivityMethod : ActivityMethod (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityMethodAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ActivityMethodAssignment'))]/AssignedActivityMethod">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(ActivityMethodAssignment : <sch:value-of select="$uid"/>) The ActivityMethodAssignment.AssignedActivityMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ActivityMethodAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=AssignmentObject.Role)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityMethodAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ActivityMethodAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ActivityMethodAssignment : <sch:value-of select="$uid"/>) The ActivityMethodAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ActivityMethodRealization"><!--(Ref to E) ActivityMethodRealization.ActivityMethod : ActivityMethod (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityMethodRealization') or (self::AssociationObject and substring-after(@xsi:type,':')='ActivityMethodRealization'))]/ActivityMethod">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(ActivityMethodRealization : <sch:value-of select="$uid"/>) The ActivityMethodRealization.ActivityMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ActivityMethodRealization.RealizedBy : ActivityMethodRealizationSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityMethodRealization') or (self::AssociationObject and substring-after(@xsi:type,':')='ActivityMethodRealization'))]/RealizedBy">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)] or //Scheme[@uid = $uidRef] or //SchemeVersion[@uid = $uidRef] or //TaskElement[@uid = $uidRef] or //TaskMethod[@uid = $uidRef] or //TaskMethodVersion[@uid = $uidRef]">(ActivityMethodRealization : <sch:value-of select="$uid"/>) The ActivityMethodRealization.RealizedBy contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ActivityMethodRealizationSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ActivityMethodRelationship"><!--(Ref to E) ActivityMethodRelationship.Related : ActivityMethod (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityMethodRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ActivityMethodRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(ActivityMethodRelationship : <sch:value-of select="$uid"/>) The ActivityMethodRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ActivityMethodRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityMethodRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ActivityMethodRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ActivityMethodRelationship : <sch:value-of select="$uid"/>) The ActivityMethodRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ActivityRelationship"><!--(Ref to E) ActivityRelationship.Related : Activity (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ActivityRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Activity'] or //Activity[@uid = $uidRef]">(ActivityRelationship : <sch:value-of select="$uid"/>) The ActivityRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Activity.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ActivityRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ActivityRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ActivityRelationship : <sch:value-of select="$uid"/>) The ActivityRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ActualActivity"><!--(Ref to S) Activity.ActivityType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActualActivity') or (self::Activity and substring-after(@xsi:type,':')='ActualActivity'))]/ActivityType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ActualActivity : <sch:value-of select="$uid"/>) The ActualActivity.ActivityType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.ChosenMethod : OPTIONAL ActivityMethod (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActualActivity') or (self::Activity and substring-after(@xsi:type,':')='ActualActivity'))]/ChosenMethod">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ChosenMethod) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(ActualActivity : <sch:value-of select="$uid"/>) The ActualActivity.ChosenMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.PossibleMethods : OPTIONAL SET[1:unbounded] OF ActivityMethod (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActualActivity') or (self::Activity and substring-after(@xsi:type,':')='ActualActivity'))]/PossibleMethods/ActivityMethod">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../PossibleMethods/ActivityMethod) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(ActualActivity : <sch:value-of select="$uid"/>) The ActualActivity.PossibleMethods contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Address"><!--(Inverse of Location.Locators :: PartProperty) Locator.Represents : OPTIONAL Location) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="AddressAssignment"><!--(Ref to E) AddressAssignment.AssignedAddress : Address (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AddressAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='AddressAssignment'))]/AssignedAddress">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Address'] or //Locator[@uid = $uidRef and contains(' Address ',substring-after(@xsi:type,':'))]">(AddressAssignment : <sch:value-of select="$uid"/>) The AddressAssignment.AssignedAddress contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Address.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AddressAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=AssignmentObject.Role)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AddressAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='AddressAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AddressAssignment : <sch:value-of select="$uid"/>) The AddressAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AddressComponent"><!--(Ref to S) AddressComponent.ComponentType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AddressComponent') or (self::AddressComponent and not(@xsi:type)))]/ComponentType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AddressComponent : <sch:value-of select="$uid"/>) The AddressComponent.ComponentType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AdvisoryNote"><!--(Ref to E) AdvisoryNote.AppliesTo : TaskElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AdvisoryNote') or (self::AdvisoryNote and not(@xsi:type)))]/AppliesTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'TaskElement'] or //TaskElement[@uid = $uidRef] or //*[@uid = $uidRef and (self::Advisory or self::TrueCaseElement or self::FalseCaseElement or self::UnknownCaseElement or self::RepeatedElement or self::Content)]">(AdvisoryNote : <sch:value-of select="$uid"/>) The AdvisoryNote.AppliesTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type TaskElement.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AdvisoryTaskStep"/>
   <sch:pattern id="AlternatePartRelationship"><!--(Ref to E) PartRelationship.Related : Part (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AlternatePartRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='AlternatePartRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Part'] or //Part[@uid = $uidRef]">(AlternatePartRelationship : <sch:value-of select="$uid"/>) The AlternatePartRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Part.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AlternatePartRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='AlternatePartRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AlternatePartRelationship : <sch:value-of select="$uid"/>) The AlternatePartRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AlternativeSolution"><!--(Ref to S) AlternativeSolution.BaseElement : ComplexProductSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AlternativeSolution') or (self::BreakdownElementVersion and substring-after(@xsi:type,':')='AlternativeSolution'))]/BaseElement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //BreakdownElementVersion[@uid = $uidRef and contains(' AlternativeSolution ',substring-after(@xsi:type,':'))] or //BreakdownElementView[@uid = $uidRef]">(AlternativeSolution : <sch:value-of select="$uid"/>) The AlternativeSolution.BaseElement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ComplexProductSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of BreakdownElement.Versions :: PartProperty) BreakdownElementVersion.VersionOf : BreakdownElement) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="Analysis"/>
   <sch:pattern id="AnalysisAssignment"><!--(Ref to E) AnalysisAssignment.AssignedAnalysis : AnalysisVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='AnalysisAssignment'))]/AssignedAnalysis">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AnalysisVersion'] or //AnalysisVersion[@uid = $uidRef]">(AnalysisAssignment : <sch:value-of select="$uid"/>) The AnalysisAssignment.AssignedAnalysis contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AnalysisVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AnalysisAssignment.AssignedTo : AnalysisAssignmentSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='AnalysisAssignment'))]/AssignedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Collection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersionRelationship  CollectionVersionSequenceRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Evidence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnection  HierarchicalInterfaceConnection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceDefinitionConnection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceDefinitionFor ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ManagedResourceRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceEventRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskPerceptionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Validation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Verification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VerificationRelationship ',@typeRef)] or //Collection[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' CollectionRelationship ',substring-after(@xsi:type,':'))] or //CollectionVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' CollectionVersionRelationship  CollectionVersionSequenceRelationship ',substring-after(@xsi:type,':'))] or //CollectionView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' CollectionViewRelationship ',substring-after(@xsi:type,':'))] or //Evidence[@uid = $uidRef] or //InterfaceConnection[@uid = $uidRef] or //InterfaceConnector[@uid = $uidRef] or //InterfaceConnectorOccurrence[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorRelationship ',substring-after(@xsi:type,':'))] or //InterfaceConnectorVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorVersionRelationship ',substring-after(@xsi:type,':'))] or //InterfaceConnectorView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',substring-after(@xsi:type,':'))] or //InterfaceDefinitionConnection[@uid = $uidRef] or //AssociationObject[@uid = $uidRef and contains(' InterfaceDefinitionFor ',substring-after(@xsi:type,':'))] or //InterfaceSpecification[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationRelationship ',substring-after(@xsi:type,':'))] or //InterfaceSpecificationVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationVersionRelationship ',substring-after(@xsi:type,':'))] or //InterfaceSpecificationView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' ManagedResourceRelationship ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' ResourceEventRelationship ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' RiskPerceptionRelationship ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' RiskRelationship ',substring-after(@xsi:type,':'))] or //Validation[@uid = $uidRef] or //Verification[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' VerificationRelationship ',substring-after(@xsi:type,':'))]">(AnalysisAssignment : <sch:value-of select="$uid"/>) The AnalysisAssignment.AssignedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AnalysisAssignmentSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AnalysisAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=AssignmentObject.Role)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='AnalysisAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AnalysisAssignment : <sch:value-of select="$uid"/>) The AnalysisAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AnalysisDisciplineDefinition"><!--(Ref to E) AnalysisDisciplineDefinition.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisDisciplineDefinition') or (self::AnalysisDisciplineDefinition and not(@xsi:type)))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(AnalysisDisciplineDefinition : <sch:value-of select="$uid"/>) The AnalysisDisciplineDefinition.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AnalysisDisciplineDefinition.DefinitionalRepresentations : OPTIONAL SET[1:unbounded] OF AnalysisModelObject (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisDisciplineDefinition') or (self::AnalysisDisciplineDefinition and not(@xsi:type)))]/DefinitionalRepresentations/AnalysisModelObject">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../DefinitionalRepresentations/AnalysisModelObject) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AnalysisModelObject'] or //AnalysisModelObject[@uid = $uidRef]">(AnalysisDisciplineDefinition : <sch:value-of select="$uid"/>) The AnalysisDisciplineDefinition.DefinitionalRepresentations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AnalysisModelObject.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AnalysisDisciplineDefinition.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisDisciplineDefinition') or (self::AnalysisDisciplineDefinition and not(@xsi:type)))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(AnalysisDisciplineDefinition : <sch:value-of select="$uid"/>) The AnalysisDisciplineDefinition.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of AnalysisVersion.Views :: PartProperty) AnalysisDisciplineDefinition.ViewOf : AnalysisVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="AnalysisModel"><!--(Ref to S) AnalysisModel.Items : SET[1:unbounded] OF AnalysisModelItemsSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisModel') or (self::AnalysisModelObject and substring-after(@xsi:type,':')='AnalysisModel'))]/Items/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::CollectionVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::SchemeEntry and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)]) or (self::StateDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinition ',@typeRef)]) or (self::StateDefinitionTransition and //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionTransition ',@typeRef)]) or (self::CollectionVersion and //CollectionVersion[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::SchemeEntry and //SchemeEntry[@uid = $uidRef]) or (self::StateDefinition and //StateDefinition[@uid = $uidRef]) or (self::StateDefinitionTransition and //RelationshipObject[@uid = $uidRef and contains(' StateDefinitionTransition ',substring-after(@xsi:type,':'))])">(AnalysisModel : <sch:value-of select="$uid"/>) The AnalysisModel.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AnalysisModelItemsSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AnalysisModelObject.ContextOfItems : AnalysisRepresentationContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisModel') or (self::AnalysisModelObject and substring-after(@xsi:type,':')='AnalysisModel'))]/ContextOfItems">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AnalysisRepresentationContext'] or //AnalysisRepresentationContext[@uid = $uidRef]">(AnalysisModel : <sch:value-of select="$uid"/>) The AnalysisModel.ContextOfItems contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AnalysisRepresentationContext.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AnalysisRepresentationContext"/>
   <sch:pattern id="AnalysisVersion"><!--(Inverse of Analysis.Versions :: PartProperty) AnalysisVersion.VersionOf : Analysis) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="AnalysisVersionRelationship"><!--(Ref to E) AnalysisVersionRelationship.Related : AnalysisVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='AnalysisVersionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AnalysisVersion'] or //AnalysisVersion[@uid = $uidRef]">(AnalysisVersionRelationship : <sch:value-of select="$uid"/>) The AnalysisVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AnalysisVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AnalysisVersionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='AnalysisVersionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AnalysisVersionRelationship : <sch:value-of select="$uid"/>) The AnalysisVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ApplicationDomain"><!--(Ref to S) ApplicationDomain.Definition : ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ApplicationDomain') or (self::ApplicationDomain and not(@xsi:type)))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(ApplicationDomain : <sch:value-of select="$uid"/>) The ApplicationDomain.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Approval"><!--(Ref to S) Approval.ApprovalScope : OPTIONAL SET[1:unbounded] OF ApprovalScopeSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Approval') or (self::Approval and not(@xsi:type)))]/ApprovalScope/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::Contract and //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::ProductClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)]) or (self::Project and //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::Contract and //Contract[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef]) or (self::ProductClass and //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::Project and //Project[@uid = $uidRef])">(Approval : <sch:value-of select="$uid"/>) The Approval.ApprovalScope contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ApprovalScopeSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ApprovalAssignment"><!--(Ref to E) ApprovalAssignment.AssignedApproval : Approval (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ApprovalAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ApprovalAssignment'))]/AssignedApproval">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Approval'] or //Approval[@uid = $uidRef]">(ApprovalAssignment : <sch:value-of select="$uid"/>) The ApprovalAssignment.AssignedApproval contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Approval.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ApprovalAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ApprovalAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ApprovalAssignment : <sch:value-of select="$uid"/>) The ApprovalAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ApprovalRelationship"><!--(Ref to E) ApprovalRelationship.Related : Approval (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ApprovalRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ApprovalRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Approval'] or //Approval[@uid = $uidRef]">(ApprovalRelationship : <sch:value-of select="$uid"/>) The ApprovalRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Approval.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ApprovalRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ApprovalRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ApprovalRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ApprovalRelationship : <sch:value-of select="$uid"/>) The ApprovalRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AssemblyDefinition"><!--(Ref to S) AssemblyDefinition.AssemblyType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyDefinition') or (self::PartView and substring-after(@xsi:type,':')='AssemblyDefinition'))]/AssemblyType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AssemblyDefinition : <sch:value-of select="$uid"/>) The AssemblyDefinition.AssemblyType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyDefinition') or (self::PartView and substring-after(@xsi:type,':')='AssemblyDefinition'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(AssemblyDefinition : <sch:value-of select="$uid"/>) The AssemblyDefinition.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyDefinition') or (self::PartView and substring-after(@xsi:type,':')='AssemblyDefinition'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(AssemblyDefinition : <sch:value-of select="$uid"/>) The AssemblyDefinition.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyDefinition') or (self::PartView and substring-after(@xsi:type,':')='AssemblyDefinition'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(AssemblyDefinition : <sch:value-of select="$uid"/>) The AssemblyDefinition.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyDefinition') or (self::PartView and substring-after(@xsi:type,':')='AssemblyDefinition'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(AssemblyDefinition : <sch:value-of select="$uid"/>) The AssemblyDefinition.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="AssemblyOccurrenceRelationshipSubstitution"><!--(Ref to E) AssemblyOccurrenceRelationshipSubstitution.Related : AssemblyOccurrenceRelationship (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyOccurrenceRelationshipSubstitution') or (self::RelationshipObject and substring-after(@xsi:type,':')='AssemblyOccurrenceRelationshipSubstitution'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AssemblyOccurrenceRelationship'] or //RelationshipObject[@uid = $uidRef and contains(' AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  PromissoryAssemblyOccurrenceUsage ',substring-after(@xsi:type,':'))]">(AssemblyOccurrenceRelationshipSubstitution : <sch:value-of select="$uid"/>) The AssemblyOccurrenceRelationshipSubstitution.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AssemblyOccurrenceRelationship.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyOccurrenceRelationshipSubstitution') or (self::RelationshipObject and substring-after(@xsi:type,':')='AssemblyOccurrenceRelationshipSubstitution'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AssemblyOccurrenceRelationshipSubstitution : <sch:value-of select="$uid"/>) The AssemblyOccurrenceRelationshipSubstitution.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AssemblyRealizationContext"><!--(Ref to S) AssemblyRealizationContext.Design : AssemblyDesignSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyRealizationContext') or (self::AssemblyRealizationContext and not(@xsi:type)))]/Design">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DefinitionalPartViewUsage ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)] or //RelationshipObject[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' DefinitionalPartViewUsage ',substring-after(@xsi:type,':'))] or //Occurrence[@uid = $uidRef]">(AssemblyRealizationContext : <sch:value-of select="$uid"/>) The AssemblyRealizationContext.Design contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AssemblyDesignSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AssemblyViewRelationshipSubstitution"><!--(Ref to E) AssemblyViewRelationshipSubstitution.Related : AssemblyViewRelationship (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyViewRelationshipSubstitution') or (self::RelationshipObject and substring-after(@xsi:type,':')='AssemblyViewRelationshipSubstitution'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AssemblyViewRelationship'] or //RelationshipObject[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',substring-after(@xsi:type,':'))]">(AssemblyViewRelationshipSubstitution : <sch:value-of select="$uid"/>) The AssemblyViewRelationshipSubstitution.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AssemblyViewRelationship.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyViewRelationshipSubstitution') or (self::RelationshipObject and substring-after(@xsi:type,':')='AssemblyViewRelationshipSubstitution'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AssemblyViewRelationshipSubstitution : <sch:value-of select="$uid"/>) The AssemblyViewRelationshipSubstitution.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AssignmentObjectRelationship"><!--(Ref to E) AssignmentObjectRelationship.Related : AssignmentObject (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssignmentObjectRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='AssignmentObjectRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AssignmentObject'] or //AssignmentObject[@uid = $uidRef]">(AssignmentObjectRelationship : <sch:value-of select="$uid"/>) The AssignmentObjectRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AssignmentObject.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObjectRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssignmentObjectRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='AssignmentObjectRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AssignmentObjectRelationship : <sch:value-of select="$uid"/>) The AssignmentObjectRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Assumption"/>
   <sch:pattern id="AssumptionAssignment"><!--(Ref to E) AssumptionAssignment.AssignedAssumption : Assumption (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssumptionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='AssumptionAssignment'))]/AssignedAssumption">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Assumption'] or //Assumption[@uid = $uidRef]">(AssumptionAssignment : <sch:value-of select="$uid"/>) The AssumptionAssignment.AssignedAssumption contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Assumption.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssumptionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='AssumptionAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AssumptionAssignment : <sch:value-of select="$uid"/>) The AssumptionAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AssumptionRelationship"><!--(Ref to E) AssumptionRelationship.Related : Assumption (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssumptionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='AssumptionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Assumption'] or //Assumption[@uid = $uidRef]">(AssumptionRelationship : <sch:value-of select="$uid"/>) The AssumptionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Assumption.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssumptionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='AssumptionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AssumptionRelationship : <sch:value-of select="$uid"/>) The AssumptionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AxisPlacement"/>
   <sch:pattern id="Breakdown"><!--(Ref to S) Breakdown.BreakdownType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Breakdown') or (self::Breakdown and not(@xsi:type)))]/BreakdownType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Breakdown : <sch:value-of select="$uid"/>) The Breakdown.BreakdownType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownElement"><!--(Ref to S) BreakdownElement.BreakdownElementType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElement') or (self::BreakdownElement and not(@xsi:type)))]/BreakdownElementType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(BreakdownElement : <sch:value-of select="$uid"/>) The BreakdownElement.BreakdownElementType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownElementHierarchy"><!--(Ref to E) BreakdownElementViewRelationship.Related : BreakdownElementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementHierarchy') or (self::RelationshipObject and substring-after(@xsi:type,':')='BreakdownElementHierarchy'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElementView'] or //BreakdownElementView[@uid = $uidRef]">(BreakdownElementHierarchy : <sch:value-of select="$uid"/>) The BreakdownElementHierarchy.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElementView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) BreakdownElementViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementHierarchy') or (self::RelationshipObject and substring-after(@xsi:type,':')='BreakdownElementHierarchy'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(BreakdownElementHierarchy : <sch:value-of select="$uid"/>) The BreakdownElementHierarchy.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownElementRealization"><!--(Ref to S) BreakdownElementRealization.RealizedAs : BreakdownElementRealizationSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementRealization') or (self::AssociationObject and substring-after(@xsi:type,':')='BreakdownElementRealization'))]/RealizedAs">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItem ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)] or //Activity[@uid = $uidRef] or //ActivityMethod[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',substring-after(@xsi:type,':'))] or //BreakdownElement[@uid = $uidRef] or //BreakdownElementVersion[@uid = $uidRef] or //BreakdownElementView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',substring-after(@xsi:type,':'))] or //CollectionView[@uid = $uidRef] or //IndividualPartView[@uid = $uidRef] or //InterfaceConnectorOccurrence[@uid = $uidRef] or //InterfaceConnectorView[@uid = $uidRef] or //Occurrence[@uid = $uidRef] or //PartView[@uid = $uidRef] or //RequirementView[@uid = $uidRef] or //ResourceItem[@uid = $uidRef] or //RiskView[@uid = $uidRef] or //Scheme[@uid = $uidRef] or //SchemeEntry[@uid = $uidRef] or //SchemeVersion[@uid = $uidRef] or //TaskElement[@uid = $uidRef] or //TaskMethod[@uid = $uidRef] or //TaskMethodVersion[@uid = $uidRef]">(BreakdownElementRealization : <sch:value-of select="$uid"/>) The BreakdownElementRealization.RealizedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of BreakdownElementRealizationSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownElementRelationship"><!--(Ref to E) BreakdownElementRelationship.Related : BreakdownElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='BreakdownElementRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElement'] or //BreakdownElement[@uid = $uidRef]">(BreakdownElementRelationship : <sch:value-of select="$uid"/>) The BreakdownElementRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElement.</sch:assert>
      </sch:rule>
      <!--(Ref to S) BreakdownElementRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='BreakdownElementRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(BreakdownElementRelationship : <sch:value-of select="$uid"/>) The BreakdownElementRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownElementVersion"><!--(Inverse of BreakdownElement.Versions :: PartProperty) BreakdownElementVersion.VersionOf : BreakdownElement) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="BreakdownElementVersionRelationship"><!--(Ref to E) BreakdownElementVersionRelationship.Related : BreakdownElementVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='BreakdownElementVersionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElementVersion'] or //BreakdownElementVersion[@uid = $uidRef]">(BreakdownElementVersionRelationship : <sch:value-of select="$uid"/>) The BreakdownElementVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElementVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) BreakdownElementVersionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='BreakdownElementVersionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(BreakdownElementVersionRelationship : <sch:value-of select="$uid"/>) The BreakdownElementVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownElementView"><!--(Ref to E) BreakdownElementView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementView') or (self::BreakdownElementView and not(@xsi:type)))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(BreakdownElementView : <sch:value-of select="$uid"/>) The BreakdownElementView.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) BreakdownElementView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementView') or (self::BreakdownElementView and not(@xsi:type)))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(BreakdownElementView : <sch:value-of select="$uid"/>) The BreakdownElementView.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) BreakdownElementView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementView') or (self::BreakdownElementView and not(@xsi:type)))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(BreakdownElementView : <sch:value-of select="$uid"/>) The BreakdownElementView.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of BreakdownElementVersion.Views :: PartProperty) BreakdownElementView.ViewOf : BreakdownElementVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="BreakdownElementViewRelationship"><!--(Ref to E) BreakdownElementViewRelationship.Related : BreakdownElementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='BreakdownElementViewRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElementView'] or //BreakdownElementView[@uid = $uidRef]">(BreakdownElementViewRelationship : <sch:value-of select="$uid"/>) The BreakdownElementViewRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElementView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) BreakdownElementViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='BreakdownElementViewRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(BreakdownElementViewRelationship : <sch:value-of select="$uid"/>) The BreakdownElementViewRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownMember"><!--(Ref to E) BreakdownMember.BreakdownElement : BreakdownElementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownMember') or (self::AssociationObject and substring-after(@xsi:type,':')='BreakdownMember'))]/BreakdownElement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElementView'] or //BreakdownElementView[@uid = $uidRef]">(BreakdownMember : <sch:value-of select="$uid"/>) The BreakdownMember.BreakdownElement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElementView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownOf"><!--(Ref to S) BreakdownOf.AssociatedTo : BreakdownOfSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownOf') or (self::AssociationObject and substring-after(@xsi:type,':')='BreakdownOf'))]/AssociatedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemView ',@typeRef)] or //BreakdownElementView[@uid = $uidRef] or //CollectionView[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //IndividualPartView[@uid = $uidRef] or //InterfaceConnectorView[@uid = $uidRef] or //InterfaceSpecificationView[@uid = $uidRef] or //Occurrence[@uid = $uidRef] or //PartView[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //RiskView[@uid = $uidRef] or //SlotDefinition[@uid = $uidRef] or //SystemView[@uid = $uidRef]">(BreakdownOf : <sch:value-of select="$uid"/>) The BreakdownOf.AssociatedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of BreakdownOfSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownRelationship"><!--(Ref to E) BreakdownRelationship.Related : Breakdown (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='BreakdownRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Breakdown'] or //Breakdown[@uid = $uidRef]">(BreakdownRelationship : <sch:value-of select="$uid"/>) The BreakdownRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Breakdown.</sch:assert>
      </sch:rule>
      <!--(Ref to S) BreakdownRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='BreakdownRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(BreakdownRelationship : <sch:value-of select="$uid"/>) The BreakdownRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownVersion"><!--(Inverse of Breakdown.Versions :: PartProperty) BreakdownVersion.VersionOf : Breakdown) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="BreakdownVersionRelationship"><!--(Ref to E) BreakdownVersionRelationship.Related : BreakdownVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='BreakdownVersionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownVersion'] or //BreakdownVersion[@uid = $uidRef]">(BreakdownVersionRelationship : <sch:value-of select="$uid"/>) The BreakdownVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) BreakdownVersionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='BreakdownVersionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(BreakdownVersionRelationship : <sch:value-of select="$uid"/>) The BreakdownVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CartesianPoint"/>
   <sch:pattern id="CartesianTransformation"/>
   <sch:pattern id="CausalConsequence"><!--(Ref to E) CausalConsequence.Related : RiskConsequence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CausalConsequence') or (self::RelationshipObject and substring-after(@xsi:type,':')='CausalConsequence'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RiskConsequence'] or //RiskView[@uid = $uidRef and contains(' RiskConsequence ',substring-after(@xsi:type,':'))]">(CausalConsequence : <sch:value-of select="$uid"/>) The CausalConsequence.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RiskConsequence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CausalConsequence') or (self::RelationshipObject and substring-after(@xsi:type,':')='CausalConsequence'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(CausalConsequence : <sch:value-of select="$uid"/>) The CausalConsequence.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Certification"><!--(Ref to S) Certification.CertificationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Certification') or (self::Certification and not(@xsi:type)))]/CertificationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Certification : <sch:value-of select="$uid"/>) The Certification.CertificationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CertificationAssignment"><!--(Ref to E) CertificationAssignment.AssignedCertification : Certification (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CertificationAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='CertificationAssignment'))]/AssignedCertification">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Certification'] or //Certification[@uid = $uidRef]">(CertificationAssignment : <sch:value-of select="$uid"/>) The CertificationAssignment.AssignedCertification contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Certification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CertificationAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='CertificationAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(CertificationAssignment : <sch:value-of select="$uid"/>) The CertificationAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Class"><!--(Ref to E) Class.DefinedIn : OPTIONAL ExternalLibrary (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Class') or (self::Class and not(@xsi:type)))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefinedIn) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExternalLibrary'] or //ExternalLibrary[@uid = $uidRef]">(Class : <sch:value-of select="$uid"/>) The Class.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExternalLibrary.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ClassAttribute"><!--(Ref to E) ClassAttribute.AttributeDefinition : PropertyDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ClassAttribute') or (self::ClassAttribute and not(@xsi:type)))]/AttributeDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinition'] or //PropertyDefinition[@uid = $uidRef]">(ClassAttribute : <sch:value-of select="$uid"/>) The ClassAttribute.AttributeDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Classification"><!--(Ref to S) Classification.Class : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Classification') or (self::Classification and not(@xsi:type)))]/Class/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Classification : <sch:value-of select="$uid"/>) The Classification.Class contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Classification.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Classification') or (self::Classification and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Classification : <sch:value-of select="$uid"/>) The Classification.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ClassificationRelationship"><!--(Ref to E) ClassificationRelationship.Related : Classification (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ClassificationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ClassificationRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ClassificationRelationship : <sch:value-of select="$uid"/>) The ClassificationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ClassificationRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ClassificationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ClassificationRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ClassificationRelationship : <sch:value-of select="$uid"/>) The ClassificationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CollectedPartRelationship"><!--(Ref to E) ViewOccurrenceRelationship.Related : DefinitionBasedOccurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectedPartRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='CollectedPartRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DefinitionBasedOccurrence'] or //Occurrence[@uid = $uidRef and contains(' DefinitionBasedOccurrence  QuantifiedOccurrence  SingleOccurrence ',substring-after(@xsi:type,':'))]">(CollectedPartRelationship : <sch:value-of select="$uid"/>) The CollectedPartRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DefinitionBasedOccurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ViewOccurrenceRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectedPartRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='CollectedPartRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(CollectedPartRelationship : <sch:value-of select="$uid"/>) The CollectedPartRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Collection"/>
   <sch:pattern id="CollectionAssignment"><!--(Ref to E) CollectionAssignment.AssignedCollection : CollectionView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='CollectionAssignment'))]/AssignedCollection">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'CollectionView'] or //CollectionView[@uid = $uidRef]">(CollectionAssignment : <sch:value-of select="$uid"/>) The CollectionAssignment.AssignedCollection contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type CollectionView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='CollectionAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(CollectionAssignment : <sch:value-of select="$uid"/>) The CollectionAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CollectionDefinition"><!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionDefinition') or (self::PartView and substring-after(@xsi:type,':')='CollectionDefinition'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(CollectionDefinition : <sch:value-of select="$uid"/>) The CollectionDefinition.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionDefinition') or (self::PartView and substring-after(@xsi:type,':')='CollectionDefinition'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(CollectionDefinition : <sch:value-of select="$uid"/>) The CollectionDefinition.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionDefinition') or (self::PartView and substring-after(@xsi:type,':')='CollectionDefinition'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(CollectionDefinition : <sch:value-of select="$uid"/>) The CollectionDefinition.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionDefinition') or (self::PartView and substring-after(@xsi:type,':')='CollectionDefinition'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(CollectionDefinition : <sch:value-of select="$uid"/>) The CollectionDefinition.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="CollectionMembership"><!--(Ref to S) CollectionMembership.Member : CollectionMemberSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionMembership') or (self::AssociationObject and substring-after(@xsi:type,':')='CollectionMembership'))]/Member/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment  RiskEvent ',@typeRef)]) or (self::ActivityMethodRealization and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodRealization ',@typeRef)]) or (self::ActivityMethodRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodRelationship ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AdvisoryNote and //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvisoryNote ',@typeRef)]) or (self::Analysis and //ExternalRefBaseObject[@uid = $uidRef and contains(' Analysis ',@typeRef)]) or (self::AnalysisAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AnalysisAssignment ',@typeRef)]) or (self::AnalysisVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' AnalysisVersion ',@typeRef)]) or (self::Approval and //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment ',@typeRef)]) or (self::ApprovalRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalRelationship ',@typeRef)]) or (self::AssemblyViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',@typeRef)]) or (self::Assumption and //ExternalRefBaseObject[@uid = $uidRef and contains(' Assumption ',@typeRef)]) or (self::AssumptionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssumptionAssignment ',@typeRef)]) or (self::AssumptionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssumptionRelationship ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementRealization and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRealization ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)]) or (self::BreakdownElementVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',@typeRef)]) or (self::BreakdownMember and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownMember ',@typeRef)]) or (self::BreakdownOf and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownOf ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionRelationship ',@typeRef)]) or (self::Certification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Certification ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (self::Collection and //ExternalRefBaseObject[@uid = $uidRef and contains(' Collection ',@typeRef)]) or (self::CollectionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionAssignment ',@typeRef)]) or (self::CollectionMembership and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionMembership ',@typeRef)]) or (self::CollectionMembershipRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionMembershipRelationship ',@typeRef)]) or (self::CollectionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionRelationship ',@typeRef)]) or (self::CollectionVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)]) or (self::CollectionVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersionRelationship  CollectionVersionSequenceRelationship ',@typeRef)]) or (self::CollectionView and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)]) or (self::CollectionViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionViewRelationship ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Condition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (*[(self::ConditionEvaluation or (self::ConditionEvaluation and contains(' ConditionEvaluation ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionEvaluation ',@typeRef)]) or (self::ConditionEvaluationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionEvaluationAssignment ',@typeRef)]) or (self::ConditionEvaluationParameter and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionEvaluationParameter ',@typeRef)]) or (self::ConditionParameter and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionParameter ',@typeRef)]) or (self::ConditionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionRelationship ',@typeRef)]) or (self::ConfiguredAssemblyEffectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConfiguredAssemblyEffectivity ',@typeRef)]) or (self::Contract and //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::ContractRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractRelationship ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment  PartialDocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::DocumentVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersionRelationship ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::EffectivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)]) or (self::Envelope and //ExternalRefBaseObject[@uid = $uidRef and contains(' Envelope ',@typeRef)]) or (self::EnvelopeRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvelopeRelationship ',@typeRef)]) or (self::EnvironmentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvironmentAssignment ',@typeRef)]) or (self::EnvironmentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvironmentDefinition ',@typeRef)]) or (self::EnvironmentDefinitionVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvironmentDefinitionVersion ',@typeRef)]) or (*[(self::EnvironmentDefinitionView or (self::AssignedEnvironment and contains(' EnvironmentDefinitionView ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvironmentDefinitionView ',@typeRef)]) or (self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event  RelativeEvent ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::EventRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventRelationship ',@typeRef)]) or (self::Evidence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Evidence ',@typeRef)]) or (self::ExperienceGained and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExperienceGained ',@typeRef)]) or (self::ExperienceInstance and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExperienceInstance ',@typeRef)]) or (self::ExperienceType and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExperienceType ',@typeRef)]) or (self::ExperienceTypeRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExperienceTypeRelationship ',@typeRef)]) or (self::File and //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)]) or (self::FileRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::IdentifierRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IdentifierRelationship ',@typeRef)]) or (self::InZone and //ExternalRefBaseObject[@uid = $uidRef and contains(' InZone ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::InformationRight and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationRight ',@typeRef)]) or (self::InformationUsageRight and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRight ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::InformationUsageRightRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightRelationship ',@typeRef)]) or (self::InterfaceConnection and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnection  HierarchicalInterfaceConnection ',@typeRef)]) or (self::InterfaceConnector and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)]) or (self::InterfaceConnectorOccurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)]) or (self::InterfaceConnectorOccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',@typeRef)]) or (self::InterfaceConnectorRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorRelationship ',@typeRef)]) or (self::InterfaceConnectorVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)]) or (self::InterfaceConnectorVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersionRelationship ',@typeRef)]) or (self::InterfaceConnectorView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)]) or (self::InterfaceConnectorViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',@typeRef)]) or (self::InterfaceDefinitionConnection and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceDefinitionConnection ',@typeRef)]) or (self::InterfaceDefinitionFor and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceDefinitionFor ',@typeRef)]) or (self::InterfaceSpecification and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)]) or (self::InterfaceSpecificationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationRelationship ',@typeRef)]) or (self::InterfaceSpecificationVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)]) or (self::InterfaceSpecificationVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersionRelationship ',@typeRef)]) or (self::InterfaceSpecificationView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)]) or (self::InterfaceSpecificationViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',@typeRef)]) or (self::ItemAssumed and //ExternalRefBaseObject[@uid = $uidRef and contains(' ItemAssumed ',@typeRef)]) or (self::Justification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Justification ',@typeRef)]) or (self::JustificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' JustificationAssignment ',@typeRef)]) or (self::JustificationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' JustificationRelationship ',@typeRef)]) or (self::JustificationSupportAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' JustificationSupportAssignment ',@typeRef)]) or (*[(self::Language or (self::Language and contains(' Language ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Language ',@typeRef)]) or (self::Location and //ExternalRefBaseObject[@uid = $uidRef and contains(' Location ',@typeRef)]) or (self::LocationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' LocationAssignment ',@typeRef)]) or (self::LocationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' LocationRelationship ',@typeRef)]) or (*[(self::Locator or (self::Location and contains(' Locator  Address  CompoundAddress  GeographicalArea  GlobalPositionLocation  ProductBasedLocator  RegionalGrid ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Locator  Address  CompoundAddress  GeographicalArea  GlobalPositionLocation  ProductBasedLocator  RegionalGrid ',@typeRef)]) or (self::ManagedResource and //ExternalRefBaseObject[@uid = $uidRef and contains(' ManagedResource ',@typeRef)]) or (self::ManagedResourceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ManagedResourceRelationship ',@typeRef)]) or (self::Market and //ExternalRefBaseObject[@uid = $uidRef and contains(' Market ',@typeRef)]) or (self::MeasureQualification and //ExternalRefBaseObject[@uid = $uidRef and contains(' MeasureQualification ',@typeRef)]) or (self::Message and //ExternalRefBaseObject[@uid = $uidRef and contains(' Message ',@typeRef)]) or (self::MessageRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' MessageRelationship ',@typeRef)]) or (self::Observation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::ObservationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)]) or (self::ObservedEnvironment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservedEnvironment ',@typeRef)]) or (self::ObservedEnvironmentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservedEnvironmentAssignment ',@typeRef)]) or (self::ObservedEnvironmentToDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservedEnvironmentToDefinition ',@typeRef)]) or (self::ObservedEnvironmentToDefinitionVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservedEnvironmentToDefinitionVersion ',@typeRef)]) or (self::ObservedEnvironmentToDefinitionView and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservedEnvironmentToDefinitionView ',@typeRef)]) or (self::ObservedEnvironmentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservedEnvironmentVersion ',@typeRef)]) or (self::ObservedEnvironmentView and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservedEnvironmentView ',@typeRef)]) or (self::Occurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrganizationTypeAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrganizationTypeAssociation ',@typeRef)]) or (self::OrganizationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationRelationship ',@typeRef)]) or (self::OrganizationType and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationType ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartRelationship  AlternatePartRelationship ',@typeRef)]) or (self::PartToIndividualPartAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartToIndividualPartAssociation ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship ',@typeRef)]) or (self::PartVersionToIndividualPartVersionAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionToIndividualPartVersionAssociation ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)]) or (self::PartViewToIndividualPartViewAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewToIndividualPartViewAssociation ',@typeRef)]) or (self::Person and //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::PersonOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',@typeRef)]) or (self::PersonOrganizationInPosition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonOrganizationInPosition ',@typeRef)]) or (self::PersonOrganizationInPositionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonOrganizationInPositionRelationship ',@typeRef)]) or (self::Position and //ExternalRefBaseObject[@uid = $uidRef and contains(' Position ',@typeRef)]) or (self::PositionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionAssignment ',@typeRef)]) or (self::PositionGroup and //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionGroup ',@typeRef)]) or (self::PositionGroupAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionGroupAssignment ',@typeRef)]) or (self::PositionGroupAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionGroupAssociation ',@typeRef)]) or (self::PositionPositionTypeAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionPositionTypeAssociation ',@typeRef)]) or (self::PositionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionRelationship ',@typeRef)]) or (self::PositionType and //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionType ',@typeRef)]) or (self::PositionTypeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionTypeAssignment ',@typeRef)]) or (self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::ProductConcept and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)]) or (self::ProductConfigurationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)]) or (self::ProductDesignAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductDesignAssociation ',@typeRef)]) or (self::ProductGroup and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductGroup ',@typeRef)]) or (self::ProductGroupMembership and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductGroupMembership ',@typeRef)]) or (self::Project and //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::ProjectRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectRelationship ',@typeRef)]) or (self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::QualificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' QualificationAssignment ',@typeRef)]) or (self::QualificationType and //ExternalRefBaseObject[@uid = $uidRef and contains(' QualificationType ',@typeRef)]) or (self::QualificationTypeRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' QualificationTypeRelationship ',@typeRef)]) or (self::RelatedConditionParameter and //ExternalRefBaseObject[@uid = $uidRef and contains(' RelatedConditionParameter ',@typeRef)]) or (self::Representation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',@typeRef)]) or (self::RepresentationContext and //ExternalRefBaseObject[@uid = $uidRef and contains(' RepresentationContext  GeometricCoordinateSpace ',@typeRef)]) or (self::RepresentationItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' RepresentationItem  DetailedGeometricModelItem  AxisPlacement  Direction  Point  CartesianPoint  ExternalRepresentationItem ',@typeRef)]) or (self::RepresentationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RepresentationRelationship  GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',@typeRef)]) or (self::RequiredResource and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequiredResource ',@typeRef)]) or (self::RequiredResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequiredResourceAssignment ',@typeRef)]) or (self::RequiredResourceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequiredResourceRelationship ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementSatisfactionAssertion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementSatisfactionAssertion ',@typeRef)]) or (self::RequirementSource and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementSource ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::ResourceAsRealized and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealized ',@typeRef)]) or (self::ResourceAsRealizedAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealizedAssignment ',@typeRef)]) or (self::ResourceAsRealizedAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealizedAssociation ',@typeRef)]) or (self::ResourceEvent and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceEvent  DecreasingResourceEvent  IncreasingResourceEvent ',@typeRef)]) or (self::ResourceEventCorrespondenceAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceEventCorrespondenceAssociation ',@typeRef)]) or (self::ResourceEventRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceEventRelationship ',@typeRef)]) or (self::ResourceItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItem ',@typeRef)]) or (self::ResourceItemAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemAssignment ',@typeRef)]) or (self::ResourceItemRealization and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRealization ',@typeRef)]) or (self::ResourceItemRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',@typeRef)]) or (self::Risk and //ExternalRefBaseObject[@uid = $uidRef and contains(' Risk ',@typeRef)]) or (self::RiskImpactAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskImpactAssignment ',@typeRef)]) or (self::RiskPerceptionSourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskPerceptionSourceAssignment ',@typeRef)]) or (self::RiskRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskRelationship ',@typeRef)]) or (self::RiskVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)]) or (self::RiskView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)]) or (self::Scheme and //ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)]) or (self::SchemeEntry and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)]) or (self::SchemeEntryRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntryRelationship  SequencingRelationship ',@typeRef)]) or (self::SchemeRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeRelationship ',@typeRef)]) or (self::SchemeVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)]) or (self::SchemeVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersionRelationship ',@typeRef)]) or (self::SecurityClassification and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassification ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Slot and //ExternalRefBaseObject[@uid = $uidRef and contains(' Slot ',@typeRef)]) or (self::SlotDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)]) or (self::SlotDesignToPlanned and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDesignToPlanned ',@typeRef)]) or (self::SlotDesignToRealized and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDesignToRealized ',@typeRef)]) or (self::SlotOn and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotOn ',@typeRef)]) or (self::SlotPlannedToRealized and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotPlannedToRealized ',@typeRef)]) or (*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',@typeRef)]) or (self::State and //ExternalRefBaseObject[@uid = $uidRef and contains(' State  StateObserved  StatePredicted ',@typeRef)]) or (self::StateAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' StateAssignment ',@typeRef)]) or (self::StateDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinition ',@typeRef)]) or (self::StateDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionAssignment ',@typeRef)]) or (self::StateDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionRelationship  StateDefinitionCauseEffect  StateDefinitionComposition  StateDefinitionTransition ',@typeRef)]) or (self::StateDefinitionStateAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionStateAssociation  StateDefinitionConfirmedAssociation  StateDefinitionHypothesisAssociation  StateDefinitionPredictedAssociation ',@typeRef)]) or (self::StateDefinitionStateAssociationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionStateAssociationRelationship  StateHypothesisToConfirmationRelationship ',@typeRef)]) or (self::StateRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' StateRelationship  StateCauseEffect  StateComposition  StatePredictedToObserved  StateTransition ',@typeRef)]) or (self::System and //ExternalRefBaseObject[@uid = $uidRef and contains(' System ',@typeRef)]) or (self::SystemVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)]) or (self::SystemView and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemView ',@typeRef)]) or (*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)]) or (self::TaskElementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElementAssignment ',@typeRef)]) or (self::TaskElementRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElementRelationship ',@typeRef)]) or (self::TaskElementStateAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElementStateAssociation ',@typeRef)]) or (self::TaskMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)]) or (self::TaskMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodAssignment ',@typeRef)]) or (self::TaskMethodRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodRelationship ',@typeRef)]) or (self::TaskMethodStateAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodStateAssociation ',@typeRef)]) or (self::TaskMethodVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)]) or (self::TaskMethodVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersionAssignment ',@typeRef)]) or (self::TaskMethodVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersionRelationship ',@typeRef)]) or (self::TaskObjective and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskObjective ',@typeRef)]) or (self::TaskObjectiveStateAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskObjectiveStateAssociation ',@typeRef)]) or (*[(self::TimeInterval or (self::AssignedTimeInterval and contains(' TimeInterval  TimeIntervalWithBounds ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeInterval  TimeIntervalWithBounds ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::TimeIntervalRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalRelationship ',@typeRef)]) or (self::TypeOfPerson and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeOfPerson ',@typeRef)]) or (self::TypeOfPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeOfPersonAssignment ',@typeRef)]) or (self::TypeOfPersonDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeOfPersonDefinition ',@typeRef)]) or (self::TypeOfPersonDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeOfPersonDefinitionRelationship ',@typeRef)]) or (self::TypeOfPersonDefinitionRequiredAttributesAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeOfPersonDefinitionRequiredAttributesAssociation ',@typeRef)]) or (self::TypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::Unit and //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)]) or (self::Validation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Validation ',@typeRef)]) or (self::Verification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Verification ',@typeRef)]) or (self::VerificationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' VerificationRelationship ',@typeRef)]) or (self::ViewContext and //ExternalRefBaseObject[@uid = $uidRef and contains(' ViewContext ',@typeRef)]) or (self::ViewOccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship ',@typeRef)]) or (self::WorkOrder and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrder ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //AssignmentObject[@uid = $uidRef and contains(' ActivityAssignment ',substring-after(@xsi:type,':'))]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //AssignmentObject[@uid = $uidRef and contains(' ActivityMethodAssignment  RiskEvent ',substring-after(@xsi:type,':'))]) or (self::ActivityMethodRealization and //AssociationObject[@uid = $uidRef and contains(' ActivityMethodRealization ',substring-after(@xsi:type,':'))]) or (self::ActivityMethodRelationship and //RelationshipObject[@uid = $uidRef and contains(' ActivityMethodRelationship ',substring-after(@xsi:type,':'))]) or (self::ActivityRelationship and //RelationshipObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',substring-after(@xsi:type,':'))]) or (self::AddressAssignment and //AssignmentObject[@uid = $uidRef and contains(' AddressAssignment ',substring-after(@xsi:type,':'))]) or (self::AdvisoryNote and //AdvisoryNote[@uid = $uidRef]) or (self::Analysis and //Analysis[@uid = $uidRef]) or (self::AnalysisAssignment and //AssignmentObject[@uid = $uidRef and contains(' AnalysisAssignment ',substring-after(@xsi:type,':'))]) or (self::AnalysisVersion and //AnalysisVersion[@uid = $uidRef]) or (self::Approval and //Approval[@uid = $uidRef]) or (self::ApprovalAssignment and //AssignmentObject[@uid = $uidRef and contains(' ApprovalAssignment ',substring-after(@xsi:type,':'))]) or (self::ApprovalRelationship and //RelationshipObject[@uid = $uidRef and contains(' ApprovalRelationship ',substring-after(@xsi:type,':'))]) or (self::AssemblyViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',substring-after(@xsi:type,':'))]) or (self::Assumption and //Assumption[@uid = $uidRef]) or (self::AssumptionAssignment and //AssignmentObject[@uid = $uidRef and contains(' AssumptionAssignment ',substring-after(@xsi:type,':'))]) or (self::AssumptionRelationship and //RelationshipObject[@uid = $uidRef and contains(' AssumptionRelationship ',substring-after(@xsi:type,':'))]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementRealization and //AssociationObject[@uid = $uidRef and contains(' BreakdownElementRealization ',substring-after(@xsi:type,':'))]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',substring-after(@xsi:type,':'))]) or (self::BreakdownMember and //AssociationObject[@uid = $uidRef and contains(' BreakdownMember ',substring-after(@xsi:type,':'))]) or (self::BreakdownOf and //AssociationObject[@uid = $uidRef and contains(' BreakdownOf ',substring-after(@xsi:type,':'))]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' BreakdownVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::Certification and //Certification[@uid = $uidRef]) or (self::CertificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' CertificationAssignment ',substring-after(@xsi:type,':'))]) or (self::Class and //Class[@uid = $uidRef]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::Collection and //Collection[@uid = $uidRef]) or (self::CollectionAssignment and //AssignmentObject[@uid = $uidRef and contains(' CollectionAssignment ',substring-after(@xsi:type,':'))]) or (self::CollectionMembership and //AssociationObject[@uid = $uidRef and contains(' CollectionMembership ',substring-after(@xsi:type,':'))]) or (self::CollectionMembershipRelationship and //RelationshipObject[@uid = $uidRef and contains(' CollectionMembershipRelationship ',substring-after(@xsi:type,':'))]) or (self::CollectionRelationship and //RelationshipObject[@uid = $uidRef and contains(' CollectionRelationship ',substring-after(@xsi:type,':'))]) or (self::CollectionVersion and //CollectionVersion[@uid = $uidRef]) or (self::CollectionVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' CollectionVersionRelationship  CollectionVersionSequenceRelationship ',substring-after(@xsi:type,':'))]) or (self::CollectionView and //CollectionView[@uid = $uidRef]) or (self::CollectionViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' CollectionViewRelationship ',substring-after(@xsi:type,':'))]) or (self::Condition and //*[(self::Condition or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Condition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ConditionAssignment and //AssignmentObject[@uid = $uidRef and contains(' ConditionAssignment ',substring-after(@xsi:type,':'))]) or (self::ConditionEvaluation and //*[(self::ConditionEvaluation or (self::ConditionEvaluation and contains(' ConditionEvaluation ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ConditionEvaluationAssignment and //AssignmentObject[@uid = $uidRef and contains(' ConditionEvaluationAssignment ',substring-after(@xsi:type,':'))]) or (self::ConditionEvaluationParameter and //ConditionEvaluationParameter[@uid = $uidRef]) or (self::ConditionParameter and //ConditionParameter[@uid = $uidRef]) or (self::ConditionRelationship and //RelationshipObject[@uid = $uidRef and contains(' ConditionRelationship ',substring-after(@xsi:type,':'))]) or (self::ConfiguredAssemblyEffectivity and //ConfiguredAssemblyEffectivity[@uid = $uidRef]) or (self::Contract and //Contract[@uid = $uidRef]) or (self::ContractAssignment and //AssignmentObject[@uid = $uidRef and contains(' ContractAssignment ',substring-after(@xsi:type,':'))]) or (self::ContractRelationship and //RelationshipObject[@uid = $uidRef and contains(' ContractRelationship ',substring-after(@xsi:type,':'))]) or (self::DateTimeAssignment and //AssignmentObject[@uid = $uidRef and contains(' DateTimeAssignment ',substring-after(@xsi:type,':'))]) or (self::DateTimeString) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //AssignmentObject[@uid = $uidRef and contains(' DocumentAssignment  PartialDocumentAssignment ',substring-after(@xsi:type,':'))]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',substring-after(@xsi:type,':'))]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::DocumentVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' DocumentVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //AssignmentObject[@uid = $uidRef and contains(' EffectivityAssignment ',substring-after(@xsi:type,':'))]) or (self::EffectivityRelationship and //RelationshipObject[@uid = $uidRef and contains(' EffectivityRelationship ',substring-after(@xsi:type,':'))]) or (self::Envelope and //Envelope[@uid = $uidRef]) or (self::EnvelopeRelationship and //RelationshipObject[@uid = $uidRef and contains(' EnvelopeRelationship ',substring-after(@xsi:type,':'))]) or (self::EnvironmentAssignment and //AssignmentObject[@uid = $uidRef and contains(' EnvironmentAssignment ',substring-after(@xsi:type,':'))]) or (self::EnvironmentDefinition and //Environment[@uid = $uidRef and contains(' EnvironmentDefinition ',substring-after(@xsi:type,':'))]) or (self::EnvironmentDefinitionVersion and //EnvironmentVersion[@uid = $uidRef and contains(' EnvironmentDefinitionVersion ',substring-after(@xsi:type,':'))]) or (self::EnvironmentDefinitionView and //*[(self::EnvironmentDefinitionView or (self::AssignedEnvironment and contains(' EnvironmentDefinitionView ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef and contains(' EnvironmentDefinitionView ',substring-after(@xsi:type,':'))]) or (self::Event and //Event[@uid = $uidRef]) or (self::EventAssignment and //AssignmentObject[@uid = $uidRef and contains(' EventAssignment ',substring-after(@xsi:type,':'))]) or (self::EventRelationship and //RelationshipObject[@uid = $uidRef and contains(' EventRelationship ',substring-after(@xsi:type,':'))]) or (self::Evidence and //Evidence[@uid = $uidRef]) or (self::ExperienceGained and //ExperienceGained[@uid = $uidRef]) or (self::ExperienceInstance and //ExperienceInstance[@uid = $uidRef]) or (self::ExperienceType and //ExperienceType[@uid = $uidRef]) or (self::ExperienceTypeRelationship and //RelationshipObject[@uid = $uidRef and contains(' ExperienceTypeRelationship ',substring-after(@xsi:type,':'))]) or (self::File and //File[@uid = $uidRef]) or (self::FileRelationship and //RelationshipObject[@uid = $uidRef and contains(' FileRelationship ',substring-after(@xsi:type,':'))]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::IdentifierRelationship and //RelationshipObject[@uid = $uidRef and contains(' IdentifierRelationship ',substring-after(@xsi:type,':'))]) or (self::InZone and //AssociationObject[@uid = $uidRef and contains(' InZone ',substring-after(@xsi:type,':'))]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',substring-after(@xsi:type,':'))]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::InformationRight and //InformationRight[@uid = $uidRef]) or (self::InformationUsageRight and //InformationUsageRight[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //AssignmentObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',substring-after(@xsi:type,':'))]) or (self::InformationUsageRightRelationship and //RelationshipObject[@uid = $uidRef and contains(' InformationUsageRightRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnection and //InterfaceConnection[@uid = $uidRef]) or (self::InterfaceConnector and //InterfaceConnector[@uid = $uidRef]) or (self::InterfaceConnectorOccurrence and //InterfaceConnectorOccurrence[@uid = $uidRef]) or (self::InterfaceConnectorOccurrenceRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorVersion and //InterfaceConnectorVersion[@uid = $uidRef]) or (self::InterfaceConnectorVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorView and //InterfaceConnectorView[@uid = $uidRef]) or (self::InterfaceConnectorViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceDefinitionConnection and //InterfaceDefinitionConnection[@uid = $uidRef]) or (self::InterfaceDefinitionFor and //AssociationObject[@uid = $uidRef and contains(' InterfaceDefinitionFor ',substring-after(@xsi:type,':'))]) or (self::InterfaceSpecification and //InterfaceSpecification[@uid = $uidRef]) or (self::InterfaceSpecificationRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceSpecificationVersion and //InterfaceSpecificationVersion[@uid = $uidRef]) or (self::InterfaceSpecificationVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceSpecificationView and //InterfaceSpecificationView[@uid = $uidRef]) or (self::InterfaceSpecificationViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',substring-after(@xsi:type,':'))]) or (self::ItemAssumed and //AssociationObject[@uid = $uidRef and contains(' ItemAssumed ',substring-after(@xsi:type,':'))]) or (self::Justification and //Justification[@uid = $uidRef]) or (self::JustificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' JustificationAssignment ',substring-after(@xsi:type,':'))]) or (self::JustificationRelationship and //RelationshipObject[@uid = $uidRef and contains(' JustificationRelationship ',substring-after(@xsi:type,':'))]) or (self::JustificationSupportAssignment and //AssignmentObject[@uid = $uidRef and contains(' JustificationSupportAssignment ',substring-after(@xsi:type,':'))]) or (self::Language and //*[(self::Language or (self::Language and contains(' Language ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Location and //Location[@uid = $uidRef]) or (self::LocationAssignment and //AssignmentObject[@uid = $uidRef and contains(' LocationAssignment ',substring-after(@xsi:type,':'))]) or (self::LocationRelationship and //RelationshipObject[@uid = $uidRef and contains(' LocationRelationship ',substring-after(@xsi:type,':'))]) or (self::Locator and //*[(self::Locator or (self::Location and contains(' Locator  Address  CompoundAddress  GeographicalArea  GlobalPositionLocation  ProductBasedLocator  RegionalGrid ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ManagedResource and //ManagedResource[@uid = $uidRef]) or (self::ManagedResourceRelationship and //RelationshipObject[@uid = $uidRef and contains(' ManagedResourceRelationship ',substring-after(@xsi:type,':'))]) or (self::Market and //Market[@uid = $uidRef]) or (self::MeasureQualification and //MeasureQualification[@uid = $uidRef]) or (self::Message and //Message[@uid = $uidRef]) or (self::MessageRelationship and //RelationshipObject[@uid = $uidRef and contains(' MessageRelationship ',substring-after(@xsi:type,':'))]) or (self::Observation and //Observation[@uid = $uidRef]) or (self::ObservationAssignment and //AssignmentObject[@uid = $uidRef and contains(' ObservationAssignment ',substring-after(@xsi:type,':'))]) or (self::ObservationConsequence and //AssociationObject[@uid = $uidRef and contains(' ObservationConsequence ',substring-after(@xsi:type,':'))]) or (self::ObservationRelationship and //RelationshipObject[@uid = $uidRef and contains(' ObservationRelationship ',substring-after(@xsi:type,':'))]) or (self::ObservedEnvironment and //Environment[@uid = $uidRef and contains(' ObservedEnvironment ',substring-after(@xsi:type,':'))]) or (self::ObservedEnvironmentAssignment and //AssignmentObject[@uid = $uidRef and contains(' ObservedEnvironmentAssignment ',substring-after(@xsi:type,':'))]) or (self::ObservedEnvironmentToDefinition and //AssociationObject[@uid = $uidRef and contains(' ObservedEnvironmentToDefinition ',substring-after(@xsi:type,':'))]) or (self::ObservedEnvironmentToDefinitionVersion and //AssociationObject[@uid = $uidRef and contains(' ObservedEnvironmentToDefinitionVersion ',substring-after(@xsi:type,':'))]) or (self::ObservedEnvironmentToDefinitionView and //AssociationObject[@uid = $uidRef and contains(' ObservedEnvironmentToDefinitionView ',substring-after(@xsi:type,':'))]) or (self::ObservedEnvironmentVersion and //EnvironmentVersion[@uid = $uidRef and contains(' ObservedEnvironmentVersion ',substring-after(@xsi:type,':'))]) or (self::ObservedEnvironmentView and //EnvironmentView[@uid = $uidRef and contains(' ObservedEnvironmentView ',substring-after(@xsi:type,':'))]) or (self::Occurrence and //Occurrence[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrganizationTypeAssociation and //AssociationObject[@uid = $uidRef and contains(' OrganizationOrganizationTypeAssociation ',substring-after(@xsi:type,':'))]) or (self::OrganizationRelationship and //RelationshipObject[@uid = $uidRef and contains(' OrganizationRelationship ',substring-after(@xsi:type,':'))]) or (self::OrganizationType and //OrganizationType[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartRelationship and //RelationshipObject[@uid = $uidRef and contains(' PartRelationship  AlternatePartRelationship ',substring-after(@xsi:type,':'))]) or (self::PartToIndividualPartAssociation and //AssociationObject[@uid = $uidRef and contains(' PartToIndividualPartAssociation ',substring-after(@xsi:type,':'))]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' PartVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::PartVersionToIndividualPartVersionAssociation and //AssociationObject[@uid = $uidRef and contains(' PartVersionToIndividualPartVersionAssociation ',substring-after(@xsi:type,':'))]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewToIndividualPartViewAssociation and //AssociationObject[@uid = $uidRef and contains(' PartViewToIndividualPartViewAssociation ',substring-after(@xsi:type,':'))]) or (self::Person and //Person[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef]) or (self::PersonOrganizationAssignment and //AssignmentObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',substring-after(@xsi:type,':'))]) or (self::PersonOrganizationInPosition and //PersonOrganizationInPosition[@uid = $uidRef]) or (self::PersonOrganizationInPositionRelationship and //RelationshipObject[@uid = $uidRef and contains(' PersonOrganizationInPositionRelationship ',substring-after(@xsi:type,':'))]) or (self::Position and //Position[@uid = $uidRef]) or (self::PositionAssignment and //AssignmentObject[@uid = $uidRef and contains(' PositionAssignment ',substring-after(@xsi:type,':'))]) or (self::PositionGroup and //PositionGroup[@uid = $uidRef]) or (self::PositionGroupAssignment and //AssignmentObject[@uid = $uidRef and contains(' PositionGroupAssignment ',substring-after(@xsi:type,':'))]) or (self::PositionGroupAssociation and //AssociationObject[@uid = $uidRef and contains(' PositionGroupAssociation ',substring-after(@xsi:type,':'))]) or (self::PositionPositionTypeAssociation and //AssociationObject[@uid = $uidRef and contains(' PositionPositionTypeAssociation ',substring-after(@xsi:type,':'))]) or (self::PositionRelationship and //RelationshipObject[@uid = $uidRef and contains(' PositionRelationship ',substring-after(@xsi:type,':'))]) or (self::PositionType and //PositionType[@uid = $uidRef]) or (self::PositionTypeAssignment and //AssignmentObject[@uid = $uidRef and contains(' PositionTypeAssignment ',substring-after(@xsi:type,':'))]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::ProductConcept and //ProductConcept[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProductConfigurationRelationship and //RelationshipObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',substring-after(@xsi:type,':'))]) or (self::ProductDesignAssociation and //AssociationObject[@uid = $uidRef and contains(' ProductDesignAssociation ',substring-after(@xsi:type,':'))]) or (self::ProductGroup and //ProductGroup[@uid = $uidRef]) or (self::ProductGroupMembership and //AssociationObject[@uid = $uidRef and contains(' ProductGroupMembership ',substring-after(@xsi:type,':'))]) or (self::Project and //Project[@uid = $uidRef]) or (self::ProjectAssignment and //AssignmentObject[@uid = $uidRef and contains(' ProjectAssignment ',substring-after(@xsi:type,':'))]) or (self::ProjectRelationship and //RelationshipObject[@uid = $uidRef and contains(' ProjectRelationship ',substring-after(@xsi:type,':'))]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',substring-after(@xsi:type,':'))]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //AssignmentObject[@uid = $uidRef and contains(' PropertyValueAssignment ',substring-after(@xsi:type,':'))]) or (self::QualificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' QualificationAssignment ',substring-after(@xsi:type,':'))]) or (self::QualificationType and //QualificationType[@uid = $uidRef]) or (self::QualificationTypeRelationship and //RelationshipObject[@uid = $uidRef and contains(' QualificationTypeRelationship ',substring-after(@xsi:type,':'))]) or (self::RelatedConditionParameter and //AssociationObject[@uid = $uidRef and contains(' RelatedConditionParameter ',substring-after(@xsi:type,':'))]) or (self::Representation and //Representation[@uid = $uidRef]) or (self::RepresentationContext and //RepresentationContext[@uid = $uidRef]) or (self::RepresentationItem and //RepresentationItem[@uid = $uidRef]) or (self::RepresentationRelationship and //RelationshipObject[@uid = $uidRef and contains(' RepresentationRelationship  GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',substring-after(@xsi:type,':'))]) or (self::RequiredResource and //RequiredResource[@uid = $uidRef]) or (self::RequiredResourceAssignment and //AssignmentObject[@uid = $uidRef and contains(' RequiredResourceAssignment ',substring-after(@xsi:type,':'))]) or (self::RequiredResourceRelationship and //RelationshipObject[@uid = $uidRef and contains(' RequiredResourceRelationship ',substring-after(@xsi:type,':'))]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //AssignmentObject[@uid = $uidRef and contains(' RequirementAssignment ',substring-after(@xsi:type,':'))]) or (self::RequirementSatisfactionAssertion and //RequirementSatisfactionAssertion[@uid = $uidRef]) or (self::RequirementSource and //RequirementSource[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::ResourceAsRealized and //ResourceAsRealized[@uid = $uidRef]) or (self::ResourceAsRealizedAssignment and //AssignmentObject[@uid = $uidRef and contains(' ResourceAsRealizedAssignment ',substring-after(@xsi:type,':'))]) or (self::ResourceAsRealizedAssociation and //AssociationObject[@uid = $uidRef and contains(' ResourceAsRealizedAssociation ',substring-after(@xsi:type,':'))]) or (self::ResourceEvent and //ResourceEvent[@uid = $uidRef]) or (self::ResourceEventCorrespondenceAssociation and //AssociationObject[@uid = $uidRef and contains(' ResourceEventCorrespondenceAssociation ',substring-after(@xsi:type,':'))]) or (self::ResourceEventRelationship and //RelationshipObject[@uid = $uidRef and contains(' ResourceEventRelationship ',substring-after(@xsi:type,':'))]) or (self::ResourceItem and //ResourceItem[@uid = $uidRef]) or (self::ResourceItemAssignment and //AssignmentObject[@uid = $uidRef and contains(' ResourceItemAssignment ',substring-after(@xsi:type,':'))]) or (self::ResourceItemRealization and //AssociationObject[@uid = $uidRef and contains(' ResourceItemRealization ',substring-after(@xsi:type,':'))]) or (self::ResourceItemRelationship and //RelationshipObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',substring-after(@xsi:type,':'))]) or (self::Risk and //Risk[@uid = $uidRef]) or (self::RiskImpactAssignment and //AssignmentObject[@uid = $uidRef and contains(' RiskImpactAssignment ',substring-after(@xsi:type,':'))]) or (self::RiskPerceptionSourceAssignment and //AssignmentObject[@uid = $uidRef and contains(' RiskPerceptionSourceAssignment ',substring-after(@xsi:type,':'))]) or (self::RiskRelationship and //RelationshipObject[@uid = $uidRef and contains(' RiskRelationship ',substring-after(@xsi:type,':'))]) or (self::RiskVersion and //RiskVersion[@uid = $uidRef]) or (self::RiskView and //RiskView[@uid = $uidRef]) or (self::Scheme and //Scheme[@uid = $uidRef]) or (self::SchemeEntry and //SchemeEntry[@uid = $uidRef]) or (self::SchemeEntryRelationship and //RelationshipObject[@uid = $uidRef and contains(' SchemeEntryRelationship  SequencingRelationship ',substring-after(@xsi:type,':'))]) or (self::SchemeRelationship and //RelationshipObject[@uid = $uidRef and contains(' SchemeRelationship ',substring-after(@xsi:type,':'))]) or (self::SchemeVersion and //SchemeVersion[@uid = $uidRef]) or (self::SchemeVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' SchemeVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::SecurityClassification and //SecurityClassification[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',substring-after(@xsi:type,':'))]) or (self::Slot and //Slot[@uid = $uidRef]) or (self::SlotDefinition and //SlotDefinition[@uid = $uidRef]) or (self::SlotDesignToPlanned and //RelationshipObject[@uid = $uidRef and contains(' SlotDesignToPlanned ',substring-after(@xsi:type,':'))]) or (self::SlotDesignToRealized and //RelationshipObject[@uid = $uidRef and contains(' SlotDesignToRealized ',substring-after(@xsi:type,':'))]) or (self::SlotOn and //AssociationObject[@uid = $uidRef and contains(' SlotOn ',substring-after(@xsi:type,':'))]) or (self::SlotPlannedToRealized and //RelationshipObject[@uid = $uidRef and contains(' SlotPlannedToRealized ',substring-after(@xsi:type,':'))]) or (self::SlotVersion and //*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::State and //State[@uid = $uidRef]) or (self::StateAssignment and //AssignmentObject[@uid = $uidRef and contains(' StateAssignment ',substring-after(@xsi:type,':'))]) or (self::StateDefinition and //StateDefinition[@uid = $uidRef]) or (self::StateDefinitionAssignment and //AssignmentObject[@uid = $uidRef and contains(' StateDefinitionAssignment ',substring-after(@xsi:type,':'))]) or (self::StateDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' StateDefinitionRelationship  StateDefinitionCauseEffect  StateDefinitionComposition  StateDefinitionTransition ',substring-after(@xsi:type,':'))]) or (self::StateDefinitionStateAssociation and //AssociationObject[@uid = $uidRef and contains(' StateDefinitionStateAssociation  StateDefinitionConfirmedAssociation  StateDefinitionHypothesisAssociation  StateDefinitionPredictedAssociation ',substring-after(@xsi:type,':'))]) or (self::StateDefinitionStateAssociationRelationship and //RelationshipObject[@uid = $uidRef and contains(' StateDefinitionStateAssociationRelationship  StateHypothesisToConfirmationRelationship ',substring-after(@xsi:type,':'))]) or (self::StateRelationship and //RelationshipObject[@uid = $uidRef and contains(' StateRelationship  StateCauseEffect  StateComposition  StatePredictedToObserved  StateTransition ',substring-after(@xsi:type,':'))]) or (self::System and //System[@uid = $uidRef]) or (self::SystemVersion and //SystemVersion[@uid = $uidRef]) or (self::SystemView and //SystemView[@uid = $uidRef]) or (self::TaskElement and //*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::TaskElementAssignment and //AssignmentObject[@uid = $uidRef and contains(' TaskElementAssignment ',substring-after(@xsi:type,':'))]) or (self::TaskElementRelationship and //RelationshipObject[@uid = $uidRef and contains(' TaskElementRelationship ',substring-after(@xsi:type,':'))]) or (self::TaskElementStateAssociation and //AssociationObject[@uid = $uidRef and contains(' TaskElementStateAssociation ',substring-after(@xsi:type,':'))]) or (self::TaskMethod and //TaskMethod[@uid = $uidRef]) or (self::TaskMethodAssignment and //AssignmentObject[@uid = $uidRef and contains(' TaskMethodAssignment ',substring-after(@xsi:type,':'))]) or (self::TaskMethodRelationship and //RelationshipObject[@uid = $uidRef and contains(' TaskMethodRelationship ',substring-after(@xsi:type,':'))]) or (self::TaskMethodStateAssociation and //AssociationObject[@uid = $uidRef and contains(' TaskMethodStateAssociation ',substring-after(@xsi:type,':'))]) or (self::TaskMethodVersion and //TaskMethodVersion[@uid = $uidRef]) or (self::TaskMethodVersionAssignment and //AssignmentObject[@uid = $uidRef and contains(' TaskMethodVersionAssignment ',substring-after(@xsi:type,':'))]) or (self::TaskMethodVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' TaskMethodVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::TaskObjective and //TaskObjective[@uid = $uidRef]) or (self::TaskObjectiveStateAssociation and //AssociationObject[@uid = $uidRef and contains(' TaskObjectiveStateAssociation ',substring-after(@xsi:type,':'))]) or (self::TimeInterval and //*[(self::TimeInterval or (self::AssignedTimeInterval and contains(' TimeInterval  TimeIntervalWithBounds ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::TimeIntervalAssignment and //AssignmentObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',substring-after(@xsi:type,':'))]) or (self::TimeIntervalRelationship and //RelationshipObject[@uid = $uidRef and contains(' TimeIntervalRelationship ',substring-after(@xsi:type,':'))]) or (self::TypeOfPerson and //TypeOfPerson[@uid = $uidRef]) or (self::TypeOfPersonAssignment and //AssignmentObject[@uid = $uidRef and contains(' TypeOfPersonAssignment ',substring-after(@xsi:type,':'))]) or (self::TypeOfPersonDefinition and //TypeOfPersonDefinition[@uid = $uidRef]) or (self::TypeOfPersonDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' TypeOfPersonDefinitionRelationship ',substring-after(@xsi:type,':'))]) or (self::TypeOfPersonDefinitionRequiredAttributesAssociation and //AssociationObject[@uid = $uidRef and contains(' TypeOfPersonDefinitionRequiredAttributesAssociation ',substring-after(@xsi:type,':'))]) or (self::TypeQualifier and //TypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::Unit and //Unit[@uid = $uidRef]) or (self::Validation and //Validation[@uid = $uidRef]) or (self::Verification and //Verification[@uid = $uidRef]) or (self::VerificationRelationship and //RelationshipObject[@uid = $uidRef and contains(' VerificationRelationship ',substring-after(@xsi:type,':'))]) or (self::ViewContext and //ViewContext[@uid = $uidRef]) or (self::ViewOccurrenceRelationship and //RelationshipObject[@uid = $uidRef and contains(' ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship ',substring-after(@xsi:type,':'))]) or (self::WorkOrder and //WorkOrder[@uid = $uidRef]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef]) or (self::WorkRequestAssignment and //AssignmentObject[@uid = $uidRef and contains(' WorkRequestAssignment ',substring-after(@xsi:type,':'))])">(CollectionMembership : <sch:value-of select="$uid"/>) The CollectionMembership.Member contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of CollectionMemberSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CollectionMembershipRelationship"><!--(Ref to E) CollectionMembershipRelationship.Related : CollectionMembership (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionMembershipRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='CollectionMembershipRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'CollectionMembership'] or //AssociationObject[@uid = $uidRef and contains(' CollectionMembership ',substring-after(@xsi:type,':'))]">(CollectionMembershipRelationship : <sch:value-of select="$uid"/>) The CollectionMembershipRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type CollectionMembership.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionMembershipRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='CollectionMembershipRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(CollectionMembershipRelationship : <sch:value-of select="$uid"/>) The CollectionMembershipRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CollectionRelationship"><!--(Ref to E) CollectionRelationship.Related : Collection (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='CollectionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Collection'] or //Collection[@uid = $uidRef]">(CollectionRelationship : <sch:value-of select="$uid"/>) The CollectionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Collection.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='CollectionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(CollectionRelationship : <sch:value-of select="$uid"/>) The CollectionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CollectionVersion"><!--(Inverse of Collection.Versions :: PartProperty) CollectionVersion.VersionOf : Collection) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="CollectionVersionRelationship"><!--(Ref to E) CollectionVersionRelationship.Related : CollectionVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='CollectionVersionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'CollectionVersion'] or //CollectionVersion[@uid = $uidRef]">(CollectionVersionRelationship : <sch:value-of select="$uid"/>) The CollectionVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type CollectionVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='CollectionVersionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(CollectionVersionRelationship : <sch:value-of select="$uid"/>) The CollectionVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CollectionVersionSequenceRelationship"><!--(Ref to E) CollectionVersionRelationship.Related : CollectionVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionVersionSequenceRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='CollectionVersionSequenceRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'CollectionVersion'] or //CollectionVersion[@uid = $uidRef]">(CollectionVersionSequenceRelationship : <sch:value-of select="$uid"/>) The CollectionVersionSequenceRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type CollectionVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionVersionSequenceRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='CollectionVersionSequenceRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(CollectionVersionSequenceRelationship : <sch:value-of select="$uid"/>) The CollectionVersionSequenceRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CollectionView"><!--(Ref to E) CollectionView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionView') or (self::CollectionView and not(@xsi:type)))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(CollectionView : <sch:value-of select="$uid"/>) The CollectionView.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) CollectionView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionView') or (self::CollectionView and not(@xsi:type)))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(CollectionView : <sch:value-of select="$uid"/>) The CollectionView.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of CollectionVersion.Views :: PartProperty) CollectionView.ViewOf : CollectionVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="CollectionViewRelationship"><!--(Ref to E) CollectionViewRelationship.Related : CollectionView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='CollectionViewRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'CollectionView'] or //CollectionView[@uid = $uidRef]">(CollectionViewRelationship : <sch:value-of select="$uid"/>) The CollectionViewRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type CollectionView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='CollectionViewRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(CollectionViewRelationship : <sch:value-of select="$uid"/>) The CollectionViewRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ComponentPlacement"><!--(Ref to E) ComponentPlacement.PlacedComponent : BreakdownElementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ComponentPlacement') or (self::ComponentPlacement and not(@xsi:type)))]/PlacedComponent">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElementView'] or //BreakdownElementView[@uid = $uidRef]">(ComponentPlacement : <sch:value-of select="$uid"/>) The ComponentPlacement.PlacedComponent contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElementView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ComponentPlacement.Placement : TransformationSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ComponentPlacement') or (self::ComponentPlacement and not(@xsi:type)))]/Placement/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::CartesianTransformation and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)]) or (self::GeometricRepresentationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',@typeRef)]) or (self::CartesianTransformation) or (self::GeometricRepresentationRelationship and //RelationshipObject[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',substring-after(@xsi:type,':'))])">(ComponentPlacement : <sch:value-of select="$uid"/>) The ComponentPlacement.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of TransformationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ComponentPlacement.ReferenceComponent : BreakdownElementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ComponentPlacement') or (self::ComponentPlacement and not(@xsi:type)))]/ReferenceComponent">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElementView'] or //BreakdownElementView[@uid = $uidRef]">(ComponentPlacement : <sch:value-of select="$uid"/>) The ComponentPlacement.ReferenceComponent contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElementView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ComposedGeometricModel"><!--(Ref to S) ComposedGeometricModel.Items : SET[1:unbounded] OF AxisPlacementOrTransformationSelect (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ComposedGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='ComposedGeometricModel'))]/Items/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::AxisPlacement and //ExternalRefBaseObject[@uid = $uidRef and contains(' AxisPlacement ',@typeRef)]) or (self::CartesianTransformation and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)]) or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement ',substring-after(@xsi:type,':'))] or //CartesianTransformation[@uid = $uidRef]">(ComposedGeometricModel : <sch:value-of select="$uid"/>) The ComposedGeometricModel.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AxisPlacementOrTransformationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace (kind=SINGLE - redefined=Representation.ContextOfItems)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ComposedGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='ComposedGeometricModel'))]/ContextOfItems">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricCoordinateSpace'] or //RepresentationContext[@uid = $uidRef and contains(' GeometricCoordinateSpace ',substring-after(@xsi:type,':'))]">(ComposedGeometricModel : <sch:value-of select="$uid"/>) The ComposedGeometricModel.ContextOfItems contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricCoordinateSpace.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ComposedGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='ComposedGeometricModel'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ComposedGeometricModel : <sch:value-of select="$uid"/>) The ComposedGeometricModel.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CompoundAddress"><!--(Ref to S) CompoundAddress.Class : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompoundAddress') or (self::Locator and substring-after(@xsi:type,':')='CompoundAddress'))]/Class/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(CompoundAddress : <sch:value-of select="$uid"/>) The CompoundAddress.Class contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of Location.Locators :: PartProperty) Locator.Represents : OPTIONAL Location) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ConcurrentElements"/>
   <sch:pattern id="Condition"><!--(Ref to S) Condition.ConditionType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Condition') or (self::Condition or (self::AssignedCondition and substring-after(@xsi:type,':')='Condition') or (self::Condition and substring-after(@xsi:type,':')='Condition') or (self::AssignedCondition and substring-after(@xsi:type,':')='Condition')))]/ConditionType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Condition : <sch:value-of select="$uid"/>) The Condition.ConditionType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Condition.Parameter : SET[1:unbounded] OF ParameterSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Condition') or (self::Condition or (self::AssignedCondition and substring-after(@xsi:type,':')='Condition') or (self::Condition and substring-after(@xsi:type,':')='Condition') or (self::AssignedCondition and substring-after(@xsi:type,':')='Condition')))]/Parameter/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ConditionParameter and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionParameter ',@typeRef)]) or (self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment  RiskEvent ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::Approval and //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',@typeRef)]) or (self::BreakdownOf and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownOf ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (self::Collection and //ExternalRefBaseObject[@uid = $uidRef and contains(' Collection ',@typeRef)]) or (self::CollectionMembershipRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionMembershipRelationship ',@typeRef)]) or (self::CollectionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionRelationship ',@typeRef)]) or (self::CollectionVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)]) or (self::CollectionView and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Condition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConditionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionRelationship ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::Descriptor and //ExternalRefBaseObject[@uid = $uidRef and contains(' Descriptor ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment  PartialDocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (*[(self::EnvironmentView or (self::AssignedEnvironment and contains(' EnvironmentView  EnvironmentDefinitionView  ObservedEnvironmentView ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvironmentView  EnvironmentDefinitionView  ObservedEnvironmentView ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::Evidence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Evidence ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::InterfaceConnection and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnection  HierarchicalInterfaceConnection ',@typeRef)]) or (self::InterfaceConnector and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)]) or (self::InterfaceConnectorOccurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)]) or (self::InterfaceConnectorOccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',@typeRef)]) or (self::InterfaceConnectorRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorRelationship ',@typeRef)]) or (self::InterfaceConnectorVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)]) or (self::InterfaceConnectorVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersionRelationship ',@typeRef)]) or (self::InterfaceConnectorView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)]) or (self::InterfaceConnectorViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',@typeRef)]) or (self::InterfaceDefinitionConnection and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceDefinitionConnection ',@typeRef)]) or (self::InterfaceSpecification and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)]) or (self::InterfaceSpecificationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationRelationship ',@typeRef)]) or (self::InterfaceSpecificationVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)]) or (self::InterfaceSpecificationVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersionRelationship ',@typeRef)]) or (self::InterfaceSpecificationView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)]) or (self::InterfaceSpecificationViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',@typeRef)]) or (self::ManagedResource and //ExternalRefBaseObject[@uid = $uidRef and contains(' ManagedResource ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',@typeRef)]) or (self::PersonOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',@typeRef)]) or (self::ProductConcept and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (self::RequiredResource and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequiredResource ',@typeRef)]) or (self::RequiredResourceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequiredResourceRelationship ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::ResourceAsRealized and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealized ',@typeRef)]) or (self::ResourceAsRealizedAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealizedAssociation ',@typeRef)]) or (self::ResourceEvent and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceEvent  DecreasingResourceEvent  IncreasingResourceEvent ',@typeRef)]) or (self::ResourceItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItem ',@typeRef)]) or (self::ResourceItemAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemAssignment ',@typeRef)]) or (self::ResourceItemRealization and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRealization ',@typeRef)]) or (self::ResourceItemRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',@typeRef)]) or (self::Risk and //ExternalRefBaseObject[@uid = $uidRef and contains(' Risk ',@typeRef)]) or (self::RiskVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)]) or (self::RiskView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)]) or (self::Scheme and //ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)]) or (self::SchemeEntry and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)]) or (self::SchemeVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Slot and //ExternalRefBaseObject[@uid = $uidRef and contains(' Slot ',@typeRef)]) or (self::SlotDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)]) or (self::SlotDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinitionRelationship ',@typeRef)]) or (*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::System and //ExternalRefBaseObject[@uid = $uidRef and contains(' System ',@typeRef)]) or (self::SystemVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)]) or (self::SystemView and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemView ',@typeRef)]) or (self::SystemViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemViewRelationship ',@typeRef)]) or (*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)]) or (self::TaskElementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElementAssignment ',@typeRef)]) or (self::TaskMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)]) or (self::TaskMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodAssignment ',@typeRef)]) or (self::TaskMethodVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)]) or (self::TaskMethodVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersionAssignment ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::Validation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Validation ',@typeRef)]) or (self::Verification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Verification ',@typeRef)]) or (self::VerificationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' VerificationRelationship ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::ConditionParameter) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //AssignmentObject[@uid = $uidRef and contains(' ActivityAssignment ',substring-after(@xsi:type,':'))]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //AssignmentObject[@uid = $uidRef and contains(' ActivityMethodAssignment  RiskEvent ',substring-after(@xsi:type,':'))]) or (self::AddressAssignment and //AssignmentObject[@uid = $uidRef and contains(' AddressAssignment ',substring-after(@xsi:type,':'))]) or (self::Approval and //Approval[@uid = $uidRef]) or (self::ApprovalAssignment and //AssignmentObject[@uid = $uidRef and contains(' ApprovalAssignment ',substring-after(@xsi:type,':'))]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',substring-after(@xsi:type,':'))]) or (self::BreakdownOf and //AssociationObject[@uid = $uidRef and contains(' BreakdownOf ',substring-after(@xsi:type,':'))]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::CertificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' CertificationAssignment ',substring-after(@xsi:type,':'))]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::Collection and //Collection[@uid = $uidRef]) or (self::CollectionMembershipRelationship and //RelationshipObject[@uid = $uidRef and contains(' CollectionMembershipRelationship ',substring-after(@xsi:type,':'))]) or (self::CollectionRelationship and //RelationshipObject[@uid = $uidRef and contains(' CollectionRelationship ',substring-after(@xsi:type,':'))]) or (self::CollectionVersion and //CollectionVersion[@uid = $uidRef]) or (self::CollectionView and //CollectionView[@uid = $uidRef]) or (self::Condition) or (self::ConditionAssignment and //AssignmentObject[@uid = $uidRef and contains(' ConditionAssignment ',substring-after(@xsi:type,':'))]) or (self::ConditionRelationship and //RelationshipObject[@uid = $uidRef and contains(' ConditionRelationship ',substring-after(@xsi:type,':'))]) or (self::ContractAssignment and //AssignmentObject[@uid = $uidRef and contains(' ContractAssignment ',substring-after(@xsi:type,':'))]) or (self::DateTimeAssignment and //AssignmentObject[@uid = $uidRef and contains(' DateTimeAssignment ',substring-after(@xsi:type,':'))]) or (self::DateTimeString) or (self::Descriptor and //Descriptor[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //AssignmentObject[@uid = $uidRef and contains(' DocumentAssignment  PartialDocumentAssignment ',substring-after(@xsi:type,':'))]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',substring-after(@xsi:type,':'))]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //AssignmentObject[@uid = $uidRef and contains(' EffectivityAssignment ',substring-after(@xsi:type,':'))]) or (self::EnvironmentView and //*[(self::EnvironmentView or (self::AssignedEnvironment and contains(' EnvironmentView  EnvironmentDefinitionView  ObservedEnvironmentView ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::EventAssignment and //AssignmentObject[@uid = $uidRef and contains(' EventAssignment ',substring-after(@xsi:type,':'))]) or (self::Evidence and //Evidence[@uid = $uidRef]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',substring-after(@xsi:type,':'))]) or (self::InformationUsageRightAssignment and //AssignmentObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnection and //InterfaceConnection[@uid = $uidRef]) or (self::InterfaceConnector and //InterfaceConnector[@uid = $uidRef]) or (self::InterfaceConnectorOccurrence and //InterfaceConnectorOccurrence[@uid = $uidRef]) or (self::InterfaceConnectorOccurrenceRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorVersion and //InterfaceConnectorVersion[@uid = $uidRef]) or (self::InterfaceConnectorVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorView and //InterfaceConnectorView[@uid = $uidRef]) or (self::InterfaceConnectorViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceDefinitionConnection and //InterfaceDefinitionConnection[@uid = $uidRef]) or (self::InterfaceSpecification and //InterfaceSpecification[@uid = $uidRef]) or (self::InterfaceSpecificationRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceSpecificationVersion and //InterfaceSpecificationVersion[@uid = $uidRef]) or (self::InterfaceSpecificationVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceSpecificationView and //InterfaceSpecificationView[@uid = $uidRef]) or (self::InterfaceSpecificationViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',substring-after(@xsi:type,':'))]) or (self::ManagedResource and //ManagedResource[@uid = $uidRef]) or (self::ObservationAssignment and //AssignmentObject[@uid = $uidRef and contains(' ObservationAssignment ',substring-after(@xsi:type,':'))]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',substring-after(@xsi:type,':'))]) or (self::PersonOrganizationAssignment and //AssignmentObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',substring-after(@xsi:type,':'))]) or (self::ProductConcept and //ProductConcept[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProjectAssignment and //AssignmentObject[@uid = $uidRef and contains(' ProjectAssignment ',substring-after(@xsi:type,':'))]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //AssignmentObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',substring-after(@xsi:type,':'))]) or (self::PropertyDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',substring-after(@xsi:type,':'))]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //AssignmentObject[@uid = $uidRef and contains(' PropertyValueAssignment ',substring-after(@xsi:type,':'))]) or (self::PropertyValueRelationship and //RelationshipObject[@uid = $uidRef and contains(' PropertyValueRelationship ',substring-after(@xsi:type,':'))]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::RequiredResource and //RequiredResource[@uid = $uidRef]) or (self::RequiredResourceRelationship and //RelationshipObject[@uid = $uidRef and contains(' RequiredResourceRelationship ',substring-after(@xsi:type,':'))]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //AssignmentObject[@uid = $uidRef and contains(' RequirementAssignment ',substring-after(@xsi:type,':'))]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',substring-after(@xsi:type,':'))]) or (self::ResourceAsRealized and //ResourceAsRealized[@uid = $uidRef]) or (self::ResourceAsRealizedAssociation and //AssociationObject[@uid = $uidRef and contains(' ResourceAsRealizedAssociation ',substring-after(@xsi:type,':'))]) or (self::ResourceEvent and //ResourceEvent[@uid = $uidRef]) or (self::ResourceItem and //ResourceItem[@uid = $uidRef]) or (self::ResourceItemAssignment and //AssignmentObject[@uid = $uidRef and contains(' ResourceItemAssignment ',substring-after(@xsi:type,':'))]) or (self::ResourceItemRealization and //AssociationObject[@uid = $uidRef and contains(' ResourceItemRealization ',substring-after(@xsi:type,':'))]) or (self::ResourceItemRelationship and //RelationshipObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',substring-after(@xsi:type,':'))]) or (self::Risk and //Risk[@uid = $uidRef]) or (self::RiskVersion and //RiskVersion[@uid = $uidRef]) or (self::RiskView and //RiskView[@uid = $uidRef]) or (self::Scheme and //Scheme[@uid = $uidRef]) or (self::SchemeEntry and //SchemeEntry[@uid = $uidRef]) or (self::SchemeVersion and //SchemeVersion[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',substring-after(@xsi:type,':'))]) or (self::Slot and //Slot[@uid = $uidRef]) or (self::SlotDefinition and //SlotDefinition[@uid = $uidRef]) or (self::SlotDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' SlotDefinitionRelationship ',substring-after(@xsi:type,':'))]) or (self::SlotVersion and //*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' SpecificationAssignment ',substring-after(@xsi:type,':'))]) or (self::SpecificationCategoryAssignment and //AssignmentObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',substring-after(@xsi:type,':'))]) or (self::SpecificationConditionAssignment and //AssignmentObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',substring-after(@xsi:type,':'))]) or (self::SpecificationInclusionAssignment and //AssignmentObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',substring-after(@xsi:type,':'))]) or (self::System and //System[@uid = $uidRef]) or (self::SystemVersion and //SystemVersion[@uid = $uidRef]) or (self::SystemView and //SystemView[@uid = $uidRef]) or (self::SystemViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' SystemViewRelationship ',substring-after(@xsi:type,':'))]) or (self::TaskElement and //*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::TaskElementAssignment and //AssignmentObject[@uid = $uidRef and contains(' TaskElementAssignment ',substring-after(@xsi:type,':'))]) or (self::TaskMethod and //TaskMethod[@uid = $uidRef]) or (self::TaskMethodAssignment and //AssignmentObject[@uid = $uidRef and contains(' TaskMethodAssignment ',substring-after(@xsi:type,':'))]) or (self::TaskMethodVersion and //TaskMethodVersion[@uid = $uidRef]) or (self::TaskMethodVersionAssignment and //AssignmentObject[@uid = $uidRef and contains(' TaskMethodVersionAssignment ',substring-after(@xsi:type,':'))]) or (self::TimeIntervalAssignment and //AssignmentObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',substring-after(@xsi:type,':'))]) or (self::Validation and //Validation[@uid = $uidRef]) or (self::Verification and //Verification[@uid = $uidRef]) or (self::VerificationRelationship and //RelationshipObject[@uid = $uidRef and contains(' VerificationRelationship ',substring-after(@xsi:type,':'))]) or (self::WorkOrderAssignment and //AssignmentObject[@uid = $uidRef and contains(' WorkOrderAssignment ',substring-after(@xsi:type,':'))]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef]) or (self::WorkRequestAssignment and //AssignmentObject[@uid = $uidRef and contains(' WorkRequestAssignment ',substring-after(@xsi:type,':'))])">(Condition : <sch:value-of select="$uid"/>) The Condition.Parameter contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ParameterSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConditionAssignment"><!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ConditionAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ConditionAssignment : <sch:value-of select="$uid"/>) The ConditionAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConditionEvaluation"><!--(Ref to E) ConditionEvaluation.EvaluatedCondition : OPTIONAL Condition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionEvaluation') or (self::ConditionEvaluation or (self::ConditionEvaluation and substring-after(@xsi:type,':')='ConditionEvaluation')))]/EvaluatedCondition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./EvaluatedCondition) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Condition'] or //Condition[@uid = $uidRef] or //*[@uid = $uidRef and (self::AssignedCondition or self::Condition or self::AssignedCondition)]">(ConditionEvaluation : <sch:value-of select="$uid"/>) The ConditionEvaluation.EvaluatedCondition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Condition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ConditionEvaluation.Parameter : SET[1:unbounded] OF EvaluationParameterSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionEvaluation') or (self::ConditionEvaluation or (self::ConditionEvaluation and substring-after(@xsi:type,':')='ConditionEvaluation')))]/Parameter/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ConditionEvaluationParameter and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionEvaluationParameter ',@typeRef)]) or (self::Collection and //ExternalRefBaseObject[@uid = $uidRef and contains(' Collection ',@typeRef)]) or (self::CollectionVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)]) or (self::CollectionView and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)]) or (self::CollectionViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionViewRelationship ',@typeRef)]) or (self::Evidence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Evidence ',@typeRef)]) or (self::InterfaceConnection and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnection  HierarchicalInterfaceConnection ',@typeRef)]) or (self::InterfaceConnector and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)]) or (self::InterfaceConnectorOccurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)]) or (self::InterfaceConnectorOccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',@typeRef)]) or (self::InterfaceConnectorVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)]) or (self::InterfaceConnectorView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)]) or (self::InterfaceConnectorViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',@typeRef)]) or (self::InterfaceDefinitionConnection and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceDefinitionConnection ',@typeRef)]) or (self::InterfaceSpecification and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)]) or (self::InterfaceSpecificationVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)]) or (self::InterfaceSpecificationView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)]) or (self::InterfaceSpecificationViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::RequiredResource and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequiredResource ',@typeRef)]) or (self::ResourceAsRealized and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealized ',@typeRef)]) or (self::ResourceAsRealizedAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealizedAssociation ',@typeRef)]) or (self::ResourceEvent and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceEvent  DecreasingResourceEvent  IncreasingResourceEvent ',@typeRef)]) or (self::ResourceItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItem ',@typeRef)]) or (self::ResourceItemAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemAssignment ',@typeRef)]) or (self::ResourceItemRealization and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRealization ',@typeRef)]) or (self::ResourceItemRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',@typeRef)]) or (self::Validation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Validation ',@typeRef)]) or (self::Verification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Verification ',@typeRef)]) or (self::VerificationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' VerificationRelationship ',@typeRef)]) or (self::ConditionEvaluationParameter and //ConditionEvaluationParameter[@uid = $uidRef]) or (self::Collection and //Collection[@uid = $uidRef]) or (self::CollectionVersion and //CollectionVersion[@uid = $uidRef]) or (self::CollectionView and //CollectionView[@uid = $uidRef]) or (self::CollectionViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' CollectionViewRelationship ',substring-after(@xsi:type,':'))]) or (self::Evidence and //Evidence[@uid = $uidRef]) or (self::InterfaceConnection and //InterfaceConnection[@uid = $uidRef]) or (self::InterfaceConnector and //InterfaceConnector[@uid = $uidRef]) or (self::InterfaceConnectorOccurrence and //InterfaceConnectorOccurrence[@uid = $uidRef]) or (self::InterfaceConnectorOccurrenceRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorVersion and //InterfaceConnectorVersion[@uid = $uidRef]) or (self::InterfaceConnectorView and //InterfaceConnectorView[@uid = $uidRef]) or (self::InterfaceConnectorViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceDefinitionConnection and //InterfaceDefinitionConnection[@uid = $uidRef]) or (self::InterfaceSpecification and //InterfaceSpecification[@uid = $uidRef]) or (self::InterfaceSpecificationVersion and //InterfaceSpecificationVersion[@uid = $uidRef]) or (self::InterfaceSpecificationView and //InterfaceSpecificationView[@uid = $uidRef]) or (self::InterfaceSpecificationViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',substring-after(@xsi:type,':'))]) or (self::ObservationAssignment and //AssignmentObject[@uid = $uidRef and contains(' ObservationAssignment ',substring-after(@xsi:type,':'))]) or (self::RequiredResource and //RequiredResource[@uid = $uidRef]) or (self::ResourceAsRealized and //ResourceAsRealized[@uid = $uidRef]) or (self::ResourceAsRealizedAssociation and //AssociationObject[@uid = $uidRef and contains(' ResourceAsRealizedAssociation ',substring-after(@xsi:type,':'))]) or (self::ResourceEvent and //ResourceEvent[@uid = $uidRef]) or (self::ResourceItem and //ResourceItem[@uid = $uidRef]) or (self::ResourceItemAssignment and //AssignmentObject[@uid = $uidRef and contains(' ResourceItemAssignment ',substring-after(@xsi:type,':'))]) or (self::ResourceItemRealization and //AssociationObject[@uid = $uidRef and contains(' ResourceItemRealization ',substring-after(@xsi:type,':'))]) or (self::ResourceItemRelationship and //RelationshipObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',substring-after(@xsi:type,':'))]) or (self::Validation and //Validation[@uid = $uidRef]) or (self::Verification and //Verification[@uid = $uidRef]) or (self::VerificationRelationship and //RelationshipObject[@uid = $uidRef and contains(' VerificationRelationship ',substring-after(@xsi:type,':'))])">(ConditionEvaluation : <sch:value-of select="$uid"/>) The ConditionEvaluation.Parameter contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EvaluationParameterSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConditionEvaluationAssignment"><!--(Ref to S) ConditionEvaluationAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=AssignmentObject.Role)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionEvaluationAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ConditionEvaluationAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ConditionEvaluationAssignment : <sch:value-of select="$uid"/>) The ConditionEvaluationAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConditionEvaluationParameter"><!--(Ref to S) ConditionEvaluationParameter.Parameter : ConditionEvaluationParameterSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionEvaluationParameter') or (self::ConditionEvaluationParameter and not(@xsi:type)))]/Parameter">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Collection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Evidence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnection  HierarchicalInterfaceConnection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceDefinitionConnection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequiredResource ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealized ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealizedAssociation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceEvent  DecreasingResourceEvent  IncreasingResourceEvent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItem ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRealization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Validation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Verification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VerificationRelationship ',@typeRef)] or //Collection[@uid = $uidRef] or //CollectionVersion[@uid = $uidRef] or //CollectionView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' CollectionViewRelationship ',substring-after(@xsi:type,':'))] or //Evidence[@uid = $uidRef] or //InterfaceConnection[@uid = $uidRef] or //InterfaceConnector[@uid = $uidRef] or //InterfaceConnectorOccurrence[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',substring-after(@xsi:type,':'))] or //InterfaceConnectorVersion[@uid = $uidRef] or //InterfaceConnectorView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',substring-after(@xsi:type,':'))] or //InterfaceDefinitionConnection[@uid = $uidRef] or //InterfaceSpecification[@uid = $uidRef] or //InterfaceSpecificationVersion[@uid = $uidRef] or //InterfaceSpecificationView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',substring-after(@xsi:type,':'))] or //AssignmentObject[@uid = $uidRef and contains(' ObservationAssignment ',substring-after(@xsi:type,':'))] or //RequiredResource[@uid = $uidRef] or //ResourceAsRealized[@uid = $uidRef] or //AssociationObject[@uid = $uidRef and contains(' ResourceAsRealizedAssociation ',substring-after(@xsi:type,':'))] or //ResourceEvent[@uid = $uidRef] or //ResourceItem[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' ResourceItemAssignment ',substring-after(@xsi:type,':'))] or //AssociationObject[@uid = $uidRef and contains(' ResourceItemRealization ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',substring-after(@xsi:type,':'))] or //Validation[@uid = $uidRef] or //Verification[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' VerificationRelationship ',substring-after(@xsi:type,':'))]">(ConditionEvaluationParameter : <sch:value-of select="$uid"/>) The ConditionEvaluationParameter.Parameter contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ConditionEvaluationParameterSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConditionEvaluationRelationship"><!--(Ref to E) ConditionEvaluationRelationship.Related : ConditionEvaluation (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionEvaluationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ConditionEvaluationRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ConditionEvaluation'] or //ConditionEvaluation[@uid = $uidRef] or //*[@uid = $uidRef and (self::ConditionEvaluation)]">(ConditionEvaluationRelationship : <sch:value-of select="$uid"/>) The ConditionEvaluationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ConditionEvaluation.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionEvaluationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ConditionEvaluationRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ConditionEvaluationRelationship : <sch:value-of select="$uid"/>) The ConditionEvaluationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConditionParameter"><!--(Ref to S) ConditionParameter.Parameter : OPTIONAL ConditionParameterSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionParameter') or (self::ConditionParameter and not(@xsi:type)))]/Parameter/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment  RiskEvent ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::Approval and //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',@typeRef)]) or (self::BreakdownOf and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownOf ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (self::Collection and //ExternalRefBaseObject[@uid = $uidRef and contains(' Collection ',@typeRef)]) or (self::CollectionMembershipRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionMembershipRelationship ',@typeRef)]) or (self::CollectionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionRelationship ',@typeRef)]) or (self::CollectionVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)]) or (self::CollectionView and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Condition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConditionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionRelationship ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::Descriptor and //ExternalRefBaseObject[@uid = $uidRef and contains(' Descriptor ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment  PartialDocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (*[(self::EnvironmentView or (self::AssignedEnvironment and contains(' EnvironmentView  EnvironmentDefinitionView  ObservedEnvironmentView ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvironmentView  EnvironmentDefinitionView  ObservedEnvironmentView ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::Evidence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Evidence ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::InterfaceConnection and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnection  HierarchicalInterfaceConnection ',@typeRef)]) or (self::InterfaceConnector and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)]) or (self::InterfaceConnectorOccurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)]) or (self::InterfaceConnectorOccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',@typeRef)]) or (self::InterfaceConnectorRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorRelationship ',@typeRef)]) or (self::InterfaceConnectorVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)]) or (self::InterfaceConnectorVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersionRelationship ',@typeRef)]) or (self::InterfaceConnectorView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)]) or (self::InterfaceConnectorViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',@typeRef)]) or (self::InterfaceDefinitionConnection and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceDefinitionConnection ',@typeRef)]) or (self::InterfaceSpecification and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)]) or (self::InterfaceSpecificationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationRelationship ',@typeRef)]) or (self::InterfaceSpecificationVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)]) or (self::InterfaceSpecificationVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersionRelationship ',@typeRef)]) or (self::InterfaceSpecificationView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)]) or (self::InterfaceSpecificationViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',@typeRef)]) or (self::ManagedResource and //ExternalRefBaseObject[@uid = $uidRef and contains(' ManagedResource ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',@typeRef)]) or (self::PersonOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',@typeRef)]) or (self::ProductConcept and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (self::RequiredResource and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequiredResource ',@typeRef)]) or (self::RequiredResourceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequiredResourceRelationship ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::ResourceAsRealized and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealized ',@typeRef)]) or (self::ResourceAsRealizedAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealizedAssociation ',@typeRef)]) or (self::ResourceEvent and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceEvent  DecreasingResourceEvent  IncreasingResourceEvent ',@typeRef)]) or (self::ResourceItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItem ',@typeRef)]) or (self::ResourceItemAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemAssignment ',@typeRef)]) or (self::ResourceItemRealization and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRealization ',@typeRef)]) or (self::ResourceItemRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',@typeRef)]) or (self::Risk and //ExternalRefBaseObject[@uid = $uidRef and contains(' Risk ',@typeRef)]) or (self::RiskVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)]) or (self::RiskView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)]) or (self::Scheme and //ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)]) or (self::SchemeEntry and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)]) or (self::SchemeVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Slot and //ExternalRefBaseObject[@uid = $uidRef and contains(' Slot ',@typeRef)]) or (self::SlotDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)]) or (self::SlotDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinitionRelationship ',@typeRef)]) or (*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::System and //ExternalRefBaseObject[@uid = $uidRef and contains(' System ',@typeRef)]) or (self::SystemVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)]) or (self::SystemView and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemView ',@typeRef)]) or (self::SystemViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemViewRelationship ',@typeRef)]) or (*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)]) or (self::TaskElementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElementAssignment ',@typeRef)]) or (self::TaskMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)]) or (self::TaskMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodAssignment ',@typeRef)]) or (self::TaskMethodVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)]) or (self::TaskMethodVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersionAssignment ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::Validation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Validation ',@typeRef)]) or (self::Verification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Verification ',@typeRef)]) or (self::VerificationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' VerificationRelationship ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //AssignmentObject[@uid = $uidRef and contains(' ActivityAssignment ',substring-after(@xsi:type,':'))]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //AssignmentObject[@uid = $uidRef and contains(' ActivityMethodAssignment  RiskEvent ',substring-after(@xsi:type,':'))]) or (self::AddressAssignment and //AssignmentObject[@uid = $uidRef and contains(' AddressAssignment ',substring-after(@xsi:type,':'))]) or (self::Approval and //Approval[@uid = $uidRef]) or (self::ApprovalAssignment and //AssignmentObject[@uid = $uidRef and contains(' ApprovalAssignment ',substring-after(@xsi:type,':'))]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',substring-after(@xsi:type,':'))]) or (self::BreakdownOf and //AssociationObject[@uid = $uidRef and contains(' BreakdownOf ',substring-after(@xsi:type,':'))]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::CertificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' CertificationAssignment ',substring-after(@xsi:type,':'))]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::Collection and //Collection[@uid = $uidRef]) or (self::CollectionMembershipRelationship and //RelationshipObject[@uid = $uidRef and contains(' CollectionMembershipRelationship ',substring-after(@xsi:type,':'))]) or (self::CollectionRelationship and //RelationshipObject[@uid = $uidRef and contains(' CollectionRelationship ',substring-after(@xsi:type,':'))]) or (self::CollectionVersion and //CollectionVersion[@uid = $uidRef]) or (self::CollectionView and //CollectionView[@uid = $uidRef]) or (self::Condition) or (self::ConditionAssignment and //AssignmentObject[@uid = $uidRef and contains(' ConditionAssignment ',substring-after(@xsi:type,':'))]) or (self::ConditionRelationship and //RelationshipObject[@uid = $uidRef and contains(' ConditionRelationship ',substring-after(@xsi:type,':'))]) or (self::ContractAssignment and //AssignmentObject[@uid = $uidRef and contains(' ContractAssignment ',substring-after(@xsi:type,':'))]) or (self::DateTimeAssignment and //AssignmentObject[@uid = $uidRef and contains(' DateTimeAssignment ',substring-after(@xsi:type,':'))]) or (self::DateTimeString) or (self::Descriptor and //Descriptor[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //AssignmentObject[@uid = $uidRef and contains(' DocumentAssignment  PartialDocumentAssignment ',substring-after(@xsi:type,':'))]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',substring-after(@xsi:type,':'))]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //AssignmentObject[@uid = $uidRef and contains(' EffectivityAssignment ',substring-after(@xsi:type,':'))]) or (self::EnvironmentView and //*[(self::EnvironmentView or (self::AssignedEnvironment and contains(' EnvironmentView  EnvironmentDefinitionView  ObservedEnvironmentView ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::EventAssignment and //AssignmentObject[@uid = $uidRef and contains(' EventAssignment ',substring-after(@xsi:type,':'))]) or (self::Evidence and //Evidence[@uid = $uidRef]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',substring-after(@xsi:type,':'))]) or (self::InformationUsageRightAssignment and //AssignmentObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnection and //InterfaceConnection[@uid = $uidRef]) or (self::InterfaceConnector and //InterfaceConnector[@uid = $uidRef]) or (self::InterfaceConnectorOccurrence and //InterfaceConnectorOccurrence[@uid = $uidRef]) or (self::InterfaceConnectorOccurrenceRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorVersion and //InterfaceConnectorVersion[@uid = $uidRef]) or (self::InterfaceConnectorVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorView and //InterfaceConnectorView[@uid = $uidRef]) or (self::InterfaceConnectorViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceDefinitionConnection and //InterfaceDefinitionConnection[@uid = $uidRef]) or (self::InterfaceSpecification and //InterfaceSpecification[@uid = $uidRef]) or (self::InterfaceSpecificationRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceSpecificationVersion and //InterfaceSpecificationVersion[@uid = $uidRef]) or (self::InterfaceSpecificationVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceSpecificationView and //InterfaceSpecificationView[@uid = $uidRef]) or (self::InterfaceSpecificationViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',substring-after(@xsi:type,':'))]) or (self::ManagedResource and //ManagedResource[@uid = $uidRef]) or (self::ObservationAssignment and //AssignmentObject[@uid = $uidRef and contains(' ObservationAssignment ',substring-after(@xsi:type,':'))]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',substring-after(@xsi:type,':'))]) or (self::PersonOrganizationAssignment and //AssignmentObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',substring-after(@xsi:type,':'))]) or (self::ProductConcept and //ProductConcept[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProjectAssignment and //AssignmentObject[@uid = $uidRef and contains(' ProjectAssignment ',substring-after(@xsi:type,':'))]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //AssignmentObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',substring-after(@xsi:type,':'))]) or (self::PropertyDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',substring-after(@xsi:type,':'))]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //AssignmentObject[@uid = $uidRef and contains(' PropertyValueAssignment ',substring-after(@xsi:type,':'))]) or (self::PropertyValueRelationship and //RelationshipObject[@uid = $uidRef and contains(' PropertyValueRelationship ',substring-after(@xsi:type,':'))]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::RequiredResource and //RequiredResource[@uid = $uidRef]) or (self::RequiredResourceRelationship and //RelationshipObject[@uid = $uidRef and contains(' RequiredResourceRelationship ',substring-after(@xsi:type,':'))]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //AssignmentObject[@uid = $uidRef and contains(' RequirementAssignment ',substring-after(@xsi:type,':'))]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',substring-after(@xsi:type,':'))]) or (self::ResourceAsRealized and //ResourceAsRealized[@uid = $uidRef]) or (self::ResourceAsRealizedAssociation and //AssociationObject[@uid = $uidRef and contains(' ResourceAsRealizedAssociation ',substring-after(@xsi:type,':'))]) or (self::ResourceEvent and //ResourceEvent[@uid = $uidRef]) or (self::ResourceItem and //ResourceItem[@uid = $uidRef]) or (self::ResourceItemAssignment and //AssignmentObject[@uid = $uidRef and contains(' ResourceItemAssignment ',substring-after(@xsi:type,':'))]) or (self::ResourceItemRealization and //AssociationObject[@uid = $uidRef and contains(' ResourceItemRealization ',substring-after(@xsi:type,':'))]) or (self::ResourceItemRelationship and //RelationshipObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',substring-after(@xsi:type,':'))]) or (self::Risk and //Risk[@uid = $uidRef]) or (self::RiskVersion and //RiskVersion[@uid = $uidRef]) or (self::RiskView and //RiskView[@uid = $uidRef]) or (self::Scheme and //Scheme[@uid = $uidRef]) or (self::SchemeEntry and //SchemeEntry[@uid = $uidRef]) or (self::SchemeVersion and //SchemeVersion[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',substring-after(@xsi:type,':'))]) or (self::Slot and //Slot[@uid = $uidRef]) or (self::SlotDefinition and //SlotDefinition[@uid = $uidRef]) or (self::SlotDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' SlotDefinitionRelationship ',substring-after(@xsi:type,':'))]) or (self::SlotVersion and //*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' SpecificationAssignment ',substring-after(@xsi:type,':'))]) or (self::SpecificationCategoryAssignment and //AssignmentObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',substring-after(@xsi:type,':'))]) or (self::SpecificationConditionAssignment and //AssignmentObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',substring-after(@xsi:type,':'))]) or (self::SpecificationInclusionAssignment and //AssignmentObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',substring-after(@xsi:type,':'))]) or (self::System and //System[@uid = $uidRef]) or (self::SystemVersion and //SystemVersion[@uid = $uidRef]) or (self::SystemView and //SystemView[@uid = $uidRef]) or (self::SystemViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' SystemViewRelationship ',substring-after(@xsi:type,':'))]) or (self::TaskElement and //*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::TaskElementAssignment and //AssignmentObject[@uid = $uidRef and contains(' TaskElementAssignment ',substring-after(@xsi:type,':'))]) or (self::TaskMethod and //TaskMethod[@uid = $uidRef]) or (self::TaskMethodAssignment and //AssignmentObject[@uid = $uidRef and contains(' TaskMethodAssignment ',substring-after(@xsi:type,':'))]) or (self::TaskMethodVersion and //TaskMethodVersion[@uid = $uidRef]) or (self::TaskMethodVersionAssignment and //AssignmentObject[@uid = $uidRef and contains(' TaskMethodVersionAssignment ',substring-after(@xsi:type,':'))]) or (self::TimeIntervalAssignment and //AssignmentObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',substring-after(@xsi:type,':'))]) or (self::Validation and //Validation[@uid = $uidRef]) or (self::Verification and //Verification[@uid = $uidRef]) or (self::VerificationRelationship and //RelationshipObject[@uid = $uidRef and contains(' VerificationRelationship ',substring-after(@xsi:type,':'))]) or (self::WorkOrderAssignment and //AssignmentObject[@uid = $uidRef and contains(' WorkOrderAssignment ',substring-after(@xsi:type,':'))]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef]) or (self::WorkRequestAssignment and //AssignmentObject[@uid = $uidRef and contains(' WorkRequestAssignment ',substring-after(@xsi:type,':'))])">(ConditionParameter : <sch:value-of select="$uid"/>) The ConditionParameter.Parameter contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ConditionParameterSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConditionRelationship"><!--(Ref to E) ConditionRelationship.Related : Condition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ConditionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Condition'] or //Condition[@uid = $uidRef] or //*[@uid = $uidRef and (self::AssignedCondition or self::Condition or self::AssignedCondition)]">(ConditionRelationship : <sch:value-of select="$uid"/>) The ConditionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Condition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ConditionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ConditionRelationship : <sch:value-of select="$uid"/>) The ConditionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConditionalConfiguration"><!--(Ref to S) ConditionalConfiguration.ConfigurationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionalConfiguration') or (self::Effectivity and substring-after(@xsi:type,':')='ConditionalConfiguration'))]/ConfigurationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ConditionalConfiguration : <sch:value-of select="$uid"/>) The ConditionalConfiguration.ConfigurationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ConditionalConfiguration.InheritanceType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionalConfiguration') or (self::Effectivity and substring-after(@xsi:type,':')='ConditionalConfiguration'))]/InheritanceType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ConditionalConfiguration : <sch:value-of select="$uid"/>) The ConditionalConfiguration.InheritanceType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionalConfiguration') or (self::Effectivity and substring-after(@xsi:type,':')='ConditionalConfiguration'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(ConditionalConfiguration : <sch:value-of select="$uid"/>) The ConditionalConfiguration.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Effectivity.EffectivityContext : OPTIONAL EffectivityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionalConfiguration') or (self::Effectivity and substring-after(@xsi:type,':')='ConditionalConfiguration'))]/EffectivityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //Activity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef]">(ConditionalConfiguration : <sch:value-of select="$uid"/>) The ConditionalConfiguration.EffectivityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EffectivityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConditionalEffectivity"><!--(Ref to E) Effectivity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionalEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='ConditionalEffectivity'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(ConditionalEffectivity : <sch:value-of select="$uid"/>) The ConditionalEffectivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Effectivity.EffectivityContext : OPTIONAL EffectivityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionalEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='ConditionalEffectivity'))]/EffectivityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //Activity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef]">(ConditionalEffectivity : <sch:value-of select="$uid"/>) The ConditionalEffectivity.EffectivityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EffectivityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConfiguredAssemblyEffectivity"><!--(Ref to S) ConfiguredAssemblyEffectivity.ConfiguredElement : AssemblyDesignSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConfiguredAssemblyEffectivity') or (self::ConfiguredAssemblyEffectivity and not(@xsi:type)))]/ConfiguredElement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DefinitionalPartViewUsage ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)] or //RelationshipObject[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' DefinitionalPartViewUsage ',substring-after(@xsi:type,':'))] or //Occurrence[@uid = $uidRef]">(ConfiguredAssemblyEffectivity : <sch:value-of select="$uid"/>) The ConfiguredAssemblyEffectivity.ConfiguredElement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AssemblyDesignSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ConfiguredAssemblyEffectivity.EffectivityDomain : OPTIONAL Effectivity (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConfiguredAssemblyEffectivity') or (self::ConfiguredAssemblyEffectivity and not(@xsi:type)))]/EffectivityDomain">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./EffectivityDomain) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Effectivity'] or //Effectivity[@uid = $uidRef]">(ConfiguredAssemblyEffectivity : <sch:value-of select="$uid"/>) The ConfiguredAssemblyEffectivity.EffectivityDomain contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Effectivity.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ConfiguredAssemblyEffectivity.ResolvedConfiguration : ProductDesignAssociation (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConfiguredAssemblyEffectivity') or (self::ConfiguredAssemblyEffectivity and not(@xsi:type)))]/ResolvedConfiguration">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ProductDesignAssociation'] or //AssociationObject[@uid = $uidRef and contains(' ProductDesignAssociation ',substring-after(@xsi:type,':'))]">(ConfiguredAssemblyEffectivity : <sch:value-of select="$uid"/>) The ConfiguredAssemblyEffectivity.ResolvedConfiguration contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ProductDesignAssociation.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Contract"><!--(Ref to S) Contract.ContractType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Contract') or (self::Contract and not(@xsi:type)))]/ContractType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Contract : <sch:value-of select="$uid"/>) The Contract.ContractType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ContractAssignment"><!--(Ref to E) ContractAssignment.AssignedContract : Contract (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContractAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ContractAssignment'))]/AssignedContract">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Contract'] or //Contract[@uid = $uidRef]">(ContractAssignment : <sch:value-of select="$uid"/>) The ContractAssignment.AssignedContract contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Contract.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContractAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ContractAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ContractAssignment : <sch:value-of select="$uid"/>) The ContractAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ContractRelationship"><!--(Ref to E) ContractRelationship.Related : Contract (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContractRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ContractRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Contract'] or //Contract[@uid = $uidRef]">(ContractRelationship : <sch:value-of select="$uid"/>) The ContractRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Contract.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ContractRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContractRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ContractRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ContractRelationship : <sch:value-of select="$uid"/>) The ContractRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DateTimeAssignment"><!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DateTimeAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='DateTimeAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DateTimeAssignment : <sch:value-of select="$uid"/>) The DateTimeAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DatedEffectivity"><!--(Ref to S) DatedEffectivity.EndDefinition : OPTIONAL EventOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatedEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='DatedEffectivity'))]/EndDefinition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event  RelativeEvent ',@typeRef)]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(DatedEffectivity : <sch:value-of select="$uid"/>) The DatedEffectivity.EndDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EventOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DatedEffectivity.StartDefinition : OPTIONAL EventOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatedEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='DatedEffectivity'))]/StartDefinition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event  RelativeEvent ',@typeRef)]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(DatedEffectivity : <sch:value-of select="$uid"/>) The DatedEffectivity.StartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EventOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatedEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='DatedEffectivity'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(DatedEffectivity : <sch:value-of select="$uid"/>) The DatedEffectivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Effectivity.EffectivityContext : OPTIONAL EffectivityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatedEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='DatedEffectivity'))]/EffectivityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //Activity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef]">(DatedEffectivity : <sch:value-of select="$uid"/>) The DatedEffectivity.EffectivityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EffectivityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DecisionPoint"><!--(Ref to E) DecisionPoint.Condition : Condition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DecisionPoint') or (self::TaskElement and substring-after(@xsi:type,':')='DecisionPoint'))]/Condition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Condition'] or //Condition[@uid = $uidRef] or //*[@uid = $uidRef and (self::AssignedCondition or self::Condition or self::AssignedCondition)]">(DecisionPoint : <sch:value-of select="$uid"/>) The DecisionPoint.Condition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Condition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DecreasingResourceEvent"><!--(Ref to E) ResourceEvent.Resource : ManagedResource (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DecreasingResourceEvent') or (self::ResourceEvent and substring-after(@xsi:type,':')='DecreasingResourceEvent'))]/Resource">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ManagedResource'] or //ManagedResource[@uid = $uidRef]">(DecreasingResourceEvent : <sch:value-of select="$uid"/>) The DecreasingResourceEvent.Resource contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ManagedResource.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DefinitionalPartViewUsage"><!--(Ref to E) PartViewRelationship.Related : PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DefinitionalPartViewUsage') or (self::RelationshipObject and substring-after(@xsi:type,':')='DefinitionalPartViewUsage'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(DefinitionalPartViewUsage : <sch:value-of select="$uid"/>) The DefinitionalPartViewUsage.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DefinitionalPartViewUsage') or (self::RelationshipObject and substring-after(@xsi:type,':')='DefinitionalPartViewUsage'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DefinitionalPartViewUsage : <sch:value-of select="$uid"/>) The DefinitionalPartViewUsage.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Descriptor"><!--(Ref to S) Descriptor.DescriptionContext : OPTIONAL SET[1:unbounded] OF IdentificationContextSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Descriptor') or (self::Descriptor and not(@xsi:type)))]/DescriptionContext/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef])">(Descriptor : <sch:value-of select="$uid"/>) The Descriptor.DescriptionContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of IdentificationContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DescriptorRelationship"><!--(Ref to E) DescriptorRelationship.Related : Descriptor (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DescriptorRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='DescriptorRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Descriptor'] or //Descriptor[@uid = $uidRef]">(DescriptorRelationship : <sch:value-of select="$uid"/>) The DescriptorRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Descriptor.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DescriptorRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DescriptorRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='DescriptorRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DescriptorRelationship : <sch:value-of select="$uid"/>) The DescriptorRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DigitalDocumentDefinition"><!--(Ref to E) DigitalDocumentDefinition.Files : OPTIONAL SET[1:unbounded] OF DigitalFile (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DigitalDocumentDefinition') or (self::DocumentDefinition and substring-after(@xsi:type,':')='DigitalDocumentDefinition'))]/Files/DigitalFile">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Files/DigitalFile) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(DigitalDocumentDefinition : <sch:value-of select="$uid"/>) The DigitalDocumentDefinition.Files contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Inverse of DocumentVersion.Views :: PartProperty) DocumentDefinition.ViewOf : DocumentVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="DigitalFile"><!--(Inverse of ExternalGeometricModel.ExternalFile :: ReferenceProperty) DigitalFile.AssociatedModelSpace : OPTIONAL SET[1:unbounded] OF ExternalGeometricModel) => no rule needed when PartProperty or Optional--><!--(Ref to S) File.FileType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DigitalFile') or (self::File and substring-after(@xsi:type,':')='DigitalFile'))]/FileType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DigitalFile : <sch:value-of select="$uid"/>) The DigitalFile.FileType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DirectedPlannedActivity"><!--(Ref to E) DirectedPlannedActivity.Directive : WorkOrder (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedPlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedPlannedActivity'))]/Directive">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'WorkOrder'] or //WorkOrder[@uid = $uidRef]">(DirectedPlannedActivity : <sch:value-of select="$uid"/>) The DirectedPlannedActivity.Directive contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type WorkOrder.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Activity.ActivityType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedPlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedPlannedActivity'))]/ActivityType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DirectedPlannedActivity : <sch:value-of select="$uid"/>) The DirectedPlannedActivity.ActivityType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.ChosenMethod : OPTIONAL ActivityMethod (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedPlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedPlannedActivity'))]/ChosenMethod">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ChosenMethod) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(DirectedPlannedActivity : <sch:value-of select="$uid"/>) The DirectedPlannedActivity.ChosenMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.PossibleMethods : OPTIONAL SET[1:unbounded] OF ActivityMethod (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedPlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedPlannedActivity'))]/PossibleMethods/ActivityMethod">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../PossibleMethods/ActivityMethod) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(DirectedPlannedActivity : <sch:value-of select="$uid"/>) The DirectedPlannedActivity.PossibleMethods contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Direction"/>
   <sch:pattern id="DistributionByValue"><!--(Ref to E) DistributionByValue.DefinedFunction : SET[1:unbounded] OF FunctionValuePair (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DistributionByValue') or (self::PropertyValue and substring-after(@xsi:type,':')='DistributionByValue'))]/DefinedFunction/FunctionValuePair">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'FunctionValuePair'] or //FunctionValuePair[@uid = $uidRef]">(DistributionByValue : <sch:value-of select="$uid"/>) The DistributionByValue.DefinedFunction contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type FunctionValuePair.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ValueWithUnit.Qualifications : OPTIONAL SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DistributionByValue') or (self::DistributionByValue or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Altitude and substring-after(@xsi:type,':')='DistributionByValue') or (self::Longitude and substring-after(@xsi:type,':')='DistributionByValue') or (self::Latitude and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::LotSize and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Offset and substring-after(@xsi:type,':')='DistributionByValue') or (self::RequiredQuantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='DistributionByValue') or (self::Duration and substring-after(@xsi:type,':')='DistributionByValue')))]/Qualifications/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::TypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::TypeQualifier and //TypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(DistributionByValue : <sch:value-of select="$uid"/>) The DistributionByValue.Qualifications contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ValueWithUnit.Unit : UnitSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DistributionByValue') or (self::DistributionByValue or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Altitude and substring-after(@xsi:type,':')='DistributionByValue') or (self::Longitude and substring-after(@xsi:type,':')='DistributionByValue') or (self::Latitude and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::LotSize and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Offset and substring-after(@xsi:type,':')='DistributionByValue') or (self::RequiredQuantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='DistributionByValue') or (self::Duration and substring-after(@xsi:type,':')='DistributionByValue')))]/Unit">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)] or //ExternalUnit[@uid = $uidRef] or //Unit[@uid = $uidRef]">(DistributionByValue : <sch:value-of select="$uid"/>) The DistributionByValue.Unit contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyValue.Definition : PropertyDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DistributionByValue') or (self::DistributionByValue or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Altitude and substring-after(@xsi:type,':')='DistributionByValue') or (self::Longitude and substring-after(@xsi:type,':')='DistributionByValue') or (self::Latitude and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::LotSize and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Offset and substring-after(@xsi:type,':')='DistributionByValue') or (self::RequiredQuantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::Quantity and substring-after(@xsi:type,':')='DistributionByValue') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='DistributionByValue') or (self::Duration and substring-after(@xsi:type,':')='DistributionByValue')))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinition'] or //PropertyDefinition[@uid = $uidRef]">(DistributionByValue : <sch:value-of select="$uid"/>) The DistributionByValue.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Document"><!--(Ref to S) Document.DocumentTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Document') or (self::Document and not(@xsi:type)))]/DocumentTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Document : <sch:value-of select="$uid"/>) The Document.DocumentTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DocumentAssignment"><!--(Ref to S) DocumentAssignment.AssignedDocument : AssignedDocumentSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='DocumentAssignment'))]/AssignedDocument">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)] or //Document[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //DocumentVersion[@uid = $uidRef] or //File[@uid = $uidRef]">(DocumentAssignment : <sch:value-of select="$uid"/>) The DocumentAssignment.AssignedDocument contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AssignedDocumentSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DocumentAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=AssignmentObject.Role)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='DocumentAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DocumentAssignment : <sch:value-of select="$uid"/>) The DocumentAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DocumentDefinition"><!--(Inverse of DocumentVersion.Views :: PartProperty) DocumentDefinition.ViewOf : DocumentVersion) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="DocumentDefinitionRelationship"><!--(Ref to E) DocumentDefinitionRelationship.Related : DocumentDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentDefinitionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='DocumentDefinitionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DocumentDefinition'] or //DocumentDefinition[@uid = $uidRef]">(DocumentDefinitionRelationship : <sch:value-of select="$uid"/>) The DocumentDefinitionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DocumentDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DocumentDefinitionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentDefinitionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='DocumentDefinitionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DocumentDefinitionRelationship : <sch:value-of select="$uid"/>) The DocumentDefinitionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DocumentRelationship"><!--(Ref to E) DocumentRelationship.Related : Document (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='DocumentRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Document'] or //Document[@uid = $uidRef]">(DocumentRelationship : <sch:value-of select="$uid"/>) The DocumentRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Document.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DocumentRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='DocumentRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DocumentRelationship : <sch:value-of select="$uid"/>) The DocumentRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DocumentVersion"><!--(Inverse of Document.Versions :: PartProperty) DocumentVersion.VersionOf : Document) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="DocumentVersionRelationship"><!--(Ref to E) DocumentVersionRelationship.Related : DocumentVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='DocumentVersionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DocumentVersion'] or //DocumentVersion[@uid = $uidRef]">(DocumentVersionRelationship : <sch:value-of select="$uid"/>) The DocumentVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DocumentVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DocumentVersionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='DocumentVersionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DocumentVersionRelationship : <sch:value-of select="$uid"/>) The DocumentVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Duration"><!--(Ref to E) NumericalValue.ValueContext : OPTIONAL NumericalContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Duration') or (self::Duration or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Altitude and substring-after(@xsi:type,':')='Duration') or (self::Longitude and substring-after(@xsi:type,':')='Duration') or (self::Latitude and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::LotSize and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Offset and substring-after(@xsi:type,':')='Duration') or (self::RequiredQuantity and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='Duration') or (self::Duration and substring-after(@xsi:type,':')='Duration')))]/ValueContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ValueContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'NumericalContext'] or //NumericalContext[@uid = $uidRef]">(Duration : <sch:value-of select="$uid"/>) The Duration.ValueContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type NumericalContext.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ValueWithUnit.Qualifications : OPTIONAL SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Duration') or (self::Duration or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Altitude and substring-after(@xsi:type,':')='Duration') or (self::Longitude and substring-after(@xsi:type,':')='Duration') or (self::Latitude and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::LotSize and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Offset and substring-after(@xsi:type,':')='Duration') or (self::RequiredQuantity and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='Duration') or (self::Duration and substring-after(@xsi:type,':')='Duration')))]/Qualifications/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::TypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::TypeQualifier and //TypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(Duration : <sch:value-of select="$uid"/>) The Duration.Qualifications contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ValueWithUnit.Unit : UnitSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Duration') or (self::Duration or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Altitude and substring-after(@xsi:type,':')='Duration') or (self::Longitude and substring-after(@xsi:type,':')='Duration') or (self::Latitude and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::LotSize and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Offset and substring-after(@xsi:type,':')='Duration') or (self::RequiredQuantity and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='Duration') or (self::Duration and substring-after(@xsi:type,':')='Duration')))]/Unit">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)] or //ExternalUnit[@uid = $uidRef] or //Unit[@uid = $uidRef]">(Duration : <sch:value-of select="$uid"/>) The Duration.Unit contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyValue.Definition : PropertyDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Duration') or (self::Duration or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Altitude and substring-after(@xsi:type,':')='Duration') or (self::Longitude and substring-after(@xsi:type,':')='Duration') or (self::Latitude and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::LotSize and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Offset and substring-after(@xsi:type,':')='Duration') or (self::RequiredQuantity and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::Quantity and substring-after(@xsi:type,':')='Duration') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='Duration') or (self::Duration and substring-after(@xsi:type,':')='Duration')))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinition'] or //PropertyDefinition[@uid = $uidRef]">(Duration : <sch:value-of select="$uid"/>) The Duration.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Effectivity"><!--(Ref to E) Effectivity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Effectivity') or (self::Effectivity and not(@xsi:type)))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(Effectivity : <sch:value-of select="$uid"/>) The Effectivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Effectivity.EffectivityContext : OPTIONAL EffectivityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Effectivity') or (self::Effectivity and not(@xsi:type)))]/EffectivityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //Activity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef]">(Effectivity : <sch:value-of select="$uid"/>) The Effectivity.EffectivityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EffectivityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EffectivityAssignment"><!--(Ref to E) EffectivityAssignment.AssignedEffectivity : Effectivity (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EffectivityAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='EffectivityAssignment'))]/AssignedEffectivity">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Effectivity'] or //Effectivity[@uid = $uidRef]">(EffectivityAssignment : <sch:value-of select="$uid"/>) The EffectivityAssignment.AssignedEffectivity contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Effectivity.</sch:assert>
      </sch:rule>
      <!--(Ref to S) EffectivityAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=AssignmentObject.Role)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EffectivityAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='EffectivityAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(EffectivityAssignment : <sch:value-of select="$uid"/>) The EffectivityAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EffectivityRelationship"><!--(Ref to E) EffectivityRelationship.Related : Effectivity (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EffectivityRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='EffectivityRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Effectivity'] or //Effectivity[@uid = $uidRef]">(EffectivityRelationship : <sch:value-of select="$uid"/>) The EffectivityRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Effectivity.</sch:assert>
      </sch:rule>
      <!--(Ref to S) EffectivityRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EffectivityRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='EffectivityRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(EffectivityRelationship : <sch:value-of select="$uid"/>) The EffectivityRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EndTask"/>
   <sch:pattern id="Envelope"><!--(Ref to E) Envelope.Wrapping : OPTIONAL Message (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Envelope') or (self::Envelope and not(@xsi:type)))]/Wrapping">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Wrapping) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Message'] or //Message[@uid = $uidRef]">(Envelope : <sch:value-of select="$uid"/>) The Envelope.Wrapping contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Message.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EnvelopeRelationship"><!--(Ref to E) EnvelopeRelationship.Related : Envelope (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EnvelopeRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='EnvelopeRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Envelope'] or //Envelope[@uid = $uidRef]">(EnvelopeRelationship : <sch:value-of select="$uid"/>) The EnvelopeRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Envelope.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EnvelopeRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='EnvelopeRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(EnvelopeRelationship : <sch:value-of select="$uid"/>) The EnvelopeRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EnvironmentAssignment"><!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EnvironmentAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='EnvironmentAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(EnvironmentAssignment : <sch:value-of select="$uid"/>) The EnvironmentAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EnvironmentDefinition"/>
   <sch:pattern id="EnvironmentDefinitionVersion"><!--(Inverse of Environment.Versions :: PartProperty) EnvironmentVersion.VersionOf : Environment) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="EnvironmentDefinitionView"><!--(Ref to E) EnvironmentView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EnvironmentDefinitionView') or (self::EnvironmentDefinitionView or (self::AssignedEnvironment and substring-after(@xsi:type,':')='EnvironmentDefinitionView')))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(EnvironmentDefinitionView : <sch:value-of select="$uid"/>) The EnvironmentDefinitionView.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) EnvironmentView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EnvironmentDefinitionView') or (self::EnvironmentDefinitionView or (self::AssignedEnvironment and substring-after(@xsi:type,':')='EnvironmentDefinitionView')))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(EnvironmentDefinitionView : <sch:value-of select="$uid"/>) The EnvironmentDefinitionView.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of EnvironmentVersion.Views :: PartProperty) EnvironmentView.ViewOf : EnvironmentVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="EnvironmentDefinitionViewRelationship"><!--(Ref to E) EnvironmentDefinitionViewRelationship.Related : EnvironmentDefinitionView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EnvironmentDefinitionViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='EnvironmentDefinitionViewRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'EnvironmentDefinitionView'] or //EnvironmentView[@uid = $uidRef and contains(' EnvironmentDefinitionView ',substring-after(@xsi:type,':'))] or //*[@uid = $uidRef and (self::AssignedEnvironment)]">(EnvironmentDefinitionViewRelationship : <sch:value-of select="$uid"/>) The EnvironmentDefinitionViewRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type EnvironmentDefinitionView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) EnvironmentDefinitionViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EnvironmentDefinitionViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='EnvironmentDefinitionViewRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(EnvironmentDefinitionViewRelationship : <sch:value-of select="$uid"/>) The EnvironmentDefinitionViewRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Event"><!--(Ref to S) Event.EventType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Event') or (self::Event and not(@xsi:type)))]/EventType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Event : <sch:value-of select="$uid"/>) The Event.EventType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EventAssignment"><!--(Ref to E) EventAssignment.AssignedEvent : Event (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EventAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='EventAssignment'))]/AssignedEvent">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Event'] or //Event[@uid = $uidRef]">(EventAssignment : <sch:value-of select="$uid"/>) The EventAssignment.AssignedEvent contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Event.</sch:assert>
      </sch:rule>
      <!--(Ref to S) EventAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=AssignmentObject.Role)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EventAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='EventAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(EventAssignment : <sch:value-of select="$uid"/>) The EventAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EventRelationship"><!--(Ref to E) EventRelationship.Related : Event (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EventRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='EventRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Event'] or //Event[@uid = $uidRef]">(EventRelationship : <sch:value-of select="$uid"/>) The EventRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Event.</sch:assert>
      </sch:rule>
      <!--(Ref to S) EventRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EventRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='EventRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(EventRelationship : <sch:value-of select="$uid"/>) The EventRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Evidence"><!--(Ref to S) Evidence.Items : SET[1:unbounded] OF EvidenceSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Evidence') or (self::Evidence and not(@xsi:type)))]/Items/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::ActualActivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActualActivity ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (self::Collection and //ExternalRefBaseObject[@uid = $uidRef and contains(' Collection ',@typeRef)]) or (self::CollectionVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)]) or (self::CollectionVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersionRelationship  CollectionVersionSequenceRelationship ',@typeRef)]) or (self::CollectionView and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)]) or (self::CollectionViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionViewRelationship ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::InterfaceConnector and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)]) or (self::InterfaceConnectorOccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',@typeRef)]) or (self::InterfaceConnectorVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)]) or (self::InterfaceConnectorVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersionRelationship ',@typeRef)]) or (self::InterfaceConnectorView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)]) or (self::InterfaceConnectorViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',@typeRef)]) or (self::InterfaceSpecification and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)]) or (self::InterfaceSpecificationVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)]) or (self::InterfaceSpecificationVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersionRelationship ',@typeRef)]) or (self::InterfaceSpecificationView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)]) or (self::InterfaceSpecificationViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',@typeRef)]) or (self::JustificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' JustificationAssignment ',@typeRef)]) or (self::JustificationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' JustificationRelationship ',@typeRef)]) or (self::JustificationSupportAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' JustificationSupportAssignment ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::PersonOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::Risk and //ExternalRefBaseObject[@uid = $uidRef and contains(' Risk ',@typeRef)]) or (self::RiskImpactAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskImpactAssignment ',@typeRef)]) or (self::RiskPerceptionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskPerceptionRelationship ',@typeRef)]) or (self::RiskVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)]) or (self::RiskView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)]) or (self::Scheme and //ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)]) or (self::SchemeEntry and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)]) or (self::SchemeVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Slot and //ExternalRefBaseObject[@uid = $uidRef and contains(' Slot ',@typeRef)]) or (self::SlotDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)]) or (self::SlotDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinitionRelationship ',@typeRef)]) or (*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',@typeRef)]) or (self::System and //ExternalRefBaseObject[@uid = $uidRef and contains(' System ',@typeRef)]) or (self::SystemVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)]) or (self::SystemView and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemView ',@typeRef)]) or (self::SystemViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemViewRelationship ',@typeRef)]) or (*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)]) or (self::TaskMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)]) or (self::TaskMethodVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)]) or (self::Validation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Validation ',@typeRef)]) or (self::Verification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Verification ',@typeRef)]) or (self::ActivityAssignment and //AssignmentObject[@uid = $uidRef and contains(' ActivityAssignment ',substring-after(@xsi:type,':'))]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityRelationship and //RelationshipObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',substring-after(@xsi:type,':'))]) or (self::ActualActivity and //Activity[@uid = $uidRef and contains(' ActualActivity ',substring-after(@xsi:type,':'))]) or (self::ApprovalAssignment and //AssignmentObject[@uid = $uidRef and contains(' ApprovalAssignment ',substring-after(@xsi:type,':'))]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::CertificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' CertificationAssignment ',substring-after(@xsi:type,':'))]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::Collection and //Collection[@uid = $uidRef]) or (self::CollectionVersion and //CollectionVersion[@uid = $uidRef]) or (self::CollectionVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' CollectionVersionRelationship  CollectionVersionSequenceRelationship ',substring-after(@xsi:type,':'))]) or (self::CollectionView and //CollectionView[@uid = $uidRef]) or (self::CollectionViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' CollectionViewRelationship ',substring-after(@xsi:type,':'))]) or (self::ContractAssignment and //AssignmentObject[@uid = $uidRef and contains(' ContractAssignment ',substring-after(@xsi:type,':'))]) or (self::DateTimeAssignment and //AssignmentObject[@uid = $uidRef and contains(' DateTimeAssignment ',substring-after(@xsi:type,':'))]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::EffectivityAssignment and //AssignmentObject[@uid = $uidRef and contains(' EffectivityAssignment ',substring-after(@xsi:type,':'))]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //AssignmentObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnector and //InterfaceConnector[@uid = $uidRef]) or (self::InterfaceConnectorOccurrenceRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorVersion and //InterfaceConnectorVersion[@uid = $uidRef]) or (self::InterfaceConnectorVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorView and //InterfaceConnectorView[@uid = $uidRef]) or (self::InterfaceConnectorViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceSpecification and //InterfaceSpecification[@uid = $uidRef]) or (self::InterfaceSpecificationVersion and //InterfaceSpecificationVersion[@uid = $uidRef]) or (self::InterfaceSpecificationVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceSpecificationView and //InterfaceSpecificationView[@uid = $uidRef]) or (self::InterfaceSpecificationViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',substring-after(@xsi:type,':'))]) or (self::JustificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' JustificationAssignment ',substring-after(@xsi:type,':'))]) or (self::JustificationRelationship and //RelationshipObject[@uid = $uidRef and contains(' JustificationRelationship ',substring-after(@xsi:type,':'))]) or (self::JustificationSupportAssignment and //AssignmentObject[@uid = $uidRef and contains(' JustificationSupportAssignment ',substring-after(@xsi:type,':'))]) or (self::ObservationAssignment and //AssignmentObject[@uid = $uidRef and contains(' ObservationAssignment ',substring-after(@xsi:type,':'))]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' PartVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',substring-after(@xsi:type,':'))]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef]) or (self::PersonOrganizationAssignment and //AssignmentObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',substring-after(@xsi:type,':'))]) or (self::ProjectAssignment and //AssignmentObject[@uid = $uidRef and contains(' ProjectAssignment ',substring-after(@xsi:type,':'))]) or (self::PropertyDefinitionAssignment and //AssignmentObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',substring-after(@xsi:type,':'))]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //AssignmentObject[@uid = $uidRef and contains(' PropertyValueAssignment ',substring-after(@xsi:type,':'))]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::Risk and //Risk[@uid = $uidRef]) or (self::RiskImpactAssignment and //AssignmentObject[@uid = $uidRef and contains(' RiskImpactAssignment ',substring-after(@xsi:type,':'))]) or (self::RiskPerceptionRelationship and //RelationshipObject[@uid = $uidRef and contains(' RiskPerceptionRelationship ',substring-after(@xsi:type,':'))]) or (self::RiskVersion and //RiskVersion[@uid = $uidRef]) or (self::RiskView and //RiskView[@uid = $uidRef]) or (self::Scheme and //Scheme[@uid = $uidRef]) or (self::SchemeEntry and //SchemeEntry[@uid = $uidRef]) or (self::SchemeVersion and //SchemeVersion[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',substring-after(@xsi:type,':'))]) or (self::Slot and //Slot[@uid = $uidRef]) or (self::SlotDefinition and //SlotDefinition[@uid = $uidRef]) or (self::SlotDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' SlotDefinitionRelationship ',substring-after(@xsi:type,':'))]) or (self::SlotVersion and //*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::System and //System[@uid = $uidRef]) or (self::SystemVersion and //SystemVersion[@uid = $uidRef]) or (self::SystemView and //SystemView[@uid = $uidRef]) or (self::SystemViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' SystemViewRelationship ',substring-after(@xsi:type,':'))]) or (self::TaskElement and //*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::TaskMethod and //TaskMethod[@uid = $uidRef]) or (self::TaskMethodVersion and //TaskMethodVersion[@uid = $uidRef]) or (self::Validation and //Validation[@uid = $uidRef]) or (self::Verification and //Verification[@uid = $uidRef])">(Evidence : <sch:value-of select="$uid"/>) The Evidence.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EvidenceSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Evidence.Supports : EvidenceSupportSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Evidence') or (self::Evidence and not(@xsi:type)))]/Supports">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Validation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Verification ',@typeRef)] or //Validation[@uid = $uidRef] or //Verification[@uid = $uidRef]">(Evidence : <sch:value-of select="$uid"/>) The Evidence.Supports contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EvidenceSupportSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExchangeContext"><!--(Ref to S) ExchangeContext.DefaultIdentificationContext : OPTIONAL IdentificationContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExchangeContext') or (self::ExchangeContext or (self::ExchangeContext and substring-after(@xsi:type,':')='ExchangeContext')))]/DefaultIdentificationContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //Identifier[@uid = $uidRef] or //Organization[@uid = $uidRef]">(ExchangeContext : <sch:value-of select="$uid"/>) The ExchangeContext.DefaultIdentificationContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of IdentificationContextSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ExchangeContext.DefaultLanguage : OPTIONAL Language (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExchangeContext') or (self::ExchangeContext or (self::ExchangeContext and substring-after(@xsi:type,':')='ExchangeContext')))]/DefaultLanguage">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefaultLanguage) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Language'] or //Language[@uid = $uidRef] or //*[@uid = $uidRef and (self::Language)]">(ExchangeContext : <sch:value-of select="$uid"/>) The ExchangeContext.DefaultLanguage contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Language.</sch:assert>
      </sch:rule>
      <!--(Default Value) ExchangeContext.ClassLibrary : OPTIONAL Uri = 'http://standards.iso.org/iso/10303/tech/refdata/core_rd' (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExchangeContext') or (self::ExchangeContext or (self::ExchangeContext and substring-after(@xsi:type,':')='ExchangeContext')))]/ClassLibrary">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="count(./ClassLibrary) = 0 or text() = 'http://standards.iso.org/iso/10303/tech/refdata/core_rd'">(ExchangeContext : <sch:value-of select="$uid"/>) The ExchangeContext.ClassLibrary contains the wrong value () must be 'http://standards.iso.org/iso/10303/tech/refdata/core_rd'.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExitLoop"/>
   <sch:pattern id="ExpandedUncertainty"/>
   <sch:pattern id="ExperienceGained"><!--(Ref to E) ExperienceGained.ExperienceOf : ExperienceInstance (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExperienceGained') or (self::ExperienceGained and not(@xsi:type)))]/ExperienceOf">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExperienceInstance'] or //ExperienceInstance[@uid = $uidRef]">(ExperienceGained : <sch:value-of select="$uid"/>) The ExperienceGained.ExperienceOf contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExperienceInstance.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ExperienceGained.GainedBy : PersonOrganizationSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExperienceGained') or (self::ExperienceGained and not(@xsi:type)))]/GainedBy">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //Organization[@uid = $uidRef] or //Person[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef]">(ExperienceGained : <sch:value-of select="$uid"/>) The ExperienceGained.GainedBy contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PersonOrganizationSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExperienceInstance"><!--(Ref to S) ExperienceInstance.ConsistsOf : OPTIONAL DefinedActivitiesSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExperienceInstance') or (self::ExperienceInstance and not(@xsi:type)))]/ConsistsOf">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ActualActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealized ',@typeRef)] or //Activity[@uid = $uidRef and contains(' ActualActivity ',substring-after(@xsi:type,':'))] or //ResourceAsRealized[@uid = $uidRef]">(ExperienceInstance : <sch:value-of select="$uid"/>) The ExperienceInstance.ConsistsOf contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of DefinedActivitiesSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ExperienceInstance.IsDefinedBy : ExperienceType (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExperienceInstance') or (self::ExperienceInstance and not(@xsi:type)))]/IsDefinedBy">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExperienceType'] or //ExperienceType[@uid = $uidRef]">(ExperienceInstance : <sch:value-of select="$uid"/>) The ExperienceInstance.IsDefinedBy contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExperienceType.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExperienceType"><!--(Ref to S) ExperienceType.ConsistsOf : OPTIONAL DefinedMethodsSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExperienceType') or (self::ExperienceType and not(@xsi:type)))]/ConsistsOf">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequiredResource ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)] or //Activity[@uid = $uidRef] or //ActivityMethod[@uid = $uidRef] or //RequiredResource[@uid = $uidRef] or //Scheme[@uid = $uidRef] or //SchemeEntry[@uid = $uidRef] or //SchemeVersion[@uid = $uidRef] or //TaskElement[@uid = $uidRef] or //TaskMethod[@uid = $uidRef] or //TaskMethodVersion[@uid = $uidRef]">(ExperienceType : <sch:value-of select="$uid"/>) The ExperienceType.ConsistsOf contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of DefinedMethodsSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExperienceTypeRelationship"><!--(Ref to E) ExperienceTypeRelationship.Related : ExperienceType (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExperienceTypeRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ExperienceTypeRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExperienceType'] or //ExperienceType[@uid = $uidRef]">(ExperienceTypeRelationship : <sch:value-of select="$uid"/>) The ExperienceTypeRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExperienceType.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExperienceTypeRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ExperienceTypeRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ExperienceTypeRelationship : <sch:value-of select="$uid"/>) The ExperienceTypeRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExternalAnalysisModel"><!--(Ref to E) ExternalAnalysisModel.ExternalFile : DigitalFile (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalAnalysisModel') or (self::AnalysisModelObject and substring-after(@xsi:type,':')='ExternalAnalysisModel'))]/ExternalFile">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(ExternalAnalysisModel : <sch:value-of select="$uid"/>) The ExternalAnalysisModel.ExternalFile contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AnalysisModelObject.ContextOfItems : AnalysisRepresentationContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalAnalysisModel') or (self::AnalysisModelObject and substring-after(@xsi:type,':')='ExternalAnalysisModel'))]/ContextOfItems">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AnalysisRepresentationContext'] or //AnalysisRepresentationContext[@uid = $uidRef]">(ExternalAnalysisModel : <sch:value-of select="$uid"/>) The ExternalAnalysisModel.ContextOfItems contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AnalysisRepresentationContext.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExternalGeometricModel"><!--(Ref to E) ExternalGeometricModel.ExternalFile : DigitalFile (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='ExternalGeometricModel'))]/ExternalFile">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(ExternalGeometricModel : <sch:value-of select="$uid"/>) The ExternalGeometricModel.ExternalFile contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricModel.Items : SET[1:unbounded] OF DetailedGeometricModelItem (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='ExternalGeometricModel'))]/Items/DetailedGeometricModelItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DetailedGeometricModelItem'] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AxisPlacement  Direction  Point  CartesianPoint ',substring-after(@xsi:type,':'))]">(ExternalGeometricModel : <sch:value-of select="$uid"/>) The ExternalGeometricModel.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DetailedGeometricModelItem.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace (kind=SINGLE - redefined=Representation.ContextOfItems)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='ExternalGeometricModel'))]/ContextOfItems">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricCoordinateSpace'] or //RepresentationContext[@uid = $uidRef and contains(' GeometricCoordinateSpace ',substring-after(@xsi:type,':'))]">(ExternalGeometricModel : <sch:value-of select="$uid"/>) The ExternalGeometricModel.ContextOfItems contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricCoordinateSpace.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='ExternalGeometricModel'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ExternalGeometricModel : <sch:value-of select="$uid"/>) The ExternalGeometricModel.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExternalItem"><!--(Ref to S) ExternalItem.Source : OPTIONAL ExternalSourceSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalItem') or (self::ExternalItem or (self::External and substring-after(@xsi:type,':')='ExternalItem')))]/Source/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DigitalFile and //ExternalRefBaseObject[@uid = $uidRef and contains(' DigitalFile ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::DigitalFile and //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Identifier) or (self::IdentifierString)">(ExternalItem : <sch:value-of select="$uid"/>) The ExternalItem.Source contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ExternalSourceSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExternalLibrary"><!--(Ref to S) ExternalLibrary.Source : OPTIONAL ExternalSourceSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalLibrary') or (self::ExternalLibrary and not(@xsi:type)))]/Source/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DigitalFile and //ExternalRefBaseObject[@uid = $uidRef and contains(' DigitalFile ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::DigitalFile and //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Identifier) or (self::IdentifierString)">(ExternalLibrary : <sch:value-of select="$uid"/>) The ExternalLibrary.Source contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ExternalSourceSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExternalOwlClass"/>
   <sch:pattern id="ExternalOwlObject"/>
   <sch:pattern id="ExternalRepresentationItem"/>
   <sch:pattern id="ExternalUnit"><!--(Ref to S) ExternalUnit.Definition : ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalUnit') or (self::ExternalUnit and not(@xsi:type)))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(ExternalUnit : <sch:value-of select="$uid"/>) The ExternalUnit.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExternalValue"><!--(Ref to S) ExternalValue.SameAs : ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalValue') or (self::PropertyValue and substring-after(@xsi:type,':')='ExternalValue'))]/SameAs/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(ExternalValue : <sch:value-of select="$uid"/>) The ExternalValue.SameAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyValue.Definition : PropertyDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalValue') or (self::ExternalValue or (self::Quantity and substring-after(@xsi:type,':')='ExternalValue') or (self::Altitude and substring-after(@xsi:type,':')='ExternalValue') or (self::Longitude and substring-after(@xsi:type,':')='ExternalValue') or (self::Latitude and substring-after(@xsi:type,':')='ExternalValue') or (self::Quantity and substring-after(@xsi:type,':')='ExternalValue') or (self::LotSize and substring-after(@xsi:type,':')='ExternalValue') or (self::Quantity and substring-after(@xsi:type,':')='ExternalValue') or (self::Quantity and substring-after(@xsi:type,':')='ExternalValue') or (self::Offset and substring-after(@xsi:type,':')='ExternalValue') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ExternalValue') or (self::Quantity and substring-after(@xsi:type,':')='ExternalValue') or (self::Quantity and substring-after(@xsi:type,':')='ExternalValue') or (self::Quantity and substring-after(@xsi:type,':')='ExternalValue') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ExternalValue') or (self::Duration and substring-after(@xsi:type,':')='ExternalValue')))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinition'] or //PropertyDefinition[@uid = $uidRef]">(ExternalValue : <sch:value-of select="$uid"/>) The ExternalValue.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="FileRelationship"><!--(Ref to E) FileRelationship.Related : File (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FileRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='FileRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'File'] or //File[@uid = $uidRef]">(FileRelationship : <sch:value-of select="$uid"/>) The FileRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type File.</sch:assert>
      </sch:rule>
      <!--(Ref to S) FileRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FileRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='FileRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(FileRelationship : <sch:value-of select="$uid"/>) The FileRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="FunctionValuePair"><!--(Ref to E) FunctionValuePair.FunctionValue : NumericalValue (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FunctionValuePair') or (self::FunctionValuePair and not(@xsi:type)))]/FunctionValue">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'NumericalValue'] or //PropertyValue[@uid = $uidRef and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',substring-after(@xsi:type,':'))] or //*[@uid = $uidRef and (self::Quantity or self::Altitude or self::Longitude or self::Latitude or self::Quantity or self::LotSize or self::Quantity or self::Offset or self::RequiredQuantity or self::Quantity or self::Quantity or self::Quantity or self::EffectivityPeriod or self::Duration)]">(FunctionValuePair : <sch:value-of select="$uid"/>) The FunctionValuePair.FunctionValue contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type NumericalValue.</sch:assert>
      </sch:rule>
      <!--(Ref to E) FunctionValuePair.VariableValue : NumericalValue (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FunctionValuePair') or (self::FunctionValuePair and not(@xsi:type)))]/VariableValue">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'NumericalValue'] or //PropertyValue[@uid = $uidRef and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',substring-after(@xsi:type,':'))] or //*[@uid = $uidRef and (self::Quantity or self::Altitude or self::Longitude or self::Latitude or self::Quantity or self::LotSize or self::Quantity or self::Offset or self::RequiredQuantity or self::Quantity or self::Quantity or self::Quantity or self::EffectivityPeriod or self::Duration)]">(FunctionValuePair : <sch:value-of select="$uid"/>) The FunctionValuePair.VariableValue contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type NumericalValue.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeneralGeometricRepresentationRelationship"><!--(Ref to S) GeneralGeometricRepresentationRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeneralGeometricRepresentationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='GeneralGeometricRepresentationRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(GeneralGeometricRepresentationRelationship : <sch:value-of select="$uid"/>) The GeneralGeometricRepresentationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricRepresentationRelationship.Related : GeometricRepresentationSelect (kind=SINGLE - redefined=RepresentationRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeneralGeometricRepresentationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='GeneralGeometricRepresentationRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentation  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',@typeRef)] or //Representation[@uid = $uidRef and contains(' GeometricRepresentation  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(GeneralGeometricRepresentationRelationship : <sch:value-of select="$uid"/>) The GeneralGeometricRepresentationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricRepresentationSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeographicalArea"><!--(Ref to S) GeographicalArea.GeographicalAreaType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeographicalArea') or (self::Locator and substring-after(@xsi:type,':')='GeographicalArea'))]/GeographicalAreaType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(GeographicalArea : <sch:value-of select="$uid"/>) The GeographicalArea.GeographicalAreaType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of Location.Locators :: PartProperty) Locator.Represents : OPTIONAL Location) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="GeometricCoordinateSpace"><!--(Ref to E) RepresentationContext.Accuracies : OPTIONAL SET[1:unbounded] OF MeasureQualification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricCoordinateSpace') or (self::RepresentationContext and substring-after(@xsi:type,':')='GeometricCoordinateSpace'))]/Accuracies/MeasureQualification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Accuracies/MeasureQualification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'MeasureQualification'] or //MeasureQualification[@uid = $uidRef]">(GeometricCoordinateSpace : <sch:value-of select="$uid"/>) The GeometricCoordinateSpace.Accuracies contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type MeasureQualification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RepresentationContext.Units : OPTIONAL SET[1:unbounded] OF Unit (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricCoordinateSpace') or (self::RepresentationContext and substring-after(@xsi:type,':')='GeometricCoordinateSpace'))]/Units/Unit">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Units/Unit) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Unit'] or //Unit[@uid = $uidRef]">(GeometricCoordinateSpace : <sch:value-of select="$uid"/>) The GeometricCoordinateSpace.Units contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Unit.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricModel"><!--(Ref to E) GeometricModel.Items : SET[1:unbounded] OF DetailedGeometricModelItem (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricModel') or (self::Representation and substring-after(@xsi:type,':')='GeometricModel'))]/Items/DetailedGeometricModelItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DetailedGeometricModelItem'] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AxisPlacement  Direction  Point  CartesianPoint ',substring-after(@xsi:type,':'))]">(GeometricModel : <sch:value-of select="$uid"/>) The GeometricModel.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DetailedGeometricModelItem.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace (kind=SINGLE - redefined=Representation.ContextOfItems)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricModel') or (self::Representation and substring-after(@xsi:type,':')='GeometricModel'))]/ContextOfItems">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricCoordinateSpace'] or //RepresentationContext[@uid = $uidRef and contains(' GeometricCoordinateSpace ',substring-after(@xsi:type,':'))]">(GeometricModel : <sch:value-of select="$uid"/>) The GeometricModel.ContextOfItems contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricCoordinateSpace.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricModel') or (self::Representation and substring-after(@xsi:type,':')='GeometricModel'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(GeometricModel : <sch:value-of select="$uid"/>) The GeometricModel.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricRepresentationRelationshipWithCartesianTransformation"><!--(Ref to E) GeometricRepresentationRelationshipWithCartesianTransformation.Transformation : CartesianTransformation (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithCartesianTransformation') or (self::RelationshipObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithCartesianTransformation'))]/Transformation">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'CartesianTransformation'] or //CartesianTransformation[@uid = $uidRef]">(GeometricRepresentationRelationshipWithCartesianTransformation : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithCartesianTransformation.Transformation contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type CartesianTransformation.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricRepresentationRelationship.Related : GeometricRepresentationSelect (kind=SINGLE - redefined=RepresentationRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithCartesianTransformation') or (self::RelationshipObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithCartesianTransformation'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentation  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',@typeRef)] or //Representation[@uid = $uidRef and contains(' GeometricRepresentation  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(GeometricRepresentationRelationshipWithCartesianTransformation : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithCartesianTransformation.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricRepresentationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithCartesianTransformation') or (self::RelationshipObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithCartesianTransformation'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(GeometricRepresentationRelationshipWithCartesianTransformation : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithCartesianTransformation.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricRepresentationRelationshipWithPlacementTransformation"><!--(Ref to E) GeometricRepresentationRelationshipWithPlacementTransformation.Origin : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithPlacementTransformation') or (self::RelationshipObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithPlacementTransformation'))]/Origin">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement ',substring-after(@xsi:type,':'))]">(GeometricRepresentationRelationshipWithPlacementTransformation : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithPlacementTransformation.Origin contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricRepresentationRelationshipWithPlacementTransformation.Target : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithPlacementTransformation') or (self::RelationshipObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithPlacementTransformation'))]/Target">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement ',substring-after(@xsi:type,':'))]">(GeometricRepresentationRelationshipWithPlacementTransformation : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithPlacementTransformation.Target contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricRepresentationRelationship.Related : GeometricRepresentationSelect (kind=SINGLE - redefined=RepresentationRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithPlacementTransformation') or (self::RelationshipObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithPlacementTransformation'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentation  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',@typeRef)] or //Representation[@uid = $uidRef and contains(' GeometricRepresentation  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(GeometricRepresentationRelationshipWithPlacementTransformation : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithPlacementTransformation.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricRepresentationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithPlacementTransformation') or (self::RelationshipObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithPlacementTransformation'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(GeometricRepresentationRelationshipWithPlacementTransformation : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithPlacementTransformation.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricRepresentationRelationshipWithSameCoordinateSpace"><!--(Default Value) GeometricRepresentationRelationshipWithSameCoordinateSpace.Definitional : Boolean = 'true' (kind=SINGLE - redefined=RepresentationRelationship.Definitional)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithSameCoordinateSpace') or (self::RelationshipObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithSameCoordinateSpace'))]/Definitional">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="text() = 'true'">(GeometricRepresentationRelationshipWithSameCoordinateSpace : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithSameCoordinateSpace.Definitional contains the wrong value () must be 'true'.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricRepresentationRelationship.Related : GeometricRepresentationSelect (kind=SINGLE - redefined=RepresentationRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithSameCoordinateSpace') or (self::RelationshipObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithSameCoordinateSpace'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentation  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',@typeRef)] or //Representation[@uid = $uidRef and contains(' GeometricRepresentation  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(GeometricRepresentationRelationshipWithSameCoordinateSpace : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithSameCoordinateSpace.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricRepresentationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithSameCoordinateSpace') or (self::RelationshipObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithSameCoordinateSpace'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(GeometricRepresentationRelationshipWithSameCoordinateSpace : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithSameCoordinateSpace.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricalRelationship"><!--(Ref to E) GeometricalRelationship.Placement : GeometricRepresentationRelationshipWithPlacementTransformation (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricalRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='GeometricalRelationship'))]/Placement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricRepresentationRelationshipWithPlacementTransformation'] or //RelationshipObject[@uid = $uidRef and contains(' GeometricRepresentationRelationshipWithPlacementTransformation ',substring-after(@xsi:type,':'))]">(GeometricalRelationship : <sch:value-of select="$uid"/>) The GeometricalRelationship.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricRepresentationRelationshipWithPlacementTransformation.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.Related : PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricalRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='GeometricalRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(GeometricalRelationship : <sch:value-of select="$uid"/>) The GeometricalRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricalRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='GeometricalRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(GeometricalRelationship : <sch:value-of select="$uid"/>) The GeometricalRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GlobalPositionLocation"><!--(Inverse of Location.Locators :: PartProperty) Locator.Represents : OPTIONAL Location) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="Hardcopy"><!--(Ref to S) File.FileType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Hardcopy') or (self::File and substring-after(@xsi:type,':')='Hardcopy'))]/FileType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Hardcopy : <sch:value-of select="$uid"/>) The Hardcopy.FileType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="HierarchicalInterfaceConnection"><!--(Ref to S) InterfaceConnection.Connected : ConnectionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HierarchicalInterfaceConnection') or (self::InterfaceConnection and substring-after(@xsi:type,':')='HierarchicalInterfaceConnection'))]/Connected">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)] or //BreakdownElementView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',substring-after(@xsi:type,':'))] or //IndividualPartView[@uid = $uidRef] or //InterfaceConnectorView[@uid = $uidRef] or //InterfaceSpecificationView[@uid = $uidRef] or //PartView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',substring-after(@xsi:type,':'))] or //RiskView[@uid = $uidRef] or //SlotDefinition[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' SystemViewRelationship ',substring-after(@xsi:type,':'))] or //InterfaceConnectorOccurrence[@uid = $uidRef]">(HierarchicalInterfaceConnection : <sch:value-of select="$uid"/>) The HierarchicalInterfaceConnection.Connected contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ConnectionSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Identifier"><!--(Ref specific) Identifier.IdentificationContext : OPTIONAL IdentificationContextSelect--><!--(Ref specific) Identifier.Role : ClassSelect-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Identifier') or self::Identifier)]">
         <sch:let name="uid" value="./@uid"/>
         <sch:let name="idContextRef" value="./@idContextRef"/>
         <sch:let name="idRoleRef" value="./@idRoleRef"/>
         <sch:assert test="count($idContextRef) = 0 or (count($idContextRef) = 1 and (//Identifier[@uid = $idContextRef] or //Organization[@uid = $idContextRef]))">(Identifier : <sch:value-of select="$uid"/>) The Identifier.IdentificationContext contains a bad reference (<sch:value-of select="$idContextRef"/>).</sch:assert>
         <sch:assert test="//Class[@uid = $idRoleRef] or //ExternalOwlClass[@uid = $idRoleRef]">(Identifier : <sch:value-of select="$uid"/>) The Identifier.Role contains a bad reference (<sch:value-of select="$idRoleRef"/>).</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="IdentifierRelationship"><!--(Ref to E) IdentifierRelationship.Related : Identifier (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IdentifierRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='IdentifierRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Identifier'] or //Identifier[@uid = $uidRef]">(IdentifierRelationship : <sch:value-of select="$uid"/>) The IdentifierRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Identifier.</sch:assert>
      </sch:rule>
      <!--(Ref to S) IdentifierRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IdentifierRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='IdentifierRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(IdentifierRelationship : <sch:value-of select="$uid"/>) The IdentifierRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InZone"><!--(Ref to E) InZone.Zone : BreakdownElementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InZone') or (self::AssociationObject and substring-after(@xsi:type,':')='InZone'))]/Zone">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElementView'] or //BreakdownElementView[@uid = $uidRef]">(InZone : <sch:value-of select="$uid"/>) The InZone.Zone contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElementView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="IncreasingResourceEvent"><!--(Ref to E) ResourceEvent.Resource : ManagedResource (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IncreasingResourceEvent') or (self::ResourceEvent and substring-after(@xsi:type,':')='IncreasingResourceEvent'))]/Resource">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ManagedResource'] or //ManagedResource[@uid = $uidRef]">(IncreasingResourceEvent : <sch:value-of select="$uid"/>) The IncreasingResourceEvent.Resource contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ManagedResource.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="IndividualAssemblyRelationship"><!--(Ref to S) IndividualAssemblyRelationship.Related : IndividualOrPartViewSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualAssemblyRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='IndividualAssemblyRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Slot ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',@typeRef)] or //IndividualPartView[@uid = $uidRef] or //PartView[@uid = $uidRef] or //Slot[@uid = $uidRef] or //SlotDefinition[@uid = $uidRef] or //SlotVersion[@uid = $uidRef]">(IndividualAssemblyRelationship : <sch:value-of select="$uid"/>) The IndividualAssemblyRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of IndividualOrPartViewSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualAssemblyRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='IndividualAssemblyRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(IndividualAssemblyRelationship : <sch:value-of select="$uid"/>) The IndividualAssemblyRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="IndividualPart"/>
   <sch:pattern id="IndividualPartEffectivity"><!--(Ref to E) IndividualPartEffectivity.Items : SET[1:unbounded] OF IndividualPart (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='IndividualPartEffectivity'))]/Items/IndividualPart">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'IndividualPart'] or //IndividualPart[@uid = $uidRef]">(IndividualPartEffectivity : <sch:value-of select="$uid"/>) The IndividualPartEffectivity.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type IndividualPart.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='IndividualPartEffectivity'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(IndividualPartEffectivity : <sch:value-of select="$uid"/>) The IndividualPartEffectivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Effectivity.EffectivityContext : OPTIONAL EffectivityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='IndividualPartEffectivity'))]/EffectivityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //Activity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef]">(IndividualPartEffectivity : <sch:value-of select="$uid"/>) The IndividualPartEffectivity.EffectivityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EffectivityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="IndividualPartRelationship"><!--(Ref to E) IndividualPartRelationship.Related : IndividualPart (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='IndividualPartRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'IndividualPart'] or //IndividualPart[@uid = $uidRef]">(IndividualPartRelationship : <sch:value-of select="$uid"/>) The IndividualPartRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type IndividualPart.</sch:assert>
      </sch:rule>
      <!--(Ref to S) IndividualPartRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='IndividualPartRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(IndividualPartRelationship : <sch:value-of select="$uid"/>) The IndividualPartRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="IndividualPartVersion"><!--(Inverse of IndividualPart.Versions :: PartProperty) IndividualPartVersion.VersionOf : IndividualPart) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="IndividualPartVersionRelationship"><!--(Ref to E) IndividualPartVersionRelationship.Related : IndividualPartVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='IndividualPartVersionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'IndividualPartVersion'] or //IndividualPartVersion[@uid = $uidRef]">(IndividualPartVersionRelationship : <sch:value-of select="$uid"/>) The IndividualPartVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type IndividualPartVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) IndividualPartVersionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='IndividualPartVersionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(IndividualPartVersionRelationship : <sch:value-of select="$uid"/>) The IndividualPartVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="IndividualPartView"><!--(Ref to E) IndividualPartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartView') or (self::IndividualPartView and not(@xsi:type)))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(IndividualPartView : <sch:value-of select="$uid"/>) The IndividualPartView.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) IndividualPartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartView') or (self::IndividualPartView and not(@xsi:type)))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(IndividualPartView : <sch:value-of select="$uid"/>) The IndividualPartView.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) IndividualPartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartView') or (self::IndividualPartView and not(@xsi:type)))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(IndividualPartView : <sch:value-of select="$uid"/>) The IndividualPartView.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of IndividualPartVersion.Views :: PartProperty) IndividualPartView.ViewOf : IndividualPartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="IndividualPartViewRelationship"><!--(Ref to E) IndividualPartViewRelationship.Related : IndividualPartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='IndividualPartViewRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'IndividualPartView'] or //IndividualPartView[@uid = $uidRef]">(IndividualPartViewRelationship : <sch:value-of select="$uid"/>) The IndividualPartViewRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type IndividualPartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) IndividualPartViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='IndividualPartViewRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(IndividualPartViewRelationship : <sch:value-of select="$uid"/>) The IndividualPartViewRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InformationRight"/>
   <sch:pattern id="InformationUsageRight"><!--(Ref to E) InformationUsageRight.GrantsRight : SET[1:unbounded] OF InformationRight (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InformationUsageRight') or (self::InformationUsageRight and not(@xsi:type)))]/GrantsRight/InformationRight">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'InformationRight'] or //InformationRight[@uid = $uidRef]">(InformationUsageRight : <sch:value-of select="$uid"/>) The InformationUsageRight.GrantsRight contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type InformationRight.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InformationUsageRightAssignment"><!--(Ref to E) InformationUsageRightAssignment.AssignedRight : InformationUsageRight (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InformationUsageRightAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='InformationUsageRightAssignment'))]/AssignedRight">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'InformationUsageRight'] or //InformationUsageRight[@uid = $uidRef]">(InformationUsageRightAssignment : <sch:value-of select="$uid"/>) The InformationUsageRightAssignment.AssignedRight contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type InformationUsageRight.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InformationUsageRightAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='InformationUsageRightAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(InformationUsageRightAssignment : <sch:value-of select="$uid"/>) The InformationUsageRightAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InformationUsageRightRelationship"><!--(Ref to E) InformationUsageRightRelationship.Related : InformationUsageRight (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InformationUsageRightRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='InformationUsageRightRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'InformationUsageRight'] or //InformationUsageRight[@uid = $uidRef]">(InformationUsageRightRelationship : <sch:value-of select="$uid"/>) The InformationUsageRightRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type InformationUsageRight.</sch:assert>
      </sch:rule>
      <!--(Ref to S) InformationUsageRightRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InformationUsageRightRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='InformationUsageRightRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(InformationUsageRightRelationship : <sch:value-of select="$uid"/>) The InformationUsageRightRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceConnection"><!--(Ref to S) InterfaceConnection.Connected : ConnectionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnection') or (self::InterfaceConnection and not(@xsi:type)))]/Connected">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)] or //BreakdownElementView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',substring-after(@xsi:type,':'))] or //IndividualPartView[@uid = $uidRef] or //InterfaceConnectorView[@uid = $uidRef] or //InterfaceSpecificationView[@uid = $uidRef] or //PartView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',substring-after(@xsi:type,':'))] or //RiskView[@uid = $uidRef] or //SlotDefinition[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' SystemViewRelationship ',substring-after(@xsi:type,':'))] or //InterfaceConnectorOccurrence[@uid = $uidRef]">(InterfaceConnection : <sch:value-of select="$uid"/>) The InterfaceConnection.Connected contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ConnectionSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceConnectionToDefinitionAssociation"><!--(Ref to E) InterfaceConnectionToDefinitionAssociation.AssociatedConnection : InterfaceConnection (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectionToDefinitionAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='InterfaceConnectionToDefinitionAssociation'))]/AssociatedConnection">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'InterfaceConnection'] or //InterfaceConnection[@uid = $uidRef]">(InterfaceConnectionToDefinitionAssociation : <sch:value-of select="$uid"/>) The InterfaceConnectionToDefinitionAssociation.AssociatedConnection contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type InterfaceConnection.</sch:assert>
      </sch:rule>
      <!--(Ref to E) InterfaceConnectionToDefinitionAssociation.AssociatedDefinition : InterfaceDefinitionConnection (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectionToDefinitionAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='InterfaceConnectionToDefinitionAssociation'))]/AssociatedDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'InterfaceDefinitionConnection'] or //InterfaceDefinitionConnection[@uid = $uidRef]">(InterfaceConnectionToDefinitionAssociation : <sch:value-of select="$uid"/>) The InterfaceConnectionToDefinitionAssociation.AssociatedDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type InterfaceDefinitionConnection.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceConnector"/>
   <sch:pattern id="InterfaceConnectorOccurrence"><!--(Ref to S) InterfaceConnectorOccurrence.ConnectorOn : ConnectorOnSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorOccurrence') or (self::InterfaceConnectorOccurrence and not(@xsi:type)))]/ConnectorOn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemViewRelationship ',@typeRef)] or //BreakdownElementView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',substring-after(@xsi:type,':'))] or //IndividualPartView[@uid = $uidRef] or //InterfaceConnectorView[@uid = $uidRef] or //InterfaceSpecificationView[@uid = $uidRef] or //PartView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',substring-after(@xsi:type,':'))] or //RiskView[@uid = $uidRef] or //SlotDefinition[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' SystemViewRelationship ',substring-after(@xsi:type,':'))]">(InterfaceConnectorOccurrence : <sch:value-of select="$uid"/>) The InterfaceConnectorOccurrence.ConnectorOn contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ConnectorOnSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) InterfaceConnectorOccurrence.OccurrenceOf : InterfaceConnectorView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorOccurrence') or (self::InterfaceConnectorOccurrence and not(@xsi:type)))]/OccurrenceOf">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'InterfaceConnectorView'] or //InterfaceConnectorView[@uid = $uidRef]">(InterfaceConnectorOccurrence : <sch:value-of select="$uid"/>) The InterfaceConnectorOccurrence.OccurrenceOf contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type InterfaceConnectorView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceConnectorOccurrenceRelationship"><!--(Ref to E) InterfaceConnectorOccurrenceRelationship.Related : InterfaceConnectorOccurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorOccurrenceRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='InterfaceConnectorOccurrenceRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'InterfaceConnectorOccurrence'] or //InterfaceConnectorOccurrence[@uid = $uidRef]">(InterfaceConnectorOccurrenceRelationship : <sch:value-of select="$uid"/>) The InterfaceConnectorOccurrenceRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type InterfaceConnectorOccurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorOccurrenceRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='InterfaceConnectorOccurrenceRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(InterfaceConnectorOccurrenceRelationship : <sch:value-of select="$uid"/>) The InterfaceConnectorOccurrenceRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceConnectorRelationship"><!--(Ref to E) InterfaceConnectorRelationship.Related : InterfaceConnector (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='InterfaceConnectorRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'InterfaceConnector'] or //InterfaceConnector[@uid = $uidRef]">(InterfaceConnectorRelationship : <sch:value-of select="$uid"/>) The InterfaceConnectorRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type InterfaceConnector.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='InterfaceConnectorRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(InterfaceConnectorRelationship : <sch:value-of select="$uid"/>) The InterfaceConnectorRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceConnectorVersion"><!--(Inverse of InterfaceConnector.Versions :: PartProperty) InterfaceConnectorVersion.VersionOf : InterfaceConnector) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="InterfaceConnectorVersionRelationship"><!--(Ref to E) InterfaceConnectorVersionRelationship.Related : InterfaceConnectorVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='InterfaceConnectorVersionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'InterfaceConnectorVersion'] or //InterfaceConnectorVersion[@uid = $uidRef]">(InterfaceConnectorVersionRelationship : <sch:value-of select="$uid"/>) The InterfaceConnectorVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type InterfaceConnectorVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='InterfaceConnectorVersionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(InterfaceConnectorVersionRelationship : <sch:value-of select="$uid"/>) The InterfaceConnectorVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceConnectorView"><!--(Ref to E) InterfaceConnectorView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorView') or (self::InterfaceConnectorView and not(@xsi:type)))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(InterfaceConnectorView : <sch:value-of select="$uid"/>) The InterfaceConnectorView.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to S) InterfaceConnectorView.ConnectorOn : OPTIONAL InterfaceDefinitionConnectionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorView') or (self::InterfaceConnectorView and not(@xsi:type)))]/ConnectorOn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)] or //BreakdownElementView[@uid = $uidRef] or //InterfaceConnectorView[@uid = $uidRef] or //PartView[@uid = $uidRef] or //RiskView[@uid = $uidRef] or //SlotDefinition[@uid = $uidRef]">(InterfaceConnectorView : <sch:value-of select="$uid"/>) The InterfaceConnectorView.ConnectorOn contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of InterfaceDefinitionConnectionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) InterfaceConnectorView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorView') or (self::InterfaceConnectorView and not(@xsi:type)))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(InterfaceConnectorView : <sch:value-of select="$uid"/>) The InterfaceConnectorView.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of InterfaceConnectorVersion.Views :: PartProperty) InterfaceConnectorView.ViewOf : InterfaceConnectorVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="InterfaceConnectorViewRelationship"><!--(Ref to E) InterfaceConnectorViewRelationship.Related : InterfaceConnectorView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='InterfaceConnectorViewRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'InterfaceConnectorView'] or //InterfaceConnectorView[@uid = $uidRef]">(InterfaceConnectorViewRelationship : <sch:value-of select="$uid"/>) The InterfaceConnectorViewRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type InterfaceConnectorView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='InterfaceConnectorViewRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(InterfaceConnectorViewRelationship : <sch:value-of select="$uid"/>) The InterfaceConnectorViewRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceDefinitionConnection"><!--(Ref to S) InterfaceDefinitionConnection.Connected : InterfaceDefinitionConnectionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceDefinitionConnection') or (self::InterfaceDefinitionConnection and not(@xsi:type)))]/Connected">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)] or //BreakdownElementView[@uid = $uidRef] or //InterfaceConnectorView[@uid = $uidRef] or //PartView[@uid = $uidRef] or //RiskView[@uid = $uidRef] or //SlotDefinition[@uid = $uidRef]">(InterfaceDefinitionConnection : <sch:value-of select="$uid"/>) The InterfaceDefinitionConnection.Connected contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of InterfaceDefinitionConnectionSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceDefinitionFor"><!--(Ref to E) InterfaceDefinitionFor.Interface : InterfaceSpecificationView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceDefinitionFor') or (self::AssociationObject and substring-after(@xsi:type,':')='InterfaceDefinitionFor'))]/Interface">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'InterfaceSpecificationView'] or //InterfaceSpecificationView[@uid = $uidRef]">(InterfaceDefinitionFor : <sch:value-of select="$uid"/>) The InterfaceDefinitionFor.Interface contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type InterfaceSpecificationView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) InterfaceDefinitionFor.InterfaceComponent : InterfaceDefinitionForSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceDefinitionFor') or (self::AssociationObject and substring-after(@xsi:type,':')='InterfaceDefinitionFor'))]/InterfaceComponent">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnection  HierarchicalInterfaceConnection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceDefinitionConnection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)] or //CollectionView[@uid = $uidRef] or //InterfaceConnection[@uid = $uidRef] or //InterfaceConnectorOccurrence[@uid = $uidRef] or //InterfaceConnectorView[@uid = $uidRef] or //InterfaceDefinitionConnection[@uid = $uidRef] or //InterfaceSpecificationView[@uid = $uidRef] or //PartView[@uid = $uidRef] or //RiskView[@uid = $uidRef] or //SlotDefinition[@uid = $uidRef]">(InterfaceDefinitionFor : <sch:value-of select="$uid"/>) The InterfaceDefinitionFor.InterfaceComponent contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of InterfaceDefinitionForSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceSpecification"/>
   <sch:pattern id="InterfaceSpecificationRelationship"><!--(Ref to E) InterfaceSpecificationRelationship.Related : InterfaceSpecification (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceSpecificationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='InterfaceSpecificationRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'InterfaceSpecification'] or //InterfaceSpecification[@uid = $uidRef]">(InterfaceSpecificationRelationship : <sch:value-of select="$uid"/>) The InterfaceSpecificationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type InterfaceSpecification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceSpecificationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='InterfaceSpecificationRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(InterfaceSpecificationRelationship : <sch:value-of select="$uid"/>) The InterfaceSpecificationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceSpecificationVersion"><!--(Inverse of InterfaceSpecification.Versions :: PartProperty) InterfaceSpecificationVersion.VersionOf : InterfaceSpecification) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="InterfaceSpecificationVersionRelationship"><!--(Ref to E) InterfaceSpecificationVersionRelationship.Related : InterfaceSpecificationVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceSpecificationVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='InterfaceSpecificationVersionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'InterfaceSpecificationVersion'] or //InterfaceSpecificationVersion[@uid = $uidRef]">(InterfaceSpecificationVersionRelationship : <sch:value-of select="$uid"/>) The InterfaceSpecificationVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type InterfaceSpecificationVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceSpecificationVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='InterfaceSpecificationVersionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(InterfaceSpecificationVersionRelationship : <sch:value-of select="$uid"/>) The InterfaceSpecificationVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceSpecificationView"><!--(Ref to E) InterfaceSpecificationView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceSpecificationView') or (self::InterfaceSpecificationView and not(@xsi:type)))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(InterfaceSpecificationView : <sch:value-of select="$uid"/>) The InterfaceSpecificationView.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) InterfaceSpecificationView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceSpecificationView') or (self::InterfaceSpecificationView and not(@xsi:type)))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(InterfaceSpecificationView : <sch:value-of select="$uid"/>) The InterfaceSpecificationView.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of InterfaceSpecificationVersion.Views :: PartProperty) InterfaceSpecificationView.ViewOf : InterfaceSpecificationVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="InterfaceSpecificationViewRelationship"><!--(Ref to E) InterfaceSpecificationViewRelationship.Related : InterfaceSpecificationView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceSpecificationViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='InterfaceSpecificationViewRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'InterfaceSpecificationView'] or //InterfaceSpecificationView[@uid = $uidRef]">(InterfaceSpecificationViewRelationship : <sch:value-of select="$uid"/>) The InterfaceSpecificationViewRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type InterfaceSpecificationView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceSpecificationViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='InterfaceSpecificationViewRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(InterfaceSpecificationViewRelationship : <sch:value-of select="$uid"/>) The InterfaceSpecificationViewRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ItemAssumed"><!--(Ref to E) ItemAssumed.Assumption : Assumption (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ItemAssumed') or (self::AssociationObject and substring-after(@xsi:type,':')='ItemAssumed'))]/Assumption">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Assumption'] or //Assumption[@uid = $uidRef]">(ItemAssumed : <sch:value-of select="$uid"/>) The ItemAssumed.Assumption contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Assumption.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ItemAssumed.Item : AssumedItemSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ItemAssumed') or (self::AssociationObject and substring-after(@xsi:type,':')='ItemAssumed'))]/Item">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment  RiskEvent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Analysis ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AnalysisVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRealization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Collection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionMembership ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvironmentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvironmentDefinitionVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvironmentDefinitionView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Location ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' LocationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservedEnvironment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservedEnvironmentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservedEnvironmentView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewToIndividualPartViewAssociation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceEvent  DecreasingResourceEvent  IncreasingResourceEvent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItem ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Risk ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskImpactAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskPerceptionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Slot ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' System ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElementAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrder ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)] or //Activity[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' ActivityAssignment ',substring-after(@xsi:type,':'))] or //AssignmentObject[@uid = $uidRef and contains(' ActivityMethodAssignment  RiskEvent ',substring-after(@xsi:type,':'))] or //Analysis[@uid = $uidRef] or //AnalysisVersion[@uid = $uidRef] or //Approval[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' ApprovalAssignment ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',substring-after(@xsi:type,':'))] or //Breakdown[@uid = $uidRef] or //BreakdownElement[@uid = $uidRef] or //AssociationObject[@uid = $uidRef and contains(' BreakdownElementRealization ',substring-after(@xsi:type,':'))] or //BreakdownElementVersion[@uid = $uidRef] or //BreakdownElementView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',substring-after(@xsi:type,':'))] or //BreakdownVersion[@uid = $uidRef] or //Collection[@uid = $uidRef] or //AssociationObject[@uid = $uidRef and contains(' CollectionMembership ',substring-after(@xsi:type,':'))] or //CollectionVersion[@uid = $uidRef] or //CollectionView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' CollectionViewRelationship ',substring-after(@xsi:type,':'))] or //Contract[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' ContractAssignment ',substring-after(@xsi:type,':'))] or //Document[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //DocumentVersion[@uid = $uidRef] or //Environment[@uid = $uidRef and contains(' EnvironmentDefinition ',substring-after(@xsi:type,':'))] or //EnvironmentVersion[@uid = $uidRef and contains(' EnvironmentDefinitionVersion ',substring-after(@xsi:type,':'))] or //EnvironmentView[@uid = $uidRef and contains(' EnvironmentDefinitionView ',substring-after(@xsi:type,':'))] or //IndividualPart[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //IndividualPartView[@uid = $uidRef] or //InterfaceConnector[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',substring-after(@xsi:type,':'))] or //InterfaceConnectorVersion[@uid = $uidRef] or //InterfaceConnectorView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',substring-after(@xsi:type,':'))] or //InterfaceSpecification[@uid = $uidRef] or //InterfaceSpecificationVersion[@uid = $uidRef] or //InterfaceSpecificationView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',substring-after(@xsi:type,':'))] or //Location[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' LocationAssignment ',substring-after(@xsi:type,':'))] or //Environment[@uid = $uidRef and contains(' ObservedEnvironment ',substring-after(@xsi:type,':'))] or //EnvironmentVersion[@uid = $uidRef and contains(' ObservedEnvironmentVersion ',substring-after(@xsi:type,':'))] or //EnvironmentView[@uid = $uidRef and contains(' ObservedEnvironmentView ',substring-after(@xsi:type,':'))] or //Occurrence[@uid = $uidRef] or //Part[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //AssociationObject[@uid = $uidRef and contains(' PartViewToIndividualPartViewAssociation ',substring-after(@xsi:type,':'))] or //ProductConcept[@uid = $uidRef] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' ProjectAssignment ',substring-after(@xsi:type,':'))] or //Requirement[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' RequirementAssignment ',substring-after(@xsi:type,':'))] or //RequirementVersion[@uid = $uidRef] or //RequirementView[@uid = $uidRef] or //ResourceEvent[@uid = $uidRef] or //ResourceItem[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' ResourceItemAssignment ',substring-after(@xsi:type,':'))] or //Risk[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' RiskImpactAssignment ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' RiskPerceptionRelationship ',substring-after(@xsi:type,':'))] or //RiskVersion[@uid = $uidRef] or //Slot[@uid = $uidRef] or //SlotDefinition[@uid = $uidRef] or //SlotVersion[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' StateAssignment ',substring-after(@xsi:type,':'))] or //System[@uid = $uidRef] or //SystemVersion[@uid = $uidRef] or //SystemView[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' TaskElementAssignment ',substring-after(@xsi:type,':'))] or //AssignmentObject[@uid = $uidRef and contains(' TaskMethodAssignment ',substring-after(@xsi:type,':'))] or //AssignmentObject[@uid = $uidRef and contains(' TaskMethodVersionAssignment ',substring-after(@xsi:type,':'))] or //WorkOrder[@uid = $uidRef] or //WorkRequest[@uid = $uidRef]">(ItemAssumed : <sch:value-of select="$uid"/>) The ItemAssumed.Item contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AssumedItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ItemInSlot"><!--(Ref to S) ItemInSlot.AssociationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ItemInSlot') or (self::AssociationObject and substring-after(@xsi:type,':')='ItemInSlot'))]/AssociationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ItemInSlot : <sch:value-of select="$uid"/>) The ItemInSlot.AssociationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ItemInSlot.Item : ItemInSlotSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ItemInSlot') or (self::AssociationObject and substring-after(@xsi:type,':')='ItemInSlot'))]/Item">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvironmentDefinitionView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)] or //BreakdownElementView[@uid = $uidRef] or //CollectionView[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //EnvironmentView[@uid = $uidRef and contains(' EnvironmentDefinitionView ',substring-after(@xsi:type,':'))] or //IndividualPartView[@uid = $uidRef] or //InterfaceConnectorView[@uid = $uidRef] or //InterfaceSpecificationView[@uid = $uidRef] or //PartView[@uid = $uidRef] or //RequirementView[@uid = $uidRef] or //SlotDefinition[@uid = $uidRef]">(ItemInSlot : <sch:value-of select="$uid"/>) The ItemInSlot.Item contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ItemInSlotSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Justification"/>
   <sch:pattern id="JustificationAssignment"><!--(Ref to E) JustificationAssignment.AssignedJustification : Justification (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='JustificationAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='JustificationAssignment'))]/AssignedJustification">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Justification'] or //Justification[@uid = $uidRef]">(JustificationAssignment : <sch:value-of select="$uid"/>) The JustificationAssignment.AssignedJustification contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Justification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='JustificationAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='JustificationAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(JustificationAssignment : <sch:value-of select="$uid"/>) The JustificationAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="JustificationRelationship"><!--(Ref to E) JustificationRelationship.Related : Justification (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='JustificationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='JustificationRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Justification'] or //Justification[@uid = $uidRef]">(JustificationRelationship : <sch:value-of select="$uid"/>) The JustificationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Justification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='JustificationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='JustificationRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(JustificationRelationship : <sch:value-of select="$uid"/>) The JustificationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="JustificationSupportAssignment"><!--(Ref to S) JustificationSupportAssignment.AssignedSupportItem : JustificationSupportAssignmentSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='JustificationSupportAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='JustificationSupportAssignment'))]/AssignedSupportItem">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment  RiskEvent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Analysis ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AnalysisAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AnalysisVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Assumption ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssumptionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssumptionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Certification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Collection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionMembershipRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersionRelationship  CollectionVersionSequenceRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvironmentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvironmentDefinitionVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvironmentDefinitionView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Event  RelativeEvent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Evidence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnection  HierarchicalInterfaceConnection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceDefinitionConnection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Location ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' LocationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Message ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservedEnvironment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservedEnvironmentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservedEnvironmentView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Risk ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskImpactAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Slot ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' State  StateObserved  StatePredicted ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionRelationship  StateDefinitionCauseEffect  StateDefinitionComposition  StateDefinitionTransition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateRelationship  StateCauseEffect  StateComposition  StatePredictedToObserved  StateTransition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' System ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElementAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Validation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Verification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrder ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)] or //Activity[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' ActivityAssignment ',substring-after(@xsi:type,':'))] or //ActivityMethod[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' ActivityMethodAssignment  RiskEvent ',substring-after(@xsi:type,':'))] or //Analysis[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' AnalysisAssignment ',substring-after(@xsi:type,':'))] or //AnalysisVersion[@uid = $uidRef] or //Approval[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',substring-after(@xsi:type,':'))] or //Assumption[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' AssumptionAssignment ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' AssumptionRelationship ',substring-after(@xsi:type,':'))] or //Breakdown[@uid = $uidRef] or //BreakdownElement[@uid = $uidRef] or //BreakdownElementVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',substring-after(@xsi:type,':'))] or //BreakdownElementView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',substring-after(@xsi:type,':'))] or //BreakdownVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' BreakdownVersionRelationship ',substring-after(@xsi:type,':'))] or //Certification[@uid = $uidRef] or //Collection[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' CollectionMembershipRelationship ',substring-after(@xsi:type,':'))] or //CollectionVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' CollectionVersionRelationship  CollectionVersionSequenceRelationship ',substring-after(@xsi:type,':'))] or //CollectionView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' CollectionViewRelationship ',substring-after(@xsi:type,':'))] or //Contract[@uid = $uidRef] or //Document[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',substring-after(@xsi:type,':'))] or //DocumentVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' DocumentVersionRelationship ',substring-after(@xsi:type,':'))] or //Effectivity[@uid = $uidRef] or //Environment[@uid = $uidRef and contains(' EnvironmentDefinition ',substring-after(@xsi:type,':'))] or //EnvironmentVersion[@uid = $uidRef and contains(' EnvironmentDefinitionVersion ',substring-after(@xsi:type,':'))] or //EnvironmentView[@uid = $uidRef and contains(' EnvironmentDefinitionView ',substring-after(@xsi:type,':'))] or //Event[@uid = $uidRef] or //Evidence[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' FileRelationship ',substring-after(@xsi:type,':'))] or //IndividualPart[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',substring-after(@xsi:type,':'))] or //IndividualPartView[@uid = $uidRef] or //InterfaceConnection[@uid = $uidRef] or //InterfaceConnector[@uid = $uidRef] or //InterfaceConnectorOccurrence[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',substring-after(@xsi:type,':'))] or //InterfaceConnectorVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorVersionRelationship ',substring-after(@xsi:type,':'))] or //InterfaceConnectorView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',substring-after(@xsi:type,':'))] or //InterfaceDefinitionConnection[@uid = $uidRef] or //InterfaceSpecification[@uid = $uidRef] or //InterfaceSpecificationVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationVersionRelationship ',substring-after(@xsi:type,':'))] or //InterfaceSpecificationView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',substring-after(@xsi:type,':'))] or //Location[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' LocationAssignment ',substring-after(@xsi:type,':'))] or //Message[@uid = $uidRef] or //Observation[@uid = $uidRef] or //Environment[@uid = $uidRef and contains(' ObservedEnvironment ',substring-after(@xsi:type,':'))] or //EnvironmentVersion[@uid = $uidRef and contains(' ObservedEnvironmentVersion ',substring-after(@xsi:type,':'))] or //EnvironmentView[@uid = $uidRef and contains(' ObservedEnvironmentView ',substring-after(@xsi:type,':'))] or //Occurrence[@uid = $uidRef] or //Part[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' PartVersionRelationship ',substring-after(@xsi:type,':'))] or //AssignmentObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',substring-after(@xsi:type,':'))] or //Project[@uid = $uidRef] or //PropertyDefinition[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',substring-after(@xsi:type,':'))] or //Requirement[@uid = $uidRef] or //RequirementVersion[@uid = $uidRef] or //RequirementView[@uid = $uidRef] or //Risk[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' RiskImpactAssignment ',substring-after(@xsi:type,':'))] or //RiskVersion[@uid = $uidRef] or //Scheme[@uid = $uidRef] or //SchemeEntry[@uid = $uidRef] or //SchemeVersion[@uid = $uidRef] or //Slot[@uid = $uidRef] or //SlotDefinition[@uid = $uidRef] or //SlotVersion[@uid = $uidRef] or //State[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' StateAssignment ',substring-after(@xsi:type,':'))] or //StateDefinition[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' StateDefinitionAssignment ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' StateDefinitionRelationship  StateDefinitionCauseEffect  StateDefinitionComposition  StateDefinitionTransition ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' StateRelationship  StateCauseEffect  StateComposition  StatePredictedToObserved  StateTransition ',substring-after(@xsi:type,':'))] or //System[@uid = $uidRef] or //SystemVersion[@uid = $uidRef] or //TaskElement[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' TaskElementAssignment ',substring-after(@xsi:type,':'))] or //TaskMethod[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' TaskMethodAssignment ',substring-after(@xsi:type,':'))] or //TaskMethodVersion[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' TaskMethodVersionAssignment ',substring-after(@xsi:type,':'))] or //Validation[@uid = $uidRef] or //Verification[@uid = $uidRef] or //WorkOrder[@uid = $uidRef] or //WorkRequest[@uid = $uidRef]">(JustificationSupportAssignment : <sch:value-of select="$uid"/>) The JustificationSupportAssignment.AssignedSupportItem contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of JustificationSupportAssignmentSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='JustificationSupportAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='JustificationSupportAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(JustificationSupportAssignment : <sch:value-of select="$uid"/>) The JustificationSupportAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Language"/>
   <sch:pattern id="LifeCycleStage"><!--(Ref to S) LifeCycleStage.Definition : ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LifeCycleStage') or (self::LifeCycleStage and not(@xsi:type)))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(LifeCycleStage : <sch:value-of select="$uid"/>) The LifeCycleStage.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="LocalizedString"/>
   <sch:pattern id="Location"/>
   <sch:pattern id="LocationAssignment"><!--(Ref to E) LocationAssignment.AssignedLocation : Location (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LocationAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='LocationAssignment'))]/AssignedLocation">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Location'] or //Location[@uid = $uidRef]">(LocationAssignment : <sch:value-of select="$uid"/>) The LocationAssignment.AssignedLocation contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Location.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LocationAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='LocationAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(LocationAssignment : <sch:value-of select="$uid"/>) The LocationAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="LocationRelationship"><!--(Ref to E) LocationRelationship.Related : Location (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LocationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='LocationRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Location'] or //Location[@uid = $uidRef]">(LocationRelationship : <sch:value-of select="$uid"/>) The LocationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Location.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LocationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='LocationRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(LocationRelationship : <sch:value-of select="$uid"/>) The LocationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="LocatorAssignment"><!--(Ref to E) LocatorAssignment.AssignedLocator : Locator (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LocatorAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='LocatorAssignment'))]/AssignedLocator">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Locator'] or //Locator[@uid = $uidRef] or //*[@uid = $uidRef and (self::Location)]">(LocatorAssignment : <sch:value-of select="$uid"/>) The LocatorAssignment.AssignedLocator contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Locator.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LocatorAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='LocatorAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(LocatorAssignment : <sch:value-of select="$uid"/>) The LocatorAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="LocatorRelationship"><!--(Ref to E) LocatorRelationship.Related : Locator (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LocatorRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='LocatorRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Locator'] or //Locator[@uid = $uidRef] or //*[@uid = $uidRef and (self::Location)]">(LocatorRelationship : <sch:value-of select="$uid"/>) The LocatorRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Locator.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LocatorRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='LocatorRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(LocatorRelationship : <sch:value-of select="$uid"/>) The LocatorRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="LoopingElement"/>
   <sch:pattern id="LotEffectivity"><!--(Ref to E) Effectivity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LotEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='LotEffectivity'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(LotEffectivity : <sch:value-of select="$uid"/>) The LotEffectivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Effectivity.EffectivityContext : OPTIONAL EffectivityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LotEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='LotEffectivity'))]/EffectivityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //Activity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef]">(LotEffectivity : <sch:value-of select="$uid"/>) The LotEffectivity.EffectivityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EffectivityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ManagedResource"><!--(Ref to S) ManagedResource.Item : ResourceItemSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ManagedResource') or (self::ManagedResource and not(@xsi:type)))]/Item">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItem ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionType ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductGroup ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeOfPerson ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)] or //BreakdownElementVersion[@uid = $uidRef] or //BreakdownElementView[@uid = $uidRef] or //BreakdownVersion[@uid = $uidRef] or //Document[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //DocumentVersion[@uid = $uidRef] or //Organization[@uid = $uidRef] or //ResourceItem[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //InterfaceConnector[@uid = $uidRef] or //InterfaceConnectorVersion[@uid = $uidRef] or //InterfaceConnectorView[@uid = $uidRef] or //InterfaceSpecification[@uid = $uidRef] or //InterfaceSpecificationVersion[@uid = $uidRef] or //InterfaceSpecificationView[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //PositionType[@uid = $uidRef] or //ProductGroup[@uid = $uidRef] or //RiskVersion[@uid = $uidRef] or //TypeOfPerson[@uid = $uidRef] or //SystemVersion[@uid = $uidRef]">(ManagedResource : <sch:value-of select="$uid"/>) The ManagedResource.Item contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ResourceItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ManagedResourceRelationship"><!--(Ref to E) ManagedResourceRelationship.Related : ManagedResource (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ManagedResourceRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ManagedResourceRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ManagedResource'] or //ManagedResource[@uid = $uidRef]">(ManagedResourceRelationship : <sch:value-of select="$uid"/>) The ManagedResourceRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ManagedResource.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ManagedResourceRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ManagedResourceRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ManagedResourceRelationship : <sch:value-of select="$uid"/>) The ManagedResourceRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Market"><!--(Ref to S) Market.MarketSegmentType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Market') or (self::Market and not(@xsi:type)))]/MarketSegmentType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Market : <sch:value-of select="$uid"/>) The Market.MarketSegmentType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="MeasureQualification"><!--(Ref to S) MeasureQualification.Qualifiers : SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MeasureQualification') or (self::MeasureQualification and not(@xsi:type)))]/Qualifiers/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::TypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::TypeQualifier and //TypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(MeasureQualification : <sch:value-of select="$uid"/>) The MeasureQualification.Qualifiers contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Message"><!--(Ref to S) Message.Contains : OPTIONAL SET[1:unbounded] OF MessageContentSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Message') or (self::Message and not(@xsi:type)))]/Contains/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::Acknowledgement or (self::Acknowledge and contains(' Acknowledgement ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Acknowledgement ',@typeRef)]) or (self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::AddressComponent and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressComponent ',@typeRef)]) or (self::AdvisoryNote and //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvisoryNote ',@typeRef)]) or (self::Analysis and //ExternalRefBaseObject[@uid = $uidRef and contains(' Analysis ',@typeRef)]) or (self::AnalysisDisciplineDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' AnalysisDisciplineDefinition ',@typeRef)]) or (self::AnalysisModelObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' AnalysisModelObject  AnalysisModel  ExternalAnalysisModel ',@typeRef)]) or (self::AnalysisRepresentationContext and //ExternalRefBaseObject[@uid = $uidRef and contains(' AnalysisRepresentationContext ',@typeRef)]) or (self::AnalysisVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' AnalysisVersion ',@typeRef)]) or (self::ApplicationDomain and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApplicationDomain ',@typeRef)]) or (self::Approval and //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)]) or (self::AssignmentObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssignmentObject  ActivityAssignment  ActivityMethodAssignment  RiskEvent  AddressAssignment  AnalysisAssignment  ApprovalAssignment  AssumptionAssignment  CertificationAssignment  CollectionAssignment  ConditionAssignment  ConditionEvaluationAssignment  ContractAssignment  DateTimeAssignment  DocumentAssignment  PartialDocumentAssignment  EffectivityAssignment  EnvironmentAssignment  EventAssignment  InformationUsageRightAssignment  JustificationAssignment  JustificationSupportAssignment  LocationAssignment  LocatorAssignment  ObservationAssignment  ObservedEnvironmentAssignment  PersonOrganizationAssignment  PositionAssignment  PositionGroupAssignment  PositionTypeAssignment  ProjectAssignment  PropertyDefinitionAssignment  PropertyValueAssignment  QualificationAssignment  RequiredResourceAssignment  RequirementAssignment  ResourceAsRealizedAssignment  ResourceItemAssignment  RiskImpactAssignment  RiskPerceptionSourceAssignment  SchemeEntryAssignment  SchemeSubjectAssignment  SchemeVersionAssignment  SecurityClassificationAssignment  SpecificationAssignment  SpecificationCategoryAssignment  SpecificationConditionAssignment  SpecificationInclusionAssignment  StateAssignment  StateDefinitionAssignment  TaskElementAssignment  TaskMethodAssignment  TaskMethodVersionAssignment  TimeIntervalAssignment  TypeOfPersonAssignment  WorkOrderAssignment  WorkRequestAssignment ',@typeRef)]) or (self::AssociationObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssociationObject  ActivityMethodRealization  BreakdownElementRealization  BreakdownMember  BreakdownOf  CollectionMembership  InZone  InterfaceConnectionToDefinitionAssociation  InterfaceDefinitionFor  ItemAssumed  ItemInSlot  ObservationConsequence  ObservedEnvironmentToDefinition  ObservedEnvironmentToDefinitionVersion  ObservedEnvironmentToDefinitionView  OrganizationOrganizationTypeAssociation  PartToIndividualPartAssociation  PartVersionToIndividualPartVersionAssociation  PartViewToIndividualPartViewAssociation  PositionGroupAssociation  PositionPositionTypeAssociation  ProductDesignAssociation  ProductGroupMembership  RelatedConditionParameter  ResourceAsRealizedAssociation  ResourceEventCorrespondenceAssociation  ResourceItemRealization  SlotOn  StateDefinitionStateAssociation  StateDefinitionConfirmedAssociation  StateDefinitionHypothesisAssociation  StateDefinitionPredictedAssociation  TaskElementStateAssociation  TaskMethodStateAssociation  TaskObjectiveStateAssociation  TypeOfPersonDefinitionRequiredAttributesAssociation ',@typeRef)]) or (self::Assumption and //ExternalRefBaseObject[@uid = $uidRef and contains(' Assumption ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::CartesianTransformation and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)]) or (self::Certification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Certification ',@typeRef)]) or (self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ClassAttribute and //ExternalRefBaseObject[@uid = $uidRef and contains(' ClassAttribute ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (self::Collection and //ExternalRefBaseObject[@uid = $uidRef and contains(' Collection ',@typeRef)]) or (self::CollectionVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)]) or (self::CollectionView and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)]) or (self::ComponentPlacement and //ExternalRefBaseObject[@uid = $uidRef and contains(' ComponentPlacement ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Condition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition ',@typeRef)]) or (*[(self::ConditionEvaluation or (self::ConditionEvaluation and contains(' ConditionEvaluation ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionEvaluation ',@typeRef)]) or (self::ConditionEvaluationParameter and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionEvaluationParameter ',@typeRef)]) or (self::ConditionParameter and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionParameter ',@typeRef)]) or (self::ConfiguredAssemblyEffectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConfiguredAssemblyEffectivity ',@typeRef)]) or (self::Contract and //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)]) or (self::Descriptor and //ExternalRefBaseObject[@uid = $uidRef and contains(' Descriptor ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity ',@typeRef)]) or (self::Envelope and //ExternalRefBaseObject[@uid = $uidRef and contains(' Envelope ',@typeRef)]) or (self::Environment and //ExternalRefBaseObject[@uid = $uidRef and contains(' Environment  EnvironmentDefinition  ObservedEnvironment ',@typeRef)]) or (self::EnvironmentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvironmentVersion  EnvironmentDefinitionVersion  ObservedEnvironmentVersion ',@typeRef)]) or (*[(self::EnvironmentView or (self::AssignedEnvironment and contains(' EnvironmentView  EnvironmentDefinitionView  ObservedEnvironmentView ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvironmentView  EnvironmentDefinitionView  ObservedEnvironmentView ',@typeRef)]) or (self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event  RelativeEvent ',@typeRef)]) or (self::Evidence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Evidence ',@typeRef)]) or (*[(self::ExchangeContext or (self::ExchangeContext and contains(' ExchangeContext ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExchangeContext ',@typeRef)]) or (self::ExperienceGained and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExperienceGained ',@typeRef)]) or (self::ExperienceInstance and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExperienceInstance ',@typeRef)]) or (self::ExperienceType and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExperienceType ',@typeRef)]) or (*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem ',@typeRef)]) or (self::ExternalLibrary and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalLibrary ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalUnit and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)]) or (self::File and //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)]) or (self::FunctionValuePair and //ExternalRefBaseObject[@uid = $uidRef and contains(' FunctionValuePair ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::InformationRight and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationRight ',@typeRef)]) or (self::InformationUsageRight and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRight ',@typeRef)]) or (self::InterfaceConnection and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnection  HierarchicalInterfaceConnection ',@typeRef)]) or (self::InterfaceConnector and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)]) or (self::InterfaceConnectorOccurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)]) or (self::InterfaceConnectorVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)]) or (self::InterfaceConnectorView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)]) or (self::InterfaceDefinitionConnection and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceDefinitionConnection ',@typeRef)]) or (self::InterfaceSpecification and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)]) or (self::InterfaceSpecificationVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)]) or (self::InterfaceSpecificationView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)]) or (self::Justification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Justification ',@typeRef)]) or (*[(self::Language or (self::Language and contains(' Language ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Language ',@typeRef)]) or (self::LifeCycleStage and //ExternalRefBaseObject[@uid = $uidRef and contains(' LifeCycleStage ',@typeRef)]) or (self::Location and //ExternalRefBaseObject[@uid = $uidRef and contains(' Location ',@typeRef)]) or (*[(self::Locator or (self::Location and contains(' Locator  Address  CompoundAddress  GeographicalArea  GlobalPositionLocation  ProductBasedLocator  RegionalGrid ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Locator  Address  CompoundAddress  GeographicalArea  GlobalPositionLocation  ProductBasedLocator  RegionalGrid ',@typeRef)]) or (self::ManagedResource and //ExternalRefBaseObject[@uid = $uidRef and contains(' ManagedResource ',@typeRef)]) or (self::Market and //ExternalRefBaseObject[@uid = $uidRef and contains(' Market ',@typeRef)]) or (self::MeasureQualification and //ExternalRefBaseObject[@uid = $uidRef and contains(' MeasureQualification ',@typeRef)]) or (self::Message and //ExternalRefBaseObject[@uid = $uidRef and contains(' Message ',@typeRef)]) or (self::NumericalContext and //ExternalRefBaseObject[@uid = $uidRef and contains(' NumericalContext ',@typeRef)]) or (self::Observation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)]) or (self::Occurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)]) or (self::OccurrencePlacement and //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrencePlacement ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationType and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationType ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)]) or (self::Person and //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::PersonName and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonName ',@typeRef)]) or (self::PersonNameComponent and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonNameComponent ',@typeRef)]) or (self::PersonNameSet and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonNameSet ',@typeRef)]) or (self::PersonOrganizationInPosition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonOrganizationInPosition ',@typeRef)]) or (self::PositionGroup and //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionGroup ',@typeRef)]) or (self::PositionType and //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionType ',@typeRef)]) or (self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::ProductConcept and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)]) or (self::Project and //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)]) or (self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (self::QualificationType and //ExternalRefBaseObject[@uid = $uidRef and contains(' QualificationType ',@typeRef)]) or (self::RelationshipObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' RelationshipObject  ActivityMethodRelationship  ActivityRelationship  ActivityHappeningRelationship  AnalysisVersionRelationship  ApprovalRelationship  AssemblyOccurrenceRelationshipSubstitution  AssemblyViewRelationshipSubstitution  AssignmentObjectRelationship  AssumptionRelationship  BreakdownElementRelationship  BreakdownElementVersionRelationship  BreakdownElementViewRelationship  BreakdownElementHierarchy  BreakdownRelationship  BreakdownVersionRelationship  CausalConsequence  ClassificationRelationship  CollectionMembershipRelationship  CollectionRelationship  CollectionVersionRelationship  CollectionVersionSequenceRelationship  CollectionViewRelationship  ConditionEvaluationRelationship  ConditionRelationship  ContractRelationship  DescriptorRelationship  DocumentDefinitionRelationship  DocumentRelationship  DocumentVersionRelationship  EffectivityRelationship  EnvelopeRelationship  EnvironmentDefinitionViewRelationship  EventRelationship  ExperienceTypeRelationship  FileRelationship  IdentifierRelationship  IndividualAssemblyRelationship  IndividualPartRelationship  IndividualPartVersionRelationship  ProductPlannedToRealized  IndividualPartViewRelationship  InformationUsageRightRelationship  InterfaceConnectorOccurrenceRelationship  InterfaceConnectorRelationship  InterfaceConnectorVersionRelationship  InterfaceConnectorViewRelationship  InterfaceSpecificationRelationship  InterfaceSpecificationVersionRelationship  InterfaceSpecificationViewRelationship  JustificationRelationship  LocationRelationship  LocatorRelationship  ManagedResourceRelationship  MessageRelationship  ObservationRelationship  ObservedEnvironmentViewRelationship  OccurrenceRelationship  ReplacedUsageRelationship  OrganizationRelationship  PartRelationship  AlternatePartRelationship  PartVersionRelationship  PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship  PersonInOrganizationRelationship  PersonOrganizationInPositionRelationship  PositionRelationship  ProductClassRelationship  ProductConfigurationRelationship  ProductGroupRelationship  ProjectRelationship  PropertyDefinitionAssignmentRelationship  PropertyDefinitionRelationship  PropertyValueAssignmentRelationship  PropertyValueRelationship  ProxyRelationship  QualificationTypeRelationship  RelatedConsequence  RepresentationRelationship  GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace  RequiredResourceRelationship  RequirementRelationship  RequirementVersionRelationship  RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship  ResourceEventRelationship  ResourceItemRelationship  ResourceGroupRelationship  RiskPerceptionRelationship  RiskRelationship  SchemeEntryRelationship  SequencingRelationship  SchemeRelationship  SchemeVersionRelationship  SlotDefinitionRelationship  SlotDesignToPlanned  SlotDesignToRealized  SlotPlannedToRealized  StateDefinitionRelationship  StateDefinitionCauseEffect  StateDefinitionComposition  StateDefinitionTransition  StateDefinitionStateAssociationRelationship  StateHypothesisToConfirmationRelationship  StateRelationship  StateCauseEffect  StateComposition  StatePredictedToObserved  StateTransition  SuppliedObjectRelationship  SystemVersionRelationship  SystemViewRelationship  TaskElementRelationship  TaskMethodRelationship  TaskMethodVersionRelationship  TimeIntervalRelationship  TypeOfPersonDefinitionRelationship  VerificationRelationship  ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship  WorkOrderRelationship  WorkRequestRelationship ',@typeRef)]) or (self::Representation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',@typeRef)]) or (self::RepresentationContext and //ExternalRefBaseObject[@uid = $uidRef and contains(' RepresentationContext  GeometricCoordinateSpace ',@typeRef)]) or (self::RepresentationItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' RepresentationItem  DetailedGeometricModelItem  AxisPlacement  Direction  Point  CartesianPoint  ExternalRepresentationItem ',@typeRef)]) or (self::RequiredResource and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequiredResource ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementSatisfactionAssertion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementSatisfactionAssertion ',@typeRef)]) or (self::RequirementSource and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementSource ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::ResourceAsRealized and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealized ',@typeRef)]) or (self::ResourceEvent and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceEvent  DecreasingResourceEvent  IncreasingResourceEvent ',@typeRef)]) or (self::ResourceItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItem ',@typeRef)]) or (self::RetentionPeriod and //ExternalRefBaseObject[@uid = $uidRef and contains(' RetentionPeriod ',@typeRef)]) or (self::Risk and //ExternalRefBaseObject[@uid = $uidRef and contains(' Risk ',@typeRef)]) or (self::RiskVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)]) or (self::RiskView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)]) or (self::Scheme and //ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)]) or (self::SchemeEntry and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)]) or (self::SchemeVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)]) or (self::SecurityClassification and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassification ',@typeRef)]) or (self::SetMembership and //ExternalRefBaseObject[@uid = $uidRef and contains(' SetMembership ',@typeRef)]) or (self::SimplePersonName and //ExternalRefBaseObject[@uid = $uidRef and contains(' SimplePersonName ',@typeRef)]) or (self::Slot and //ExternalRefBaseObject[@uid = $uidRef and contains(' Slot ',@typeRef)]) or (self::SlotDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)]) or (*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationCategory and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategory ',@typeRef)]) or (self::SpecificationCategoryHierarchy and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryHierarchy ',@typeRef)]) or (*[(self::SpecificationInclusion or (self::AssignedInclusion and contains(' SpecificationInclusion ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusion ',@typeRef)]) or (self::State and //ExternalRefBaseObject[@uid = $uidRef and contains(' State  StateObserved  StatePredicted ',@typeRef)]) or (self::StateDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinition ',@typeRef)]) or (self::SubsetMember and //ExternalRefBaseObject[@uid = $uidRef and contains(' SubsetMember ',@typeRef)]) or (self::System and //ExternalRefBaseObject[@uid = $uidRef and contains(' System ',@typeRef)]) or (self::SystemVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)]) or (self::SystemView and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemView ',@typeRef)]) or (*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)]) or (self::TaskMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)]) or (self::TaskMethodVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)]) or (self::TaskObjective and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskObjective ',@typeRef)]) or (*[(self::TimeInterval or (self::AssignedTimeInterval and contains(' TimeInterval  TimeIntervalWithBounds ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeInterval  TimeIntervalWithBounds ',@typeRef)]) or (self::TypeOfPerson and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeOfPerson ',@typeRef)]) or (self::TypeOfPersonDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeOfPersonDefinition ',@typeRef)]) or (self::TypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::Unit and //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)]) or (self::Validation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Validation ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::Verification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Verification ',@typeRef)]) or (self::ViewContext and //ExternalRefBaseObject[@uid = $uidRef and contains(' ViewContext ',@typeRef)]) or (self::WorkOrder and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrder ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::Acknowledgement and //*[(self::Acknowledgement or (self::Acknowledge and contains(' Acknowledgement ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::AddressComponent and //AddressComponent[@uid = $uidRef]) or (self::AdvisoryNote and //AdvisoryNote[@uid = $uidRef]) or (self::Analysis and //Analysis[@uid = $uidRef]) or (self::AnalysisDisciplineDefinition and //AnalysisDisciplineDefinition[@uid = $uidRef]) or (self::AnalysisModelObject and //AnalysisModelObject[@uid = $uidRef]) or (self::AnalysisRepresentationContext and //AnalysisRepresentationContext[@uid = $uidRef]) or (self::AnalysisVersion and //AnalysisVersion[@uid = $uidRef]) or (self::ApplicationDomain and //ApplicationDomain[@uid = $uidRef]) or (self::Approval and //Approval[@uid = $uidRef]) or (self::AssignmentObject and //AssignmentObject[@uid = $uidRef]) or (self::AssociationObject and //AssociationObject[@uid = $uidRef]) or (self::Assumption and //Assumption[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::CartesianTransformation and //CartesianTransformation[@uid = $uidRef]) or (self::Certification and //Certification[@uid = $uidRef]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassAttribute and //ClassAttribute[@uid = $uidRef]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::Collection and //Collection[@uid = $uidRef]) or (self::CollectionVersion and //CollectionVersion[@uid = $uidRef]) or (self::CollectionView and //CollectionView[@uid = $uidRef]) or (self::ComponentPlacement and //ComponentPlacement[@uid = $uidRef]) or (self::Condition and //*[(self::Condition or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Condition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ConditionEvaluation and //*[(self::ConditionEvaluation or (self::ConditionEvaluation and contains(' ConditionEvaluation ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ConditionEvaluationParameter and //ConditionEvaluationParameter[@uid = $uidRef]) or (self::ConditionParameter and //ConditionParameter[@uid = $uidRef]) or (self::ConfiguredAssemblyEffectivity and //ConfiguredAssemblyEffectivity[@uid = $uidRef]) or (self::Contract and //Contract[@uid = $uidRef]) or (self::Descriptor and //Descriptor[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::Envelope and //Envelope[@uid = $uidRef]) or (self::Environment and //Environment[@uid = $uidRef]) or (self::EnvironmentVersion and //EnvironmentVersion[@uid = $uidRef]) or (self::EnvironmentView and //*[(self::EnvironmentView or (self::AssignedEnvironment and contains(' EnvironmentView  EnvironmentDefinitionView  ObservedEnvironmentView ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Event and //Event[@uid = $uidRef]) or (self::Evidence and //Evidence[@uid = $uidRef]) or (self::ExchangeContext and //*[(self::ExchangeContext or (self::ExchangeContext and contains(' ExchangeContext ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExperienceGained and //ExperienceGained[@uid = $uidRef]) or (self::ExperienceInstance and //ExperienceInstance[@uid = $uidRef]) or (self::ExperienceType and //ExperienceType[@uid = $uidRef]) or (self::ExternalItem and //*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalLibrary and //ExternalLibrary[@uid = $uidRef]) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ExternalUnit and //ExternalUnit[@uid = $uidRef]) or (self::File and //File[@uid = $uidRef]) or (self::FunctionValuePair and //FunctionValuePair[@uid = $uidRef]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::InformationRight and //InformationRight[@uid = $uidRef]) or (self::InformationUsageRight and //InformationUsageRight[@uid = $uidRef]) or (self::InterfaceConnection and //InterfaceConnection[@uid = $uidRef]) or (self::InterfaceConnector and //InterfaceConnector[@uid = $uidRef]) or (self::InterfaceConnectorOccurrence and //InterfaceConnectorOccurrence[@uid = $uidRef]) or (self::InterfaceConnectorVersion and //InterfaceConnectorVersion[@uid = $uidRef]) or (self::InterfaceConnectorView and //InterfaceConnectorView[@uid = $uidRef]) or (self::InterfaceDefinitionConnection and //InterfaceDefinitionConnection[@uid = $uidRef]) or (self::InterfaceSpecification and //InterfaceSpecification[@uid = $uidRef]) or (self::InterfaceSpecificationVersion and //InterfaceSpecificationVersion[@uid = $uidRef]) or (self::InterfaceSpecificationView and //InterfaceSpecificationView[@uid = $uidRef]) or (self::Justification and //Justification[@uid = $uidRef]) or (self::Language and //*[(self::Language or (self::Language and contains(' Language ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::LifeCycleStage and //LifeCycleStage[@uid = $uidRef]) or (self::LocalizedString) or (self::Location and //Location[@uid = $uidRef]) or (self::Locator and //*[(self::Locator or (self::Location and contains(' Locator  Address  CompoundAddress  GeographicalArea  GlobalPositionLocation  ProductBasedLocator  RegionalGrid ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ManagedResource and //ManagedResource[@uid = $uidRef]) or (self::Market and //Market[@uid = $uidRef]) or (self::MeasureQualification and //MeasureQualification[@uid = $uidRef]) or (self::Message and //Message[@uid = $uidRef]) or (self::NumericalContext and //NumericalContext[@uid = $uidRef]) or (self::Observation and //Observation[@uid = $uidRef]) or (self::Occurrence and //Occurrence[@uid = $uidRef]) or (self::OccurrencePlacement and //OccurrencePlacement[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationType and //OrganizationType[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::Person and //Person[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef]) or (self::PersonName and //PersonName[@uid = $uidRef]) or (self::PersonNameComponent and //PersonNameComponent[@uid = $uidRef]) or (self::PersonNameSet and //PersonNameSet[@uid = $uidRef]) or (self::PersonOrganizationInPosition and //PersonOrganizationInPosition[@uid = $uidRef]) or (self::PositionGroup and //PositionGroup[@uid = $uidRef]) or (self::PositionType and //PositionType[@uid = $uidRef]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::ProductConcept and //ProductConcept[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::Project and //Project[@uid = $uidRef]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::QualificationType and //QualificationType[@uid = $uidRef]) or (self::RelationshipObject and //RelationshipObject[@uid = $uidRef]) or (self::Representation and //Representation[@uid = $uidRef]) or (self::RepresentationContext and //RepresentationContext[@uid = $uidRef]) or (self::RepresentationItem and //RepresentationItem[@uid = $uidRef]) or (self::RequiredResource and //RequiredResource[@uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementSatisfactionAssertion and //RequirementSatisfactionAssertion[@uid = $uidRef]) or (self::RequirementSource and //RequirementSource[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::ResourceAsRealized and //ResourceAsRealized[@uid = $uidRef]) or (self::ResourceEvent and //ResourceEvent[@uid = $uidRef]) or (self::ResourceItem and //ResourceItem[@uid = $uidRef]) or (self::RetentionPeriod and //RetentionPeriod[@uid = $uidRef]) or (self::Risk and //Risk[@uid = $uidRef]) or (self::RiskVersion and //RiskVersion[@uid = $uidRef]) or (self::RiskView and //RiskView[@uid = $uidRef]) or (self::Scheme and //Scheme[@uid = $uidRef]) or (self::SchemeEntry and //SchemeEntry[@uid = $uidRef]) or (self::SchemeVersion and //SchemeVersion[@uid = $uidRef]) or (self::SecurityClassification and //SecurityClassification[@uid = $uidRef]) or (self::SetMembership and //SetMembership[@uid = $uidRef]) or (self::SimplePersonName and //SimplePersonName[@uid = $uidRef]) or (self::Slot and //Slot[@uid = $uidRef]) or (self::SlotDefinition and //SlotDefinition[@uid = $uidRef]) or (self::SlotVersion and //*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationCategory and //SpecificationCategory[@uid = $uidRef]) or (self::SpecificationCategoryHierarchy and //SpecificationCategoryHierarchy[@uid = $uidRef]) or (self::SpecificationInclusion and //*[(self::SpecificationInclusion or (self::AssignedInclusion and contains(' SpecificationInclusion ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::State and //State[@uid = $uidRef]) or (self::StateDefinition and //StateDefinition[@uid = $uidRef]) or (self::SubsetMember and //SubsetMember[@uid = $uidRef]) or (self::System and //System[@uid = $uidRef]) or (self::SystemVersion and //SystemVersion[@uid = $uidRef]) or (self::SystemView and //SystemView[@uid = $uidRef]) or (self::TaskElement and //*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::TaskMethod and //TaskMethod[@uid = $uidRef]) or (self::TaskMethodVersion and //TaskMethodVersion[@uid = $uidRef]) or (self::TaskObjective and //TaskObjective[@uid = $uidRef]) or (self::TimeInterval and //*[(self::TimeInterval or (self::AssignedTimeInterval and contains(' TimeInterval  TimeIntervalWithBounds ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::TypeOfPerson and //TypeOfPerson[@uid = $uidRef]) or (self::TypeOfPersonDefinition and //TypeOfPersonDefinition[@uid = $uidRef]) or (self::TypeQualifier and //TypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::Unit and //Unit[@uid = $uidRef]) or (self::Validation and //Validation[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef]) or (self::Verification and //Verification[@uid = $uidRef]) or (self::ViewContext and //ViewContext[@uid = $uidRef]) or (self::WorkOrder and //WorkOrder[@uid = $uidRef]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef])">(Message : <sch:value-of select="$uid"/>) The Message.Contains contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of MessageContentSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Message.DefinedBy : OPTIONAL SET[1:unbounded] OF MessageDefinerSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Message') or (self::Message and not(@xsi:type)))]/DefinedBy/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::Person and //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::Person and //Person[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef])">(Message : <sch:value-of select="$uid"/>) The Message.DefinedBy contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of MessageDefinerSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="MessageRelationship"><!--(Ref to E) MessageRelationship.Related : Message (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MessageRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='MessageRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Message'] or //Message[@uid = $uidRef]">(MessageRelationship : <sch:value-of select="$uid"/>) The MessageRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Message.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MessageRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='MessageRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(MessageRelationship : <sch:value-of select="$uid"/>) The MessageRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="NextAssemblyOccurrenceUsage"><!--(Ref to S) AssemblyOccurrenceRelationship.Placement : OPTIONAL TransformationSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextAssemblyOccurrenceUsage') or (self::RelationshipObject and substring-after(@xsi:type,':')='NextAssemblyOccurrenceUsage'))]/Placement/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::CartesianTransformation and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)]) or (self::GeometricRepresentationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',@typeRef)]) or (self::CartesianTransformation) or (self::GeometricRepresentationRelationship and //RelationshipObject[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',substring-after(@xsi:type,':'))])">(NextAssemblyOccurrenceUsage : <sch:value-of select="$uid"/>) The NextAssemblyOccurrenceUsage.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of TransformationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ViewOccurrenceRelationship.Related : DefinitionBasedOccurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextAssemblyOccurrenceUsage') or (self::RelationshipObject and substring-after(@xsi:type,':')='NextAssemblyOccurrenceUsage'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DefinitionBasedOccurrence'] or //Occurrence[@uid = $uidRef and contains(' DefinitionBasedOccurrence  QuantifiedOccurrence  SingleOccurrence ',substring-after(@xsi:type,':'))]">(NextAssemblyOccurrenceUsage : <sch:value-of select="$uid"/>) The NextAssemblyOccurrenceUsage.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DefinitionBasedOccurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ViewOccurrenceRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextAssemblyOccurrenceUsage') or (self::RelationshipObject and substring-after(@xsi:type,':')='NextAssemblyOccurrenceUsage'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(NextAssemblyOccurrenceUsage : <sch:value-of select="$uid"/>) The NextAssemblyOccurrenceUsage.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="NextAssemblyViewUsage"><!--(Ref to E) AssemblyViewRelationship.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextAssemblyViewUsage') or (self::RelationshipObject and substring-after(@xsi:type,':')='NextAssemblyViewUsage'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(NextAssemblyViewUsage : <sch:value-of select="$uid"/>) The NextAssemblyViewUsage.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.Related : PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextAssemblyViewUsage') or (self::RelationshipObject and substring-after(@xsi:type,':')='NextAssemblyViewUsage'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(NextAssemblyViewUsage : <sch:value-of select="$uid"/>) The NextAssemblyViewUsage.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextAssemblyViewUsage') or (self::RelationshipObject and substring-after(@xsi:type,':')='NextAssemblyViewUsage'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(NextAssemblyViewUsage : <sch:value-of select="$uid"/>) The NextAssemblyViewUsage.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="NumericalContext"/>
   <sch:pattern id="NumericalValue"><!--(Ref to E) NumericalValue.ValueContext : OPTIONAL NumericalContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NumericalValue') or (self::NumericalValue or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Altitude and substring-after(@xsi:type,':')='NumericalValue') or (self::Longitude and substring-after(@xsi:type,':')='NumericalValue') or (self::Latitude and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::LotSize and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::RequiredQuantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='NumericalValue') or (self::Duration and substring-after(@xsi:type,':')='NumericalValue')))]/ValueContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ValueContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'NumericalContext'] or //NumericalContext[@uid = $uidRef]">(NumericalValue : <sch:value-of select="$uid"/>) The NumericalValue.ValueContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type NumericalContext.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ValueWithUnit.Qualifications : OPTIONAL SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NumericalValue') or (self::NumericalValue or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Altitude and substring-after(@xsi:type,':')='NumericalValue') or (self::Longitude and substring-after(@xsi:type,':')='NumericalValue') or (self::Latitude and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::LotSize and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::RequiredQuantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='NumericalValue') or (self::Duration and substring-after(@xsi:type,':')='NumericalValue')))]/Qualifications/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::TypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::TypeQualifier and //TypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(NumericalValue : <sch:value-of select="$uid"/>) The NumericalValue.Qualifications contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ValueWithUnit.Unit : UnitSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NumericalValue') or (self::NumericalValue or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Altitude and substring-after(@xsi:type,':')='NumericalValue') or (self::Longitude and substring-after(@xsi:type,':')='NumericalValue') or (self::Latitude and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::LotSize and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::RequiredQuantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='NumericalValue') or (self::Duration and substring-after(@xsi:type,':')='NumericalValue')))]/Unit">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)] or //ExternalUnit[@uid = $uidRef] or //Unit[@uid = $uidRef]">(NumericalValue : <sch:value-of select="$uid"/>) The NumericalValue.Unit contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyValue.Definition : PropertyDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NumericalValue') or (self::NumericalValue or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Altitude and substring-after(@xsi:type,':')='NumericalValue') or (self::Longitude and substring-after(@xsi:type,':')='NumericalValue') or (self::Latitude and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::LotSize and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::RequiredQuantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='NumericalValue') or (self::Duration and substring-after(@xsi:type,':')='NumericalValue')))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinition'] or //PropertyDefinition[@uid = $uidRef]">(NumericalValue : <sch:value-of select="$uid"/>) The NumericalValue.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Observation"><!--(Ref to S) Observation.InContext : OPTIONAL SET[1:unbounded] OF ObservationContextSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Observation') or (self::Observation and not(@xsi:type)))]/InContext/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::AnalysisAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AnalysisAssignment ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::InterfaceConnector and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)]) or (self::InterfaceConnectorVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)]) or (self::InterfaceConnectorView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)]) or (self::InterfaceConnectorViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',@typeRef)]) or (self::InterfaceSpecification and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)]) or (self::InterfaceSpecificationVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)]) or (self::InterfaceSpecificationView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)]) or (self::InterfaceSpecificationViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',@typeRef)]) or (self::ProductGroup and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductGroup ',@typeRef)]) or (self::RequiredResource and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequiredResource ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::ResourceAsRealized and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealized ',@typeRef)]) or (self::ResourceItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItem ',@typeRef)]) or (self::Scheme and //ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)]) or (self::SchemeEntry and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)]) or (self::SchemeVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)]) or (self::Slot and //ExternalRefBaseObject[@uid = $uidRef and contains(' Slot ',@typeRef)]) or (self::SlotDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)]) or (self::SlotDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinitionRelationship ',@typeRef)]) or (*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',@typeRef)]) or (self::System and //ExternalRefBaseObject[@uid = $uidRef and contains(' System ',@typeRef)]) or (self::SystemVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)]) or (self::SystemView and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemView ',@typeRef)]) or (self::SystemViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemViewRelationship ',@typeRef)]) or (*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)]) or (self::TaskMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)]) or (self::TaskMethodVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)]) or (self::WorkOrder and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrder ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //AssignmentObject[@uid = $uidRef and contains(' ActivityAssignment ',substring-after(@xsi:type,':'))]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::AnalysisAssignment and //AssignmentObject[@uid = $uidRef and contains(' AnalysisAssignment ',substring-after(@xsi:type,':'))]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',substring-after(@xsi:type,':'))]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::InterfaceConnector and //InterfaceConnector[@uid = $uidRef]) or (self::InterfaceConnectorVersion and //InterfaceConnectorVersion[@uid = $uidRef]) or (self::InterfaceConnectorView and //InterfaceConnectorView[@uid = $uidRef]) or (self::InterfaceConnectorViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceSpecification and //InterfaceSpecification[@uid = $uidRef]) or (self::InterfaceSpecificationVersion and //InterfaceSpecificationVersion[@uid = $uidRef]) or (self::InterfaceSpecificationView and //InterfaceSpecificationView[@uid = $uidRef]) or (self::InterfaceSpecificationViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',substring-after(@xsi:type,':'))]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',substring-after(@xsi:type,':'))]) or (self::ProductGroup and //ProductGroup[@uid = $uidRef]) or (self::RequiredResource and //RequiredResource[@uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',substring-after(@xsi:type,':'))]) or (self::ResourceAsRealized and //ResourceAsRealized[@uid = $uidRef]) or (self::ResourceItem and //ResourceItem[@uid = $uidRef]) or (self::Scheme and //Scheme[@uid = $uidRef]) or (self::SchemeEntry and //SchemeEntry[@uid = $uidRef]) or (self::SchemeVersion and //SchemeVersion[@uid = $uidRef]) or (self::Slot and //Slot[@uid = $uidRef]) or (self::SlotDefinition and //SlotDefinition[@uid = $uidRef]) or (self::SlotDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' SlotDefinitionRelationship ',substring-after(@xsi:type,':'))]) or (self::SlotVersion and //*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::System and //System[@uid = $uidRef]) or (self::SystemVersion and //SystemVersion[@uid = $uidRef]) or (self::SystemView and //SystemView[@uid = $uidRef]) or (self::SystemViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' SystemViewRelationship ',substring-after(@xsi:type,':'))]) or (self::TaskElement and //*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::TaskMethod and //TaskMethod[@uid = $uidRef]) or (self::TaskMethodVersion and //TaskMethodVersion[@uid = $uidRef]) or (self::WorkOrder and //WorkOrder[@uid = $uidRef]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef])">(Observation : <sch:value-of select="$uid"/>) The Observation.InContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ObservationContextSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Observation.ObservedBy : OPTIONAL SET[1:unbounded] OF RealizedIndividualPart (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Observation') or (self::Observation and not(@xsi:type)))]/ObservedBy/RealizedIndividualPart">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ObservedBy/RealizedIndividualPart) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RealizedIndividualPart'] or //IndividualPartVersion[@uid = $uidRef and contains(' RealizedIndividualPart ',substring-after(@xsi:type,':'))]">(Observation : <sch:value-of select="$uid"/>) The Observation.ObservedBy contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RealizedIndividualPart.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Observation.ObservedDuring : OPTIONAL ActualActivity (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Observation') or (self::Observation and not(@xsi:type)))]/ObservedDuring">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ObservedDuring) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActualActivity'] or //Activity[@uid = $uidRef and contains(' ActualActivity ',substring-after(@xsi:type,':'))]">(Observation : <sch:value-of select="$uid"/>) The Observation.ObservedDuring contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActualActivity.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ObservationAssignment"><!--(Ref to E) ObservationAssignment.AssignedObservation : Observation (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservationAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ObservationAssignment'))]/AssignedObservation">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Observation'] or //Observation[@uid = $uidRef]">(ObservationAssignment : <sch:value-of select="$uid"/>) The ObservationAssignment.AssignedObservation contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Observation.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservationAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ObservationAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ObservationAssignment : <sch:value-of select="$uid"/>) The ObservationAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ObservationConsequence"><!--(Ref to S) ObservationConsequence.Request : ObservationConsequenceSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservationConsequence') or (self::AssociationObject and substring-after(@xsi:type,':')='ObservationConsequence'))]/Request">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrder ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)] or //Activity[@uid = $uidRef] or //WorkOrder[@uid = $uidRef] or //WorkRequest[@uid = $uidRef]">(ObservationConsequence : <sch:value-of select="$uid"/>) The ObservationConsequence.Request contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ObservationConsequenceSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ObservationConsequence.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservationConsequence') or (self::AssociationObject and substring-after(@xsi:type,':')='ObservationConsequence'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ObservationConsequence : <sch:value-of select="$uid"/>) The ObservationConsequence.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ObservationRelationship"><!--(Ref to E) ObservationRelationship.Related : Observation (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ObservationRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Observation'] or //Observation[@uid = $uidRef]">(ObservationRelationship : <sch:value-of select="$uid"/>) The ObservationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Observation.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ObservationRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ObservationRelationship : <sch:value-of select="$uid"/>) The ObservationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ObservedEnvironment"/>
   <sch:pattern id="ObservedEnvironmentAssignment"><!--(Ref to E) ObservedEnvironmentAssignment.AssignedEnvironment : ObservedEnvironmentView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservedEnvironmentAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ObservedEnvironmentAssignment'))]/AssignedEnvironment">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ObservedEnvironmentView'] or //EnvironmentView[@uid = $uidRef and contains(' ObservedEnvironmentView ',substring-after(@xsi:type,':'))]">(ObservedEnvironmentAssignment : <sch:value-of select="$uid"/>) The ObservedEnvironmentAssignment.AssignedEnvironment contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ObservedEnvironmentView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservedEnvironmentAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ObservedEnvironmentAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ObservedEnvironmentAssignment : <sch:value-of select="$uid"/>) The ObservedEnvironmentAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ObservedEnvironmentToDefinition"><!--(Ref to E) ObservedEnvironmentToDefinition.DefinedEnvironment : EnvironmentDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservedEnvironmentToDefinition') or (self::AssociationObject and substring-after(@xsi:type,':')='ObservedEnvironmentToDefinition'))]/DefinedEnvironment">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'EnvironmentDefinition'] or //Environment[@uid = $uidRef and contains(' EnvironmentDefinition ',substring-after(@xsi:type,':'))]">(ObservedEnvironmentToDefinition : <sch:value-of select="$uid"/>) The ObservedEnvironmentToDefinition.DefinedEnvironment contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type EnvironmentDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ObservedEnvironmentToDefinition.ObservedEnvironment : ObservedEnvironment (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservedEnvironmentToDefinition') or (self::AssociationObject and substring-after(@xsi:type,':')='ObservedEnvironmentToDefinition'))]/ObservedEnvironment">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ObservedEnvironment'] or //Environment[@uid = $uidRef and contains(' ObservedEnvironment ',substring-after(@xsi:type,':'))]">(ObservedEnvironmentToDefinition : <sch:value-of select="$uid"/>) The ObservedEnvironmentToDefinition.ObservedEnvironment contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ObservedEnvironment.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ObservedEnvironmentToDefinitionVersion"><!--(Ref to E) ObservedEnvironmentToDefinitionVersion.DefinedEnvironmentVersion : EnvironmentDefinitionVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservedEnvironmentToDefinitionVersion') or (self::AssociationObject and substring-after(@xsi:type,':')='ObservedEnvironmentToDefinitionVersion'))]/DefinedEnvironmentVersion">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'EnvironmentDefinitionVersion'] or //EnvironmentVersion[@uid = $uidRef and contains(' EnvironmentDefinitionVersion ',substring-after(@xsi:type,':'))]">(ObservedEnvironmentToDefinitionVersion : <sch:value-of select="$uid"/>) The ObservedEnvironmentToDefinitionVersion.DefinedEnvironmentVersion contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type EnvironmentDefinitionVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ObservedEnvironmentToDefinitionVersion.ObservedEnvironmentVersion : ObservedEnvironmentVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservedEnvironmentToDefinitionVersion') or (self::AssociationObject and substring-after(@xsi:type,':')='ObservedEnvironmentToDefinitionVersion'))]/ObservedEnvironmentVersion">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ObservedEnvironmentVersion'] or //EnvironmentVersion[@uid = $uidRef and contains(' ObservedEnvironmentVersion ',substring-after(@xsi:type,':'))]">(ObservedEnvironmentToDefinitionVersion : <sch:value-of select="$uid"/>) The ObservedEnvironmentToDefinitionVersion.ObservedEnvironmentVersion contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ObservedEnvironmentVersion.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ObservedEnvironmentToDefinitionView"><!--(Ref to E) ObservedEnvironmentToDefinitionView.DefinedEnvironmentView : EnvironmentDefinitionView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservedEnvironmentToDefinitionView') or (self::AssociationObject and substring-after(@xsi:type,':')='ObservedEnvironmentToDefinitionView'))]/DefinedEnvironmentView">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'EnvironmentDefinitionView'] or //EnvironmentView[@uid = $uidRef and contains(' EnvironmentDefinitionView ',substring-after(@xsi:type,':'))] or //*[@uid = $uidRef and (self::AssignedEnvironment)]">(ObservedEnvironmentToDefinitionView : <sch:value-of select="$uid"/>) The ObservedEnvironmentToDefinitionView.DefinedEnvironmentView contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type EnvironmentDefinitionView.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ObservedEnvironmentToDefinitionView.ObservedEnvironmentView : ObservedEnvironmentView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservedEnvironmentToDefinitionView') or (self::AssociationObject and substring-after(@xsi:type,':')='ObservedEnvironmentToDefinitionView'))]/ObservedEnvironmentView">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ObservedEnvironmentView'] or //EnvironmentView[@uid = $uidRef and contains(' ObservedEnvironmentView ',substring-after(@xsi:type,':'))]">(ObservedEnvironmentToDefinitionView : <sch:value-of select="$uid"/>) The ObservedEnvironmentToDefinitionView.ObservedEnvironmentView contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ObservedEnvironmentView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ObservedEnvironmentVersion"><!--(Inverse of Environment.Versions :: PartProperty) EnvironmentVersion.VersionOf : Environment) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="ObservedEnvironmentView"><!--(Ref to E) EnvironmentView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservedEnvironmentView') or (self::ObservedEnvironmentView or (self::AssignedEnvironment and substring-after(@xsi:type,':')='ObservedEnvironmentView')))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(ObservedEnvironmentView : <sch:value-of select="$uid"/>) The ObservedEnvironmentView.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) EnvironmentView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservedEnvironmentView') or (self::ObservedEnvironmentView or (self::AssignedEnvironment and substring-after(@xsi:type,':')='ObservedEnvironmentView')))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(ObservedEnvironmentView : <sch:value-of select="$uid"/>) The ObservedEnvironmentView.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of EnvironmentVersion.Views :: PartProperty) EnvironmentView.ViewOf : EnvironmentVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ObservedEnvironmentViewRelationship"><!--(Ref to E) ObservedEnvironmentViewRelationship.Related : ObservedEnvironmentView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservedEnvironmentViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ObservedEnvironmentViewRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ObservedEnvironmentView'] or //EnvironmentView[@uid = $uidRef and contains(' ObservedEnvironmentView ',substring-after(@xsi:type,':'))]">(ObservedEnvironmentViewRelationship : <sch:value-of select="$uid"/>) The ObservedEnvironmentViewRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ObservedEnvironmentView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ObservedEnvironmentViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservedEnvironmentViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ObservedEnvironmentViewRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ObservedEnvironmentViewRelationship : <sch:value-of select="$uid"/>) The ObservedEnvironmentViewRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="OccurrencePlacement"><!--(Ref to E) OccurrencePlacement.PlacedInstance : SingleOccurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrencePlacement') or (self::OccurrencePlacement and not(@xsi:type)))]/PlacedInstance">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SingleOccurrence'] or //Occurrence[@uid = $uidRef and contains(' SingleOccurrence ',substring-after(@xsi:type,':'))]">(OccurrencePlacement : <sch:value-of select="$uid"/>) The OccurrencePlacement.PlacedInstance contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SingleOccurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) OccurrencePlacement.Placement : TransformationSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrencePlacement') or (self::OccurrencePlacement and not(@xsi:type)))]/Placement/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::CartesianTransformation and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)]) or (self::GeometricRepresentationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',@typeRef)]) or (self::CartesianTransformation) or (self::GeometricRepresentationRelationship and //RelationshipObject[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',substring-after(@xsi:type,':'))])">(OccurrencePlacement : <sch:value-of select="$uid"/>) The OccurrencePlacement.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of TransformationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) OccurrencePlacement.ReferenceComponent : BreakdownElementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrencePlacement') or (self::OccurrencePlacement and not(@xsi:type)))]/ReferenceComponent">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElementView'] or //BreakdownElementView[@uid = $uidRef]">(OccurrencePlacement : <sch:value-of select="$uid"/>) The OccurrencePlacement.ReferenceComponent contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElementView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="OccurrenceRelationship"><!--(Ref to E) OccurrenceRelationship.Related : Occurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='OccurrenceRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Occurrence'] or //Occurrence[@uid = $uidRef]">(OccurrenceRelationship : <sch:value-of select="$uid"/>) The OccurrenceRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Occurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) OccurrenceRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='OccurrenceRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(OccurrenceRelationship : <sch:value-of select="$uid"/>) The OccurrenceRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Organization"/>
   <sch:pattern id="OrganizationOrganizationTypeAssociation"><!--(Ref to E) OrganizationOrganizationTypeAssociation.AssociatedOrganizationType : OrganizationType (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrganizationOrganizationTypeAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='OrganizationOrganizationTypeAssociation'))]/AssociatedOrganizationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'OrganizationType'] or //OrganizationType[@uid = $uidRef]">(OrganizationOrganizationTypeAssociation : <sch:value-of select="$uid"/>) The OrganizationOrganizationTypeAssociation.AssociatedOrganizationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type OrganizationType.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="OrganizationRelationship"><!--(Ref to E) OrganizationRelationship.Related : Organization (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrganizationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='OrganizationRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(OrganizationRelationship : <sch:value-of select="$uid"/>) The OrganizationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) OrganizationRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrganizationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='OrganizationRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(OrganizationRelationship : <sch:value-of select="$uid"/>) The OrganizationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="OrganizationType"/>
   <sch:pattern id="ParameterizedDistribution"><!--(Ref to E) ParameterizedDistribution.HasParameters : OPTIONAL SET[1:unbounded] OF NumericalValue (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::PropertyValue and substring-after(@xsi:type,':')='ParameterizedDistribution'))]/HasParameters/NumericalValue">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../HasParameters/NumericalValue) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'NumericalValue'] or //PropertyValue[@uid = $uidRef and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',substring-after(@xsi:type,':'))] or //*[@uid = $uidRef and (self::Quantity or self::Altitude or self::Longitude or self::Latitude or self::Quantity or self::LotSize or self::Quantity or self::Offset or self::RequiredQuantity or self::Quantity or self::Quantity or self::Quantity or self::EffectivityPeriod or self::Duration)]">(ParameterizedDistribution : <sch:value-of select="$uid"/>) The ParameterizedDistribution.HasParameters contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type NumericalValue.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ValueWithUnit.Qualifications : OPTIONAL SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::ParameterizedDistribution or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Altitude and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Longitude and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Latitude and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::LotSize and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Offset and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Duration and substring-after(@xsi:type,':')='ParameterizedDistribution')))]/Qualifications/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::TypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::TypeQualifier and //TypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(ParameterizedDistribution : <sch:value-of select="$uid"/>) The ParameterizedDistribution.Qualifications contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ValueWithUnit.Unit : UnitSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::ParameterizedDistribution or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Altitude and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Longitude and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Latitude and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::LotSize and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Offset and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Duration and substring-after(@xsi:type,':')='ParameterizedDistribution')))]/Unit">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)] or //ExternalUnit[@uid = $uidRef] or //Unit[@uid = $uidRef]">(ParameterizedDistribution : <sch:value-of select="$uid"/>) The ParameterizedDistribution.Unit contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyValue.Definition : PropertyDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::ParameterizedDistribution or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Altitude and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Longitude and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Latitude and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::LotSize and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Offset and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Quantity and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ParameterizedDistribution') or (self::Duration and substring-after(@xsi:type,':')='ParameterizedDistribution')))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinition'] or //PropertyDefinition[@uid = $uidRef]">(ParameterizedDistribution : <sch:value-of select="$uid"/>) The ParameterizedDistribution.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Part"><!--(Ref to S) Part.PartTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Part') or (self::Part and not(@xsi:type)))]/PartTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Part : <sch:value-of select="$uid"/>) The Part.PartTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartRelationship"><!--(Ref to E) PartRelationship.Related : Part (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PartRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Part'] or //Part[@uid = $uidRef]">(PartRelationship : <sch:value-of select="$uid"/>) The PartRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Part.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PartRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PartRelationship : <sch:value-of select="$uid"/>) The PartRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartToIndividualPartAssociation"><!--(Ref to E) PartToIndividualPartAssociation.AssociatedIndividualPart : IndividualPart (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartToIndividualPartAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='PartToIndividualPartAssociation'))]/AssociatedIndividualPart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'IndividualPart'] or //IndividualPart[@uid = $uidRef]">(PartToIndividualPartAssociation : <sch:value-of select="$uid"/>) The PartToIndividualPartAssociation.AssociatedIndividualPart contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type IndividualPart.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartToIndividualPartAssociation.AssociatedPart : Part (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartToIndividualPartAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='PartToIndividualPartAssociation'))]/AssociatedPart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Part'] or //Part[@uid = $uidRef]">(PartToIndividualPartAssociation : <sch:value-of select="$uid"/>) The PartToIndividualPartAssociation.AssociatedPart contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Part.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartToIndividualPartAssociation.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartToIndividualPartAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='PartToIndividualPartAssociation'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PartToIndividualPartAssociation : <sch:value-of select="$uid"/>) The PartToIndividualPartAssociation.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartVersion"><!--(Inverse of ProductDesignAssociation.AssociatedDesign :: ReferenceProperty) PartVersion.CorrespondingProductConfiguration : OPTIONAL ProductDesignAssociation) => no rule needed when PartProperty or Optional--><!--(Inverse of Part.Versions :: PartProperty) PartVersion.VersionOf : Part) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="PartVersionRelationship"><!--(Ref to E) PartVersionRelationship.Related : PartVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PartVersionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartVersion'] or //PartVersion[@uid = $uidRef]">(PartVersionRelationship : <sch:value-of select="$uid"/>) The PartVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartVersionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PartVersionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PartVersionRelationship : <sch:value-of select="$uid"/>) The PartVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartVersionToIndividualPartVersionAssociation"><!--(Ref to E) PartVersionToIndividualPartVersionAssociation.AssociatedIndividualPart : IndividualPartVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartVersionToIndividualPartVersionAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='PartVersionToIndividualPartVersionAssociation'))]/AssociatedIndividualPart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'IndividualPartVersion'] or //IndividualPartVersion[@uid = $uidRef]">(PartVersionToIndividualPartVersionAssociation : <sch:value-of select="$uid"/>) The PartVersionToIndividualPartVersionAssociation.AssociatedIndividualPart contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type IndividualPartVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartVersionToIndividualPartVersionAssociation.AssociatedPart : PartVersionOrProductConfigurationSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartVersionToIndividualPartVersionAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='PartVersionToIndividualPartVersionAssociation'))]/AssociatedPart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)] or //CollectionVersion[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //ProductConfiguration[@uid = $uidRef] or //RiskVersion[@uid = $uidRef]">(PartVersionToIndividualPartVersionAssociation : <sch:value-of select="$uid"/>) The PartVersionToIndividualPartVersionAssociation.AssociatedPart contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartVersionOrProductConfigurationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartVersionToIndividualPartVersionAssociation.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartVersionToIndividualPartVersionAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='PartVersionToIndividualPartVersionAssociation'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PartVersionToIndividualPartVersionAssociation : <sch:value-of select="$uid"/>) The PartVersionToIndividualPartVersionAssociation.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartView"><!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartView') or (self::PartView and not(@xsi:type)))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(PartView : <sch:value-of select="$uid"/>) The PartView.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartView') or (self::PartView and not(@xsi:type)))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(PartView : <sch:value-of select="$uid"/>) The PartView.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartView') or (self::PartView and not(@xsi:type)))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(PartView : <sch:value-of select="$uid"/>) The PartView.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartView') or (self::PartView and not(@xsi:type)))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(PartView : <sch:value-of select="$uid"/>) The PartView.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="PartViewRelationship"><!--(Ref to E) PartViewRelationship.Related : PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PartViewRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(PartViewRelationship : <sch:value-of select="$uid"/>) The PartViewRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PartViewRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PartViewRelationship : <sch:value-of select="$uid"/>) The PartViewRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartViewToIndividualPartViewAssociation"><!--(Ref to E) PartViewToIndividualPartViewAssociation.AssociatedIndividualPart : IndividualPartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartViewToIndividualPartViewAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='PartViewToIndividualPartViewAssociation'))]/AssociatedIndividualPart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'IndividualPartView'] or //IndividualPartView[@uid = $uidRef]">(PartViewToIndividualPartViewAssociation : <sch:value-of select="$uid"/>) The PartViewToIndividualPartViewAssociation.AssociatedIndividualPart contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type IndividualPartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewToIndividualPartViewAssociation.AssociatedPart : PartViewOrProductConfigurationSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartViewToIndividualPartViewAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='PartViewToIndividualPartViewAssociation'))]/AssociatedPart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)] or //CollectionView[@uid = $uidRef] or //PartView[@uid = $uidRef] or //ProductConfiguration[@uid = $uidRef] or //RiskView[@uid = $uidRef] or //SlotDefinition[@uid = $uidRef]">(PartViewToIndividualPartViewAssociation : <sch:value-of select="$uid"/>) The PartViewToIndividualPartViewAssociation.AssociatedPart contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartViewOrProductConfigurationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewToIndividualPartViewAssociation.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartViewToIndividualPartViewAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='PartViewToIndividualPartViewAssociation'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PartViewToIndividualPartViewAssociation : <sch:value-of select="$uid"/>) The PartViewToIndividualPartViewAssociation.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartialDocumentAssignment"><!--(Ref to S) DocumentAssignment.AssignedDocument : AssignedDocumentSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartialDocumentAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='PartialDocumentAssignment'))]/AssignedDocument">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)] or //Document[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //DocumentVersion[@uid = $uidRef] or //File[@uid = $uidRef]">(PartialDocumentAssignment : <sch:value-of select="$uid"/>) The PartialDocumentAssignment.AssignedDocument contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AssignedDocumentSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DocumentAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=AssignmentObject.Role)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartialDocumentAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='PartialDocumentAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PartialDocumentAssignment : <sch:value-of select="$uid"/>) The PartialDocumentAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Person"><!--(Ref to S) Person.PersonName : OPTIONAL PersonNameSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Person') or (self::Person and not(@xsi:type)))]/PersonName">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' PersonNameSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SimplePersonName ',@typeRef)] or //PersonNameSet[@uid = $uidRef] or //SimplePersonName[@uid = $uidRef]">(Person : <sch:value-of select="$uid"/>) The Person.PersonName contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PersonNameSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of PersonInOrganization.AssociatedPerson :: ReferenceProperty) Person.AssociatedPersonInOrganization : OPTIONAL SET[1:unbounded] OF PersonInOrganization) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="PersonInOrganization"><!--(Ref to E) PersonInOrganization.AssociatedOrganization : Organization (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonInOrganization') or (self::PersonInOrganization and not(@xsi:type)))]/AssociatedOrganization">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(PersonInOrganization : <sch:value-of select="$uid"/>) The PersonInOrganization.AssociatedOrganization contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PersonInOrganization.AssociatedPerson : Person (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonInOrganization') or (self::PersonInOrganization and not(@xsi:type)))]/AssociatedPerson">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Person'] or //Person[@uid = $uidRef]">(PersonInOrganization : <sch:value-of select="$uid"/>) The PersonInOrganization.AssociatedPerson contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Person.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PersonInOrganization.PersonRole : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonInOrganization') or (self::PersonInOrganization and not(@xsi:type)))]/PersonRole/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PersonInOrganization : <sch:value-of select="$uid"/>) The PersonInOrganization.PersonRole contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PersonInOrganizationRelationship"><!--(Ref to E) PersonInOrganizationRelationship.Related : PersonInOrganization (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonInOrganizationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PersonInOrganizationRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PersonInOrganization'] or //PersonInOrganization[@uid = $uidRef]">(PersonInOrganizationRelationship : <sch:value-of select="$uid"/>) The PersonInOrganizationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PersonInOrganization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PersonInOrganizationRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonInOrganizationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PersonInOrganizationRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PersonInOrganizationRelationship : <sch:value-of select="$uid"/>) The PersonInOrganizationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PersonName"><!--(Ref to S) PersonName.NameType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonName') or (self::PersonName and not(@xsi:type)))]/NameType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PersonName : <sch:value-of select="$uid"/>) The PersonName.NameType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PersonNameComponent"><!--(Ref to S) PersonNameComponent.NameComponentType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonNameComponent') or (self::PersonNameComponent and not(@xsi:type)))]/NameComponentType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PersonNameComponent : <sch:value-of select="$uid"/>) The PersonNameComponent.NameComponentType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PersonNameSet"/>
   <sch:pattern id="PersonOrganizationAssignment"><!--(Ref to S) PersonOrganizationAssignment.AssignedPersonOrganization : PersonOrganizationSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonOrganizationAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='PersonOrganizationAssignment'))]/AssignedPersonOrganization">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //Organization[@uid = $uidRef] or //Person[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef]">(PersonOrganizationAssignment : <sch:value-of select="$uid"/>) The PersonOrganizationAssignment.AssignedPersonOrganization contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PersonOrganizationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonOrganizationAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='PersonOrganizationAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PersonOrganizationAssignment : <sch:value-of select="$uid"/>) The PersonOrganizationAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PersonOrganizationInPosition"><!--(Ref to E) PersonOrganizationInPosition.Position : Position (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonOrganizationInPosition') or (self::PersonOrganizationInPosition and not(@xsi:type)))]/Position">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Position'] or //Position[@uid = $uidRef]">(PersonOrganizationInPosition : <sch:value-of select="$uid"/>) The PersonOrganizationInPosition.Position contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Position.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PersonOrganizationInPositionRelationship"><!--(Ref to E) PersonOrganizationInPositionRelationship.Related : PersonOrganizationInPosition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonOrganizationInPositionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PersonOrganizationInPositionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PersonOrganizationInPosition'] or //PersonOrganizationInPosition[@uid = $uidRef]">(PersonOrganizationInPositionRelationship : <sch:value-of select="$uid"/>) The PersonOrganizationInPositionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PersonOrganizationInPosition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonOrganizationInPositionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PersonOrganizationInPositionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PersonOrganizationInPositionRelationship : <sch:value-of select="$uid"/>) The PersonOrganizationInPositionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PhysicalDocumentDefinition"><!--(Ref to E) PhysicalDocumentDefinition.Components : OPTIONAL SET[1:unbounded] OF Hardcopy (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PhysicalDocumentDefinition') or (self::DocumentDefinition and substring-after(@xsi:type,':')='PhysicalDocumentDefinition'))]/Components/Hardcopy">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Components/Hardcopy) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Hardcopy'] or //File[@uid = $uidRef and contains(' Hardcopy ',substring-after(@xsi:type,':'))]">(PhysicalDocumentDefinition : <sch:value-of select="$uid"/>) The PhysicalDocumentDefinition.Components contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Hardcopy.</sch:assert>
      </sch:rule>
      <!--(Inverse of DocumentVersion.Views :: PartProperty) DocumentDefinition.ViewOf : DocumentVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="PlannedActivity"><!--(Ref to S) Activity.ActivityType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='PlannedActivity'))]/ActivityType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PlannedActivity : <sch:value-of select="$uid"/>) The PlannedActivity.ActivityType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.ChosenMethod : OPTIONAL ActivityMethod (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='PlannedActivity'))]/ChosenMethod">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ChosenMethod) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(PlannedActivity : <sch:value-of select="$uid"/>) The PlannedActivity.ChosenMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.PossibleMethods : OPTIONAL SET[1:unbounded] OF ActivityMethod (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='PlannedActivity'))]/PossibleMethods/ActivityMethod">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../PossibleMethods/ActivityMethod) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(PlannedActivity : <sch:value-of select="$uid"/>) The PlannedActivity.PossibleMethods contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PlannedIndividualPart"><!--(Inverse of IndividualPart.Versions :: PartProperty) IndividualPartVersion.VersionOf : IndividualPart) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="Position"/>
   <sch:pattern id="PositionAssignment"><!--(Ref to E) PositionAssignment.AssignedPosition : Position (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PositionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='PositionAssignment'))]/AssignedPosition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Position'] or //Position[@uid = $uidRef]">(PositionAssignment : <sch:value-of select="$uid"/>) The PositionAssignment.AssignedPosition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Position.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PositionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='PositionAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PositionAssignment : <sch:value-of select="$uid"/>) The PositionAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PositionGroup"/>
   <sch:pattern id="PositionGroupAssignment"><!--(Ref to E) PositionGroupAssignment.AssignedPositionGroup : PositionGroup (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PositionGroupAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='PositionGroupAssignment'))]/AssignedPositionGroup">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PositionGroup'] or //PositionGroup[@uid = $uidRef]">(PositionGroupAssignment : <sch:value-of select="$uid"/>) The PositionGroupAssignment.AssignedPositionGroup contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PositionGroup.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PositionGroupAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='PositionGroupAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PositionGroupAssignment : <sch:value-of select="$uid"/>) The PositionGroupAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PositionGroupAssociation"><!--(Ref to E) PositionGroupAssociation.Position : Position (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PositionGroupAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='PositionGroupAssociation'))]/Position">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Position'] or //Position[@uid = $uidRef]">(PositionGroupAssociation : <sch:value-of select="$uid"/>) The PositionGroupAssociation.Position contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Position.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PositionGroupAssociation.PositionGroup : PositionGroup (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PositionGroupAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='PositionGroupAssociation'))]/PositionGroup">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PositionGroup'] or //PositionGroup[@uid = $uidRef]">(PositionGroupAssociation : <sch:value-of select="$uid"/>) The PositionGroupAssociation.PositionGroup contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PositionGroup.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PositionPositionTypeAssociation"><!--(Ref to E) PositionPositionTypeAssociation.AssociatedPositionType : PositionType (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PositionPositionTypeAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='PositionPositionTypeAssociation'))]/AssociatedPositionType">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PositionType'] or //PositionType[@uid = $uidRef]">(PositionPositionTypeAssociation : <sch:value-of select="$uid"/>) The PositionPositionTypeAssociation.AssociatedPositionType contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PositionType.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PositionRelationship"><!--(Ref to E) PositionRelationship.Related : Position (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PositionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PositionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Position'] or //Position[@uid = $uidRef]">(PositionRelationship : <sch:value-of select="$uid"/>) The PositionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Position.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PositionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PositionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PositionRelationship : <sch:value-of select="$uid"/>) The PositionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PositionType"><!--(Ref to E) PositionType.DefinedBy : TypeOfPerson (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PositionType') or (self::PositionType and not(@xsi:type)))]/DefinedBy">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'TypeOfPerson'] or //TypeOfPerson[@uid = $uidRef]">(PositionType : <sch:value-of select="$uid"/>) The PositionType.DefinedBy contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type TypeOfPerson.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PositionTypeAssignment"><!--(Ref to E) PositionTypeAssignment.AssignedPositionType : PositionType (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PositionTypeAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='PositionTypeAssignment'))]/AssignedPositionType">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PositionType'] or //PositionType[@uid = $uidRef]">(PositionTypeAssignment : <sch:value-of select="$uid"/>) The PositionTypeAssignment.AssignedPositionType contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PositionType.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PositionTypeAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='PositionTypeAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PositionTypeAssignment : <sch:value-of select="$uid"/>) The PositionTypeAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PrecisionQualifier"/>
   <sch:pattern id="ProbabilityDerived"><!--(Ref to E) ProbabilityDerived.DerivesFrom : ProbabilityDistribution (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::PropertyValue and substring-after(@xsi:type,':')='ProbabilityDerived'))]/DerivesFrom">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ProbabilityDistribution'] or //PropertyValue[@uid = $uidRef and contains(' ProbabilityDistribution  DistributionByValue  ParameterizedDistribution ',substring-after(@xsi:type,':'))]">(ProbabilityDerived : <sch:value-of select="$uid"/>) The ProbabilityDerived.DerivesFrom contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ProbabilityDistribution.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProbabilityDerived.HasParameter : OPTIONAL SET[1:unbounded] OF NumericalValue (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::PropertyValue and substring-after(@xsi:type,':')='ProbabilityDerived'))]/HasParameter/NumericalValue">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../HasParameter/NumericalValue) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'NumericalValue'] or //PropertyValue[@uid = $uidRef and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',substring-after(@xsi:type,':'))] or //*[@uid = $uidRef and (self::Quantity or self::Altitude or self::Longitude or self::Latitude or self::Quantity or self::LotSize or self::Quantity or self::Offset or self::RequiredQuantity or self::Quantity or self::Quantity or self::Quantity or self::EffectivityPeriod or self::Duration)]">(ProbabilityDerived : <sch:value-of select="$uid"/>) The ProbabilityDerived.HasParameter contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type NumericalValue.</sch:assert>
      </sch:rule>
      <!--(Ref to E) NumericalValue.ValueContext : OPTIONAL NumericalContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::ProbabilityDerived or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Altitude and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Longitude and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Latitude and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::LotSize and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Offset and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Duration and substring-after(@xsi:type,':')='ProbabilityDerived')))]/ValueContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ValueContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'NumericalContext'] or //NumericalContext[@uid = $uidRef]">(ProbabilityDerived : <sch:value-of select="$uid"/>) The ProbabilityDerived.ValueContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type NumericalContext.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ValueWithUnit.Qualifications : OPTIONAL SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::ProbabilityDerived or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Altitude and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Longitude and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Latitude and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::LotSize and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Offset and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Duration and substring-after(@xsi:type,':')='ProbabilityDerived')))]/Qualifications/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::TypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::TypeQualifier and //TypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(ProbabilityDerived : <sch:value-of select="$uid"/>) The ProbabilityDerived.Qualifications contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ValueWithUnit.Unit : UnitSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::ProbabilityDerived or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Altitude and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Longitude and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Latitude and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::LotSize and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Offset and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Duration and substring-after(@xsi:type,':')='ProbabilityDerived')))]/Unit">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)] or //ExternalUnit[@uid = $uidRef] or //Unit[@uid = $uidRef]">(ProbabilityDerived : <sch:value-of select="$uid"/>) The ProbabilityDerived.Unit contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyValue.Definition : PropertyDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::ProbabilityDerived or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Altitude and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Longitude and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Latitude and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::LotSize and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Offset and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Quantity and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ProbabilityDerived') or (self::Duration and substring-after(@xsi:type,':')='ProbabilityDerived')))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinition'] or //PropertyDefinition[@uid = $uidRef]">(ProbabilityDerived : <sch:value-of select="$uid"/>) The ProbabilityDerived.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductBasedLocator"><!--(Ref to S) ProductBasedLocator.ProductLocatorContext : ProductLocatorContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductBasedLocator') or (self::Locator and substring-after(@xsi:type,':')='ProductBasedLocator'))]/ProductLocatorContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Collection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnection  HierarchicalInterfaceConnection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceDefinitionConnection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)] or //Collection[@uid = $uidRef] or //CollectionVersion[@uid = $uidRef] or //InterfaceConnection[@uid = $uidRef] or //InterfaceConnector[@uid = $uidRef] or //InterfaceConnectorOccurrence[@uid = $uidRef] or //InterfaceConnectorVersion[@uid = $uidRef] or //InterfaceDefinitionConnection[@uid = $uidRef] or //InterfaceSpecification[@uid = $uidRef] or //InterfaceSpecificationVersion[@uid = $uidRef]">(ProductBasedLocator : <sch:value-of select="$uid"/>) The ProductBasedLocator.ProductLocatorContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProductLocatorContextSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of Location.Locators :: PartProperty) Locator.Represents : OPTIONAL Location) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ProductClass"><!--(Ref to S) ProductClass.LevelType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductClass') or (self::ProductConcept and substring-after(@xsi:type,':')='ProductClass'))]/LevelType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProductClass : <sch:value-of select="$uid"/>) The ProductClass.LevelType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductConcept.TargetMarket : OPTIONAL Market (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductClass') or (self::ProductConcept and substring-after(@xsi:type,':')='ProductClass'))]/TargetMarket">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./TargetMarket) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Market'] or //Market[@uid = $uidRef]">(ProductClass : <sch:value-of select="$uid"/>) The ProductClass.TargetMarket contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Market.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductClassRelationship"><!--(Ref to E) ProductClassRelationship.Related : ProductClass (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductClassRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ProductClassRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ProductClass'] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))]">(ProductClassRelationship : <sch:value-of select="$uid"/>) The ProductClassRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ProductClass.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProductClassRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductClassRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ProductClassRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProductClassRelationship : <sch:value-of select="$uid"/>) The ProductClassRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductConcept"><!--(Ref to E) ProductConcept.TargetMarket : OPTIONAL Market (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductConcept') or (self::ProductConcept and not(@xsi:type)))]/TargetMarket">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./TargetMarket) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Market'] or //Market[@uid = $uidRef]">(ProductConcept : <sch:value-of select="$uid"/>) The ProductConcept.TargetMarket contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Market.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductConfiguration"><!--(Ref to E) ProductConfiguration.DefiningSpecifications : OPTIONAL SET[1:unbounded] OF Specification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductConfiguration') or (self::ProductConfiguration and not(@xsi:type)))]/DefiningSpecifications/Specification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../DefiningSpecifications/Specification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Specification'] or //Specification[@uid = $uidRef]">(ProductConfiguration : <sch:value-of select="$uid"/>) The ProductConfiguration.DefiningSpecifications contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Specification.</sch:assert>
      </sch:rule>
      <!--(Inverse of ProductDesignAssociation.AssociatedConfiguration :: ReferenceProperty) ProductConfiguration.CorrespondingPartVersion : OPTIONAL ProductDesignAssociation) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ProductConfigurationRelationship"><!--(Ref to E) ProductConfigurationRelationship.Related : ProductConfiguration (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductConfigurationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ProductConfigurationRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ProductConfiguration'] or //ProductConfiguration[@uid = $uidRef]">(ProductConfigurationRelationship : <sch:value-of select="$uid"/>) The ProductConfigurationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ProductConfiguration.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProductConfigurationRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductConfigurationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ProductConfigurationRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProductConfigurationRelationship : <sch:value-of select="$uid"/>) The ProductConfigurationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductDesignAssociation"><!--(Ref to E) ProductDesignAssociation.AssociatedConfiguration : ProductConfiguration (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductDesignAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='ProductDesignAssociation'))]/AssociatedConfiguration">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ProductConfiguration'] or //ProductConfiguration[@uid = $uidRef]">(ProductDesignAssociation : <sch:value-of select="$uid"/>) The ProductDesignAssociation.AssociatedConfiguration contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ProductConfiguration.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductDesignAssociation.AssociatedDesign : PartVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductDesignAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='ProductDesignAssociation'))]/AssociatedDesign">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartVersion'] or //PartVersion[@uid = $uidRef]">(ProductDesignAssociation : <sch:value-of select="$uid"/>) The ProductDesignAssociation.AssociatedDesign contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartVersion.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductGroup"/>
   <sch:pattern id="ProductGroupMembership"><!--(Ref to S) ProductGroupMembership.Member : ProductGroupMemberSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductGroupMembership') or (self::AssociationObject and substring-after(@xsi:type,':')='ProductGroupMembership'))]/Member">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductGroup ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' System ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)] or //IndividualPart[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //Part[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //ProductConcept[@uid = $uidRef] or //ProductGroup[@uid = $uidRef] or //System[@uid = $uidRef] or //SystemVersion[@uid = $uidRef]">(ProductGroupMembership : <sch:value-of select="$uid"/>) The ProductGroupMembership.Member contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProductGroupMemberSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductGroupMembership.OfProductGroup : ProductGroup (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductGroupMembership') or (self::AssociationObject and substring-after(@xsi:type,':')='ProductGroupMembership'))]/OfProductGroup">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ProductGroup'] or //ProductGroup[@uid = $uidRef]">(ProductGroupMembership : <sch:value-of select="$uid"/>) The ProductGroupMembership.OfProductGroup contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ProductGroup.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductGroupRelationship"><!--(Ref to E) ProductGroupRelationship.Related : ProductGroup (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductGroupRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ProductGroupRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ProductGroup'] or //ProductGroup[@uid = $uidRef]">(ProductGroupRelationship : <sch:value-of select="$uid"/>) The ProductGroupRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ProductGroup.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductGroupRelationship.Relating : ProductGroup (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductGroupRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ProductGroupRelationship'))]/Relating">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ProductGroup'] or //ProductGroup[@uid = $uidRef]">(ProductGroupRelationship : <sch:value-of select="$uid"/>) The ProductGroupRelationship.Relating contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ProductGroup.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductGroupRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ProductGroupRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProductGroupRelationship : <sch:value-of select="$uid"/>) The ProductGroupRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductPlannedToRealized"><!--(Ref to E) ProductPlannedToRealized.Related : RealizedIndividualPart (kind=SINGLE - redefined=IndividualPartVersionRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductPlannedToRealized') or (self::RelationshipObject and substring-after(@xsi:type,':')='ProductPlannedToRealized'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RealizedIndividualPart'] or //IndividualPartVersion[@uid = $uidRef and contains(' RealizedIndividualPart ',substring-after(@xsi:type,':'))]">(ProductPlannedToRealized : <sch:value-of select="$uid"/>) The ProductPlannedToRealized.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RealizedIndividualPart.</sch:assert>
      </sch:rule>
      <!--(Ref to S) IndividualPartVersionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductPlannedToRealized') or (self::RelationshipObject and substring-after(@xsi:type,':')='ProductPlannedToRealized'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProductPlannedToRealized : <sch:value-of select="$uid"/>) The ProductPlannedToRealized.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Project"/>
   <sch:pattern id="ProjectAssignment"><!--(Ref to E) ProjectAssignment.AssignedProject : Project (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProjectAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ProjectAssignment'))]/AssignedProject">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Project'] or //Project[@uid = $uidRef]">(ProjectAssignment : <sch:value-of select="$uid"/>) The ProjectAssignment.AssignedProject contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Project.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProjectAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=AssignmentObject.Role)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProjectAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ProjectAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProjectAssignment : <sch:value-of select="$uid"/>) The ProjectAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProjectRelationship"><!--(Ref to E) ProjectRelationship.Related : Project (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProjectRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ProjectRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Project'] or //Project[@uid = $uidRef]">(ProjectRelationship : <sch:value-of select="$uid"/>) The ProjectRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Project.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProjectRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProjectRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ProjectRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProjectRelationship : <sch:value-of select="$uid"/>) The ProjectRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PromissoryAssemblyOccurrenceUsage"><!--(Ref to S) AssemblyOccurrenceRelationship.Placement : OPTIONAL TransformationSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PromissoryAssemblyOccurrenceUsage') or (self::RelationshipObject and substring-after(@xsi:type,':')='PromissoryAssemblyOccurrenceUsage'))]/Placement/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::CartesianTransformation and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)]) or (self::GeometricRepresentationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',@typeRef)]) or (self::CartesianTransformation) or (self::GeometricRepresentationRelationship and //RelationshipObject[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',substring-after(@xsi:type,':'))])">(PromissoryAssemblyOccurrenceUsage : <sch:value-of select="$uid"/>) The PromissoryAssemblyOccurrenceUsage.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of TransformationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ViewOccurrenceRelationship.Related : DefinitionBasedOccurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PromissoryAssemblyOccurrenceUsage') or (self::RelationshipObject and substring-after(@xsi:type,':')='PromissoryAssemblyOccurrenceUsage'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DefinitionBasedOccurrence'] or //Occurrence[@uid = $uidRef and contains(' DefinitionBasedOccurrence  QuantifiedOccurrence  SingleOccurrence ',substring-after(@xsi:type,':'))]">(PromissoryAssemblyOccurrenceUsage : <sch:value-of select="$uid"/>) The PromissoryAssemblyOccurrenceUsage.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DefinitionBasedOccurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ViewOccurrenceRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PromissoryAssemblyOccurrenceUsage') or (self::RelationshipObject and substring-after(@xsi:type,':')='PromissoryAssemblyOccurrenceUsage'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PromissoryAssemblyOccurrenceUsage : <sch:value-of select="$uid"/>) The PromissoryAssemblyOccurrenceUsage.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PromissoryAssemblyViewUsage"><!--(Ref to E) AssemblyViewRelationship.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PromissoryAssemblyViewUsage') or (self::RelationshipObject and substring-after(@xsi:type,':')='PromissoryAssemblyViewUsage'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(PromissoryAssemblyViewUsage : <sch:value-of select="$uid"/>) The PromissoryAssemblyViewUsage.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.Related : PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PromissoryAssemblyViewUsage') or (self::RelationshipObject and substring-after(@xsi:type,':')='PromissoryAssemblyViewUsage'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(PromissoryAssemblyViewUsage : <sch:value-of select="$uid"/>) The PromissoryAssemblyViewUsage.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PromissoryAssemblyViewUsage') or (self::RelationshipObject and substring-after(@xsi:type,':')='PromissoryAssemblyViewUsage'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PromissoryAssemblyViewUsage : <sch:value-of select="$uid"/>) The PromissoryAssemblyViewUsage.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyDefinition"><!--(Ref to S) PropertyDefinition.AllowedUnits : OPTIONAL SET[1:unbounded] OF UnitSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinition') or (self::PropertyDefinition and not(@xsi:type)))]/AllowedUnits/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ExternalUnit and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)]) or (self::Unit and //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)]) or (self::ExternalUnit and //ExternalUnit[@uid = $uidRef]) or (self::Unit and //Unit[@uid = $uidRef])">(PropertyDefinition : <sch:value-of select="$uid"/>) The PropertyDefinition.AllowedUnits contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyDefinition.DefinedIn : OPTIONAL ExternalLibrary (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinition') or (self::PropertyDefinition and not(@xsi:type)))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefinedIn) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExternalLibrary'] or //ExternalLibrary[@uid = $uidRef]">(PropertyDefinition : <sch:value-of select="$uid"/>) The PropertyDefinition.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExternalLibrary.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyDefinition.Definition : OPTIONAL ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinition') or (self::PropertyDefinition and not(@xsi:type)))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(PropertyDefinition : <sch:value-of select="$uid"/>) The PropertyDefinition.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyDefinition.PropertyType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinition') or (self::PropertyDefinition and not(@xsi:type)))]/PropertyType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PropertyDefinition : <sch:value-of select="$uid"/>) The PropertyDefinition.PropertyType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyDefinitionAssignment"><!--(Ref to S) PropertyDefinitionAssignment.AllowedUnits : OPTIONAL SET[1:unbounded] OF UnitSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinitionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='PropertyDefinitionAssignment'))]/AllowedUnits/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ExternalUnit and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)]) or (self::Unit and //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)]) or (self::ExternalUnit and //ExternalUnit[@uid = $uidRef]) or (self::Unit and //Unit[@uid = $uidRef])">(PropertyDefinitionAssignment : <sch:value-of select="$uid"/>) The PropertyDefinitionAssignment.AllowedUnits contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyDefinitionAssignment.AssignedPropertyDefinition : PropertyDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinitionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='PropertyDefinitionAssignment'))]/AssignedPropertyDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinition'] or //PropertyDefinition[@uid = $uidRef]">(PropertyDefinitionAssignment : <sch:value-of select="$uid"/>) The PropertyDefinitionAssignment.AssignedPropertyDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinitionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='PropertyDefinitionAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PropertyDefinitionAssignment : <sch:value-of select="$uid"/>) The PropertyDefinitionAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyDefinitionAssignmentRelationship"><!--(Ref to E) PropertyDefinitionAssignmentRelationship.Related : PropertyDefinitionAssignment (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinitionAssignmentRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PropertyDefinitionAssignmentRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinitionAssignment'] or //AssignmentObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',substring-after(@xsi:type,':'))]">(PropertyDefinitionAssignmentRelationship : <sch:value-of select="$uid"/>) The PropertyDefinitionAssignmentRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinitionAssignment.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyDefinitionAssignmentRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinitionAssignmentRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PropertyDefinitionAssignmentRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PropertyDefinitionAssignmentRelationship : <sch:value-of select="$uid"/>) The PropertyDefinitionAssignmentRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyDefinitionRelationship"><!--(Ref to E) PropertyDefinitionRelationship.Related : PropertyDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinitionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PropertyDefinitionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinition'] or //PropertyDefinition[@uid = $uidRef]">(PropertyDefinitionRelationship : <sch:value-of select="$uid"/>) The PropertyDefinitionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyDefinitionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinitionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PropertyDefinitionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PropertyDefinitionRelationship : <sch:value-of select="$uid"/>) The PropertyDefinitionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyValueAssignment"><!--(Ref to E) PropertyValueAssignment.ValueAssignmentContext : OPTIONAL PropertyDefinitionAssignment (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyValueAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='PropertyValueAssignment'))]/ValueAssignmentContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ValueAssignmentContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinitionAssignment'] or //AssignmentObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',substring-after(@xsi:type,':'))]">(PropertyValueAssignment : <sch:value-of select="$uid"/>) The PropertyValueAssignment.ValueAssignmentContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinitionAssignment.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyValueAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='PropertyValueAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PropertyValueAssignment : <sch:value-of select="$uid"/>) The PropertyValueAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyValueAssignmentRelationship"><!--(Ref to E) PropertyValueAssignmentRelationship.Related : PropertyValueAssignment (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyValueAssignmentRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PropertyValueAssignmentRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyValueAssignment'] or //AssignmentObject[@uid = $uidRef and contains(' PropertyValueAssignment ',substring-after(@xsi:type,':'))]">(PropertyValueAssignmentRelationship : <sch:value-of select="$uid"/>) The PropertyValueAssignmentRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyValueAssignment.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValueAssignmentRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyValueAssignmentRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PropertyValueAssignmentRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PropertyValueAssignmentRelationship : <sch:value-of select="$uid"/>) The PropertyValueAssignmentRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyValueRelationship"><!--(Ref to E) PropertyValueRelationship.Related : PropertyValue (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyValueRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PropertyValueRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyValue'] or //PropertyValue[@uid = $uidRef] or //*[@uid = $uidRef and (self::Quantity or self::Altitude or self::Longitude or self::Latitude or self::Quantity or self::LotSize or self::Quantity or self::Quantity or self::Offset or self::RequiredQuantity or self::Quantity or self::Quantity or self::Quantity or self::EffectivityPeriod or self::Duration)]">(PropertyValueRelationship : <sch:value-of select="$uid"/>) The PropertyValueRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyValue.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValueRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyValueRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='PropertyValueRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PropertyValueRelationship : <sch:value-of select="$uid"/>) The PropertyValueRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Proxy"><!--(Ref to S) Proxy.Individual : ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Proxy') or (self::Proxy or (self::SameAs and substring-after(@xsi:type,':')='Proxy') or (self::SameAs and substring-after(@xsi:type,':')='Proxy')))]/Individual/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(Proxy : <sch:value-of select="$uid"/>) The Proxy.Individual contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProxyRelationship"><!--(Ref to E) ProxyRelationship.Related : Proxy (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProxyRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ProxyRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Proxy'] or //Proxy[@uid = $uidRef] or //*[@uid = $uidRef and (self::SameAs or self::SameAs)]">(ProxyRelationship : <sch:value-of select="$uid"/>) The ProxyRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Proxy.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProxyRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProxyRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ProxyRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProxyRelationship : <sch:value-of select="$uid"/>) The ProxyRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="QualificationAssignment"><!--(Ref to E) QualificationAssignment.AssignedQualificationType : QualificationType (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='QualificationAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='QualificationAssignment'))]/AssignedQualificationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'QualificationType'] or //QualificationType[@uid = $uidRef]">(QualificationAssignment : <sch:value-of select="$uid"/>) The QualificationAssignment.AssignedQualificationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type QualificationType.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='QualificationAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='QualificationAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(QualificationAssignment : <sch:value-of select="$uid"/>) The QualificationAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="QualificationType"/>
   <sch:pattern id="QualificationTypeRelationship"><!--(Ref to E) QualificationTypeRelationship.Related : QualificationType (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='QualificationTypeRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='QualificationTypeRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'QualificationType'] or //QualificationType[@uid = $uidRef]">(QualificationTypeRelationship : <sch:value-of select="$uid"/>) The QualificationTypeRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type QualificationType.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='QualificationTypeRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='QualificationTypeRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(QualificationTypeRelationship : <sch:value-of select="$uid"/>) The QualificationTypeRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="QualitativeUncertainty"/>
   <sch:pattern id="QuantifiedOccurrence"><!--(Ref to E) Occurrence.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='QuantifiedOccurrence') or (self::Occurrence and substring-after(@xsi:type,':')='QuantifiedOccurrence'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(QuantifiedOccurrence : <sch:value-of select="$uid"/>) The QuantifiedOccurrence.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RealizedIndividualPart"><!--(Inverse of IndividualPart.Versions :: PartProperty) IndividualPartVersion.VersionOf : IndividualPart) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="RegionalGrid"><!--(Inverse of Location.Locators :: PartProperty) Locator.Represents : OPTIONAL Location) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="RelatedConditionParameter"><!--(Ref to E) RelatedConditionParameter.ConditionParameter : ConditionParameter (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RelatedConditionParameter') or (self::AssociationObject and substring-after(@xsi:type,':')='RelatedConditionParameter'))]/ConditionParameter">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ConditionParameter'] or //ConditionParameter[@uid = $uidRef]">(RelatedConditionParameter : <sch:value-of select="$uid"/>) The RelatedConditionParameter.ConditionParameter contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ConditionParameter.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RelatedConsequence"><!--(Ref to E) RelatedConsequence.Related : RiskConsequence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RelatedConsequence') or (self::RelationshipObject and substring-after(@xsi:type,':')='RelatedConsequence'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RiskConsequence'] or //RiskView[@uid = $uidRef and contains(' RiskConsequence ',substring-after(@xsi:type,':'))]">(RelatedConsequence : <sch:value-of select="$uid"/>) The RelatedConsequence.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RiskConsequence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RelatedConsequence') or (self::RelationshipObject and substring-after(@xsi:type,':')='RelatedConsequence'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RelatedConsequence : <sch:value-of select="$uid"/>) The RelatedConsequence.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RelativeEvent"><!--(Ref to E) RelativeEvent.RelativeTo : Event (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RelativeEvent') or (self::Event and substring-after(@xsi:type,':')='RelativeEvent'))]/RelativeTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Event'] or //Event[@uid = $uidRef]">(RelativeEvent : <sch:value-of select="$uid"/>) The RelativeEvent.RelativeTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Event.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Event.EventType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RelativeEvent') or (self::Event and substring-after(@xsi:type,':')='RelativeEvent'))]/EventType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RelativeEvent : <sch:value-of select="$uid"/>) The RelativeEvent.EventType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RepeatCount"/>
   <sch:pattern id="RepeatUntil"><!--(Ref to E) RepeatUntil.Condition : Condition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RepeatUntil') or (self::TaskElement and substring-after(@xsi:type,':')='RepeatUntil'))]/Condition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Condition'] or //Condition[@uid = $uidRef] or //*[@uid = $uidRef and (self::AssignedCondition or self::Condition or self::AssignedCondition)]">(RepeatUntil : <sch:value-of select="$uid"/>) The RepeatUntil.Condition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Condition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RepeatWhile"><!--(Ref to E) RepeatWhile.Condition : Condition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RepeatWhile') or (self::TaskElement and substring-after(@xsi:type,':')='RepeatWhile'))]/Condition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Condition'] or //Condition[@uid = $uidRef] or //*[@uid = $uidRef and (self::AssignedCondition or self::Condition or self::AssignedCondition)]">(RepeatWhile : <sch:value-of select="$uid"/>) The RepeatWhile.Condition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Condition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ReplacedPartViewRelationship"><!--(Ref to E) PartViewRelationship.Related : PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReplacedPartViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ReplacedPartViewRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(ReplacedPartViewRelationship : <sch:value-of select="$uid"/>) The ReplacedPartViewRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReplacedPartViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ReplacedPartViewRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ReplacedPartViewRelationship : <sch:value-of select="$uid"/>) The ReplacedPartViewRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ReplacedUsageRelationship"><!--(Ref to S) ReplacedUsageRelationship.UsageContext : OccurrenceUsageContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReplacedUsageRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ReplacedUsageRelationship'))]/UsageContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRealization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship ',@typeRef)] or //AssociationObject[@uid = $uidRef and contains(' BreakdownElementRealization ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship ',substring-after(@xsi:type,':'))]">(ReplacedUsageRelationship : <sch:value-of select="$uid"/>) The ReplacedUsageRelationship.UsageContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OccurrenceUsageContextSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) OccurrenceRelationship.Related : Occurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReplacedUsageRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ReplacedUsageRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Occurrence'] or //Occurrence[@uid = $uidRef]">(ReplacedUsageRelationship : <sch:value-of select="$uid"/>) The ReplacedUsageRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Occurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) OccurrenceRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReplacedUsageRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ReplacedUsageRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ReplacedUsageRelationship : <sch:value-of select="$uid"/>) The ReplacedUsageRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Representation"><!--(Ref to E) Representation.ContextOfItems : RepresentationContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Representation') or (self::Representation and not(@xsi:type)))]/ContextOfItems">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationContext'] or //RepresentationContext[@uid = $uidRef]">(Representation : <sch:value-of select="$uid"/>) The Representation.ContextOfItems contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Representation.Items : SET[1:unbounded] OF RepresentationItem (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Representation') or (self::Representation and not(@xsi:type)))]/Items/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(Representation : <sch:value-of select="$uid"/>) The Representation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Representation') or (self::Representation and not(@xsi:type)))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Representation : <sch:value-of select="$uid"/>) The Representation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RepresentationContext"><!--(Ref to E) RepresentationContext.Accuracies : OPTIONAL SET[1:unbounded] OF MeasureQualification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RepresentationContext') or (self::RepresentationContext and not(@xsi:type)))]/Accuracies/MeasureQualification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Accuracies/MeasureQualification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'MeasureQualification'] or //MeasureQualification[@uid = $uidRef]">(RepresentationContext : <sch:value-of select="$uid"/>) The RepresentationContext.Accuracies contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type MeasureQualification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RepresentationContext.Units : OPTIONAL SET[1:unbounded] OF Unit (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RepresentationContext') or (self::RepresentationContext and not(@xsi:type)))]/Units/Unit">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Units/Unit) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Unit'] or //Unit[@uid = $uidRef]">(RepresentationContext : <sch:value-of select="$uid"/>) The RepresentationContext.Units contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Unit.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequiredResource"><!--(Ref to S) RequiredResource.Item : ResourceItemSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequiredResource') or (self::RequiredResource and not(@xsi:type)))]/Item">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItem ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionType ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductGroup ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeOfPerson ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)] or //BreakdownElementVersion[@uid = $uidRef] or //BreakdownElementView[@uid = $uidRef] or //BreakdownVersion[@uid = $uidRef] or //Document[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //DocumentVersion[@uid = $uidRef] or //Organization[@uid = $uidRef] or //ResourceItem[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //InterfaceConnector[@uid = $uidRef] or //InterfaceConnectorVersion[@uid = $uidRef] or //InterfaceConnectorView[@uid = $uidRef] or //InterfaceSpecification[@uid = $uidRef] or //InterfaceSpecificationVersion[@uid = $uidRef] or //InterfaceSpecificationView[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //PositionType[@uid = $uidRef] or //ProductGroup[@uid = $uidRef] or //RiskVersion[@uid = $uidRef] or //TypeOfPerson[@uid = $uidRef] or //SystemVersion[@uid = $uidRef]">(RequiredResource : <sch:value-of select="$uid"/>) The RequiredResource.Item contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ResourceItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequiredResourceAssignment"><!--(Ref to E) RequiredResourceAssignment.AssignedResource : RequiredResource (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequiredResourceAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='RequiredResourceAssignment'))]/AssignedResource">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequiredResource'] or //RequiredResource[@uid = $uidRef]">(RequiredResourceAssignment : <sch:value-of select="$uid"/>) The RequiredResourceAssignment.AssignedResource contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequiredResource.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequiredResourceAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='RequiredResourceAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RequiredResourceAssignment : <sch:value-of select="$uid"/>) The RequiredResourceAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequiredResourceRelationship"><!--(Ref to E) RequiredResourceRelationship.Related : RequiredResource (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequiredResourceRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RequiredResourceRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequiredResource'] or //RequiredResource[@uid = $uidRef]">(RequiredResourceRelationship : <sch:value-of select="$uid"/>) The RequiredResourceRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequiredResource.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequiredResourceRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RequiredResourceRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RequiredResourceRelationship : <sch:value-of select="$uid"/>) The RequiredResourceRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Requirement"/>
   <sch:pattern id="RequirementAssignment"><!--(Ref to E) RequirementAssignment.AssignedRequirement : RequirementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='RequirementAssignment'))]/AssignedRequirement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementView'] or //RequirementView[@uid = $uidRef]">(RequirementAssignment : <sch:value-of select="$uid"/>) The RequirementAssignment.AssignedRequirement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='RequirementAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RequirementAssignment : <sch:value-of select="$uid"/>) The RequirementAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementCollectionRelationship"><!--(Ref to E) RequirementViewRelationship.Related : RequirementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementCollectionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RequirementCollectionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementView'] or //RequirementView[@uid = $uidRef]">(RequirementCollectionRelationship : <sch:value-of select="$uid"/>) The RequirementCollectionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RequirementViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementCollectionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RequirementCollectionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RequirementCollectionRelationship : <sch:value-of select="$uid"/>) The RequirementCollectionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementDecompositionRelationship"><!--(Ref to E) RequirementViewRelationship.Related : RequirementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementDecompositionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RequirementDecompositionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementView'] or //RequirementView[@uid = $uidRef]">(RequirementDecompositionRelationship : <sch:value-of select="$uid"/>) The RequirementDecompositionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RequirementViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementDecompositionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RequirementDecompositionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RequirementDecompositionRelationship : <sch:value-of select="$uid"/>) The RequirementDecompositionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementRelationship"><!--(Ref to E) RequirementRelationship.Related : Requirement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RequirementRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Requirement'] or //Requirement[@uid = $uidRef]">(RequirementRelationship : <sch:value-of select="$uid"/>) The RequirementRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Requirement.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RequirementRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RequirementRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RequirementRelationship : <sch:value-of select="$uid"/>) The RequirementRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementSatisfactionAssertion"><!--(Ref to E) RequirementSatisfactionAssertion.RelatedAssignment : OPTIONAL RequirementAssignment (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementSatisfactionAssertion') or (self::RequirementSatisfactionAssertion and not(@xsi:type)))]/RelatedAssignment">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./RelatedAssignment) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementAssignment'] or //AssignmentObject[@uid = $uidRef and contains(' RequirementAssignment ',substring-after(@xsi:type,':'))]">(RequirementSatisfactionAssertion : <sch:value-of select="$uid"/>) The RequirementSatisfactionAssertion.RelatedAssignment contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementAssignment.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RequirementSatisfactionAssertion.SatisfiedRequirement : RequirementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementSatisfactionAssertion') or (self::RequirementSatisfactionAssertion and not(@xsi:type)))]/SatisfiedRequirement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementView'] or //RequirementView[@uid = $uidRef]">(RequirementSatisfactionAssertion : <sch:value-of select="$uid"/>) The RequirementSatisfactionAssertion.SatisfiedRequirement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementSource"><!--(Ref to S) RequirementSource.Source : RequirementSourceSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementSource') or (self::RequirementSource and not(@xsi:type)))]/Source">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment  RiskEvent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Collection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Risk ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Slot ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' System ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElementAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Validation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Verification ',@typeRef)] or //Activity[@uid = $uidRef] or //ActivityMethod[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' ActivityMethodAssignment  RiskEvent ',substring-after(@xsi:type,':'))] or //Breakdown[@uid = $uidRef] or //BreakdownElement[@uid = $uidRef] or //BreakdownElementVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',substring-after(@xsi:type,':'))] or //BreakdownElementView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',substring-after(@xsi:type,':'))] or //BreakdownVersion[@uid = $uidRef] or //Collection[@uid = $uidRef] or //CollectionVersion[@uid = $uidRef] or //CollectionView[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Document[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //DocumentVersion[@uid = $uidRef] or //IndividualPart[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //IndividualPartView[@uid = $uidRef] or //InterfaceConnector[@uid = $uidRef] or //InterfaceConnectorOccurrence[@uid = $uidRef] or //InterfaceConnectorVersion[@uid = $uidRef] or //InterfaceConnectorView[@uid = $uidRef] or //InterfaceSpecification[@uid = $uidRef] or //InterfaceSpecificationVersion[@uid = $uidRef] or //InterfaceSpecificationView[@uid = $uidRef] or //Observation[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' ObservationAssignment ',substring-after(@xsi:type,':'))] or //Organization[@uid = $uidRef] or //Part[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //PartView[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //Project[@uid = $uidRef] or //Requirement[@uid = $uidRef] or //RequirementVersion[@uid = $uidRef] or //RequirementView[@uid = $uidRef] or //Risk[@uid = $uidRef] or //RiskVersion[@uid = $uidRef] or //RiskView[@uid = $uidRef] or //Scheme[@uid = $uidRef] or //SchemeEntry[@uid = $uidRef] or //SchemeVersion[@uid = $uidRef] or //Slot[@uid = $uidRef] or //SlotDefinition[@uid = $uidRef] or //SlotVersion[@uid = $uidRef] or //System[@uid = $uidRef] or //SystemVersion[@uid = $uidRef] or //SystemView[@uid = $uidRef] or //TaskElement[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' TaskElementAssignment ',substring-after(@xsi:type,':'))] or //TaskMethod[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' TaskMethodAssignment ',substring-after(@xsi:type,':'))] or //TaskMethodVersion[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' TaskMethodVersionAssignment ',substring-after(@xsi:type,':'))] or //Validation[@uid = $uidRef] or //Verification[@uid = $uidRef]">(RequirementSource : <sch:value-of select="$uid"/>) The RequirementSource.Source contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of RequirementSourceSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementTracingRelationship"><!--(Ref to E) RequirementViewRelationship.Related : RequirementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementTracingRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RequirementTracingRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementView'] or //RequirementView[@uid = $uidRef]">(RequirementTracingRelationship : <sch:value-of select="$uid"/>) The RequirementTracingRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RequirementViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementTracingRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RequirementTracingRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RequirementTracingRelationship : <sch:value-of select="$uid"/>) The RequirementTracingRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementVersion"><!--(Inverse of Requirement.Versions :: PartProperty) RequirementVersion.VersionOf : Requirement) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="RequirementVersionRelationship"><!--(Ref to E) RequirementVersionRelationship.Related : RequirementVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RequirementVersionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementVersion'] or //RequirementVersion[@uid = $uidRef]">(RequirementVersionRelationship : <sch:value-of select="$uid"/>) The RequirementVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RequirementVersionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RequirementVersionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RequirementVersionRelationship : <sch:value-of select="$uid"/>) The RequirementVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementView"><!--(Ref to E) RequirementView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementView') or (self::RequirementView and not(@xsi:type)))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(RequirementView : <sch:value-of select="$uid"/>) The RequirementView.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RequirementView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementView') or (self::RequirementView and not(@xsi:type)))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(RequirementView : <sch:value-of select="$uid"/>) The RequirementView.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of RequirementVersion.Views :: PartProperty) RequirementView.ViewOf : RequirementVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="RequirementViewRelationship"><!--(Ref to E) RequirementViewRelationship.Related : RequirementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RequirementViewRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementView'] or //RequirementView[@uid = $uidRef]">(RequirementViewRelationship : <sch:value-of select="$uid"/>) The RequirementViewRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RequirementViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RequirementViewRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RequirementViewRelationship : <sch:value-of select="$uid"/>) The RequirementViewRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ResourceAsRealized"><!--(Ref to S) ResourceAsRealized.Item : ResourceItemSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ResourceAsRealized') or (self::ResourceAsRealized and not(@xsi:type)))]/Item">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItem ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionType ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductGroup ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeOfPerson ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)] or //BreakdownElementVersion[@uid = $uidRef] or //BreakdownElementView[@uid = $uidRef] or //BreakdownVersion[@uid = $uidRef] or //Document[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //DocumentVersion[@uid = $uidRef] or //Organization[@uid = $uidRef] or //ResourceItem[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //InterfaceConnector[@uid = $uidRef] or //InterfaceConnectorVersion[@uid = $uidRef] or //InterfaceConnectorView[@uid = $uidRef] or //InterfaceSpecification[@uid = $uidRef] or //InterfaceSpecificationVersion[@uid = $uidRef] or //InterfaceSpecificationView[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //PositionType[@uid = $uidRef] or //ProductGroup[@uid = $uidRef] or //RiskVersion[@uid = $uidRef] or //TypeOfPerson[@uid = $uidRef] or //SystemVersion[@uid = $uidRef]">(ResourceAsRealized : <sch:value-of select="$uid"/>) The ResourceAsRealized.Item contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ResourceItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ResourceAsRealizedAssignment"><!--(Ref to E) ResourceAsRealizedAssignment.AssignedResource : ResourceAsRealized (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ResourceAsRealizedAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ResourceAsRealizedAssignment'))]/AssignedResource">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ResourceAsRealized'] or //ResourceAsRealized[@uid = $uidRef]">(ResourceAsRealizedAssignment : <sch:value-of select="$uid"/>) The ResourceAsRealizedAssignment.AssignedResource contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ResourceAsRealized.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ResourceAsRealizedAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ResourceAsRealizedAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ResourceAsRealizedAssignment : <sch:value-of select="$uid"/>) The ResourceAsRealizedAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ResourceAsRealizedAssociation"><!--(Ref to S) ResourceAsRealizedAssociation.AssociatedItem : ResourceAsRealizedAssociationSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ResourceAsRealizedAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='ResourceAsRealizedAssociation'))]/AssociatedItem">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' RequiredResource ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceEvent  DecreasingResourceEvent  IncreasingResourceEvent ',@typeRef)] or //RequiredResource[@uid = $uidRef] or //ResourceEvent[@uid = $uidRef]">(ResourceAsRealizedAssociation : <sch:value-of select="$uid"/>) The ResourceAsRealizedAssociation.AssociatedItem contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ResourceAsRealizedAssociationSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ResourceEvent"><!--(Ref to E) ResourceEvent.Resource : ManagedResource (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ResourceEvent') or (self::ResourceEvent and not(@xsi:type)))]/Resource">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ManagedResource'] or //ManagedResource[@uid = $uidRef]">(ResourceEvent : <sch:value-of select="$uid"/>) The ResourceEvent.Resource contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ManagedResource.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ResourceEventCorrespondenceAssociation"><!--(Ref to E) ResourceEventCorrespondenceAssociation.AssociatedRequiredResource : RequiredResource (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ResourceEventCorrespondenceAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='ResourceEventCorrespondenceAssociation'))]/AssociatedRequiredResource">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequiredResource'] or //RequiredResource[@uid = $uidRef]">(ResourceEventCorrespondenceAssociation : <sch:value-of select="$uid"/>) The ResourceEventCorrespondenceAssociation.AssociatedRequiredResource contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequiredResource.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ResourceEventRelationship"><!--(Ref to E) ResourceEventRelationship.Related : ResourceEvent (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ResourceEventRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ResourceEventRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ResourceEvent'] or //ResourceEvent[@uid = $uidRef]">(ResourceEventRelationship : <sch:value-of select="$uid"/>) The ResourceEventRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ResourceEvent.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ResourceEventRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ResourceEventRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ResourceEventRelationship : <sch:value-of select="$uid"/>) The ResourceEventRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ResourceGroupRelationship"><!--(Ref to E) ResourceItemRelationship.Related : ResourceItem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ResourceGroupRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ResourceGroupRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ResourceItem'] or //ResourceItem[@uid = $uidRef]">(ResourceGroupRelationship : <sch:value-of select="$uid"/>) The ResourceGroupRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ResourceItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ResourceGroupRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ResourceGroupRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ResourceGroupRelationship : <sch:value-of select="$uid"/>) The ResourceGroupRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ResourceItem"/>
   <sch:pattern id="ResourceItemAssignment"><!--(Ref to E) ResourceItemAssignment.AssignedResource : ResourceItem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ResourceItemAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ResourceItemAssignment'))]/AssignedResource">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ResourceItem'] or //ResourceItem[@uid = $uidRef]">(ResourceItemAssignment : <sch:value-of select="$uid"/>) The ResourceItemAssignment.AssignedResource contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ResourceItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ResourceItemAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='ResourceItemAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ResourceItemAssignment : <sch:value-of select="$uid"/>) The ResourceItemAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ResourceItemRealization"><!--(Ref to S) ResourceItemRealization.Item : ResourceRealizationSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ResourceItemRealization') or (self::AssociationObject and substring-after(@xsi:type,':')='ResourceItemRealization'))]/Item">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionType ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductGroup ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeOfPerson ',@typeRef)] or //IndividualPartVersion[@uid = $uidRef] or //InterfaceConnector[@uid = $uidRef] or //InterfaceConnectorVersion[@uid = $uidRef] or //InterfaceConnectorView[@uid = $uidRef] or //InterfaceSpecification[@uid = $uidRef] or //InterfaceSpecificationVersion[@uid = $uidRef] or //InterfaceSpecificationView[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //PositionType[@uid = $uidRef] or //ProductGroup[@uid = $uidRef] or //RiskVersion[@uid = $uidRef] or //TypeOfPerson[@uid = $uidRef]">(ResourceItemRealization : <sch:value-of select="$uid"/>) The ResourceItemRealization.Item contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ResourceRealizationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ResourceItemRealization.ResourceItem : ResourceItem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ResourceItemRealization') or (self::AssociationObject and substring-after(@xsi:type,':')='ResourceItemRealization'))]/ResourceItem">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ResourceItem'] or //ResourceItem[@uid = $uidRef]">(ResourceItemRealization : <sch:value-of select="$uid"/>) The ResourceItemRealization.ResourceItem contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ResourceItem.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ResourceItemRelationship"><!--(Ref to E) ResourceItemRelationship.Related : ResourceItem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ResourceItemRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ResourceItemRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ResourceItem'] or //ResourceItem[@uid = $uidRef]">(ResourceItemRelationship : <sch:value-of select="$uid"/>) The ResourceItemRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ResourceItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ResourceItemRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='ResourceItemRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ResourceItemRelationship : <sch:value-of select="$uid"/>) The ResourceItemRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RetentionPeriod"><!--(Ref to S) RetentionPeriod.EarliestEnd : PeriodOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RetentionPeriod') or (self::RetentionPeriod and not(@xsi:type)))]/EarliestEnd/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::Duration or (self::Offset and contains(' Duration ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' Duration ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' Duration ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Duration ',@typeRef)]) or (self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event  RelativeEvent ',@typeRef)]) or (self::Duration and //*[(self::Duration or (self::Offset and contains(' Duration ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' Duration ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' Duration ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef and contains(' Duration ',substring-after(@xsi:type,':'))]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(RetentionPeriod : <sch:value-of select="$uid"/>) The RetentionPeriod.EarliestEnd contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PeriodOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RetentionPeriod.LatestEnd : PeriodOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RetentionPeriod') or (self::RetentionPeriod and not(@xsi:type)))]/LatestEnd/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::Duration or (self::Offset and contains(' Duration ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' Duration ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' Duration ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Duration ',@typeRef)]) or (self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event  RelativeEvent ',@typeRef)]) or (self::Duration and //*[(self::Duration or (self::Offset and contains(' Duration ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' Duration ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' Duration ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef and contains(' Duration ',substring-after(@xsi:type,':'))]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(RetentionPeriod : <sch:value-of select="$uid"/>) The RetentionPeriod.LatestEnd contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PeriodOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RetentionPeriod.Start : EventOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RetentionPeriod') or (self::RetentionPeriod and not(@xsi:type)))]/Start/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event  RelativeEvent ',@typeRef)]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(RetentionPeriod : <sch:value-of select="$uid"/>) The RetentionPeriod.Start contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EventOrDateSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Risk"/>
   <sch:pattern id="RiskConsequence"><!--(Ref to E) RiskView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RiskConsequence') or (self::RiskView and substring-after(@xsi:type,':')='RiskConsequence'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(RiskConsequence : <sch:value-of select="$uid"/>) The RiskConsequence.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RiskView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RiskConsequence') or (self::RiskView and substring-after(@xsi:type,':')='RiskConsequence'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(RiskConsequence : <sch:value-of select="$uid"/>) The RiskConsequence.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of RiskVersion.Views :: PartProperty) RiskView.ViewOf : RiskVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="RiskEvent"><!--(Ref to S) RiskEvent.Probability : OPTIONAL SET[1:unbounded] OF ProbabilitySelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RiskEvent') or (self::AssignmentObject and substring-after(@xsi:type,':')='RiskEvent'))]/Probability/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ExternalValue and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalValue ',@typeRef)]) or (*[(self::NumericalValue or (self::Quantity and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',@typeRef)]) or (self::StringValue and //ExternalRefBaseObject[@uid = $uidRef and contains(' StringValue ',@typeRef)]) or (self::ExternalValue and //PropertyValue[@uid = $uidRef and contains(' ExternalValue ',substring-after(@xsi:type,':'))]) or (self::NumericalValue and //*[(self::NumericalValue or (self::Quantity and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef and contains(' NumericalValue  Duration  ProbabilityDerived  ValueLimit ',substring-after(@xsi:type,':'))]) or (self::StringValue and //PropertyValue[@uid = $uidRef and contains(' StringValue ',substring-after(@xsi:type,':'))])">(RiskEvent : <sch:value-of select="$uid"/>) The RiskEvent.Probability contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProbabilitySelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ActivityMethodAssignment.AssignedActivityMethod : ActivityMethod (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RiskEvent') or (self::AssignmentObject and substring-after(@xsi:type,':')='RiskEvent'))]/AssignedActivityMethod">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(RiskEvent : <sch:value-of select="$uid"/>) The RiskEvent.AssignedActivityMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ActivityMethodAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=AssignmentObject.Role)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RiskEvent') or (self::AssignmentObject and substring-after(@xsi:type,':')='RiskEvent'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RiskEvent : <sch:value-of select="$uid"/>) The RiskEvent.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RiskImpactAssignment"><!--(Ref to S) RiskImpactAssignment.AssignedRiskImpact : RiskImpactAssignmentSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RiskImpactAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='RiskImpactAssignment'))]/AssignedRiskImpact">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItem ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' State  StateObserved  StatePredicted ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionConfirmedAssociation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionHypothesisAssociation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionRelationship  StateDefinitionCauseEffect  StateDefinitionComposition  StateDefinitionTransition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionStateAssociationRelationship  StateHypothesisToConfirmationRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateRelationship  StateCauseEffect  StateComposition  StatePredictedToObserved  StateTransition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' System ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)] or //Activity[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' ActivityAssignment ',substring-after(@xsi:type,':'))] or //ActivityMethod[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',substring-after(@xsi:type,':'))] or //Approval[@uid = $uidRef] or //Condition[@uid = $uidRef] or //IndividualPart[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',substring-after(@xsi:type,':'))] or //IndividualPartView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',substring-after(@xsi:type,':'))] or //Organization[@uid = $uidRef] or //Part[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' PartVersionRelationship ',substring-after(@xsi:type,':'))] or //PartView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',substring-after(@xsi:type,':'))] or //Person[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',substring-after(@xsi:type,':'))] or //PropertyDefinition[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',substring-after(@xsi:type,':'))] or //PropertyValue[@uid = $uidRef] or //Requirement[@uid = $uidRef] or //RequirementVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' RequirementVersionRelationship ',substring-after(@xsi:type,':'))] or //RequirementView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',substring-after(@xsi:type,':'))] or //ResourceItem[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' ResourceItemAssignment ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',substring-after(@xsi:type,':'))] or //Scheme[@uid = $uidRef] or //SchemeEntry[@uid = $uidRef] or //SchemeVersion[@uid = $uidRef] or //State[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' StateAssignment ',substring-after(@xsi:type,':'))] or //AssociationObject[@uid = $uidRef and contains(' StateDefinitionConfirmedAssociation ',substring-after(@xsi:type,':'))] or //AssociationObject[@uid = $uidRef and contains(' StateDefinitionHypothesisAssociation ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' StateDefinitionRelationship  StateDefinitionCauseEffect  StateDefinitionComposition  StateDefinitionTransition ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' StateDefinitionStateAssociationRelationship  StateHypothesisToConfirmationRelationship ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' StateRelationship  StateCauseEffect  StateComposition  StatePredictedToObserved  StateTransition ',substring-after(@xsi:type,':'))] or //System[@uid = $uidRef] or //SystemVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' SystemVersionRelationship ',substring-after(@xsi:type,':'))] or //SystemView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' SystemViewRelationship ',substring-after(@xsi:type,':'))] or //TaskElement[@uid = $uidRef] or //TaskMethod[@uid = $uidRef] or //TaskMethodVersion[@uid = $uidRef]">(RiskImpactAssignment : <sch:value-of select="$uid"/>) The RiskImpactAssignment.AssignedRiskImpact contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of RiskImpactAssignmentSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RiskImpactAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='RiskImpactAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RiskImpactAssignment : <sch:value-of select="$uid"/>) The RiskImpactAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RiskPerception"><!--(Ref to E) RiskView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RiskPerception') or (self::RiskView and substring-after(@xsi:type,':')='RiskPerception'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(RiskPerception : <sch:value-of select="$uid"/>) The RiskPerception.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RiskView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RiskPerception') or (self::RiskView and substring-after(@xsi:type,':')='RiskPerception'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(RiskPerception : <sch:value-of select="$uid"/>) The RiskPerception.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of RiskVersion.Views :: PartProperty) RiskView.ViewOf : RiskVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="RiskPerceptionRelationship"><!--(Ref to E) RiskPerceptionRelationship.Related : RiskPerception (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RiskPerceptionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RiskPerceptionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RiskPerception'] or //RiskView[@uid = $uidRef and contains(' RiskPerception ',substring-after(@xsi:type,':'))]">(RiskPerceptionRelationship : <sch:value-of select="$uid"/>) The RiskPerceptionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RiskPerception.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RiskPerceptionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RiskPerceptionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RiskPerceptionRelationship : <sch:value-of select="$uid"/>) The RiskPerceptionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RiskPerceptionSourceAssignment"><!--(Ref to S) RiskPerceptionSourceAssignment.AssignedRiskSource : RiskPerceptionSourceAssignmentSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RiskPerceptionSourceAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='RiskPerceptionSourceAssignment'))]/AssignedRiskSource">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment  PartialDocumentAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Justification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' JustificationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' JustificationRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' JustificationSupportAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItem ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRealization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' State  StateObserved  StatePredicted ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionConfirmedAssociation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionHypothesisAssociation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionRelationship  StateDefinitionCauseEffect  StateDefinitionComposition  StateDefinitionTransition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionStateAssociationRelationship  StateHypothesisToConfirmationRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateRelationship  StateCauseEffect  StateComposition  StatePredictedToObserved  StateTransition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' System ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)] or //Activity[@uid = $uidRef] or //ActivityMethod[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',substring-after(@xsi:type,':'))] or //Approval[@uid = $uidRef] or //Condition[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' DocumentAssignment  PartialDocumentAssignment ',substring-after(@xsi:type,':'))] or //File[@uid = $uidRef] or //IndividualPart[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',substring-after(@xsi:type,':'))] or //IndividualPartView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',substring-after(@xsi:type,':'))] or //Justification[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' JustificationAssignment ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' JustificationRelationship ',substring-after(@xsi:type,':'))] or //AssignmentObject[@uid = $uidRef and contains(' JustificationSupportAssignment ',substring-after(@xsi:type,':'))] or //Observation[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' ObservationAssignment ',substring-after(@xsi:type,':'))] or //Organization[@uid = $uidRef] or //Part[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' PartVersionRelationship ',substring-after(@xsi:type,':'))] or //PartView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',substring-after(@xsi:type,':'))] or //Person[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',substring-after(@xsi:type,':'))] or //PropertyDefinition[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',substring-after(@xsi:type,':'))] or //PropertyValue[@uid = $uidRef] or //Requirement[@uid = $uidRef] or //RequirementVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' RequirementVersionRelationship ',substring-after(@xsi:type,':'))] or //RequirementView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',substring-after(@xsi:type,':'))] or //ResourceItem[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' ResourceItemAssignment ',substring-after(@xsi:type,':'))] or //AssociationObject[@uid = $uidRef and contains(' ResourceItemRealization ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',substring-after(@xsi:type,':'))] or //Scheme[@uid = $uidRef] or //SchemeEntry[@uid = $uidRef] or //SchemeVersion[@uid = $uidRef] or //State[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' StateAssignment ',substring-after(@xsi:type,':'))] or //StateDefinition[@uid = $uidRef] or //AssociationObject[@uid = $uidRef and contains(' StateDefinitionConfirmedAssociation ',substring-after(@xsi:type,':'))] or //AssociationObject[@uid = $uidRef and contains(' StateDefinitionHypothesisAssociation ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' StateDefinitionRelationship  StateDefinitionCauseEffect  StateDefinitionComposition  StateDefinitionTransition ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' StateDefinitionStateAssociationRelationship  StateHypothesisToConfirmationRelationship ',substring-after(@xsi:type,':'))] or //RelationshipObject[@uid = $uidRef and contains(' StateRelationship  StateCauseEffect  StateComposition  StatePredictedToObserved  StateTransition ',substring-after(@xsi:type,':'))] or //System[@uid = $uidRef] or //SystemVersion[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' SystemVersionRelationship ',substring-after(@xsi:type,':'))] or //SystemView[@uid = $uidRef] or //RelationshipObject[@uid = $uidRef and contains(' SystemViewRelationship ',substring-after(@xsi:type,':'))] or //TaskElement[@uid = $uidRef] or //TaskMethod[@uid = $uidRef] or //TaskMethodVersion[@uid = $uidRef]">(RiskPerceptionSourceAssignment : <sch:value-of select="$uid"/>) The RiskPerceptionSourceAssignment.AssignedRiskSource contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of RiskPerceptionSourceAssignmentSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RiskPerceptionSourceAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='RiskPerceptionSourceAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RiskPerceptionSourceAssignment : <sch:value-of select="$uid"/>) The RiskPerceptionSourceAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RiskRelationship"><!--(Ref to E) RiskRelationship.Related : Risk (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RiskRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RiskRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Risk'] or //Risk[@uid = $uidRef]">(RiskRelationship : <sch:value-of select="$uid"/>) The RiskRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Risk.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RiskRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RiskRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='RiskRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RiskRelationship : <sch:value-of select="$uid"/>) The RiskRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RiskVersion"><!--(Inverse of Risk.Versions :: PartProperty) RiskVersion.VersionOf : Risk) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="Scheme"/>
   <sch:pattern id="SchemeEntry"/>
   <sch:pattern id="SchemeEntryAssignment"><!--(Ref to E) SchemeEntryAssignment.AssignedEntry : SchemeEntry (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SchemeEntryAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='SchemeEntryAssignment'))]/AssignedEntry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SchemeEntry'] or //SchemeEntry[@uid = $uidRef]">(SchemeEntryAssignment : <sch:value-of select="$uid"/>) The SchemeEntryAssignment.AssignedEntry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SchemeEntry.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SchemeEntryAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='SchemeEntryAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SchemeEntryAssignment : <sch:value-of select="$uid"/>) The SchemeEntryAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SchemeEntryRelationship"><!--(Ref to E) SchemeEntryRelationship.Related : SchemeEntry (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SchemeEntryRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SchemeEntryRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SchemeEntry'] or //SchemeEntry[@uid = $uidRef]">(SchemeEntryRelationship : <sch:value-of select="$uid"/>) The SchemeEntryRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SchemeEntry.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SchemeEntryRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SchemeEntryRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SchemeEntryRelationship : <sch:value-of select="$uid"/>) The SchemeEntryRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SchemeRelationship"><!--(Ref to E) SchemeRelationship.Related : Scheme (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SchemeRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SchemeRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Scheme'] or //Scheme[@uid = $uidRef]">(SchemeRelationship : <sch:value-of select="$uid"/>) The SchemeRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Scheme.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SchemeRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SchemeRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SchemeRelationship : <sch:value-of select="$uid"/>) The SchemeRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SchemeSubjectAssignment"><!--(Ref to E) SchemeSubjectAssignment.AssignedScheme : Scheme (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SchemeSubjectAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='SchemeSubjectAssignment'))]/AssignedScheme">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Scheme'] or //Scheme[@uid = $uidRef]">(SchemeSubjectAssignment : <sch:value-of select="$uid"/>) The SchemeSubjectAssignment.AssignedScheme contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Scheme.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SchemeSubjectAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='SchemeSubjectAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SchemeSubjectAssignment : <sch:value-of select="$uid"/>) The SchemeSubjectAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SchemeVersion"/>
   <sch:pattern id="SchemeVersionAssignment"><!--(Ref to E) SchemeVersionAssignment.AssignedSchemeVersion : SchemeVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SchemeVersionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='SchemeVersionAssignment'))]/AssignedSchemeVersion">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SchemeVersion'] or //SchemeVersion[@uid = $uidRef]">(SchemeVersionAssignment : <sch:value-of select="$uid"/>) The SchemeVersionAssignment.AssignedSchemeVersion contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SchemeVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SchemeVersionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='SchemeVersionAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SchemeVersionAssignment : <sch:value-of select="$uid"/>) The SchemeVersionAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SchemeVersionRelationship"><!--(Ref to E) SchemeVersionRelationship.Related : SchemeVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SchemeVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SchemeVersionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SchemeVersion'] or //SchemeVersion[@uid = $uidRef]">(SchemeVersionRelationship : <sch:value-of select="$uid"/>) The SchemeVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SchemeVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SchemeVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SchemeVersionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SchemeVersionRelationship : <sch:value-of select="$uid"/>) The SchemeVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SecurityClassification"><!--(Ref to E) SecurityClassification.Level : SecurityClassificationLevel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SecurityClassification') or (self::SecurityClassification and not(@xsi:type)))]/Level">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SecurityClassificationLevel'] or //SecurityClassificationLevel[@uid = $uidRef]">(SecurityClassification : <sch:value-of select="$uid"/>) The SecurityClassification.Level contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SecurityClassificationLevel.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SecurityClassificationAssignment"><!--(Ref to E) SecurityClassificationAssignment.AssignedSecurityClassification : SecurityClassification (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SecurityClassificationAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='SecurityClassificationAssignment'))]/AssignedSecurityClassification">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SecurityClassification'] or //SecurityClassification[@uid = $uidRef]">(SecurityClassificationAssignment : <sch:value-of select="$uid"/>) The SecurityClassificationAssignment.AssignedSecurityClassification contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SecurityClassification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SecurityClassificationAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='SecurityClassificationAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SecurityClassificationAssignment : <sch:value-of select="$uid"/>) The SecurityClassificationAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SecurityClassificationLevel"><!--(Ref to S) SecurityClassificationLevel.Definition : ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SecurityClassificationLevel') or (self::SecurityClassificationLevel and not(@xsi:type)))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(SecurityClassificationLevel : <sch:value-of select="$uid"/>) The SecurityClassificationLevel.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SequencingRelationship"><!--(Ref to E) SequencingRelationship.SequencingType : Classification (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SequencingRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SequencingRelationship'))]/SequencingType">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SequencingRelationship : <sch:value-of select="$uid"/>) The SequencingRelationship.SequencingType contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) SequencingRelationship.TimeLag : OPTIONAL TimeInterval (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SequencingRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SequencingRelationship'))]/TimeLag">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./TimeLag) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'TimeInterval'] or //TimeInterval[@uid = $uidRef] or //*[@uid = $uidRef and (self::AssignedTimeInterval)]">(SequencingRelationship : <sch:value-of select="$uid"/>) The SequencingRelationship.TimeLag contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type TimeInterval.</sch:assert>
      </sch:rule>
      <!--(Ref to E) SchemeEntryRelationship.Related : SchemeEntry (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SequencingRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SequencingRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SchemeEntry'] or //SchemeEntry[@uid = $uidRef]">(SequencingRelationship : <sch:value-of select="$uid"/>) The SequencingRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SchemeEntry.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SequencingRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SequencingRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SequencingRelationship : <sch:value-of select="$uid"/>) The SequencingRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SerialEffectivity"><!--(Ref to S) SerialEffectivity.EndId : OPTIONAL SingleIdentifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SerialEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='SerialEffectivity'))]/EndId/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::Identifier) or (self::IdentifierString)">(SerialEffectivity : <sch:value-of select="$uid"/>) The SerialEffectivity.EndId contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of SingleIdentifierSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) SerialEffectivity.StartId : SingleIdentifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SerialEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='SerialEffectivity'))]/StartId/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::Identifier) or (self::IdentifierString)">(SerialEffectivity : <sch:value-of select="$uid"/>) The SerialEffectivity.StartId contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of SingleIdentifierSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SerialEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='SerialEffectivity'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(SerialEffectivity : <sch:value-of select="$uid"/>) The SerialEffectivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Effectivity.EffectivityContext : OPTIONAL EffectivityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SerialEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='SerialEffectivity'))]/EffectivityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //Activity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef]">(SerialEffectivity : <sch:value-of select="$uid"/>) The SerialEffectivity.EffectivityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EffectivityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SetMembership"><!--(Ref to S) SetMembership.Member : ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SetMembership') or (self::SetMembership and not(@xsi:type)))]/Member/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(SetMembership : <sch:value-of select="$uid"/>) The SetMembership.Member contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SimplePersonName"/>
   <sch:pattern id="SimultaneousElements"/>
   <sch:pattern id="SingleOccurrence"><!--(Ref to E) Occurrence.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SingleOccurrence') or (self::Occurrence and substring-after(@xsi:type,':')='SingleOccurrence'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(SingleOccurrence : <sch:value-of select="$uid"/>) The SingleOccurrence.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Slot"/>
   <sch:pattern id="SlotAsPlanned"><!--(Inverse of Slot.Versions :: PartProperty) SlotVersion.VersionOf : Slot) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="SlotAsRealized"><!--(Inverse of Slot.Versions :: PartProperty) SlotVersion.VersionOf : Slot) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="SlotDefinition"><!--(Ref to E) SlotDefinition.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SlotDefinition') or (self::SlotDefinition and not(@xsi:type)))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(SlotDefinition : <sch:value-of select="$uid"/>) The SlotDefinition.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) SlotDefinition.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SlotDefinition') or (self::SlotDefinition and not(@xsi:type)))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(SlotDefinition : <sch:value-of select="$uid"/>) The SlotDefinition.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) SlotDefinition.DefinitionOf : SlotVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SlotDefinition') or (self::SlotDefinition and not(@xsi:type)))]/DefinitionOf">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SlotVersion'] or //SlotVersion[@uid = $uidRef] or //*[@uid = $uidRef and (self::Design or self::Planned or self::Design or self::Realized or self::Planned or self::Realized)]">(SlotDefinition : <sch:value-of select="$uid"/>) The SlotDefinition.DefinitionOf contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SlotVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to E) SlotDefinition.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SlotDefinition') or (self::SlotDefinition and not(@xsi:type)))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(SlotDefinition : <sch:value-of select="$uid"/>) The SlotDefinition.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SlotDefinitionRelationship"><!--(Ref to E) SlotDefinitionRelationship.Related : SlotDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SlotDefinitionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SlotDefinitionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SlotDefinition'] or //SlotDefinition[@uid = $uidRef]">(SlotDefinitionRelationship : <sch:value-of select="$uid"/>) The SlotDefinitionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SlotDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SlotDefinitionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SlotDefinitionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SlotDefinitionRelationship : <sch:value-of select="$uid"/>) The SlotDefinitionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SlotDesign"><!--(Inverse of Slot.Versions :: PartProperty) SlotVersion.VersionOf : Slot) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="SlotDesignToPlanned"><!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SlotDesignToPlanned') or (self::RelationshipObject and substring-after(@xsi:type,':')='SlotDesignToPlanned'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SlotDesignToPlanned : <sch:value-of select="$uid"/>) The SlotDesignToPlanned.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SlotDesignToRealized"><!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SlotDesignToRealized') or (self::RelationshipObject and substring-after(@xsi:type,':')='SlotDesignToRealized'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SlotDesignToRealized : <sch:value-of select="$uid"/>) The SlotDesignToRealized.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SlotOn"><!--(Ref to S) SlotOn.SlotOn : SlotOnSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SlotOn') or (self::AssociationObject and substring-after(@xsi:type,':')='SlotOn'))]/SlotOn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemView ',@typeRef)] or //BreakdownElementView[@uid = $uidRef] or //IndividualPartView[@uid = $uidRef] or //PartView[@uid = $uidRef] or //SystemView[@uid = $uidRef]">(SlotOn : <sch:value-of select="$uid"/>) The SlotOn.SlotOn contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of SlotOnSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SlotPlannedToRealized"><!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SlotPlannedToRealized') or (self::RelationshipObject and substring-after(@xsi:type,':')='SlotPlannedToRealized'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SlotPlannedToRealized : <sch:value-of select="$uid"/>) The SlotPlannedToRealized.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SlotVersion"><!--(Inverse of Slot.Versions :: PartProperty) SlotVersion.VersionOf : Slot) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="Specification"><!--(Ref to E) Specification.Category : SpecificationCategory (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Specification') or (self::Specification and not(@xsi:type)))]/Category">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SpecificationCategory'] or //SpecificationCategory[@uid = $uidRef]">(Specification : <sch:value-of select="$uid"/>) The Specification.Category contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SpecificationCategory.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SpecificationAssignment"><!--(Ref to E) SpecificationAssignment.AssignedSpecification : Specification (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='SpecificationAssignment'))]/AssignedSpecification">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Specification'] or //Specification[@uid = $uidRef]">(SpecificationAssignment : <sch:value-of select="$uid"/>) The SpecificationAssignment.AssignedSpecification contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Specification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) SpecificationAssignment.AssociationType : ClassSelect (kind=AGGREGATE - redefined=AssignmentObject.Role)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='SpecificationAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SpecificationAssignment : <sch:value-of select="$uid"/>) The SpecificationAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SpecificationCategory"/>
   <sch:pattern id="SpecificationCategoryAssignment"><!--(Ref to E) SpecificationCategoryAssignment.AssignedCategory : SpecificationCategory (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationCategoryAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='SpecificationCategoryAssignment'))]/AssignedCategory">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SpecificationCategory'] or //SpecificationCategory[@uid = $uidRef]">(SpecificationCategoryAssignment : <sch:value-of select="$uid"/>) The SpecificationCategoryAssignment.AssignedCategory contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SpecificationCategory.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationCategoryAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='SpecificationCategoryAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SpecificationCategoryAssignment : <sch:value-of select="$uid"/>) The SpecificationCategoryAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SpecificationCategoryHierarchy"><!--(Ref to E) SpecificationCategoryHierarchy.SubCategory : SpecificationCategory (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationCategoryHierarchy') or (self::SpecificationCategoryHierarchy and not(@xsi:type)))]/SubCategory">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SpecificationCategory'] or //SpecificationCategory[@uid = $uidRef]">(SpecificationCategoryHierarchy : <sch:value-of select="$uid"/>) The SpecificationCategoryHierarchy.SubCategory contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SpecificationCategory.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SpecificationConditionAssignment"><!--(Ref to S) SpecificationConditionAssignment.ConditionType : ClassSelect (kind=AGGREGATE - redefined=AssignmentObject.Role)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationConditionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='SpecificationConditionAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SpecificationConditionAssignment : <sch:value-of select="$uid"/>) The SpecificationConditionAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SpecificationInclusion"><!--(Ref to S) SpecificationInclusion.IfCondition : ConditionParameterSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationInclusion') or (self::SpecificationInclusion or (self::AssignedInclusion and substring-after(@xsi:type,':')='SpecificationInclusion')))]/IfCondition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment  RiskEvent ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::Approval and //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',@typeRef)]) or (self::BreakdownOf and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownOf ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (self::Collection and //ExternalRefBaseObject[@uid = $uidRef and contains(' Collection ',@typeRef)]) or (self::CollectionMembershipRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionMembershipRelationship ',@typeRef)]) or (self::CollectionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionRelationship ',@typeRef)]) or (self::CollectionVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)]) or (self::CollectionView and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Condition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConditionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionRelationship ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::Descriptor and //ExternalRefBaseObject[@uid = $uidRef and contains(' Descriptor ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment  PartialDocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (*[(self::EnvironmentView or (self::AssignedEnvironment and contains(' EnvironmentView  EnvironmentDefinitionView  ObservedEnvironmentView ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvironmentView  EnvironmentDefinitionView  ObservedEnvironmentView ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::Evidence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Evidence ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::InterfaceConnection and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnection  HierarchicalInterfaceConnection ',@typeRef)]) or (self::InterfaceConnector and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)]) or (self::InterfaceConnectorOccurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)]) or (self::InterfaceConnectorOccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',@typeRef)]) or (self::InterfaceConnectorRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorRelationship ',@typeRef)]) or (self::InterfaceConnectorVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)]) or (self::InterfaceConnectorVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersionRelationship ',@typeRef)]) or (self::InterfaceConnectorView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)]) or (self::InterfaceConnectorViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',@typeRef)]) or (self::InterfaceDefinitionConnection and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceDefinitionConnection ',@typeRef)]) or (self::InterfaceSpecification and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)]) or (self::InterfaceSpecificationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationRelationship ',@typeRef)]) or (self::InterfaceSpecificationVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)]) or (self::InterfaceSpecificationVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersionRelationship ',@typeRef)]) or (self::InterfaceSpecificationView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)]) or (self::InterfaceSpecificationViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',@typeRef)]) or (self::ManagedResource and //ExternalRefBaseObject[@uid = $uidRef and contains(' ManagedResource ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',@typeRef)]) or (self::PersonOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',@typeRef)]) or (self::ProductConcept and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (self::RequiredResource and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequiredResource ',@typeRef)]) or (self::RequiredResourceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequiredResourceRelationship ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::ResourceAsRealized and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealized ',@typeRef)]) or (self::ResourceAsRealizedAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealizedAssociation ',@typeRef)]) or (self::ResourceEvent and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceEvent  DecreasingResourceEvent  IncreasingResourceEvent ',@typeRef)]) or (self::ResourceItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItem ',@typeRef)]) or (self::ResourceItemAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemAssignment ',@typeRef)]) or (self::ResourceItemRealization and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRealization ',@typeRef)]) or (self::ResourceItemRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',@typeRef)]) or (self::Risk and //ExternalRefBaseObject[@uid = $uidRef and contains(' Risk ',@typeRef)]) or (self::RiskVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)]) or (self::RiskView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)]) or (self::Scheme and //ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)]) or (self::SchemeEntry and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)]) or (self::SchemeVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Slot and //ExternalRefBaseObject[@uid = $uidRef and contains(' Slot ',@typeRef)]) or (self::SlotDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)]) or (self::SlotDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinitionRelationship ',@typeRef)]) or (*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::System and //ExternalRefBaseObject[@uid = $uidRef and contains(' System ',@typeRef)]) or (self::SystemVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)]) or (self::SystemView and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemView ',@typeRef)]) or (self::SystemViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemViewRelationship ',@typeRef)]) or (*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)]) or (self::TaskElementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElementAssignment ',@typeRef)]) or (self::TaskMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)]) or (self::TaskMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodAssignment ',@typeRef)]) or (self::TaskMethodVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)]) or (self::TaskMethodVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersionAssignment ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::Validation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Validation ',@typeRef)]) or (self::Verification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Verification ',@typeRef)]) or (self::VerificationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' VerificationRelationship ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //AssignmentObject[@uid = $uidRef and contains(' ActivityAssignment ',substring-after(@xsi:type,':'))]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //AssignmentObject[@uid = $uidRef and contains(' ActivityMethodAssignment  RiskEvent ',substring-after(@xsi:type,':'))]) or (self::AddressAssignment and //AssignmentObject[@uid = $uidRef and contains(' AddressAssignment ',substring-after(@xsi:type,':'))]) or (self::Approval and //Approval[@uid = $uidRef]) or (self::ApprovalAssignment and //AssignmentObject[@uid = $uidRef and contains(' ApprovalAssignment ',substring-after(@xsi:type,':'))]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',substring-after(@xsi:type,':'))]) or (self::BreakdownOf and //AssociationObject[@uid = $uidRef and contains(' BreakdownOf ',substring-after(@xsi:type,':'))]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::CertificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' CertificationAssignment ',substring-after(@xsi:type,':'))]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::Collection and //Collection[@uid = $uidRef]) or (self::CollectionMembershipRelationship and //RelationshipObject[@uid = $uidRef and contains(' CollectionMembershipRelationship ',substring-after(@xsi:type,':'))]) or (self::CollectionRelationship and //RelationshipObject[@uid = $uidRef and contains(' CollectionRelationship ',substring-after(@xsi:type,':'))]) or (self::CollectionVersion and //CollectionVersion[@uid = $uidRef]) or (self::CollectionView and //CollectionView[@uid = $uidRef]) or (self::Condition) or (self::ConditionAssignment and //AssignmentObject[@uid = $uidRef and contains(' ConditionAssignment ',substring-after(@xsi:type,':'))]) or (self::ConditionRelationship and //RelationshipObject[@uid = $uidRef and contains(' ConditionRelationship ',substring-after(@xsi:type,':'))]) or (self::ContractAssignment and //AssignmentObject[@uid = $uidRef and contains(' ContractAssignment ',substring-after(@xsi:type,':'))]) or (self::DateTimeAssignment and //AssignmentObject[@uid = $uidRef and contains(' DateTimeAssignment ',substring-after(@xsi:type,':'))]) or (self::DateTimeString) or (self::Descriptor and //Descriptor[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //AssignmentObject[@uid = $uidRef and contains(' DocumentAssignment  PartialDocumentAssignment ',substring-after(@xsi:type,':'))]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',substring-after(@xsi:type,':'))]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //AssignmentObject[@uid = $uidRef and contains(' EffectivityAssignment ',substring-after(@xsi:type,':'))]) or (self::EnvironmentView and //*[(self::EnvironmentView or (self::AssignedEnvironment and contains(' EnvironmentView  EnvironmentDefinitionView  ObservedEnvironmentView ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::EventAssignment and //AssignmentObject[@uid = $uidRef and contains(' EventAssignment ',substring-after(@xsi:type,':'))]) or (self::Evidence and //Evidence[@uid = $uidRef]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',substring-after(@xsi:type,':'))]) or (self::InformationUsageRightAssignment and //AssignmentObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnection and //InterfaceConnection[@uid = $uidRef]) or (self::InterfaceConnector and //InterfaceConnector[@uid = $uidRef]) or (self::InterfaceConnectorOccurrence and //InterfaceConnectorOccurrence[@uid = $uidRef]) or (self::InterfaceConnectorOccurrenceRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorVersion and //InterfaceConnectorVersion[@uid = $uidRef]) or (self::InterfaceConnectorVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorView and //InterfaceConnectorView[@uid = $uidRef]) or (self::InterfaceConnectorViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceDefinitionConnection and //InterfaceDefinitionConnection[@uid = $uidRef]) or (self::InterfaceSpecification and //InterfaceSpecification[@uid = $uidRef]) or (self::InterfaceSpecificationRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceSpecificationVersion and //InterfaceSpecificationVersion[@uid = $uidRef]) or (self::InterfaceSpecificationVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceSpecificationView and //InterfaceSpecificationView[@uid = $uidRef]) or (self::InterfaceSpecificationViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',substring-after(@xsi:type,':'))]) or (self::ManagedResource and //ManagedResource[@uid = $uidRef]) or (self::ObservationAssignment and //AssignmentObject[@uid = $uidRef and contains(' ObservationAssignment ',substring-after(@xsi:type,':'))]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',substring-after(@xsi:type,':'))]) or (self::PersonOrganizationAssignment and //AssignmentObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',substring-after(@xsi:type,':'))]) or (self::ProductConcept and //ProductConcept[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProjectAssignment and //AssignmentObject[@uid = $uidRef and contains(' ProjectAssignment ',substring-after(@xsi:type,':'))]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //AssignmentObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',substring-after(@xsi:type,':'))]) or (self::PropertyDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',substring-after(@xsi:type,':'))]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //AssignmentObject[@uid = $uidRef and contains(' PropertyValueAssignment ',substring-after(@xsi:type,':'))]) or (self::PropertyValueRelationship and //RelationshipObject[@uid = $uidRef and contains(' PropertyValueRelationship ',substring-after(@xsi:type,':'))]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::RequiredResource and //RequiredResource[@uid = $uidRef]) or (self::RequiredResourceRelationship and //RelationshipObject[@uid = $uidRef and contains(' RequiredResourceRelationship ',substring-after(@xsi:type,':'))]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //AssignmentObject[@uid = $uidRef and contains(' RequirementAssignment ',substring-after(@xsi:type,':'))]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',substring-after(@xsi:type,':'))]) or (self::ResourceAsRealized and //ResourceAsRealized[@uid = $uidRef]) or (self::ResourceAsRealizedAssociation and //AssociationObject[@uid = $uidRef and contains(' ResourceAsRealizedAssociation ',substring-after(@xsi:type,':'))]) or (self::ResourceEvent and //ResourceEvent[@uid = $uidRef]) or (self::ResourceItem and //ResourceItem[@uid = $uidRef]) or (self::ResourceItemAssignment and //AssignmentObject[@uid = $uidRef and contains(' ResourceItemAssignment ',substring-after(@xsi:type,':'))]) or (self::ResourceItemRealization and //AssociationObject[@uid = $uidRef and contains(' ResourceItemRealization ',substring-after(@xsi:type,':'))]) or (self::ResourceItemRelationship and //RelationshipObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',substring-after(@xsi:type,':'))]) or (self::Risk and //Risk[@uid = $uidRef]) or (self::RiskVersion and //RiskVersion[@uid = $uidRef]) or (self::RiskView and //RiskView[@uid = $uidRef]) or (self::Scheme and //Scheme[@uid = $uidRef]) or (self::SchemeEntry and //SchemeEntry[@uid = $uidRef]) or (self::SchemeVersion and //SchemeVersion[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',substring-after(@xsi:type,':'))]) or (self::Slot and //Slot[@uid = $uidRef]) or (self::SlotDefinition and //SlotDefinition[@uid = $uidRef]) or (self::SlotDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' SlotDefinitionRelationship ',substring-after(@xsi:type,':'))]) or (self::SlotVersion and //*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' SpecificationAssignment ',substring-after(@xsi:type,':'))]) or (self::SpecificationCategoryAssignment and //AssignmentObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',substring-after(@xsi:type,':'))]) or (self::SpecificationConditionAssignment and //AssignmentObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',substring-after(@xsi:type,':'))]) or (self::SpecificationInclusionAssignment and //AssignmentObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',substring-after(@xsi:type,':'))]) or (self::System and //System[@uid = $uidRef]) or (self::SystemVersion and //SystemVersion[@uid = $uidRef]) or (self::SystemView and //SystemView[@uid = $uidRef]) or (self::SystemViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' SystemViewRelationship ',substring-after(@xsi:type,':'))]) or (self::TaskElement and //*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::TaskElementAssignment and //AssignmentObject[@uid = $uidRef and contains(' TaskElementAssignment ',substring-after(@xsi:type,':'))]) or (self::TaskMethod and //TaskMethod[@uid = $uidRef]) or (self::TaskMethodAssignment and //AssignmentObject[@uid = $uidRef and contains(' TaskMethodAssignment ',substring-after(@xsi:type,':'))]) or (self::TaskMethodVersion and //TaskMethodVersion[@uid = $uidRef]) or (self::TaskMethodVersionAssignment and //AssignmentObject[@uid = $uidRef and contains(' TaskMethodVersionAssignment ',substring-after(@xsi:type,':'))]) or (self::TimeIntervalAssignment and //AssignmentObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',substring-after(@xsi:type,':'))]) or (self::Validation and //Validation[@uid = $uidRef]) or (self::Verification and //Verification[@uid = $uidRef]) or (self::VerificationRelationship and //RelationshipObject[@uid = $uidRef and contains(' VerificationRelationship ',substring-after(@xsi:type,':'))]) or (self::WorkOrderAssignment and //AssignmentObject[@uid = $uidRef and contains(' WorkOrderAssignment ',substring-after(@xsi:type,':'))]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef]) or (self::WorkRequestAssignment and //AssignmentObject[@uid = $uidRef and contains(' WorkRequestAssignment ',substring-after(@xsi:type,':'))])">(SpecificationInclusion : <sch:value-of select="$uid"/>) The SpecificationInclusion.IfCondition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ConditionParameterSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) SpecificationInclusion.IncludedSpecification : ConditionParameterSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationInclusion') or (self::SpecificationInclusion or (self::AssignedInclusion and substring-after(@xsi:type,':')='SpecificationInclusion')))]/IncludedSpecification/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment  RiskEvent ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::Approval and //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',@typeRef)]) or (self::BreakdownOf and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownOf ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (self::Collection and //ExternalRefBaseObject[@uid = $uidRef and contains(' Collection ',@typeRef)]) or (self::CollectionMembershipRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionMembershipRelationship ',@typeRef)]) or (self::CollectionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionRelationship ',@typeRef)]) or (self::CollectionVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)]) or (self::CollectionView and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Condition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConditionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionRelationship ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::Descriptor and //ExternalRefBaseObject[@uid = $uidRef and contains(' Descriptor ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment  PartialDocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (*[(self::EnvironmentView or (self::AssignedEnvironment and contains(' EnvironmentView  EnvironmentDefinitionView  ObservedEnvironmentView ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' EnvironmentView  EnvironmentDefinitionView  ObservedEnvironmentView ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::Evidence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Evidence ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::InterfaceConnection and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnection  HierarchicalInterfaceConnection ',@typeRef)]) or (self::InterfaceConnector and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)]) or (self::InterfaceConnectorOccurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)]) or (self::InterfaceConnectorOccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',@typeRef)]) or (self::InterfaceConnectorRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorRelationship ',@typeRef)]) or (self::InterfaceConnectorVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)]) or (self::InterfaceConnectorVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersionRelationship ',@typeRef)]) or (self::InterfaceConnectorView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)]) or (self::InterfaceConnectorViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',@typeRef)]) or (self::InterfaceDefinitionConnection and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceDefinitionConnection ',@typeRef)]) or (self::InterfaceSpecification and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)]) or (self::InterfaceSpecificationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationRelationship ',@typeRef)]) or (self::InterfaceSpecificationVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)]) or (self::InterfaceSpecificationVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersionRelationship ',@typeRef)]) or (self::InterfaceSpecificationView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)]) or (self::InterfaceSpecificationViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',@typeRef)]) or (self::ManagedResource and //ExternalRefBaseObject[@uid = $uidRef and contains(' ManagedResource ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',@typeRef)]) or (self::PersonOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',@typeRef)]) or (self::ProductConcept and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (self::RequiredResource and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequiredResource ',@typeRef)]) or (self::RequiredResourceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequiredResourceRelationship ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::ResourceAsRealized and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealized ',@typeRef)]) or (self::ResourceAsRealizedAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealizedAssociation ',@typeRef)]) or (self::ResourceEvent and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceEvent  DecreasingResourceEvent  IncreasingResourceEvent ',@typeRef)]) or (self::ResourceItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItem ',@typeRef)]) or (self::ResourceItemAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemAssignment ',@typeRef)]) or (self::ResourceItemRealization and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRealization ',@typeRef)]) or (self::ResourceItemRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',@typeRef)]) or (self::Risk and //ExternalRefBaseObject[@uid = $uidRef and contains(' Risk ',@typeRef)]) or (self::RiskVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)]) or (self::RiskView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)]) or (self::Scheme and //ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)]) or (self::SchemeEntry and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)]) or (self::SchemeVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Slot and //ExternalRefBaseObject[@uid = $uidRef and contains(' Slot ',@typeRef)]) or (self::SlotDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)]) or (self::SlotDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinitionRelationship ',@typeRef)]) or (*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::System and //ExternalRefBaseObject[@uid = $uidRef and contains(' System ',@typeRef)]) or (self::SystemVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)]) or (self::SystemView and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemView ',@typeRef)]) or (self::SystemViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemViewRelationship ',@typeRef)]) or (*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)]) or (self::TaskElementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElementAssignment ',@typeRef)]) or (self::TaskMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)]) or (self::TaskMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodAssignment ',@typeRef)]) or (self::TaskMethodVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)]) or (self::TaskMethodVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersionAssignment ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::Validation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Validation ',@typeRef)]) or (self::Verification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Verification ',@typeRef)]) or (self::VerificationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' VerificationRelationship ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //AssignmentObject[@uid = $uidRef and contains(' ActivityAssignment ',substring-after(@xsi:type,':'))]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //AssignmentObject[@uid = $uidRef and contains(' ActivityMethodAssignment  RiskEvent ',substring-after(@xsi:type,':'))]) or (self::AddressAssignment and //AssignmentObject[@uid = $uidRef and contains(' AddressAssignment ',substring-after(@xsi:type,':'))]) or (self::Approval and //Approval[@uid = $uidRef]) or (self::ApprovalAssignment and //AssignmentObject[@uid = $uidRef and contains(' ApprovalAssignment ',substring-after(@xsi:type,':'))]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship  BreakdownElementHierarchy ',substring-after(@xsi:type,':'))]) or (self::BreakdownOf and //AssociationObject[@uid = $uidRef and contains(' BreakdownOf ',substring-after(@xsi:type,':'))]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::CertificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' CertificationAssignment ',substring-after(@xsi:type,':'))]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::Collection and //Collection[@uid = $uidRef]) or (self::CollectionMembershipRelationship and //RelationshipObject[@uid = $uidRef and contains(' CollectionMembershipRelationship ',substring-after(@xsi:type,':'))]) or (self::CollectionRelationship and //RelationshipObject[@uid = $uidRef and contains(' CollectionRelationship ',substring-after(@xsi:type,':'))]) or (self::CollectionVersion and //CollectionVersion[@uid = $uidRef]) or (self::CollectionView and //CollectionView[@uid = $uidRef]) or (self::Condition) or (self::ConditionAssignment and //AssignmentObject[@uid = $uidRef and contains(' ConditionAssignment ',substring-after(@xsi:type,':'))]) or (self::ConditionRelationship and //RelationshipObject[@uid = $uidRef and contains(' ConditionRelationship ',substring-after(@xsi:type,':'))]) or (self::ContractAssignment and //AssignmentObject[@uid = $uidRef and contains(' ContractAssignment ',substring-after(@xsi:type,':'))]) or (self::DateTimeAssignment and //AssignmentObject[@uid = $uidRef and contains(' DateTimeAssignment ',substring-after(@xsi:type,':'))]) or (self::DateTimeString) or (self::Descriptor and //Descriptor[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //AssignmentObject[@uid = $uidRef and contains(' DocumentAssignment  PartialDocumentAssignment ',substring-after(@xsi:type,':'))]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',substring-after(@xsi:type,':'))]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //AssignmentObject[@uid = $uidRef and contains(' EffectivityAssignment ',substring-after(@xsi:type,':'))]) or (self::EnvironmentView and //*[(self::EnvironmentView or (self::AssignedEnvironment and contains(' EnvironmentView  EnvironmentDefinitionView  ObservedEnvironmentView ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::EventAssignment and //AssignmentObject[@uid = $uidRef and contains(' EventAssignment ',substring-after(@xsi:type,':'))]) or (self::Evidence and //Evidence[@uid = $uidRef]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',substring-after(@xsi:type,':'))]) or (self::InformationUsageRightAssignment and //AssignmentObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnection and //InterfaceConnection[@uid = $uidRef]) or (self::InterfaceConnector and //InterfaceConnector[@uid = $uidRef]) or (self::InterfaceConnectorOccurrence and //InterfaceConnectorOccurrence[@uid = $uidRef]) or (self::InterfaceConnectorOccurrenceRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrenceRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorVersion and //InterfaceConnectorVersion[@uid = $uidRef]) or (self::InterfaceConnectorVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceConnectorView and //InterfaceConnectorView[@uid = $uidRef]) or (self::InterfaceConnectorViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceConnectorViewRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceDefinitionConnection and //InterfaceDefinitionConnection[@uid = $uidRef]) or (self::InterfaceSpecification and //InterfaceSpecification[@uid = $uidRef]) or (self::InterfaceSpecificationRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceSpecificationVersion and //InterfaceSpecificationVersion[@uid = $uidRef]) or (self::InterfaceSpecificationVersionRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationVersionRelationship ',substring-after(@xsi:type,':'))]) or (self::InterfaceSpecificationView and //InterfaceSpecificationView[@uid = $uidRef]) or (self::InterfaceSpecificationViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' InterfaceSpecificationViewRelationship ',substring-after(@xsi:type,':'))]) or (self::ManagedResource and //ManagedResource[@uid = $uidRef]) or (self::ObservationAssignment and //AssignmentObject[@uid = $uidRef and contains(' ObservationAssignment ',substring-after(@xsi:type,':'))]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship ',substring-after(@xsi:type,':'))]) or (self::PersonOrganizationAssignment and //AssignmentObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',substring-after(@xsi:type,':'))]) or (self::ProductConcept and //ProductConcept[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProjectAssignment and //AssignmentObject[@uid = $uidRef and contains(' ProjectAssignment ',substring-after(@xsi:type,':'))]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //AssignmentObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',substring-after(@xsi:type,':'))]) or (self::PropertyDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',substring-after(@xsi:type,':'))]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //AssignmentObject[@uid = $uidRef and contains(' PropertyValueAssignment ',substring-after(@xsi:type,':'))]) or (self::PropertyValueRelationship and //RelationshipObject[@uid = $uidRef and contains(' PropertyValueRelationship ',substring-after(@xsi:type,':'))]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::RequiredResource and //RequiredResource[@uid = $uidRef]) or (self::RequiredResourceRelationship and //RelationshipObject[@uid = $uidRef and contains(' RequiredResourceRelationship ',substring-after(@xsi:type,':'))]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //AssignmentObject[@uid = $uidRef and contains(' RequirementAssignment ',substring-after(@xsi:type,':'))]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',substring-after(@xsi:type,':'))]) or (self::ResourceAsRealized and //ResourceAsRealized[@uid = $uidRef]) or (self::ResourceAsRealizedAssociation and //AssociationObject[@uid = $uidRef and contains(' ResourceAsRealizedAssociation ',substring-after(@xsi:type,':'))]) or (self::ResourceEvent and //ResourceEvent[@uid = $uidRef]) or (self::ResourceItem and //ResourceItem[@uid = $uidRef]) or (self::ResourceItemAssignment and //AssignmentObject[@uid = $uidRef and contains(' ResourceItemAssignment ',substring-after(@xsi:type,':'))]) or (self::ResourceItemRealization and //AssociationObject[@uid = $uidRef and contains(' ResourceItemRealization ',substring-after(@xsi:type,':'))]) or (self::ResourceItemRelationship and //RelationshipObject[@uid = $uidRef and contains(' ResourceItemRelationship  ResourceGroupRelationship ',substring-after(@xsi:type,':'))]) or (self::Risk and //Risk[@uid = $uidRef]) or (self::RiskVersion and //RiskVersion[@uid = $uidRef]) or (self::RiskView and //RiskView[@uid = $uidRef]) or (self::Scheme and //Scheme[@uid = $uidRef]) or (self::SchemeEntry and //SchemeEntry[@uid = $uidRef]) or (self::SchemeVersion and //SchemeVersion[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',substring-after(@xsi:type,':'))]) or (self::Slot and //Slot[@uid = $uidRef]) or (self::SlotDefinition and //SlotDefinition[@uid = $uidRef]) or (self::SlotDefinitionRelationship and //RelationshipObject[@uid = $uidRef and contains(' SlotDefinitionRelationship ',substring-after(@xsi:type,':'))]) or (self::SlotVersion and //*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //AssignmentObject[@uid = $uidRef and contains(' SpecificationAssignment ',substring-after(@xsi:type,':'))]) or (self::SpecificationCategoryAssignment and //AssignmentObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',substring-after(@xsi:type,':'))]) or (self::SpecificationConditionAssignment and //AssignmentObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',substring-after(@xsi:type,':'))]) or (self::SpecificationInclusionAssignment and //AssignmentObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',substring-after(@xsi:type,':'))]) or (self::System and //System[@uid = $uidRef]) or (self::SystemVersion and //SystemVersion[@uid = $uidRef]) or (self::SystemView and //SystemView[@uid = $uidRef]) or (self::SystemViewRelationship and //RelationshipObject[@uid = $uidRef and contains(' SystemViewRelationship ',substring-after(@xsi:type,':'))]) or (self::TaskElement and //*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::TaskElementAssignment and //AssignmentObject[@uid = $uidRef and contains(' TaskElementAssignment ',substring-after(@xsi:type,':'))]) or (self::TaskMethod and //TaskMethod[@uid = $uidRef]) or (self::TaskMethodAssignment and //AssignmentObject[@uid = $uidRef and contains(' TaskMethodAssignment ',substring-after(@xsi:type,':'))]) or (self::TaskMethodVersion and //TaskMethodVersion[@uid = $uidRef]) or (self::TaskMethodVersionAssignment and //AssignmentObject[@uid = $uidRef and contains(' TaskMethodVersionAssignment ',substring-after(@xsi:type,':'))]) or (self::TimeIntervalAssignment and //AssignmentObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',substring-after(@xsi:type,':'))]) or (self::Validation and //Validation[@uid = $uidRef]) or (self::Verification and //Verification[@uid = $uidRef]) or (self::VerificationRelationship and //RelationshipObject[@uid = $uidRef and contains(' VerificationRelationship ',substring-after(@xsi:type,':'))]) or (self::WorkOrderAssignment and //AssignmentObject[@uid = $uidRef and contains(' WorkOrderAssignment ',substring-after(@xsi:type,':'))]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef]) or (self::WorkRequestAssignment and //AssignmentObject[@uid = $uidRef and contains(' WorkRequestAssignment ',substring-after(@xsi:type,':'))])">(SpecificationInclusion : <sch:value-of select="$uid"/>) The SpecificationInclusion.IncludedSpecification contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ConditionParameterSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SpecificationInclusionAssignment"><!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationInclusionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='SpecificationInclusionAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SpecificationInclusionAssignment : <sch:value-of select="$uid"/>) The SpecificationInclusionAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SpecifiedOccurrence"><!--(Ref to E) SpecifiedOccurrence.UpperUsage : Occurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecifiedOccurrence') or (self::Occurrence and substring-after(@xsi:type,':')='SpecifiedOccurrence'))]/UpperUsage">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Occurrence'] or //Occurrence[@uid = $uidRef]">(SpecifiedOccurrence : <sch:value-of select="$uid"/>) The SpecifiedOccurrence.UpperUsage contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Occurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Occurrence.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecifiedOccurrence') or (self::Occurrence and substring-after(@xsi:type,':')='SpecifiedOccurrence'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(SpecifiedOccurrence : <sch:value-of select="$uid"/>) The SpecifiedOccurrence.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StandardUncertainty"/>
   <sch:pattern id="StartTask"/>
   <sch:pattern id="State"/>
   <sch:pattern id="StateAssignment"><!--(Ref to E) StateAssignment.AssignedState : State (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='StateAssignment'))]/AssignedState">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'State'] or //State[@uid = $uidRef]">(StateAssignment : <sch:value-of select="$uid"/>) The StateAssignment.AssignedState contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type State.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='StateAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateAssignment : <sch:value-of select="$uid"/>) The StateAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateCauseEffect"><!--(Ref to E) StateRelationship.Related : State (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateCauseEffect') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateCauseEffect'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'State'] or //State[@uid = $uidRef]">(StateCauseEffect : <sch:value-of select="$uid"/>) The StateCauseEffect.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type State.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateCauseEffect') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateCauseEffect'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateCauseEffect : <sch:value-of select="$uid"/>) The StateCauseEffect.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateComposition"><!--(Ref to E) StateRelationship.Related : State (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateComposition') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateComposition'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'State'] or //State[@uid = $uidRef]">(StateComposition : <sch:value-of select="$uid"/>) The StateComposition.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type State.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateComposition') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateComposition'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateComposition : <sch:value-of select="$uid"/>) The StateComposition.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinition"><!--(Ref to S) StateDefinition.Definition : ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinition') or (self::StateDefinition and not(@xsi:type)))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(StateDefinition : <sch:value-of select="$uid"/>) The StateDefinition.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionAssignment"><!--(Ref to E) StateDefinitionAssignment.AssignedStateDefinition : StateDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='StateDefinitionAssignment'))]/AssignedStateDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionAssignment : <sch:value-of select="$uid"/>) The StateDefinitionAssignment.AssignedStateDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='StateDefinitionAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateDefinitionAssignment : <sch:value-of select="$uid"/>) The StateDefinitionAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionCauseEffect"><!--(Ref to E) StateDefinitionRelationship.Related : StateDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionCauseEffect') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateDefinitionCauseEffect'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionCauseEffect : <sch:value-of select="$uid"/>) The StateDefinitionCauseEffect.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionCauseEffect') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateDefinitionCauseEffect'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateDefinitionCauseEffect : <sch:value-of select="$uid"/>) The StateDefinitionCauseEffect.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionComposition"><!--(Ref to E) StateDefinitionRelationship.Related : StateDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionComposition') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateDefinitionComposition'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionComposition : <sch:value-of select="$uid"/>) The StateDefinitionComposition.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionComposition') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateDefinitionComposition'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateDefinitionComposition : <sch:value-of select="$uid"/>) The StateDefinitionComposition.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionConfirmedAssociation"><!--(Ref to E) StateDefinitionStateAssociation.StateDefinition : StateDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionConfirmedAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='StateDefinitionConfirmedAssociation'))]/StateDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionConfirmedAssociation : <sch:value-of select="$uid"/>) The StateDefinitionConfirmedAssociation.StateDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionHypothesisAssociation"><!--(Ref to E) StateDefinitionStateAssociation.StateDefinition : StateDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionHypothesisAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='StateDefinitionHypothesisAssociation'))]/StateDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionHypothesisAssociation : <sch:value-of select="$uid"/>) The StateDefinitionHypothesisAssociation.StateDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionPredictedAssociation"><!--(Ref to E) StateDefinitionStateAssociation.StateDefinition : StateDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionPredictedAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='StateDefinitionPredictedAssociation'))]/StateDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionPredictedAssociation : <sch:value-of select="$uid"/>) The StateDefinitionPredictedAssociation.StateDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionRelationship"><!--(Ref to E) StateDefinitionRelationship.Related : StateDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateDefinitionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionRelationship : <sch:value-of select="$uid"/>) The StateDefinitionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateDefinitionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateDefinitionRelationship : <sch:value-of select="$uid"/>) The StateDefinitionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionStateAssociation"><!--(Ref to E) StateDefinitionStateAssociation.StateDefinition : StateDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionStateAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='StateDefinitionStateAssociation'))]/StateDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionStateAssociation : <sch:value-of select="$uid"/>) The StateDefinitionStateAssociation.StateDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionStateAssociationRelationship"><!--(Ref to E) StateDefinitionStateAssociationRelationship.Related : StateDefinitionStateAssociation (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionStateAssociationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateDefinitionStateAssociationRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinitionStateAssociation'] or //AssociationObject[@uid = $uidRef and contains(' StateDefinitionStateAssociation  StateDefinitionConfirmedAssociation  StateDefinitionHypothesisAssociation  StateDefinitionPredictedAssociation ',substring-after(@xsi:type,':'))]">(StateDefinitionStateAssociationRelationship : <sch:value-of select="$uid"/>) The StateDefinitionStateAssociationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinitionStateAssociation.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionStateAssociationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateDefinitionStateAssociationRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateDefinitionStateAssociationRelationship : <sch:value-of select="$uid"/>) The StateDefinitionStateAssociationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionTransition"><!--(Ref to E) StateDefinitionTransition.StartState : StateDefinition (kind=SINGLE - redefined=StateDefinitionRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionTransition') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateDefinitionTransition'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionTransition : <sch:value-of select="$uid"/>) The StateDefinitionTransition.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionTransition') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateDefinitionTransition'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateDefinitionTransition : <sch:value-of select="$uid"/>) The StateDefinitionTransition.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateHypothesisToConfirmationRelationship"><!--(Ref to E) StateHypothesisToConfirmationRelationship.HypothesizedState : StateDefinitionHypothesisAssociation (kind=SINGLE - redefined=StateDefinitionStateAssociationRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateHypothesisToConfirmationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateHypothesisToConfirmationRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinitionHypothesisAssociation'] or //AssociationObject[@uid = $uidRef and contains(' StateDefinitionHypothesisAssociation ',substring-after(@xsi:type,':'))]">(StateHypothesisToConfirmationRelationship : <sch:value-of select="$uid"/>) The StateHypothesisToConfirmationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinitionHypothesisAssociation.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateHypothesisToConfirmationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateHypothesisToConfirmationRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateHypothesisToConfirmationRelationship : <sch:value-of select="$uid"/>) The StateHypothesisToConfirmationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateObserved"/>
   <sch:pattern id="StatePredicted"/>
   <sch:pattern id="StatePredictedToObserved"><!--(Ref to E) StatePredictedToObserved.Related : StatePredicted (kind=SINGLE - redefined=StateRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StatePredictedToObserved') or (self::RelationshipObject and substring-after(@xsi:type,':')='StatePredictedToObserved'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StatePredicted'] or //State[@uid = $uidRef and contains(' StatePredicted ',substring-after(@xsi:type,':'))]">(StatePredictedToObserved : <sch:value-of select="$uid"/>) The StatePredictedToObserved.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StatePredicted.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StatePredictedToObserved') or (self::RelationshipObject and substring-after(@xsi:type,':')='StatePredictedToObserved'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StatePredictedToObserved : <sch:value-of select="$uid"/>) The StatePredictedToObserved.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateRelationship"><!--(Ref to E) StateRelationship.Related : State (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'State'] or //State[@uid = $uidRef]">(StateRelationship : <sch:value-of select="$uid"/>) The StateRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type State.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateRelationship : <sch:value-of select="$uid"/>) The StateRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateTransition"><!--(Ref to E) StateTransition.StartState : State (kind=SINGLE - redefined=StateRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateTransition') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateTransition'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'State'] or //State[@uid = $uidRef]">(StateTransition : <sch:value-of select="$uid"/>) The StateTransition.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type State.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateTransition') or (self::RelationshipObject and substring-after(@xsi:type,':')='StateTransition'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateTransition : <sch:value-of select="$uid"/>) The StateTransition.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StringValue"><!--(Ref to E) PropertyValue.Definition : PropertyDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StringValue') or (self::StringValue or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::Altitude and substring-after(@xsi:type,':')='StringValue') or (self::Longitude and substring-after(@xsi:type,':')='StringValue') or (self::Latitude and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::LotSize and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::Offset and substring-after(@xsi:type,':')='StringValue') or (self::RequiredQuantity and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='StringValue') or (self::Duration and substring-after(@xsi:type,':')='StringValue')))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinition'] or //PropertyDefinition[@uid = $uidRef]">(StringValue : <sch:value-of select="$uid"/>) The StringValue.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SubsetMember"><!--(Ref to S) SubsetMember.Subset : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SubsetMember') or (self::SubsetMember and not(@xsi:type)))]/Subset/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SubsetMember : <sch:value-of select="$uid"/>) The SubsetMember.Subset contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SuppliedObjectRelationship"><!--(Ref to S) SuppliedObjectRelationship.Related : SuppliedObjectSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SuppliedObjectRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SuppliedObjectRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ClassAttribute ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConfiguredAssemblyEffectivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Event  RelativeEvent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationRight ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRight ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementSatisfactionAssertion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Risk ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Slot ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategory ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' System ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrder ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)] or //Activity[@uid = $uidRef] or //ActivityMethod[@uid = $uidRef] or //Breakdown[@uid = $uidRef] or //BreakdownElement[@uid = $uidRef] or //BreakdownElementVersion[@uid = $uidRef] or //BreakdownElementView[@uid = $uidRef] or //BreakdownVersion[@uid = $uidRef] or //Class[@uid = $uidRef] or //ClassAttribute[@uid = $uidRef] or //Condition[@uid = $uidRef] or //ConfiguredAssemblyEffectivity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Document[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //DocumentVersion[@uid = $uidRef] or //Effectivity[@uid = $uidRef] or //Event[@uid = $uidRef] or //ExternalOwlClass[@uid = $uidRef] or //File[@uid = $uidRef] or //IndividualPartView[@uid = $uidRef] or //InformationRight[@uid = $uidRef] or //InformationUsageRight[@uid = $uidRef] or //Occurrence[@uid = $uidRef] or //Organization[@uid = $uidRef] or //Part[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //PartView[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef] or //Representation[@uid = $uidRef] or //Requirement[@uid = $uidRef] or //RequirementSatisfactionAssertion[@uid = $uidRef] or //RequirementVersion[@uid = $uidRef] or //RequirementView[@uid = $uidRef] or //Risk[@uid = $uidRef] or //RiskVersion[@uid = $uidRef] or //RiskView[@uid = $uidRef] or //Scheme[@uid = $uidRef] or //SchemeEntry[@uid = $uidRef] or //SchemeVersion[@uid = $uidRef] or //SecurityClassification[@uid = $uidRef] or //Slot[@uid = $uidRef] or //SlotDefinition[@uid = $uidRef] or //SlotVersion[@uid = $uidRef] or //Specification[@uid = $uidRef] or //SpecificationCategory[@uid = $uidRef] or //SpecificationInclusion[@uid = $uidRef] or //System[@uid = $uidRef] or //SystemVersion[@uid = $uidRef] or //SystemView[@uid = $uidRef] or //TaskElement[@uid = $uidRef] or //TaskMethod[@uid = $uidRef] or //TaskMethodVersion[@uid = $uidRef] or //WorkOrder[@uid = $uidRef] or //WorkRequest[@uid = $uidRef]">(SuppliedObjectRelationship : <sch:value-of select="$uid"/>) The SuppliedObjectRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of SuppliedObjectSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SuppliedObjectRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SuppliedObjectRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SuppliedObjectRelationship : <sch:value-of select="$uid"/>) The SuppliedObjectRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="System"/>
   <sch:pattern id="SystemVersion"><!--(Inverse of System.Versions :: PartProperty) SystemVersion.VersionOf : System) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="SystemVersionRelationship"><!--(Ref to E) SystemVersionRelationship.Related : SystemVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SystemVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SystemVersionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SystemVersion'] or //SystemVersion[@uid = $uidRef]">(SystemVersionRelationship : <sch:value-of select="$uid"/>) The SystemVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SystemVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SystemVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SystemVersionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SystemVersionRelationship : <sch:value-of select="$uid"/>) The SystemVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SystemView"><!--(Ref to E) SystemView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SystemView') or (self::SystemView and not(@xsi:type)))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(SystemView : <sch:value-of select="$uid"/>) The SystemView.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) SystemView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SystemView') or (self::SystemView and not(@xsi:type)))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(SystemView : <sch:value-of select="$uid"/>) The SystemView.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) SystemView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SystemView') or (self::SystemView and not(@xsi:type)))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(SystemView : <sch:value-of select="$uid"/>) The SystemView.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of SystemVersion.Views :: PartProperty) SystemView.ViewOf : SystemVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="SystemViewRelationship"><!--(Ref to E) SystemViewRelationship.Related : SystemView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SystemViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SystemViewRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SystemView'] or //SystemView[@uid = $uidRef]">(SystemViewRelationship : <sch:value-of select="$uid"/>) The SystemViewRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SystemView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SystemViewRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='SystemViewRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SystemViewRelationship : <sch:value-of select="$uid"/>) The SystemViewRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TaskElementAssignment"><!--(Ref to E) TaskElementAssignment.AssignedTaskElement : TaskElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TaskElementAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='TaskElementAssignment'))]/AssignedTaskElement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'TaskElement'] or //TaskElement[@uid = $uidRef] or //*[@uid = $uidRef and (self::Advisory or self::TrueCaseElement or self::FalseCaseElement or self::UnknownCaseElement or self::RepeatedElement or self::Content)]">(TaskElementAssignment : <sch:value-of select="$uid"/>) The TaskElementAssignment.AssignedTaskElement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type TaskElement.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TaskElementAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='TaskElementAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(TaskElementAssignment : <sch:value-of select="$uid"/>) The TaskElementAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TaskElementLevels"/>
   <sch:pattern id="TaskElementRelationship"><!--(Ref to E) TaskElementRelationship.Related : TaskElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TaskElementRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='TaskElementRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'TaskElement'] or //TaskElement[@uid = $uidRef] or //*[@uid = $uidRef and (self::Advisory or self::TrueCaseElement or self::FalseCaseElement or self::UnknownCaseElement or self::RepeatedElement or self::Content)]">(TaskElementRelationship : <sch:value-of select="$uid"/>) The TaskElementRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type TaskElement.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TaskElementRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='TaskElementRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(TaskElementRelationship : <sch:value-of select="$uid"/>) The TaskElementRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TaskElementSequence"/>
   <sch:pattern id="TaskElementStateAssociation"><!--(Ref to S) TaskElementStateAssociation.State : StateOrStateDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TaskElementStateAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='TaskElementStateAssociation'))]/State">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' State  StateObserved  StatePredicted ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionAssignment ',@typeRef)] or //State[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' StateAssignment ',substring-after(@xsi:type,':'))] or //StateDefinition[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' StateDefinitionAssignment ',substring-after(@xsi:type,':'))]">(TaskElementStateAssociation : <sch:value-of select="$uid"/>) The TaskElementStateAssociation.State contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of StateOrStateDefinitionSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TaskInvocation"><!--(Ref to S) TaskInvocation.TaskMethod : MethodOrMethodVersionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TaskInvocation') or (self::TaskElement and substring-after(@xsi:type,':')='TaskInvocation'))]/TaskMethod">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)] or //TaskMethod[@uid = $uidRef] or //TaskMethodVersion[@uid = $uidRef]">(TaskInvocation : <sch:value-of select="$uid"/>) The TaskInvocation.TaskMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of MethodOrMethodVersionSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TaskMethod"><!--(Ref to E) TaskMethod.Objective : OPTIONAL SET[1:unbounded] OF TaskObjective (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TaskMethod') or (self::TaskMethod and not(@xsi:type)))]/Objective/TaskObjective">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Objective/TaskObjective) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'TaskObjective'] or //TaskObjective[@uid = $uidRef]">(TaskMethod : <sch:value-of select="$uid"/>) The TaskMethod.Objective contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type TaskObjective.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TaskMethodAssignment"><!--(Ref to E) TaskMethodAssignment.AssignedTaskMethod : TaskMethod (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TaskMethodAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='TaskMethodAssignment'))]/AssignedTaskMethod">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'TaskMethod'] or //TaskMethod[@uid = $uidRef]">(TaskMethodAssignment : <sch:value-of select="$uid"/>) The TaskMethodAssignment.AssignedTaskMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type TaskMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TaskMethodAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='TaskMethodAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(TaskMethodAssignment : <sch:value-of select="$uid"/>) The TaskMethodAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TaskMethodRelationship"><!--(Ref to E) TaskMethodRelationship.Related : TaskMethod (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TaskMethodRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='TaskMethodRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'TaskMethod'] or //TaskMethod[@uid = $uidRef]">(TaskMethodRelationship : <sch:value-of select="$uid"/>) The TaskMethodRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type TaskMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TaskMethodRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='TaskMethodRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(TaskMethodRelationship : <sch:value-of select="$uid"/>) The TaskMethodRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TaskMethodStateAssociation"><!--(Ref to S) TaskMethodStateAssociation.State : StateOrStateDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TaskMethodStateAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='TaskMethodStateAssociation'))]/State">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' State  StateObserved  StatePredicted ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionAssignment ',@typeRef)] or //State[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' StateAssignment ',substring-after(@xsi:type,':'))] or //StateDefinition[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' StateDefinitionAssignment ',substring-after(@xsi:type,':'))]">(TaskMethodStateAssociation : <sch:value-of select="$uid"/>) The TaskMethodStateAssociation.State contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of StateOrStateDefinitionSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TaskMethodVersion"><!--(Inverse of TaskMethod.Versions :: PartProperty) TaskMethodVersion.VersionOf : TaskMethod) => no rule needed when PartProperty or Optional--></sch:pattern>
   <sch:pattern id="TaskMethodVersionAssignment"><!--(Ref to E) TaskMethodVersionAssignment.AssignedTaskMethodVersion : TaskMethodVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TaskMethodVersionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='TaskMethodVersionAssignment'))]/AssignedTaskMethodVersion">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'TaskMethodVersion'] or //TaskMethodVersion[@uid = $uidRef]">(TaskMethodVersionAssignment : <sch:value-of select="$uid"/>) The TaskMethodVersionAssignment.AssignedTaskMethodVersion contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type TaskMethodVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TaskMethodVersionAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='TaskMethodVersionAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(TaskMethodVersionAssignment : <sch:value-of select="$uid"/>) The TaskMethodVersionAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TaskMethodVersionRelationship"><!--(Ref to E) TaskMethodVersionRelationship.Related : TaskMethodVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TaskMethodVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='TaskMethodVersionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'TaskMethodVersion'] or //TaskMethodVersion[@uid = $uidRef]">(TaskMethodVersionRelationship : <sch:value-of select="$uid"/>) The TaskMethodVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type TaskMethodVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TaskMethodVersionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='TaskMethodVersionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(TaskMethodVersionRelationship : <sch:value-of select="$uid"/>) The TaskMethodVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TaskObjective"/>
   <sch:pattern id="TaskObjectiveStateAssociation"><!--(Ref to S) TaskObjectiveStateAssociation.State : StateOrStateDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TaskObjectiveStateAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='TaskObjectiveStateAssociation'))]/State">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' State  StateObserved  StatePredicted ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionAssignment ',@typeRef)] or //State[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' StateAssignment ',substring-after(@xsi:type,':'))] or //StateDefinition[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' StateDefinitionAssignment ',substring-after(@xsi:type,':'))]">(TaskObjectiveStateAssociation : <sch:value-of select="$uid"/>) The TaskObjectiveStateAssociation.State contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of StateOrStateDefinitionSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TaskStep"/>
   <sch:pattern id="TimeInterval"/>
   <sch:pattern id="TimeIntervalAssignment"><!--(Ref to S) TimeIntervalAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=AssignmentObject.Role)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='TimeIntervalAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(TimeIntervalAssignment : <sch:value-of select="$uid"/>) The TimeIntervalAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TimeIntervalEffectivity"><!--(Ref to S) DatedEffectivity.EndDefinition : OPTIONAL EventOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='TimeIntervalEffectivity'))]/EndDefinition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event  RelativeEvent ',@typeRef)]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(TimeIntervalEffectivity : <sch:value-of select="$uid"/>) The TimeIntervalEffectivity.EndDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EventOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DatedEffectivity.StartDefinition : OPTIONAL EventOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='TimeIntervalEffectivity'))]/StartDefinition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event  RelativeEvent ',@typeRef)]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(TimeIntervalEffectivity : <sch:value-of select="$uid"/>) The TimeIntervalEffectivity.StartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EventOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='TimeIntervalEffectivity'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(TimeIntervalEffectivity : <sch:value-of select="$uid"/>) The TimeIntervalEffectivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Effectivity.EffectivityContext : OPTIONAL EffectivityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='TimeIntervalEffectivity'))]/EffectivityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //Activity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef]">(TimeIntervalEffectivity : <sch:value-of select="$uid"/>) The TimeIntervalEffectivity.EffectivityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EffectivityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TimeIntervalRelationship"><!--(Ref to E) TimeIntervalRelationship.Related : TimeInterval (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='TimeIntervalRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'TimeInterval'] or //TimeInterval[@uid = $uidRef] or //*[@uid = $uidRef and (self::AssignedTimeInterval)]">(TimeIntervalRelationship : <sch:value-of select="$uid"/>) The TimeIntervalRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type TimeInterval.</sch:assert>
      </sch:rule>
      <!--(Ref to S) TimeIntervalRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='TimeIntervalRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(TimeIntervalRelationship : <sch:value-of select="$uid"/>) The TimeIntervalRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TimeIntervalWithBounds"><!--(Ref to S) TimeIntervalWithBounds.PrimaryBound : OPTIONAL EventOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalWithBounds') or (self::TimeInterval and substring-after(@xsi:type,':')='TimeIntervalWithBounds'))]/PrimaryBound/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event  RelativeEvent ',@typeRef)]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(TimeIntervalWithBounds : <sch:value-of select="$uid"/>) The TimeIntervalWithBounds.PrimaryBound contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EventOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) TimeIntervalWithBounds.SecondaryBound : OPTIONAL EventOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalWithBounds') or (self::TimeInterval and substring-after(@xsi:type,':')='TimeIntervalWithBounds'))]/SecondaryBound/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event  RelativeEvent ',@typeRef)]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(TimeIntervalWithBounds : <sch:value-of select="$uid"/>) The TimeIntervalWithBounds.SecondaryBound contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EventOrDateSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TransformedGeometricModel"><!--(Ref to S) TransformedGeometricModel.Items : SET[1:unbounded] OF AxisPlacementOrTransformationSelect (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TransformedGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='TransformedGeometricModel'))]/Items/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::AxisPlacement and //ExternalRefBaseObject[@uid = $uidRef and contains(' AxisPlacement ',@typeRef)]) or (self::CartesianTransformation and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)]) or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement ',substring-after(@xsi:type,':'))] or //CartesianTransformation[@uid = $uidRef]">(TransformedGeometricModel : <sch:value-of select="$uid"/>) The TransformedGeometricModel.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AxisPlacementOrTransformationSelect.</sch:assert>
      </sch:rule>
      <!--(Rule for inverse of GeometricRepresentationRelationship.Related :: ReferenceProperty) TransformedGeometricModel.DerivedFrom : GeometricRepresentationRelationship)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TransformedGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='TransformedGeometricModel'))]">
         <sch:let name="uid" value="./@uid"/>
         <sch:assert test="//RelationshipObject[contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',substring-after(@xsi:type,':'))]/Related[@uidRef = $uid]">(TransformedGeometricModel : <sch:value-of select="$uid"/>) The TransformedGeometricModel.DerivedFrom inverse rule must be referenced by GeometricRepresentationRelationship.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace (kind=SINGLE - redefined=Representation.ContextOfItems)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TransformedGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='TransformedGeometricModel'))]/ContextOfItems">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricCoordinateSpace'] or //RepresentationContext[@uid = $uidRef and contains(' GeometricCoordinateSpace ',substring-after(@xsi:type,':'))]">(TransformedGeometricModel : <sch:value-of select="$uid"/>) The TransformedGeometricModel.ContextOfItems contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricCoordinateSpace.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TransformedGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='TransformedGeometricModel'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(TransformedGeometricModel : <sch:value-of select="$uid"/>) The TransformedGeometricModel.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TypeOfPerson"><!--(Ref to E) TypeOfPerson.Definition : OPTIONAL SET[1:unbounded] OF TypeOfPersonDefinition (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TypeOfPerson') or (self::TypeOfPerson and not(@xsi:type)))]/Definition/TypeOfPersonDefinition">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Definition/TypeOfPersonDefinition) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'TypeOfPersonDefinition'] or //TypeOfPersonDefinition[@uid = $uidRef]">(TypeOfPerson : <sch:value-of select="$uid"/>) The TypeOfPerson.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type TypeOfPersonDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TypeOfPersonAssignment"><!--(Ref to E) TypeOfPersonAssignment.AssignedTypeOfPerson : TypeOfPerson (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TypeOfPersonAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='TypeOfPersonAssignment'))]/AssignedTypeOfPerson">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'TypeOfPerson'] or //TypeOfPerson[@uid = $uidRef]">(TypeOfPersonAssignment : <sch:value-of select="$uid"/>) The TypeOfPersonAssignment.AssignedTypeOfPerson contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type TypeOfPerson.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObject.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TypeOfPersonAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='TypeOfPersonAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(TypeOfPersonAssignment : <sch:value-of select="$uid"/>) The TypeOfPersonAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TypeOfPersonDefinition"/>
   <sch:pattern id="TypeOfPersonDefinitionRelationship"><!--(Ref to E) TypeOfPersonDefinitionRelationship.Related : TypeOfPersonDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TypeOfPersonDefinitionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='TypeOfPersonDefinitionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'TypeOfPersonDefinition'] or //TypeOfPersonDefinition[@uid = $uidRef]">(TypeOfPersonDefinitionRelationship : <sch:value-of select="$uid"/>) The TypeOfPersonDefinitionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type TypeOfPersonDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TypeOfPersonDefinitionRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='TypeOfPersonDefinitionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(TypeOfPersonDefinitionRelationship : <sch:value-of select="$uid"/>) The TypeOfPersonDefinitionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TypeOfPersonDefinitionRequiredAttributesAssociation"><!--(Ref to S) TypeOfPersonDefinitionRequiredAttributesAssociation.Attributes : OPTIONAL SET[1:unbounded] OF DefinedAttributeSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TypeOfPersonDefinitionRequiredAttributesAssociation') or (self::AssociationObject and substring-after(@xsi:type,':')='TypeOfPersonDefinitionRequiredAttributesAssociation'))]/Attributes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ExperienceType and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExperienceType ',@typeRef)]) or (self::QualificationType and //ExternalRefBaseObject[@uid = $uidRef and contains(' QualificationType ',@typeRef)]) or (self::ExperienceType and //ExperienceType[@uid = $uidRef]) or (self::QualificationType and //QualificationType[@uid = $uidRef])">(TypeOfPersonDefinitionRequiredAttributesAssociation : <sch:value-of select="$uid"/>) The TypeOfPersonDefinitionRequiredAttributesAssociation.Attributes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of DefinedAttributeSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TypeQualifier"><!--(Ref to S) TypeQualifier.Definition : ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TypeQualifier') or (self::TypeQualifier and not(@xsi:type)))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(TypeQualifier : <sch:value-of select="$uid"/>) The TypeQualifier.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="UncertaintyQualifier"/>
   <sch:pattern id="Unit"><!--(Ref to S) Unit.Kind : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Unit') or (self::Unit and not(@xsi:type)))]/Kind/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Unit : <sch:value-of select="$uid"/>) The Unit.Kind contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Unit.Name : ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Unit') or (self::Unit and not(@xsi:type)))]/Name/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(Unit : <sch:value-of select="$uid"/>) The Unit.Name contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Unit.Prefix : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Unit') or (self::Unit and not(@xsi:type)))]/Prefix/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Unit : <sch:value-of select="$uid"/>) The Unit.Prefix contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Unit.Quantity : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Unit') or (self::Unit and not(@xsi:type)))]/Quantity/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Unit : <sch:value-of select="$uid"/>) The Unit.Quantity contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Validation"><!--(Ref to S) Validation.Validates : ValidationSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Validation') or (self::Validation and not(@xsi:type)))]/Validates">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)] or //ActivityMethod[@uid = $uidRef] or //BreakdownElementVersion[@uid = $uidRef] or //BreakdownVersion[@uid = $uidRef] or //CollectionVersion[@uid = $uidRef] or //DocumentVersion[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //InterfaceConnectorVersion[@uid = $uidRef] or //InterfaceSpecificationVersion[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //AssignmentObject[@uid = $uidRef and contains(' PersonOrganizationAssignment ',substring-after(@xsi:type,':'))] or //RequirementVersion[@uid = $uidRef] or //RiskVersion[@uid = $uidRef] or //Scheme[@uid = $uidRef] or //SchemeEntry[@uid = $uidRef] or //SchemeVersion[@uid = $uidRef] or //SlotVersion[@uid = $uidRef] or //StateDefinition[@uid = $uidRef] or //SystemVersion[@uid = $uidRef] or //TaskElement[@uid = $uidRef] or //TaskMethod[@uid = $uidRef] or //TaskMethodVersion[@uid = $uidRef]">(Validation : <sch:value-of select="$uid"/>) The Validation.Validates contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValidationSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of Evidence.Supports :: ReferenceProperty) Validation.ValidatedBy : OPTIONAL SET[1:unbounded] OF Evidence) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ValueFormatTypeQualifier"><!--(Ref to S) ValueFormatTypeQualifier.ValueFormatType : ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueFormatTypeQualifier') or (self::ValueFormatTypeQualifier and not(@xsi:type)))]/ValueFormatType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::External and contains(' ExternalItem ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(ValueFormatTypeQualifier : <sch:value-of select="$uid"/>) The ValueFormatTypeQualifier.ValueFormatType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ValueLimit"><!--(Ref to E) ValueLimit.Qualifier : TypeQualifier (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueLimit') or (self::PropertyValue and substring-after(@xsi:type,':')='ValueLimit'))]/Qualifier">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'TypeQualifier'] or //TypeQualifier[@uid = $uidRef]">(ValueLimit : <sch:value-of select="$uid"/>) The ValueLimit.Qualifier contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type TypeQualifier.</sch:assert>
      </sch:rule>
      <!--(Ref to E) NumericalValue.ValueContext : OPTIONAL NumericalContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueLimit') or (self::ValueLimit or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Altitude and substring-after(@xsi:type,':')='ValueLimit') or (self::Longitude and substring-after(@xsi:type,':')='ValueLimit') or (self::Latitude and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::LotSize and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ValueLimit') or (self::Duration and substring-after(@xsi:type,':')='ValueLimit')))]/ValueContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ValueContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'NumericalContext'] or //NumericalContext[@uid = $uidRef]">(ValueLimit : <sch:value-of select="$uid"/>) The ValueLimit.ValueContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type NumericalContext.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ValueWithUnit.Qualifications : OPTIONAL SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueLimit') or (self::ValueLimit or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Altitude and substring-after(@xsi:type,':')='ValueLimit') or (self::Longitude and substring-after(@xsi:type,':')='ValueLimit') or (self::Latitude and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::LotSize and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ValueLimit') or (self::Duration and substring-after(@xsi:type,':')='ValueLimit')))]/Qualifications/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::TypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::TypeQualifier and //TypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(ValueLimit : <sch:value-of select="$uid"/>) The ValueLimit.Qualifications contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ValueWithUnit.Unit : UnitSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueLimit') or (self::ValueLimit or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Altitude and substring-after(@xsi:type,':')='ValueLimit') or (self::Longitude and substring-after(@xsi:type,':')='ValueLimit') or (self::Latitude and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::LotSize and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ValueLimit') or (self::Duration and substring-after(@xsi:type,':')='ValueLimit')))]/Unit">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)] or //ExternalUnit[@uid = $uidRef] or //Unit[@uid = $uidRef]">(ValueLimit : <sch:value-of select="$uid"/>) The ValueLimit.Unit contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyValue.Definition : PropertyDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueLimit') or (self::ValueLimit or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Altitude and substring-after(@xsi:type,':')='ValueLimit') or (self::Longitude and substring-after(@xsi:type,':')='ValueLimit') or (self::Latitude and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::LotSize and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ValueLimit') or (self::Duration and substring-after(@xsi:type,':')='ValueLimit')))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinition'] or //PropertyDefinition[@uid = $uidRef]">(ValueLimit : <sch:value-of select="$uid"/>) The ValueLimit.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ValueList"><!--(Ref to E) PropertyValue.Definition : PropertyDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueList') or (self::ValueList or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::Altitude and substring-after(@xsi:type,':')='ValueList') or (self::Longitude and substring-after(@xsi:type,':')='ValueList') or (self::Latitude and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::LotSize and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::Offset and substring-after(@xsi:type,':')='ValueList') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ValueList') or (self::Duration and substring-after(@xsi:type,':')='ValueList')))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinition'] or //PropertyDefinition[@uid = $uidRef]">(ValueList : <sch:value-of select="$uid"/>) The ValueList.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ValueRange"><!--(Ref to S) ValueWithUnit.Qualifications : OPTIONAL SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueRange') or (self::ValueRange or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Altitude and substring-after(@xsi:type,':')='ValueRange') or (self::Longitude and substring-after(@xsi:type,':')='ValueRange') or (self::Latitude and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::LotSize and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Offset and substring-after(@xsi:type,':')='ValueRange') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ValueRange') or (self::Duration and substring-after(@xsi:type,':')='ValueRange')))]/Qualifications/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::TypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::TypeQualifier and //TypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(ValueRange : <sch:value-of select="$uid"/>) The ValueRange.Qualifications contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ValueWithUnit.Unit : UnitSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueRange') or (self::ValueRange or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Altitude and substring-after(@xsi:type,':')='ValueRange') or (self::Longitude and substring-after(@xsi:type,':')='ValueRange') or (self::Latitude and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::LotSize and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Offset and substring-after(@xsi:type,':')='ValueRange') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ValueRange') or (self::Duration and substring-after(@xsi:type,':')='ValueRange')))]/Unit">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)] or //ExternalUnit[@uid = $uidRef] or //Unit[@uid = $uidRef]">(ValueRange : <sch:value-of select="$uid"/>) The ValueRange.Unit contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyValue.Definition : PropertyDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueRange') or (self::ValueRange or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Altitude and substring-after(@xsi:type,':')='ValueRange') or (self::Longitude and substring-after(@xsi:type,':')='ValueRange') or (self::Latitude and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::LotSize and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Offset and substring-after(@xsi:type,':')='ValueRange') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ValueRange') or (self::Duration and substring-after(@xsi:type,':')='ValueRange')))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinition'] or //PropertyDefinition[@uid = $uidRef]">(ValueRange : <sch:value-of select="$uid"/>) The ValueRange.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ValueSet"><!--(Ref to E) PropertyValue.Definition : PropertyDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueSet') or (self::ValueSet or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::Altitude and substring-after(@xsi:type,':')='ValueSet') or (self::Longitude and substring-after(@xsi:type,':')='ValueSet') or (self::Latitude and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::LotSize and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::Offset and substring-after(@xsi:type,':')='ValueSet') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ValueSet') or (self::Duration and substring-after(@xsi:type,':')='ValueSet')))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinition'] or //PropertyDefinition[@uid = $uidRef]">(ValueSet : <sch:value-of select="$uid"/>) The ValueSet.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ValueWithTolerances"><!--(Ref to S) ValueWithUnit.Qualifications : OPTIONAL SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ValueWithTolerances or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Altitude and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Longitude and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Latitude and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::LotSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Duration and substring-after(@xsi:type,':')='ValueWithTolerances')))]/Qualifications/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::TypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' TypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::TypeQualifier and //TypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(ValueWithTolerances : <sch:value-of select="$uid"/>) The ValueWithTolerances.Qualifications contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ValueWithUnit.Unit : UnitSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ValueWithTolerances or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Altitude and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Longitude and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Latitude and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::LotSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Duration and substring-after(@xsi:type,':')='ValueWithTolerances')))]/Unit">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)] or //ExternalUnit[@uid = $uidRef] or //Unit[@uid = $uidRef]">(ValueWithTolerances : <sch:value-of select="$uid"/>) The ValueWithTolerances.Unit contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyValue.Definition : PropertyDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ValueWithTolerances or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Altitude and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Longitude and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Latitude and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::LotSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::RequiredQuantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::EffectivityPeriod and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Duration and substring-after(@xsi:type,':')='ValueWithTolerances')))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinition'] or //PropertyDefinition[@uid = $uidRef]">(ValueWithTolerances : <sch:value-of select="$uid"/>) The ValueWithTolerances.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Verification"><!--(Ref to E) Verification.Verifies : RequirementSatisfactionAssertion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Verification') or (self::Verification and not(@xsi:type)))]/Verifies">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementSatisfactionAssertion'] or //RequirementSatisfactionAssertion[@uid = $uidRef]">(Verification : <sch:value-of select="$uid"/>) The Verification.Verifies contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementSatisfactionAssertion.</sch:assert>
      </sch:rule>
      <!--(Inverse of Evidence.Supports :: ReferenceProperty) Verification.VerifiedBy : OPTIONAL SET[1:unbounded] OF Evidence) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="VerificationRelationship"><!--(Ref to E) VerificationRelationship.Related : Verification (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='VerificationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='VerificationRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Verification'] or //Verification[@uid = $uidRef]">(VerificationRelationship : <sch:value-of select="$uid"/>) The VerificationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Verification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RelationshipObject.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='VerificationRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='VerificationRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(VerificationRelationship : <sch:value-of select="$uid"/>) The VerificationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ViewContext"><!--(Ref to S) ViewContext.ApplicationDomain : ApplicationDomainSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ViewContext') or (self::ViewContext and not(@xsi:type)))]/ApplicationDomain/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ApplicationDomain and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApplicationDomain ',@typeRef)]) or (self::ApplicationDomain and //ApplicationDomain[@uid = $uidRef]) or (self::ProxyString)">(ViewContext : <sch:value-of select="$uid"/>) The ViewContext.ApplicationDomain contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ApplicationDomainSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ViewContext.LifeCycleStage : LifeCycleStageSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ViewContext') or (self::ViewContext and not(@xsi:type)))]/LifeCycleStage/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::LifeCycleStage and //ExternalRefBaseObject[@uid = $uidRef and contains(' LifeCycleStage ',@typeRef)]) or (self::LifeCycleStage and //LifeCycleStage[@uid = $uidRef]) or (self::ProxyString)">(ViewContext : <sch:value-of select="$uid"/>) The ViewContext.LifeCycleStage contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of LifeCycleStageSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WorkOrder"><!--(Ref to E) WorkOrder.InResponseTo : OPTIONAL SET[1:unbounded] OF WorkRequest (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkOrder') or (self::WorkOrder and not(@xsi:type)))]/InResponseTo/WorkRequest">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../InResponseTo/WorkRequest) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'WorkRequest'] or //WorkRequest[@uid = $uidRef]">(WorkOrder : <sch:value-of select="$uid"/>) The WorkOrder.InResponseTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type WorkRequest.</sch:assert>
      </sch:rule>
      <!--(Ref to S) WorkOrder.OrderType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkOrder') or (self::WorkOrder and not(@xsi:type)))]/OrderType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(WorkOrder : <sch:value-of select="$uid"/>) The WorkOrder.OrderType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WorkOrderAssignment"><!--(Ref to E) WorkOrderAssignment.AssignedWorkOrder : WorkOrder (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkOrderAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='WorkOrderAssignment'))]/AssignedWorkOrder">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'WorkOrder'] or //WorkOrder[@uid = $uidRef]">(WorkOrderAssignment : <sch:value-of select="$uid"/>) The WorkOrderAssignment.AssignedWorkOrder contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type WorkOrder.</sch:assert>
      </sch:rule>
      <!--(Ref to S) WorkOrderAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=AssignmentObject.Role)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkOrderAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='WorkOrderAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(WorkOrderAssignment : <sch:value-of select="$uid"/>) The WorkOrderAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WorkOrderRelationship"><!--(Ref to E) WorkOrderRelationship.Related : WorkOrder (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkOrderRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='WorkOrderRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'WorkOrder'] or //WorkOrder[@uid = $uidRef]">(WorkOrderRelationship : <sch:value-of select="$uid"/>) The WorkOrderRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type WorkOrder.</sch:assert>
      </sch:rule>
      <!--(Ref to S) WorkOrderRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkOrderRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='WorkOrderRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(WorkOrderRelationship : <sch:value-of select="$uid"/>) The WorkOrderRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WorkRequest"><!--(Ref to S) WorkRequest.RequestType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkRequest') or (self::WorkRequest and not(@xsi:type)))]/RequestType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(WorkRequest : <sch:value-of select="$uid"/>) The WorkRequest.RequestType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) WorkRequest.Scope : OPTIONAL SET[1:unbounded] OF ActivityAssignmentSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkRequest') or (self::WorkRequest and not(@xsi:type)))]/Scope/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::AssignmentObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssignmentObject  ActivityAssignment  ActivityMethodAssignment  RiskEvent  AddressAssignment  AnalysisAssignment  ApprovalAssignment  AssumptionAssignment  CertificationAssignment  CollectionAssignment  ConditionAssignment  ConditionEvaluationAssignment  ContractAssignment  DateTimeAssignment  DocumentAssignment  PartialDocumentAssignment  EffectivityAssignment  EnvironmentAssignment  EventAssignment  InformationUsageRightAssignment  JustificationAssignment  JustificationSupportAssignment  LocationAssignment  LocatorAssignment  ObservationAssignment  ObservedEnvironmentAssignment  PersonOrganizationAssignment  PositionAssignment  PositionGroupAssignment  PositionTypeAssignment  ProjectAssignment  PropertyDefinitionAssignment  PropertyValueAssignment  QualificationAssignment  RequiredResourceAssignment  RequirementAssignment  ResourceAsRealizedAssignment  ResourceItemAssignment  RiskImpactAssignment  RiskPerceptionSourceAssignment  SchemeEntryAssignment  SchemeSubjectAssignment  SchemeVersionAssignment  SecurityClassificationAssignment  SpecificationAssignment  SpecificationCategoryAssignment  SpecificationConditionAssignment  SpecificationInclusionAssignment  StateAssignment  StateDefinitionAssignment  TaskElementAssignment  TaskMethodAssignment  TaskMethodVersionAssignment  TimeIntervalAssignment  TypeOfPersonAssignment  WorkOrderAssignment  WorkRequestAssignment ',@typeRef)]) or (self::AssociationObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssociationObject  ActivityMethodRealization  BreakdownElementRealization  BreakdownMember  BreakdownOf  CollectionMembership  InZone  InterfaceConnectionToDefinitionAssociation  InterfaceDefinitionFor  ItemAssumed  ItemInSlot  ObservationConsequence  ObservedEnvironmentToDefinition  ObservedEnvironmentToDefinitionVersion  ObservedEnvironmentToDefinitionView  OrganizationOrganizationTypeAssociation  PartToIndividualPartAssociation  PartVersionToIndividualPartVersionAssociation  PartViewToIndividualPartViewAssociation  PositionGroupAssociation  PositionPositionTypeAssociation  ProductDesignAssociation  ProductGroupMembership  RelatedConditionParameter  ResourceAsRealizedAssociation  ResourceEventCorrespondenceAssociation  ResourceItemRealization  SlotOn  StateDefinitionStateAssociation  StateDefinitionConfirmedAssociation  StateDefinitionHypothesisAssociation  StateDefinitionPredictedAssociation  TaskElementStateAssociation  TaskMethodStateAssociation  TaskObjectiveStateAssociation  TypeOfPersonDefinitionRequiredAttributesAssociation ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion  AlternativeSolution ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::Collection and //ExternalRefBaseObject[@uid = $uidRef and contains(' Collection ',@typeRef)]) or (self::CollectionVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionVersion ',@typeRef)]) or (self::CollectionView and //ExternalRefBaseObject[@uid = $uidRef and contains(' CollectionView ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Condition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition ',@typeRef)]) or (self::ConfiguredAssemblyEffectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConfiguredAssemblyEffectivity ',@typeRef)]) or (self::Contract and //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity ',@typeRef)]) or (self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event  RelativeEvent ',@typeRef)]) or (self::Evidence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Evidence ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::File and //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::InterfaceConnection and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnection  HierarchicalInterfaceConnection ',@typeRef)]) or (self::InterfaceConnector and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnector ',@typeRef)]) or (self::InterfaceConnectorOccurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)]) or (self::InterfaceConnectorVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorVersion ',@typeRef)]) or (self::InterfaceConnectorView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorView ',@typeRef)]) or (self::InterfaceDefinitionConnection and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceDefinitionConnection ',@typeRef)]) or (self::InterfaceSpecification and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecification ',@typeRef)]) or (self::InterfaceSpecificationVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationVersion ',@typeRef)]) or (self::InterfaceSpecificationView and //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceSpecificationView ',@typeRef)]) or (self::Justification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Justification ',@typeRef)]) or (self::ManagedResource and //ExternalRefBaseObject[@uid = $uidRef and contains(' ManagedResource ',@typeRef)]) or (self::Occurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  CollectionDefinition ',@typeRef)]) or (self::Person and //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::Position and //ExternalRefBaseObject[@uid = $uidRef and contains(' Position ',@typeRef)]) or (self::PositionGroup and //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionGroup ',@typeRef)]) or (self::ProductClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration ',@typeRef)]) or (self::ProductGroup and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductGroup ',@typeRef)]) or (self::Project and //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::RelationshipObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' RelationshipObject  ActivityMethodRelationship  ActivityRelationship  ActivityHappeningRelationship  AnalysisVersionRelationship  ApprovalRelationship  AssemblyOccurrenceRelationshipSubstitution  AssemblyViewRelationshipSubstitution  AssignmentObjectRelationship  AssumptionRelationship  BreakdownElementRelationship  BreakdownElementVersionRelationship  BreakdownElementViewRelationship  BreakdownElementHierarchy  BreakdownRelationship  BreakdownVersionRelationship  CausalConsequence  ClassificationRelationship  CollectionMembershipRelationship  CollectionRelationship  CollectionVersionRelationship  CollectionVersionSequenceRelationship  CollectionViewRelationship  ConditionEvaluationRelationship  ConditionRelationship  ContractRelationship  DescriptorRelationship  DocumentDefinitionRelationship  DocumentRelationship  DocumentVersionRelationship  EffectivityRelationship  EnvelopeRelationship  EnvironmentDefinitionViewRelationship  EventRelationship  ExperienceTypeRelationship  FileRelationship  IdentifierRelationship  IndividualAssemblyRelationship  IndividualPartRelationship  IndividualPartVersionRelationship  ProductPlannedToRealized  IndividualPartViewRelationship  InformationUsageRightRelationship  InterfaceConnectorOccurrenceRelationship  InterfaceConnectorRelationship  InterfaceConnectorVersionRelationship  InterfaceConnectorViewRelationship  InterfaceSpecificationRelationship  InterfaceSpecificationVersionRelationship  InterfaceSpecificationViewRelationship  JustificationRelationship  LocationRelationship  LocatorRelationship  ManagedResourceRelationship  MessageRelationship  ObservationRelationship  ObservedEnvironmentViewRelationship  OccurrenceRelationship  ReplacedUsageRelationship  OrganizationRelationship  PartRelationship  AlternatePartRelationship  PartVersionRelationship  PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  ReplacedPartViewRelationship  PersonInOrganizationRelationship  PersonOrganizationInPositionRelationship  PositionRelationship  ProductClassRelationship  ProductConfigurationRelationship  ProductGroupRelationship  ProjectRelationship  PropertyDefinitionAssignmentRelationship  PropertyDefinitionRelationship  PropertyValueAssignmentRelationship  PropertyValueRelationship  ProxyRelationship  QualificationTypeRelationship  RelatedConsequence  RepresentationRelationship  GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace  RequiredResourceRelationship  RequirementRelationship  RequirementVersionRelationship  RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship  ResourceEventRelationship  ResourceItemRelationship  ResourceGroupRelationship  RiskPerceptionRelationship  RiskRelationship  SchemeEntryRelationship  SequencingRelationship  SchemeRelationship  SchemeVersionRelationship  SlotDefinitionRelationship  SlotDesignToPlanned  SlotDesignToRealized  SlotPlannedToRealized  StateDefinitionRelationship  StateDefinitionCauseEffect  StateDefinitionComposition  StateDefinitionTransition  StateDefinitionStateAssociationRelationship  StateHypothesisToConfirmationRelationship  StateRelationship  StateCauseEffect  StateComposition  StatePredictedToObserved  StateTransition  SuppliedObjectRelationship  SystemVersionRelationship  SystemViewRelationship  TaskElementRelationship  TaskMethodRelationship  TaskMethodVersionRelationship  TimeIntervalRelationship  TypeOfPersonDefinitionRelationship  VerificationRelationship  ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship  WorkOrderRelationship  WorkRequestRelationship ',@typeRef)]) or (self::Representation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  TransformedGeometricModel ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::ResourceAsRealized and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceAsRealized ',@typeRef)]) or (self::ResourceEvent and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceEvent  DecreasingResourceEvent  IncreasingResourceEvent ',@typeRef)]) or (self::ResourceItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' ResourceItem ',@typeRef)]) or (self::Risk and //ExternalRefBaseObject[@uid = $uidRef and contains(' Risk ',@typeRef)]) or (self::RiskVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskVersion ',@typeRef)]) or (self::RiskView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RiskView  RiskConsequence  RiskPerception ',@typeRef)]) or (self::Scheme and //ExternalRefBaseObject[@uid = $uidRef and contains(' Scheme ',@typeRef)]) or (self::SchemeEntry and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeEntry ',@typeRef)]) or (self::SchemeVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SchemeVersion ',@typeRef)]) or (self::Slot and //ExternalRefBaseObject[@uid = $uidRef and contains(' Slot ',@typeRef)]) or (self::SlotDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotDefinition ',@typeRef)]) or (*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationCategory and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategory ',@typeRef)]) or (*[(self::SpecificationInclusion or (self::AssignedInclusion and contains(' SpecificationInclusion ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusion ',@typeRef)]) or (self::System and //ExternalRefBaseObject[@uid = $uidRef and contains(' System ',@typeRef)]) or (self::SystemVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemVersion ',@typeRef)]) or (self::SystemView and //ExternalRefBaseObject[@uid = $uidRef and contains(' SystemView ',@typeRef)]) or (*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',@typeRef)]) or (self::TaskMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethod ',@typeRef)]) or (self::TaskMethodVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' TaskMethodVersion ',@typeRef)]) or (self::Validation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Validation ',@typeRef)]) or (self::Verification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Verification ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::AssignmentObject and //AssignmentObject[@uid = $uidRef]) or (self::AssociationObject and //AssociationObject[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::Class and //Class[@uid = $uidRef]) or (self::Collection and //Collection[@uid = $uidRef]) or (self::CollectionVersion and //CollectionVersion[@uid = $uidRef]) or (self::CollectionView and //CollectionView[@uid = $uidRef]) or (self::Condition and //*[(self::Condition or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Condition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ConfiguredAssemblyEffectivity and //ConfiguredAssemblyEffectivity[@uid = $uidRef]) or (self::Contract and //Contract[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::Event and //Event[@uid = $uidRef]) or (self::Evidence and //Evidence[@uid = $uidRef]) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef]) or (self::File and //File[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::InterfaceConnection and //InterfaceConnection[@uid = $uidRef]) or (self::InterfaceConnector and //InterfaceConnector[@uid = $uidRef]) or (self::InterfaceConnectorOccurrence and //InterfaceConnectorOccurrence[@uid = $uidRef]) or (self::InterfaceConnectorVersion and //InterfaceConnectorVersion[@uid = $uidRef]) or (self::InterfaceConnectorView and //InterfaceConnectorView[@uid = $uidRef]) or (self::InterfaceDefinitionConnection and //InterfaceDefinitionConnection[@uid = $uidRef]) or (self::InterfaceSpecification and //InterfaceSpecification[@uid = $uidRef]) or (self::InterfaceSpecificationVersion and //InterfaceSpecificationVersion[@uid = $uidRef]) or (self::InterfaceSpecificationView and //InterfaceSpecificationView[@uid = $uidRef]) or (self::Justification and //Justification[@uid = $uidRef]) or (self::ManagedResource and //ManagedResource[@uid = $uidRef]) or (self::Occurrence and //Occurrence[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::Person and //Person[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef]) or (self::Position and //Position[@uid = $uidRef]) or (self::PositionGroup and //PositionGroup[@uid = $uidRef]) or (self::ProductClass and //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProductGroup and //ProductGroup[@uid = $uidRef]) or (self::Project and //Project[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Altitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Longitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Latitude and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredQuantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::EffectivityPeriod and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Duration and contains(' PropertyValue  ExternalValue  StringValue  ValueList  ValueSet  ValueWithUnit  NumericalValue  Duration  ProbabilityDerived  ValueLimit  ProbabilityDistribution  DistributionByValue  ParameterizedDistribution  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::RelationshipObject and //RelationshipObject[@uid = $uidRef]) or (self::Representation and //Representation[@uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::ResourceAsRealized and //ResourceAsRealized[@uid = $uidRef]) or (self::ResourceEvent and //ResourceEvent[@uid = $uidRef]) or (self::ResourceItem and //ResourceItem[@uid = $uidRef]) or (self::Risk and //Risk[@uid = $uidRef]) or (self::RiskVersion and //RiskVersion[@uid = $uidRef]) or (self::RiskView and //RiskView[@uid = $uidRef]) or (self::Scheme and //Scheme[@uid = $uidRef]) or (self::SchemeEntry and //SchemeEntry[@uid = $uidRef]) or (self::SchemeVersion and //SchemeVersion[@uid = $uidRef]) or (self::Slot and //Slot[@uid = $uidRef]) or (self::SlotDefinition and //SlotDefinition[@uid = $uidRef]) or (self::SlotVersion and //*[(self::SlotVersion or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Design and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Planned and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Realized and contains(' SlotVersion  SlotAsPlanned  SlotAsRealized  SlotDesign ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationCategory and //SpecificationCategory[@uid = $uidRef]) or (self::SpecificationInclusion and //*[(self::SpecificationInclusion or (self::AssignedInclusion and contains(' SpecificationInclusion ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::System and //System[@uid = $uidRef]) or (self::SystemVersion and //SystemVersion[@uid = $uidRef]) or (self::SystemView and //SystemView[@uid = $uidRef]) or (self::TaskElement and //*[(self::TaskElement or (self::Advisory and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TrueCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FalseCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnknownCaseElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RepeatedElement and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Content and contains(' TaskElement  EndTask  ExitLoop  StartTask  StructuredTaskElement  ConcurrentElements  SimultaneousElements  DecisionPoint  LoopingElement  RepeatCount  RepeatUntil  RepeatWhile  TaskElementSequence  TaskElementLevels  TaskInvocation  TaskStep  AdvisoryTaskStep ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::TaskMethod and //TaskMethod[@uid = $uidRef]) or (self::TaskMethodVersion and //TaskMethodVersion[@uid = $uidRef]) or (self::Validation and //Validation[@uid = $uidRef]) or (self::Verification and //Verification[@uid = $uidRef])">(WorkRequest : <sch:value-of select="$uid"/>) The WorkRequest.Scope contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ActivityAssignmentSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WorkRequestAssignment"><!--(Ref to E) WorkRequestAssignment.AssignedWorkRequest : WorkRequest (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkRequestAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='WorkRequestAssignment'))]/AssignedWorkRequest">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'WorkRequest'] or //WorkRequest[@uid = $uidRef]">(WorkRequestAssignment : <sch:value-of select="$uid"/>) The WorkRequestAssignment.AssignedWorkRequest contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type WorkRequest.</sch:assert>
      </sch:rule>
      <!--(Ref to S) WorkRequestAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=AssignmentObject.Role)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkRequestAssignment') or (self::AssignmentObject and substring-after(@xsi:type,':')='WorkRequestAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(WorkRequestAssignment : <sch:value-of select="$uid"/>) The WorkRequestAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WorkRequestRelationship"><!--(Ref to E) WorkRequestRelationship.Related : WorkRequest (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkRequestRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='WorkRequestRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'WorkRequest'] or //WorkRequest[@uid = $uidRef]">(WorkRequestRelationship : <sch:value-of select="$uid"/>) The WorkRequestRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type WorkRequest.</sch:assert>
      </sch:rule>
      <!--(Ref to S) WorkRequestRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=RelationshipObject.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkRequestRelationship') or (self::RelationshipObject and substring-after(@xsi:type,':')='WorkRequestRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(WorkRequestRelationship : <sch:value-of select="$uid"/>) The WorkRequestRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
</sch:schema>
