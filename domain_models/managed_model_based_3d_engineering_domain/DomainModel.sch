<?xml version="1.0" encoding="UTF-8"?>
<sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron"
            xmlns:sqf="http://www.schematron-quickfix.com/validator/process"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            queryBinding="xslt2"
            version="N11436;2024-02-16">
   <sch:ns uri="https://standards.iso.org/iso/ts/10303/-4442/ed-4/tech/xml-schema/domain_model"
           prefix="n0"/>
   <sch:ns uri="http://www.w3.org/2001/XMLSchema-instance" prefix="xsi"/>
   <sch:title>STEP AP242 Domain model schematron</sch:title>
   <sch:pattern id="ActivityAssignment"><!--(Ref to E) ActivityAssignment.AssignedActivity : Activity (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityAssignment') or (self::ActivityAssignment and not(@xsi:type)))]/AssignedActivity">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Activity'] or //Activity[@uid = $uidRef]">(ActivityAssignment : <sch:value-of select="$uid"/>) The ActivityAssignment.AssignedActivity contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Activity.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ActivityAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityAssignment') or (self::ActivityAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ActivityAssignment : <sch:value-of select="$uid"/>) The ActivityAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ActivityAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityAssignment') or (self::ActivityAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ActivityAssignment : <sch:value-of select="$uid"/>) The ActivityAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ActivityHappeningRelationship"><!--(Ref to E) ActivityHappeningRelationship.Related : ActualActivity (kind=SINGLE - redefined=ActivityRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityHappeningRelationship') or (self::ActivityRelationship and substring-after(@xsi:type,':')='ActivityHappeningRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActualActivity'] or //Activity[@uid = $uidRef and contains(' ActualActivity  DirectedActualActivity ',substring-after(@xsi:type,':'))]">(ActivityHappeningRelationship : <sch:value-of select="$uid"/>) The ActivityHappeningRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActualActivity.</sch:assert>
      </sch:rule>
      <!--(Default Value) ActivityHappeningRelationship.RelationType : String = 'happening' (kind=SINGLE - redefined=ActivityRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityHappeningRelationship') or (self::ActivityRelationship and substring-after(@xsi:type,':')='ActivityHappeningRelationship'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'happening'">(ActivityHappeningRelationship : <sch:value-of select="$uid"/>) The ActivityHappeningRelationship.RelationType contains the wrong value () must be 'happening'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ActivityRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityHappeningRelationship') or (self::ActivityRelationship and substring-after(@xsi:type,':')='ActivityHappeningRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ActivityHappeningRelationship : <sch:value-of select="$uid"/>) The ActivityHappeningRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ActivityRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityHappeningRelationship') or (self::ActivityRelationship and substring-after(@xsi:type,':')='ActivityHappeningRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ActivityHappeningRelationship : <sch:value-of select="$uid"/>) The ActivityHappeningRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ActivityMethod"><!--(Ref to E) ActivityMethod.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityMethod') or (self::ActivityMethod and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ActivityMethod : <sch:value-of select="$uid"/>) The ActivityMethod.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ActivityMethodAssignment"><!--(Ref to E) ActivityMethodAssignment.AssignedActivityMethod : ActivityMethod (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityMethodAssignment') or (self::ActivityMethodAssignment and not(@xsi:type)))]/AssignedActivityMethod">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(ActivityMethodAssignment : <sch:value-of select="$uid"/>) The ActivityMethodAssignment.AssignedActivityMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ActivityMethodAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityMethodAssignment') or (self::ActivityMethodAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ActivityMethodAssignment : <sch:value-of select="$uid"/>) The ActivityMethodAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ActivityMethodAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityMethodAssignment') or (self::ActivityMethodAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ActivityMethodAssignment : <sch:value-of select="$uid"/>) The ActivityMethodAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ActivityMethodRelationship"><!--(Ref to E) ActivityMethodRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityMethodRelationship') or (self::ActivityMethodRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ActivityMethodRelationship : <sch:value-of select="$uid"/>) The ActivityMethodRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ActivityMethodRelationship.Related : ActivityMethod (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityMethodRelationship') or (self::ActivityMethodRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(ActivityMethodRelationship : <sch:value-of select="$uid"/>) The ActivityMethodRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ActivityMethodRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityMethodRelationship') or (self::ActivityMethodRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ActivityMethodRelationship : <sch:value-of select="$uid"/>) The ActivityMethodRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ActivityMethodRelationship_WR1"><!--(Rule ActivityMethodRelationship.WR1)-->
      <sch:rule context="//ActivityMethodRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> ActivityMethodRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related ActivityMethod and the relating ActivityMethod shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="ActivityRelationship"><!--(Ref to E) ActivityRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityRelationship') or (self::ActivityRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ActivityRelationship : <sch:value-of select="$uid"/>) The ActivityRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ActivityRelationship.Related : Activity (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityRelationship') or (self::ActivityRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Activity'] or //Activity[@uid = $uidRef]">(ActivityRelationship : <sch:value-of select="$uid"/>) The ActivityRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Activity.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ActivityRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActivityRelationship') or (self::ActivityRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ActivityRelationship : <sch:value-of select="$uid"/>) The ActivityRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ActivityRelationship_WR1"><!--(Rule ActivityRelationship.WR1)-->
      <sch:rule context="//ActivityRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> ActivityRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Activity and the relating Activity shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="ActualActivity"><!--(Ref to S) Activity.ActivityType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActualActivity') or (self::Activity and substring-after(@xsi:type,':')='ActualActivity'))]/ActivityType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ActualActivity : <sch:value-of select="$uid"/>) The ActualActivity.ActivityType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.ChosenMethod : OPTIONAL ActivityMethod (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActualActivity') or (self::Activity and substring-after(@xsi:type,':')='ActualActivity'))]/ChosenMethod">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ChosenMethod) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(ActualActivity : <sch:value-of select="$uid"/>) The ActualActivity.ChosenMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActualActivity') or (self::Activity and substring-after(@xsi:type,':')='ActualActivity'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ActualActivity : <sch:value-of select="$uid"/>) The ActualActivity.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActualActivity') or (self::Activity and substring-after(@xsi:type,':')='ActualActivity'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(ActualActivity : <sch:value-of select="$uid"/>) The ActualActivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.PossibleMethods : OPTIONAL SET[1:unbounded] OF ActivityMethod (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActualActivity') or (self::Activity and substring-after(@xsi:type,':')='ActualActivity'))]/PossibleMethods/ActivityMethod">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../PossibleMethods/ActivityMethod) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(ActualActivity : <sch:value-of select="$uid"/>) The ActualActivity.PossibleMethods contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Activity.Status : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActualActivity') or (self::Activity and substring-after(@xsi:type,':')='ActualActivity'))]/Status/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ActualActivity : <sch:value-of select="$uid"/>) The ActualActivity.Status contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.SupplyingOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ActualActivity') or (self::Activity and substring-after(@xsi:type,':')='ActualActivity'))]/SupplyingOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../SupplyingOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(ActualActivity : <sch:value-of select="$uid"/>) The ActualActivity.SupplyingOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ActuatedPair"/>
   <sch:pattern id="AddElement"><!--(Ref to S) AddElement.CurrentDesignObject : SET[1:unbounded] OF DeltaChangeManagementObjectSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AddElement') or (self::DeltaChangeActivity and substring-after(@xsi:type,':')='AddElement'))]/CurrentDesignObject/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternatePartRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternatePartRelationship ',@typeRef)]) or (self::AlternativeSolution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::AssemblyOccurrenceRelationshipSubstitution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyOccurrenceRelationshipSubstitution ',@typeRef)]) or (self::AssemblyViewRelationshipSubstitution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationshipSubstitution ',@typeRef)]) or (self::AssignmentObjectRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssignmentObjectRelationship ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementRealization and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRealization ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::BreakdownVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionRelationship ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConfiguredAssemblyEffectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConfiguredAssemblyEffectivity ',@typeRef)]) or (self::Contract and //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::DeltaChangeRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DeltaChangeRelationship ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::DocumentVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersionRelationship ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::File and //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)]) or (self::IndividualAssemblyRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualAssemblyRelationship ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialIdentification and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialIdentification ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::Occurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)]) or (self::OccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceRelationship  ReplacedUsageRelationship  SameTimeMachiningRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship  AlternatePartVersionRelationship ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::Person and //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::ProcessOperationDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinition ',@typeRef)]) or (self::ProcessOperationOccurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationOccurrence ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlan and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlan ',@typeRef)]) or (self::ProductClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::Project and //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::ProjectRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectRelationship ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (self::Representation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel  PlyAngleRepresentation  ReinforcementOrientationBasis ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersionRelationship ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategory and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategory ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusion ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::StyledModel and //ExternalRefBaseObject[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::ViewOccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternatePartRelationship and //PartRelationship[@uid = $uidRef and contains(' AlternatePartRelationship ',substring-after(@xsi:type,':'))]) or (self::AlternativeSolution and //AlternativeSolution[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::AssemblyOccurrenceRelationshipSubstitution and //AssemblyOccurrenceRelationshipSubstitution[@uid = $uidRef]) or (self::AssemblyViewRelationshipSubstitution and //AssemblyViewRelationshipSubstitution[@uid = $uidRef]) or (self::AssignmentObjectRelationship and //AssignmentObjectRelationship[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementRealization and //BreakdownElementRealization[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementVersionRelationship and //BreakdownElementVersionRelationship[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::BreakdownVersionRelationship and //BreakdownVersionRelationship[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Class and //Class[@uid = $uidRef]) or (self::Condition and //*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConfiguredAssemblyEffectivity and //ConfiguredAssemblyEffectivity[@uid = $uidRef]) or (self::Contract and //Contract[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DeltaChangeRelationship and //DeltaChangeRelationship[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::DocumentVersionRelationship and //DocumentVersionRelationship[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::Event and //Event[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef]) or (self::File and //File[@uid = $uidRef]) or (self::IndividualAssemblyRelationship and //IndividualAssemblyRelationship[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartVersionRelationship and //IndividualPartVersionRelationship[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialIdentification and //MaterialIdentification[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::Occurrence and //Occurrence[@uid = $uidRef]) or (self::OccurrenceRelationship and //OccurrenceRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartVersionRelationship and //PartVersionRelationship[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::Person and //Person[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef]) or (self::ProcessOperationDefinition and //ProcessOperationDefinition[@uid = $uidRef]) or (self::ProcessOperationOccurrence and //ProcessOperationOccurrence[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlan and //ProcessPlan[@uid = $uidRef]) or (self::ProductClass and //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::Project and //Project[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::ProjectRelationship and //ProjectRelationship[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Representation and //Representation[@uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementVersionRelationship and //RequirementVersionRelationship[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategory and //SpecificationCategory[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusion and //SpecificationInclusion[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::StyledModel and //Representation[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',substring-after(@xsi:type,':'))]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::ViewOccurrenceRelationship and //ViewOccurrenceRelationship[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef])">(AddElement : <sch:value-of select="$uid"/>) The AddElement.CurrentDesignObject contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of DeltaChangeManagementObjectSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of DeltaChange.ChangeActivities :: PartProperty) DeltaChangeActivity.ChangeSet : DeltaChange) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="Address"><!--(Ref to E) Address.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Address') or (self::Address and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Address : <sch:value-of select="$uid"/>) The Address.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AddressAssignment"><!--(Ref to E) AddressAssignment.AssignedAddress : Address (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AddressAssignment') or (self::AddressAssignment and not(@xsi:type)))]/AssignedAddress">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Address'] or //Address[@uid = $uidRef]">(AddressAssignment : <sch:value-of select="$uid"/>) The AddressAssignment.AssignedAddress contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Address.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AddressAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AddressAssignment') or (self::AddressAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AddressAssignment : <sch:value-of select="$uid"/>) The AddressAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AddressAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AddressAssignment') or (self::AddressAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AddressAssignment : <sch:value-of select="$uid"/>) The AddressAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AdvancedFace"/>
   <sch:pattern id="AffectedPlaneToleranceZone"><!--(Ref to E) AffectedPlaneToleranceZone.AffectedPlane : AxisPlacementShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AffectedPlaneToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='AffectedPlaneToleranceZone'))]/AffectedPlane">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacementShapeElement'] or //ShapeElement[@uid = $uidRef and contains(' AxisPlacementShapeElement ',substring-after(@xsi:type,':'))]">(AffectedPlaneToleranceZone : <sch:value-of select="$uid"/>) The AffectedPlaneToleranceZone.AffectedPlane contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacementShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DirectedOrOrientedToleranceZone.ZoneFor : SET[1:unbounded] OF DirectedOrOrientedGeometricToleranceSelect (kind=AGGREGATE - redefined=ToleranceZone.ZoneFor)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AffectedPlaneToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='AffectedPlaneToleranceZone'))]/ZoneFor/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DimensionalLocation and //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)]) or (self::DimensionalSize and //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)]) or (self::LineProfileTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' LineProfileTolerance ',@typeRef)]) or (self::ParallelismTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' ParallelismTolerance ',@typeRef)]) or (self::PerpendicularityTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' PerpendicularityTolerance ',@typeRef)]) or (self::PositionTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionTolerance ',@typeRef)]) or (self::StraightnessTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' StraightnessTolerance ',@typeRef)]) or (self::SymmetryTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' SymmetryTolerance ',@typeRef)]) or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' LineProfileTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' ParallelismTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' PerpendicularityTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' PositionTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' StraightnessTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' SymmetryTolerance ',substring-after(@xsi:type,':'))]">(AffectedPlaneToleranceZone : <sch:value-of select="$uid"/>) The AffectedPlaneToleranceZone.ZoneFor contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of DirectedOrOrientedGeometricToleranceSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AffectedPlaneToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='AffectedPlaneToleranceZone'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AffectedPlaneToleranceZone : <sch:value-of select="$uid"/>) The AffectedPlaneToleranceZone.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AffectedPlaneToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='AffectedPlaneToleranceZone'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(AffectedPlaneToleranceZone : <sch:value-of select="$uid"/>) The AffectedPlaneToleranceZone.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AllAroundShapeElement"><!--(Ref to E) CompositeShapeElement.Components : SET[2:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AllAroundShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='AllAroundShapeElement'))]/Components/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(AllAroundShapeElement : <sch:value-of select="$uid"/>) The AllAroundShapeElement.Components contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AllAroundShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='AllAroundShapeElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AllAroundShapeElement : <sch:value-of select="$uid"/>) The AllAroundShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AllAroundShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='AllAroundShapeElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(AllAroundShapeElement : <sch:value-of select="$uid"/>) The AllAroundShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AllAroundShapeElementAlongCollectionPlane"><!--(Ref to E) AllAroundShapeElementAlongCollectionPlane.Base : DatumSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AllAroundShapeElementAlongCollectionPlane') or (self::ShapeElement and substring-after(@xsi:type,':')='AllAroundShapeElementAlongCollectionPlane'))]/Base">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DatumSystem'] or //ShapeElement[@uid = $uidRef and contains(' DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem ',substring-after(@xsi:type,':'))]">(AllAroundShapeElementAlongCollectionPlane : <sch:value-of select="$uid"/>) The AllAroundShapeElementAlongCollectionPlane.Base contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DatumSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to E) CompositeShapeElement.Components : SET[2:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AllAroundShapeElementAlongCollectionPlane') or (self::ShapeElement and substring-after(@xsi:type,':')='AllAroundShapeElementAlongCollectionPlane'))]/Components/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(AllAroundShapeElementAlongCollectionPlane : <sch:value-of select="$uid"/>) The AllAroundShapeElementAlongCollectionPlane.Components contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AllAroundShapeElementAlongCollectionPlane') or (self::ShapeElement and substring-after(@xsi:type,':')='AllAroundShapeElementAlongCollectionPlane'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AllAroundShapeElementAlongCollectionPlane : <sch:value-of select="$uid"/>) The AllAroundShapeElementAlongCollectionPlane.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AllAroundShapeElementAlongCollectionPlane') or (self::ShapeElement and substring-after(@xsi:type,':')='AllAroundShapeElementAlongCollectionPlane'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(AllAroundShapeElementAlongCollectionPlane : <sch:value-of select="$uid"/>) The AllAroundShapeElementAlongCollectionPlane.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AlternatePartRelationship"><!--(Default Value) AlternatePartRelationship.RelationType : String = 'alternate' (kind=SINGLE - redefined=PartRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AlternatePartRelationship') or (self::PartRelationship and substring-after(@xsi:type,':')='AlternatePartRelationship'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'alternate'">(AlternatePartRelationship : <sch:value-of select="$uid"/>) The AlternatePartRelationship.RelationType contains the wrong value () must be 'alternate'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AlternatePartRelationship') or (self::PartRelationship and substring-after(@xsi:type,':')='AlternatePartRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AlternatePartRelationship : <sch:value-of select="$uid"/>) The AlternatePartRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartRelationship.Related : Part (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AlternatePartRelationship') or (self::PartRelationship and substring-after(@xsi:type,':')='AlternatePartRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Part'] or //Part[@uid = $uidRef]">(AlternatePartRelationship : <sch:value-of select="$uid"/>) The AlternatePartRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Part.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AlternatePartRelationship') or (self::PartRelationship and substring-after(@xsi:type,':')='AlternatePartRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AlternatePartRelationship : <sch:value-of select="$uid"/>) The AlternatePartRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AlternatePartVersionRelationship"><!--(Default Value) AlternatePartVersionRelationship.RelationType : String = 'alternate' (kind=SINGLE - redefined=PartVersionRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AlternatePartVersionRelationship') or (self::PartVersionRelationship and substring-after(@xsi:type,':')='AlternatePartVersionRelationship'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'alternate'">(AlternatePartVersionRelationship : <sch:value-of select="$uid"/>) The AlternatePartVersionRelationship.RelationType contains the wrong value () must be 'alternate'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartVersionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AlternatePartVersionRelationship') or (self::PartVersionRelationship and substring-after(@xsi:type,':')='AlternatePartVersionRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AlternatePartVersionRelationship : <sch:value-of select="$uid"/>) The AlternatePartVersionRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartVersionRelationship.Related : PartVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AlternatePartVersionRelationship') or (self::PartVersionRelationship and substring-after(@xsi:type,':')='AlternatePartVersionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartVersion'] or //PartVersion[@uid = $uidRef]">(AlternatePartVersionRelationship : <sch:value-of select="$uid"/>) The AlternatePartVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartVersionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AlternatePartVersionRelationship') or (self::PartVersionRelationship and substring-after(@xsi:type,':')='AlternatePartVersionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AlternatePartVersionRelationship : <sch:value-of select="$uid"/>) The AlternatePartVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AlternativeSolution"><!--(Ref to S) AlternativeSolution.BaseElement : BreakdownElementOrAlternativeSolutionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AlternativeSolution') or (self::AlternativeSolution and not(@xsi:type)))]/BaseElement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //AlternativeSolution[@uid = $uidRef] or //BreakdownElement[@uid = $uidRef]">(AlternativeSolution : <sch:value-of select="$uid"/>) The AlternativeSolution.BaseElement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of BreakdownElementOrAlternativeSolutionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AlternativeSolution.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AlternativeSolution') or (self::AlternativeSolution and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AlternativeSolution : <sch:value-of select="$uid"/>) The AlternativeSolution.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AlternativeSolutionRelationship"><!--(Ref to E) AlternativeSolutionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AlternativeSolutionRelationship') or (self::AlternativeSolutionRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AlternativeSolutionRelationship : <sch:value-of select="$uid"/>) The AlternativeSolutionRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AlternativeSolutionRelationship.Related : AlternativeSolution (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AlternativeSolutionRelationship') or (self::AlternativeSolutionRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AlternativeSolution'] or //AlternativeSolution[@uid = $uidRef]">(AlternativeSolutionRelationship : <sch:value-of select="$uid"/>) The AlternativeSolutionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AlternativeSolution.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AlternativeSolutionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AlternativeSolutionRelationship') or (self::AlternativeSolutionRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AlternativeSolutionRelationship : <sch:value-of select="$uid"/>) The AlternativeSolutionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AlternativeSolutionRelationship_WR1"><!--(Rule AlternativeSolutionRelationship.WR1)-->
      <sch:rule context="//AlternativeSolutionRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> AlternativeSolutionRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related AlternativeSolution and the relating AlternativeSolution shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="Analysis"><!--(Ref to E) Analysis.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Analysis') or (self::Analysis and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Analysis : <sch:value-of select="$uid"/>) The Analysis.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AnalysisAssignment"><!--(Ref to E) AnalysisAssignment.AssignedAnalysis : AnalysisVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisAssignment') or (self::AnalysisAssignment and not(@xsi:type)))]/AssignedAnalysis">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AnalysisVersion'] or //AnalysisVersion[@uid = $uidRef]">(AnalysisAssignment : <sch:value-of select="$uid"/>) The AnalysisAssignment.AssignedAnalysis contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AnalysisVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AnalysisAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisAssignment') or (self::AnalysisAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AnalysisAssignment : <sch:value-of select="$uid"/>) The AnalysisAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AnalysisAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisAssignment') or (self::AnalysisAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AnalysisAssignment : <sch:value-of select="$uid"/>) The AnalysisAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AnalysisDisciplineDefinition"><!--(Ref to E) AnalysisDisciplineDefinition.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisDisciplineDefinition') or (self::AnalysisDisciplineDefinition and not(@xsi:type)))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(AnalysisDisciplineDefinition : <sch:value-of select="$uid"/>) The AnalysisDisciplineDefinition.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AnalysisDisciplineDefinition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisDisciplineDefinition') or (self::AnalysisDisciplineDefinition and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AnalysisDisciplineDefinition : <sch:value-of select="$uid"/>) The AnalysisDisciplineDefinition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AnalysisDisciplineDefinition.DefinitionalRepresentations : OPTIONAL SET[1:unbounded] OF AnalysisModelObject (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisDisciplineDefinition') or (self::AnalysisDisciplineDefinition and not(@xsi:type)))]/DefinitionalRepresentations/AnalysisModelObject">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../DefinitionalRepresentations/AnalysisModelObject) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AnalysisModelObject'] or //AnalysisModelObject[@uid = $uidRef]">(AnalysisDisciplineDefinition : <sch:value-of select="$uid"/>) The AnalysisDisciplineDefinition.DefinitionalRepresentations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AnalysisModelObject.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AnalysisDisciplineDefinition.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisDisciplineDefinition') or (self::AnalysisDisciplineDefinition and not(@xsi:type)))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(AnalysisDisciplineDefinition : <sch:value-of select="$uid"/>) The AnalysisDisciplineDefinition.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of AnalysisVersion.Views :: PartProperty) AnalysisDisciplineDefinition.ViewOf : AnalysisVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="AnalysisModel"><!--(Ref to S) AnalysisModel.Items : SET[1:unbounded] OF AnalysisModelItemsSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisModel') or (self::AnalysisModelObject and substring-after(@xsi:type,':')='AnalysisModel'))]/Items/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::StateDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinition ',@typeRef)]) or (self::StateDefinitionTransition and //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinitionTransition ',@typeRef)]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::StateDefinition and //StateDefinition[@uid = $uidRef]) or (self::StateDefinitionTransition and //StateDefinitionRelationship[@uid = $uidRef and contains(' StateDefinitionTransition ',substring-after(@xsi:type,':'))])">(AnalysisModel : <sch:value-of select="$uid"/>) The AnalysisModel.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AnalysisModelItemsSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AnalysisModelObject.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisModel') or (self::AnalysisModelObject and substring-after(@xsi:type,':')='AnalysisModel'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AnalysisModel : <sch:value-of select="$uid"/>) The AnalysisModel.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AnalysisRepresentationContext"><!--(Ref to E) AnalysisRepresentationContext.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisRepresentationContext') or (self::AnalysisRepresentationContext and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AnalysisRepresentationContext : <sch:value-of select="$uid"/>) The AnalysisRepresentationContext.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AnalysisVersion"><!--(Ref to E) AnalysisVersion.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisVersion') or (self::AnalysisVersion and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AnalysisVersion : <sch:value-of select="$uid"/>) The AnalysisVersion.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Inverse of Analysis.Versions :: PartProperty) AnalysisVersion.VersionOf : Analysis) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="AnalysisVersionRelationship"><!--(Ref to E) AnalysisVersionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisVersionRelationship') or (self::AnalysisVersionRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AnalysisVersionRelationship : <sch:value-of select="$uid"/>) The AnalysisVersionRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AnalysisVersionRelationship.Related : AnalysisVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisVersionRelationship') or (self::AnalysisVersionRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AnalysisVersion'] or //AnalysisVersion[@uid = $uidRef]">(AnalysisVersionRelationship : <sch:value-of select="$uid"/>) The AnalysisVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AnalysisVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AnalysisVersionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnalysisVersionRelationship') or (self::AnalysisVersionRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AnalysisVersionRelationship : <sch:value-of select="$uid"/>) The AnalysisVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AndCondition"><!--(Default Value) AndCondition.ConditionType : String = 'and' (kind=SINGLE - redefined=Condition.ConditionType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AndCondition') or (self::Condition and substring-after(@xsi:type,':')='AndCondition'))]/ConditionType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'and'">(AndCondition : <sch:value-of select="$uid"/>) The AndCondition.ConditionType contains the wrong value () must be 'and'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Condition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AndCondition') or (self::AndCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='AndCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='AndCondition')))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AndCondition : <sch:value-of select="$uid"/>) The AndCondition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Condition.ConditionType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AndCondition') or (self::AndCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='AndCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='AndCondition')))]/ConditionType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AndCondition : <sch:value-of select="$uid"/>) The AndCondition.ConditionType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Condition.Parameters : SET[1:unbounded] OF ParameterSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AndCondition') or (self::AndCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='AndCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='AndCondition')))]/Parameters/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ConditionParameter and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionParameter ',@typeRef)]) or (self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternativeSolutionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolutionRelationship ',@typeRef)]) or (self::Approval and //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConditionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionRelationship ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::Descriptor and //ExternalRefBaseObject[@uid = $uidRef and contains(' Descriptor ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::EffectivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::FileRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::Observation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::ObservationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::ProcessOperationDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinitionRelationship ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlanRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlanRelationship ',@typeRef)]) or (self::ProductClassRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClassRelationship ',@typeRef)]) or (self::ProductConcept and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::ProductConfigurationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkOrderRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderRelationship ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::WorkRequestRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestRelationship ',@typeRef)]) or (self::ConditionParameter) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternativeSolutionRelationship and //AlternativeSolutionRelationship[@uid = $uidRef]) or (self::Approval and //Approval[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::Condition) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConditionRelationship and //ConditionRelationship[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DateTimeString) or (self::Descriptor and //Descriptor[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::EffectivityRelationship and //EffectivityRelationship[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::FileRelationship and //FileRelationship[@uid = $uidRef]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::Observation and //Observation[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::ObservationRelationship and //ObservationRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::ProcessOperationDefinitionRelationship and //ProcessOperationDefinitionRelationship[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlanRelationship and //ProcessPlanRelationship[@uid = $uidRef]) or (self::ProductClassRelationship and //ProductClassRelationship[@uid = $uidRef]) or (self::ProductConcept and //ProductConcept[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProductConfigurationRelationship and //ProductConfigurationRelationship[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkOrderRelationship and //WorkOrderRelationship[@uid = $uidRef]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef]) or (self::WorkRequestRelationship and //WorkRequestRelationship[@uid = $uidRef])">(AndCondition : <sch:value-of select="$uid"/>) The AndCondition.Parameters contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ParameterSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AngularLocation"><!--(Ref to E) AngularLocation.Orientation : OPTIONAL AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AngularLocation') or (self::GeometricDimension and substring-after(@xsi:type,':')='AngularLocation'))]/Orientation">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Orientation) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(AngularLocation : <sch:value-of select="$uid"/>) The AngularLocation.Orientation contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DimensionalLocation.Origin : ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AngularLocation') or (self::GeometricDimension and substring-after(@xsi:type,':')='AngularLocation'))]/Origin">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(AngularLocation : <sch:value-of select="$uid"/>) The AngularLocation.Origin contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DimensionalLocation.Target : ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AngularLocation') or (self::GeometricDimension and substring-after(@xsi:type,':')='AngularLocation'))]/Target">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(AngularLocation : <sch:value-of select="$uid"/>) The AngularLocation.Target contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AngularLocation') or (self::GeometricDimension and substring-after(@xsi:type,':')='AngularLocation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AngularLocation : <sch:value-of select="$uid"/>) The AngularLocation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.GeometricDimensionContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AngularLocation') or (self::GeometricDimension and substring-after(@xsi:type,':')='AngularLocation'))]/GeometricDimensionContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricDimensionContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(AngularLocation : <sch:value-of select="$uid"/>) The AngularLocation.GeometricDimensionContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AngularSize"><!--(Ref to E) DimensionalSize.IsAppliedTo : ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AngularSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='AngularSize'))]/IsAppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(AngularSize : <sch:value-of select="$uid"/>) The AngularSize.IsAppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AngularSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='AngularSize'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AngularSize : <sch:value-of select="$uid"/>) The AngularSize.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.GeometricDimensionContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AngularSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='AngularSize'))]/GeometricDimensionContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricDimensionContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(AngularSize : <sch:value-of select="$uid"/>) The AngularSize.GeometricDimensionContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AngularityTolerance"><!--(Ref to E) AngularityTolerance.DatumSystem : DatumSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AngularityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='AngularityTolerance'))]/DatumSystem">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DatumSystem'] or //ShapeElement[@uid = $uidRef and contains(' DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem ',substring-after(@xsi:type,':'))]">(AngularityTolerance : <sch:value-of select="$uid"/>) The AngularityTolerance.DatumSystem contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DatumSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricTolerance.AppliedTo : GeometricToleranceTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AngularityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='AngularityTolerance'))]/AppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //PartView[@uid = $uidRef]">(AngularityTolerance : <sch:value-of select="$uid"/>) The AngularityTolerance.AppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricToleranceTargetSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AngularityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='AngularityTolerance'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AngularityTolerance : <sch:value-of select="$uid"/>) The AngularityTolerance.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.GeometricToleranceContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AngularityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='AngularityTolerance'))]/GeometricToleranceContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricToleranceContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(AngularityTolerance : <sch:value-of select="$uid"/>) The AngularityTolerance.GeometricToleranceContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AnnotatedModelItemAssociation"><!--(Ref to S) AnnotatedModelItemAssociation.Definition : AnnotatedModelItemDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnnotatedModelItemAssociation') or (self::AnnotatedModelItemAssociation and not(@xsi:type)))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricDimension  DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance  DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricTolerance  AngularityTolerance  CircularRunoutTolerance  CoaxialityTolerance  ConcentricityTolerance  CylindricityTolerance  FlatnessTolerance  LineProfileTolerance  ParallelismTolerance  PerpendicularityTolerance  PositionTolerance  RoundnessTolerance  StraightnessTolerance  SurfaceProfileTolerance  SymmetryTolerance  TotalRunoutTolerance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeElement  AxisPlacementShapeElement  CoatingLayer  CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement  ContactingFeature  Datum  DatumFeature  DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem  DatumTarget  PlacedTarget  TargetCircle  TargetCircularCurve  TargetPoint  TargetRectangle  TargetStraightLine  TargetArea  TargetCurve  DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent  OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification  PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification  PlaneShapeElement  PointShapeElement  ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement  ToleranceZone  DirectedOrOrientedToleranceZone  AffectedPlaneToleranceZone  ToleranceZoneWithDatum  DirectedToleranceZone  DirectionFeatureToleranceZone  OrientedToleranceZone ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeElementRelationship  AssemblyShapeConstraintItemRelationship  AssemblyShapeJointItemRelationship  PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship  ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //GeometricDimension[@uid = $uidRef] or //GeometricTolerance[@uid = $uidRef] or //PartView[@uid = $uidRef] or //PropertyDefinition[@uid = $uidRef] or //PropertyValueAssignment[@uid = $uidRef] or //ShapeElement[@uid = $uidRef] or //ShapeElementRelationship[@uid = $uidRef] or //ShapeFeatureDefinition[@uid = $uidRef]">(AnnotatedModelItemAssociation : <sch:value-of select="$uid"/>) The AnnotatedModelItemAssociation.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AnnotatedModelItemDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AnnotatedModelItemAssociation.UsedModel : AnnotatedModelPresentation (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnnotatedModelItemAssociation') or (self::AnnotatedModelItemAssociation and not(@xsi:type)))]/UsedModel">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AnnotatedModelPresentation'] or //Representation[@uid = $uidRef and contains(' AnnotatedModelPresentation ',substring-after(@xsi:type,':'))]">(AnnotatedModelItemAssociation : <sch:value-of select="$uid"/>) The AnnotatedModelItemAssociation.UsedModel contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AnnotatedModelPresentation.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AnnotatedModelPresentation"><!--(Ref to S) AnnotatedModelPresentation.Items : SET[1:unbounded] OF AnnotatedModelItemSelect (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnnotatedModelPresentation') or (self::Representation and substring-after(@xsi:type,':')='AnnotatedModelPresentation'))]/Items/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::AnnotationElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' AnnotationElement  AnnotationPlaceholderOccurrence  AnnotationPlane ',@typeRef)]) or (self::AxisPlacement and //ExternalRefBaseObject[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',@typeRef)]) or (self::Callout and //ExternalRefBaseObject[@uid = $uidRef and contains(' Callout ',@typeRef)]) or (self::CameraModel3D and //ExternalRefBaseObject[@uid = $uidRef and contains(' CameraModel3D ',@typeRef)]) or (self::StyledModelReplication and //ExternalRefBaseObject[@uid = $uidRef and contains(' StyledModelReplication ',@typeRef)]) or //RepresentationItem[@uid = $uidRef and contains(' AnnotationElement  AnnotationPlaceholderOccurrence  AnnotationPlane ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Callout ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' CameraModel3D ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' StyledModelReplication ',substring-after(@xsi:type,':'))]">(AnnotatedModelPresentation : <sch:value-of select="$uid"/>) The AnnotatedModelPresentation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AnnotatedModelItemSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AnnotatedModelPresentation.PresentationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnnotatedModelPresentation') or (self::Representation and substring-after(@xsi:type,':')='AnnotatedModelPresentation'))]/PresentationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AnnotatedModelPresentation : <sch:value-of select="$uid"/>) The AnnotatedModelPresentation.PresentationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnnotatedModelPresentation') or (self::Representation and substring-after(@xsi:type,':')='AnnotatedModelPresentation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AnnotatedModelPresentation : <sch:value-of select="$uid"/>) The AnnotatedModelPresentation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnnotatedModelPresentation') or (self::Representation and substring-after(@xsi:type,':')='AnnotatedModelPresentation'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AnnotatedModelPresentation : <sch:value-of select="$uid"/>) The AnnotatedModelPresentation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="AnnotatedModelPresentation_WR2"><!--(Rule AnnotatedModelPresentation.WR2)--><sch:rule context="//Representation[ @uid and substring-after(@xsi:type,':')='AnnotatedModelPresentation' and ./PresentationType/ClassString='Saved View']"> <sch:let name="uid" value="@uid"/> <sch:let name="uidRef" value="./Items/RepresentationItem/@uidRef"/> <sch:assert test=" count (//RepresentationItem[substring-after(@xsi:type,':')='CameraModel3D' and @uid=$uidRef]) = 1 "> (AnnotatedModelPresentation.WR2: <sch:value-of select="$uid"/>) If the PresentationType is 'Saved View', the Items shall contain exactly one CameraModel3D. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="AnnotatedModelPresentation_WR1"><!--(Rule AnnotatedModelPresentation.WR1)--><sch:rule context="//Representation[ @uid and substring-after(@xsi:type,':')='AnnotatedModelPresentation']"> <sch:let name="uid" value="@uid"/> <sch:let name="name" value="./Name/CharacterString"/> <sch:assert test="not($name = following-sibling::Representation[substring-after(@xsi:type,':')='AnnotatedModelPresentation']/Name/CharacterString or $name = preceding-sibling::Representation[substring-after(@xsi:type,':')='AnnotatedModelPresentation']/Name/CharacterString)"> (AnnotatedModelPresentation.WR1 <sch:value-of select="$uid"/>) the name should be unique within a population of the AnnotatedModelPresentation/> </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="AnnotationElement"><!--(Ref to S) StyledElement.Element : StyledElementTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnnotationElement') or (self::RepresentationItem and substring-after(@xsi:type,':')='AnnotationElement'))]/Element">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel  PlyAngleRepresentation  ReinforcementOrientationBasis ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef]">(AnnotationElement : <sch:value-of select="$uid"/>) The AnnotationElement.Element contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of StyledElementTargetSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AnnotationPlaceholderOccurrence"><!--(Ref to E) AnnotationPlaceholderOccurrence.Element : GeometricPlaceholderSet (kind=SINGLE - redefined=StyledElement.Element)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnnotationPlaceholderOccurrence') or (self::RepresentationItem and substring-after(@xsi:type,':')='AnnotationPlaceholderOccurrence'))]/Element">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricPlaceholderSet'] or //RepresentationItem[@uid = $uidRef and contains(' GeometricPlaceholderSet ',substring-after(@xsi:type,':'))]">(AnnotationPlaceholderOccurrence : <sch:value-of select="$uid"/>) The AnnotationPlaceholderOccurrence.Element contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricPlaceholderSet.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AnnotationPlane"><!--(Ref to S) AnnotationPlane.Element : PlaneOrPlanarBoxSelect (kind=SINGLE - redefined=StyledElement.Element)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnnotationPlane') or (self::RepresentationItem and substring-after(@xsi:type,':')='AnnotationPlane'))]/Element">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' PlanarBox ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Plane ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' PlanarBox ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Plane ',substring-after(@xsi:type,':'))]">(AnnotationPlane : <sch:value-of select="$uid"/>) The AnnotationPlane.Element contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PlaneOrPlanarBoxSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AnnotationPlane.Elements : OPTIONAL SET[1:unbounded] OF AnnotationPlaneElementSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnnotationPlane') or (self::RepresentationItem and substring-after(@xsi:type,':')='AnnotationPlane'))]/Elements/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Callout and //ExternalRefBaseObject[@uid = $uidRef and contains(' Callout ',@typeRef)]) or (self::StyledElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' StyledElement  AnnotationElement  AnnotationPlaceholderOccurrence  AnnotationPlane  OverRidingStyledElement  ContextDependentOverRidingStyledElement ',@typeRef)]) or (self::Callout and //RepresentationItem[@uid = $uidRef and contains(' Callout ',substring-after(@xsi:type,':'))]) or (self::StyledElement and //RepresentationItem[@uid = $uidRef and contains(' StyledElement  AnnotationElement  AnnotationPlaceholderOccurrence  AnnotationPlane  OverRidingStyledElement  ContextDependentOverRidingStyledElement ',substring-after(@xsi:type,':'))])">(AnnotationPlane : <sch:value-of select="$uid"/>) The AnnotationPlane.Elements contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AnnotationPlaneElementSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AnnotationToAnnotationLeaderLine"><!--(Ref to S) LeaderLine.GeometricElements : LIST[2:unbounded] OF LeaderLinePointSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnnotationToAnnotationLeaderLine') or (self::LeaderLine and substring-after(@xsi:type,':')='AnnotationToAnnotationLeaderLine'))]/GeometricElements/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::LeaderLinePoint and //ExternalRefBaseObject[@uid = $uidRef and contains(' LeaderLinePoint ',@typeRef)]) or (self::LeaderLinePointWithSurface and //ExternalRefBaseObject[@uid = $uidRef and contains(' LeaderLinePointWithSurface ',@typeRef)]) or (self::LeaderLinePoint and //RepresentationItem[@uid = $uidRef and contains(' LeaderLinePoint ',substring-after(@xsi:type,':'))]) or (self::LeaderLinePointWithSurface and //RepresentationItem[@uid = $uidRef and contains(' LeaderLinePointWithSurface ',substring-after(@xsi:type,':'))])">(AnnotationToAnnotationLeaderLine : <sch:value-of select="$uid"/>) The AnnotationToAnnotationLeaderLine.GeometricElements contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of LeaderLinePointSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AnnotationToModelLeaderLine"><!--(Ref to S) LeaderLine.GeometricElements : LIST[2:unbounded] OF LeaderLinePointSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AnnotationToModelLeaderLine') or (self::LeaderLine and substring-after(@xsi:type,':')='AnnotationToModelLeaderLine'))]/GeometricElements/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::LeaderLinePoint and //ExternalRefBaseObject[@uid = $uidRef and contains(' LeaderLinePoint ',@typeRef)]) or (self::LeaderLinePointWithSurface and //ExternalRefBaseObject[@uid = $uidRef and contains(' LeaderLinePointWithSurface ',@typeRef)]) or (self::LeaderLinePoint and //RepresentationItem[@uid = $uidRef and contains(' LeaderLinePoint ',substring-after(@xsi:type,':'))]) or (self::LeaderLinePointWithSurface and //RepresentationItem[@uid = $uidRef and contains(' LeaderLinePointWithSurface ',substring-after(@xsi:type,':'))])">(AnnotationToModelLeaderLine : <sch:value-of select="$uid"/>) The AnnotationToModelLeaderLine.GeometricElements contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of LeaderLinePointSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Apex"><!--(Ref to E) DerivedShapeElement.DerivedFrom : SET[1:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Apex') or (self::ShapeElement and substring-after(@xsi:type,':')='Apex'))]/DerivedFrom/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(Apex : <sch:value-of select="$uid"/>) The Apex.DerivedFrom contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Apex') or (self::ShapeElement and substring-after(@xsi:type,':')='Apex'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Apex : <sch:value-of select="$uid"/>) The Apex.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Apex') or (self::ShapeElement and substring-after(@xsi:type,':')='Apex'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(Apex : <sch:value-of select="$uid"/>) The Apex.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AppearanceAssignment"><!--(Ref to S) AppearanceAssignment.AppearanceComponents : SET[1:unbounded] OF AppearanceSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AppearanceAssignment') or (self::AppearanceAssignment or (self::HiddenElementAppearance and substring-after(@xsi:type,':')='AppearanceAssignment')))]/AppearanceComponents/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::CurveAppearance and //ExternalRefBaseObject[@uid = $uidRef and contains(' CurveAppearance ',@typeRef)]) or (self::TextStyle and //ExternalRefBaseObject[@uid = $uidRef and contains(' TextStyle ',@typeRef)]) or (self::CurveAppearance and //CurveAppearance[@uid = $uidRef]) or (self::TextStyle and //TextStyle[@uid = $uidRef])">(AppearanceAssignment : <sch:value-of select="$uid"/>) The AppearanceAssignment.AppearanceComponents contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AppearanceSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ApplicationDomain"/>
   <sch:pattern id="Approval"><!--(Ref to S) Approval.ApprovalScope : OPTIONAL SET[1:unbounded] OF ApprovalScopeSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Approval') or (self::Approval and not(@xsi:type)))]/ApprovalScope/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::Contract and //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::ProductClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::Project and //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::Contract and //Contract[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef]) or (self::ProductClass and //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::Project and //Project[@uid = $uidRef])">(Approval : <sch:value-of select="$uid"/>) The Approval.ApprovalScope contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ApprovalScopeSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Approval.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Approval') or (self::Approval and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Approval : <sch:value-of select="$uid"/>) The Approval.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Approval.Status : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Approval') or (self::Approval and not(@xsi:type)))]/Status/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Approval : <sch:value-of select="$uid"/>) The Approval.Status contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ApprovalAssignment"><!--(Ref to E) ApprovalAssignment.AssignedApproval : Approval (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ApprovalAssignment') or (self::ApprovalAssignment and not(@xsi:type)))]/AssignedApproval">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Approval'] or //Approval[@uid = $uidRef]">(ApprovalAssignment : <sch:value-of select="$uid"/>) The ApprovalAssignment.AssignedApproval contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Approval.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ApprovalAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ApprovalAssignment') or (self::ApprovalAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ApprovalAssignment : <sch:value-of select="$uid"/>) The ApprovalAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ApprovalAssignment.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ApprovalAssignment') or (self::ApprovalAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ApprovalAssignment : <sch:value-of select="$uid"/>) The ApprovalAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ApprovalRelationship"><!--(Ref to E) ApprovalRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ApprovalRelationship') or (self::ApprovalRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ApprovalRelationship : <sch:value-of select="$uid"/>) The ApprovalRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ApprovalRelationship.Related : Approval (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ApprovalRelationship') or (self::ApprovalRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Approval'] or //Approval[@uid = $uidRef]">(ApprovalRelationship : <sch:value-of select="$uid"/>) The ApprovalRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Approval.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ApprovalRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ApprovalRelationship') or (self::ApprovalRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ApprovalRelationship : <sch:value-of select="$uid"/>) The ApprovalRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ApprovalRelationship_WR1"><!--(Rule ApprovalRelationship.WR1)-->
      <sch:rule context="//ApprovalRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> ApprovalRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Approval and the relating Approval shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="ApprovingPersonOrganization"><!--(Ref to S) ApprovingPersonOrganization.Approver : OrganizationOrPersonInOrganizationSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ApprovingPersonOrganization') or (self::ApprovingPersonOrganization and not(@xsi:type)))]/Approver">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef]">(ApprovingPersonOrganization : <sch:value-of select="$uid"/>) The ApprovingPersonOrganization.Approver contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OrganizationOrPersonInOrganizationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ApprovingPersonOrganization.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ApprovingPersonOrganization') or (self::ApprovingPersonOrganization and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ApprovingPersonOrganization : <sch:value-of select="$uid"/>) The ApprovingPersonOrganization.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Inverse of Approval.ApprovedBy :: PartProperty) ApprovingPersonOrganization.AuthorizedApproval : Approval) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="AssemblyDefinition"><!--(Ref to S) AssemblyDefinition.AssemblyType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyDefinition') or (self::PartView and substring-after(@xsi:type,':')='AssemblyDefinition'))]/AssemblyType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AssemblyDefinition : <sch:value-of select="$uid"/>) The AssemblyDefinition.AssemblyType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyDefinition') or (self::PartView and substring-after(@xsi:type,':')='AssemblyDefinition'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(AssemblyDefinition : <sch:value-of select="$uid"/>) The AssemblyDefinition.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyDefinition') or (self::PartView and substring-after(@xsi:type,':')='AssemblyDefinition'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(AssemblyDefinition : <sch:value-of select="$uid"/>) The AssemblyDefinition.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyDefinition') or (self::PartView and substring-after(@xsi:type,':')='AssemblyDefinition'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AssemblyDefinition : <sch:value-of select="$uid"/>) The AssemblyDefinition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyDefinition') or (self::PartView and substring-after(@xsi:type,':')='AssemblyDefinition'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(AssemblyDefinition : <sch:value-of select="$uid"/>) The AssemblyDefinition.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyDefinition') or (self::PartView and substring-after(@xsi:type,':')='AssemblyDefinition'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(AssemblyDefinition : <sch:value-of select="$uid"/>) The AssemblyDefinition.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="AssemblyOccurrenceRelationshipSubstitution"><!--(Ref to E) AssemblyOccurrenceRelationshipSubstitution.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyOccurrenceRelationshipSubstitution') or (self::AssemblyOccurrenceRelationshipSubstitution and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AssemblyOccurrenceRelationshipSubstitution : <sch:value-of select="$uid"/>) The AssemblyOccurrenceRelationshipSubstitution.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AssemblyOccurrenceRelationshipSubstitution.Related : AssemblyOccurrenceRelationship (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyOccurrenceRelationshipSubstitution') or (self::AssemblyOccurrenceRelationshipSubstitution and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AssemblyOccurrenceRelationship'] or //ViewOccurrenceRelationship[@uid = $uidRef and contains(' AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage ',substring-after(@xsi:type,':'))]">(AssemblyOccurrenceRelationshipSubstitution : <sch:value-of select="$uid"/>) The AssemblyOccurrenceRelationshipSubstitution.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AssemblyOccurrenceRelationship.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AssemblyOccurrenceRelationshipSubstitution_WR1"><!--(Rule AssemblyOccurrenceRelationshipSubstitution.WR1)-->
      <sch:rule context="//AssemblyOccurrenceRelationshipSubstitution"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> AssemblyOccurrenceRelationshipSubstitution WR1 Error on entity <sch:value-of select="$uid"/>: the related AssemblyOccurrenceSubstitution and the relating AssemblyOccurrenceSubstitution shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="AssemblyRealizationContext"><!--(Ref to E) AssemblyRealizationContext.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyRealizationContext') or (self::AssemblyRealizationContext and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AssemblyRealizationContext : <sch:value-of select="$uid"/>) The AssemblyRealizationContext.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssemblyRealizationContext.Related : AssemblyDesignSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyRealizationContext') or (self::AssemblyRealizationContext and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DefinitionalPartViewUsage ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //PartViewRelationship[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',substring-after(@xsi:type,':'))] or //PartViewRelationship[@uid = $uidRef and contains(' DefinitionalPartViewUsage ',substring-after(@xsi:type,':'))] or //Occurrence[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))]">(AssemblyRealizationContext : <sch:value-of select="$uid"/>) The AssemblyRealizationContext.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AssemblyDesignSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AssemblyShapeConstraint"><!--(Ref to S) AssemblyShapeConstraint.PartDefinition : OPTIONAL AssemblyShapeConstraintOrJointDefinitionSelect (kind=SINGLE - redefined=PartShapeElement.PartDefinition)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyShapeConstraint') or (self::ShapeElement and substring-after(@xsi:type,':')='AssemblyShapeConstraint'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(AssemblyShapeConstraint : <sch:value-of select="$uid"/>) The AssemblyShapeConstraint.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AssemblyShapeConstraintOrJointDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyShapeConstraint') or (self::ShapeElement and substring-after(@xsi:type,':')='AssemblyShapeConstraint'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AssemblyShapeConstraint : <sch:value-of select="$uid"/>) The AssemblyShapeConstraint.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyShapeConstraint') or (self::ShapeElement and substring-after(@xsi:type,':')='AssemblyShapeConstraint'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(AssemblyShapeConstraint : <sch:value-of select="$uid"/>) The AssemblyShapeConstraint.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AssemblyShapeConstraintItemRelationship"><!--(Ref to E) AssemblyShapeConstraintItemRelationship.Related : OccurrenceShapeFeature (kind=SINGLE - redefined=ShapeElementRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyShapeConstraintItemRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='AssemblyShapeConstraintItemRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'OccurrenceShapeFeature'] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))]">(AssemblyShapeConstraintItemRelationship : <sch:value-of select="$uid"/>) The AssemblyShapeConstraintItemRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type OccurrenceShapeFeature.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElementRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyShapeConstraintItemRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='AssemblyShapeConstraintItemRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AssemblyShapeConstraintItemRelationship : <sch:value-of select="$uid"/>) The AssemblyShapeConstraintItemRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElementRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyShapeConstraintItemRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='AssemblyShapeConstraintItemRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AssemblyShapeConstraintItemRelationship : <sch:value-of select="$uid"/>) The AssemblyShapeConstraintItemRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElementRelationship.RepresentedGeometry : OPTIONAL RepresentationItem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyShapeConstraintItemRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='AssemblyShapeConstraintItemRelationship'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./RepresentedGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(AssemblyShapeConstraintItemRelationship : <sch:value-of select="$uid"/>) The AssemblyShapeConstraintItemRelationship.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AssemblyShapeJoint"><!--(Ref to S) AssemblyShapeJoint.PartDefinition : OPTIONAL AssemblyShapeConstraintOrJointDefinitionSelect (kind=SINGLE - redefined=PartShapeElement.PartDefinition)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyShapeJoint') or (self::ShapeElement and substring-after(@xsi:type,':')='AssemblyShapeJoint'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(AssemblyShapeJoint : <sch:value-of select="$uid"/>) The AssemblyShapeJoint.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AssemblyShapeConstraintOrJointDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyShapeJoint') or (self::ShapeElement and substring-after(@xsi:type,':')='AssemblyShapeJoint'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AssemblyShapeJoint : <sch:value-of select="$uid"/>) The AssemblyShapeJoint.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyShapeJoint') or (self::ShapeElement and substring-after(@xsi:type,':')='AssemblyShapeJoint'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(AssemblyShapeJoint : <sch:value-of select="$uid"/>) The AssemblyShapeJoint.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AssemblyShapeJointItemRelationship"><!--(Ref to E) AssemblyShapeJointItemRelationship.Related : OccurrenceShapeFeature (kind=SINGLE - redefined=ShapeElementRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyShapeJointItemRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='AssemblyShapeJointItemRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'OccurrenceShapeFeature'] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))]">(AssemblyShapeJointItemRelationship : <sch:value-of select="$uid"/>) The AssemblyShapeJointItemRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type OccurrenceShapeFeature.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElementRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyShapeJointItemRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='AssemblyShapeJointItemRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AssemblyShapeJointItemRelationship : <sch:value-of select="$uid"/>) The AssemblyShapeJointItemRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElementRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyShapeJointItemRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='AssemblyShapeJointItemRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AssemblyShapeJointItemRelationship : <sch:value-of select="$uid"/>) The AssemblyShapeJointItemRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElementRelationship.RepresentedGeometry : OPTIONAL RepresentationItem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyShapeJointItemRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='AssemblyShapeJointItemRelationship'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./RepresentedGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(AssemblyShapeJointItemRelationship : <sch:value-of select="$uid"/>) The AssemblyShapeJointItemRelationship.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AssemblyViewRelationshipSubstitution"><!--(Ref to E) AssemblyViewRelationshipSubstitution.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyViewRelationshipSubstitution') or (self::AssemblyViewRelationshipSubstitution and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AssemblyViewRelationshipSubstitution : <sch:value-of select="$uid"/>) The AssemblyViewRelationshipSubstitution.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AssemblyViewRelationshipSubstitution.Related : AssemblyViewRelationship (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssemblyViewRelationshipSubstitution') or (self::AssemblyViewRelationshipSubstitution and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AssemblyViewRelationship'] or //PartViewRelationship[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',substring-after(@xsi:type,':'))]">(AssemblyViewRelationshipSubstitution : <sch:value-of select="$uid"/>) The AssemblyViewRelationshipSubstitution.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AssemblyViewRelationship.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AssemblyViewRelationshipSubstitution_WR1"><!--(Rule AssemblyViewRelationshipSubstitution.WR1)-->
      <sch:rule context="//AssemblyViewRelationshipSubstitution"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> AssemblyViewRelationshipSubstitution WR1 Error on entity <sch:value-of select="$uid"/>: the related AssemblyViewSubstitution and the relating AssemblyViewSubstitution shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="AssignmentObjectRelationship"><!--(Ref to E) AssignmentObjectRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssignmentObjectRelationship') or (self::AssignmentObjectRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AssignmentObjectRelationship : <sch:value-of select="$uid"/>) The AssignmentObjectRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObjectRelationship.Related : AssignmentObjectSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssignmentObjectRelationship') or (self::AssignmentObjectRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)] or //ActivityAssignment[@uid = $uidRef] or //ActivityMethodAssignment[@uid = $uidRef] or //AddressAssignment[@uid = $uidRef] or //ApprovalAssignment[@uid = $uidRef] or //BreakdownVersionAssignment[@uid = $uidRef] or //CertificationAssignment[@uid = $uidRef] or //ConditionAssignment[@uid = $uidRef] or //ContractAssignment[@uid = $uidRef] or //DateAndPersonAssignment[@uid = $uidRef] or //DateTimeAssignment[@uid = $uidRef] or //DocumentAssignment[@uid = $uidRef] or //EffectivityAssignment[@uid = $uidRef] or //EventAssignment[@uid = $uidRef] or //InformationUsageRightAssignment[@uid = $uidRef] or //MaterialPropertyAssignment[@uid = $uidRef] or //ModelPropertyAssignment[@uid = $uidRef] or //ObservationAssignment[@uid = $uidRef] or //ObservationConsequence[@uid = $uidRef] or //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef] or //ProcessOperationResourceAssignment[@uid = $uidRef] or //ProjectAssignment[@uid = $uidRef] or //PropertyDefinitionAssignment[@uid = $uidRef] or //PropertyValueAssignment[@uid = $uidRef] or //RequirementAssignment[@uid = $uidRef] or //SecurityClassificationAssignment[@uid = $uidRef] or //SpecificationAssignment[@uid = $uidRef] or //SpecificationCategoryAssignment[@uid = $uidRef] or //SpecificationConditionAssignment[@uid = $uidRef] or //SpecificationInclusionAssignment[@uid = $uidRef] or //TimeIntervalAssignment[@uid = $uidRef] or //WorkOrderAssignment[@uid = $uidRef] or //WorkRequestAssignment[@uid = $uidRef]">(AssignmentObjectRelationship : <sch:value-of select="$uid"/>) The AssignmentObjectRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AssignmentObjectSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssignmentObjectRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AssignmentObjectRelationship') or (self::AssignmentObjectRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(AssignmentObjectRelationship : <sch:value-of select="$uid"/>) The AssignmentObjectRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AuxiliaryLeaderLine"><!--(Ref to E) AuxiliaryLeaderLine.ControllingLeaderLine : AnnotationToModelLeaderLine (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AuxiliaryLeaderLine') or (self::LeaderLine and substring-after(@xsi:type,':')='AuxiliaryLeaderLine'))]/ControllingLeaderLine">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AnnotationToModelLeaderLine'] or //LeaderLine[@uid = $uidRef and contains(' AnnotationToModelLeaderLine ',substring-after(@xsi:type,':'))]">(AuxiliaryLeaderLine : <sch:value-of select="$uid"/>) The AuxiliaryLeaderLine.ControllingLeaderLine contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AnnotationToModelLeaderLine.</sch:assert>
      </sch:rule>
      <!--(Ref to S) LeaderLine.GeometricElements : LIST[2:unbounded] OF LeaderLinePointSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AuxiliaryLeaderLine') or (self::LeaderLine and substring-after(@xsi:type,':')='AuxiliaryLeaderLine'))]/GeometricElements/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::LeaderLinePoint and //ExternalRefBaseObject[@uid = $uidRef and contains(' LeaderLinePoint ',@typeRef)]) or (self::LeaderLinePointWithSurface and //ExternalRefBaseObject[@uid = $uidRef and contains(' LeaderLinePointWithSurface ',@typeRef)]) or (self::LeaderLinePoint and //RepresentationItem[@uid = $uidRef and contains(' LeaderLinePoint ',substring-after(@xsi:type,':'))]) or (self::LeaderLinePointWithSurface and //RepresentationItem[@uid = $uidRef and contains(' LeaderLinePointWithSurface ',substring-after(@xsi:type,':'))])">(AuxiliaryLeaderLine : <sch:value-of select="$uid"/>) The AuxiliaryLeaderLine.GeometricElements contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of LeaderLinePointSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="AxisPlacement"/>
   <sch:pattern id="AxisPlacementShapeElement"><!--(Ref to E) AxisPlacementShapeElement.RepresentedGeometry : AxisPlacement (kind=SINGLE - redefined=ShapeElement.RepresentedGeometry)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AxisPlacementShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='AxisPlacementShapeElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(AxisPlacementShapeElement : <sch:value-of select="$uid"/>) The AxisPlacementShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='AxisPlacementShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='AxisPlacementShapeElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(AxisPlacementShapeElement : <sch:value-of select="$uid"/>) The AxisPlacementShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BetweenShapeElement"><!--(Ref to E) BetweenShapeElement.EndFeatures : SET[1:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BetweenShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='BetweenShapeElement'))]/EndFeatures/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(BetweenShapeElement : <sch:value-of select="$uid"/>) The BetweenShapeElement.EndFeatures contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) BetweenShapeElement.StartFeatures : SET[1:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BetweenShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='BetweenShapeElement'))]/StartFeatures/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(BetweenShapeElement : <sch:value-of select="$uid"/>) The BetweenShapeElement.StartFeatures contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) CompositeShapeElement.Components : SET[2:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BetweenShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='BetweenShapeElement'))]/Components/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(BetweenShapeElement : <sch:value-of select="$uid"/>) The BetweenShapeElement.Components contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BetweenShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='BetweenShapeElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(BetweenShapeElement : <sch:value-of select="$uid"/>) The BetweenShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BetweenShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='BetweenShapeElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(BetweenShapeElement : <sch:value-of select="$uid"/>) The BetweenShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BetweenShapeElement_WR2"><!--(Rule BetweenShapeElement.WR2)--><sch:rule context="//ShapeElement/EndFeatures/ShapeElement"> <sch:let name="uidRef" value="@uidRef"/> <sch:let name="uid" value="../../@uid"/> <sch:assert test=" //ShapeElement[@uid=$uidRef]/ProductDefinitional='true'"> (BetweenShapeElement <sch:value-of select="$uid"/>) all EndFeatures shall be definitional <sch:value-of select="$uidRef"/>=<sch:value-of select="//ShapeElement[@uid=$uidRef]/ProductDefinitional"/>. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="BetweenShapeElement_WR1"><!--(Rule BetweenShapeElement.WR1)--><sch:rule context="//ShapeElement/StartFeatures/ShapeElement"> <sch:let name="uidRef" value="@uidRef"/> <sch:let name="uid" value="../../@uid"/> <sch:assert test=" //ShapeElement[@uid=$uidRef]/ProductDefinitional='true'"> (BetweenShapeElement <sch:value-of select="$uid"/>) all StartFeatures shall be definitional <sch:value-of select="$uidRef"/>=<sch:value-of select="//ShapeElement[@uid=$uidRef]/ProductDefinitional"/>. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="BeveledSheetRepresentation"><!--(Ref to E) BeveledSheetRepresentation.BoundarySurface : CompositeSheetRepresentation (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BeveledSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='BeveledSheetRepresentation'))]/BoundarySurface">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'CompositeSheetRepresentation'] or //Representation[@uid = $uidRef and contains(' CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation ',substring-after(@xsi:type,':'))]">(BeveledSheetRepresentation : <sch:value-of select="$uid"/>) The BeveledSheetRepresentation.BoundarySurface contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type CompositeSheetRepresentation.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BeveledSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='BeveledSheetRepresentation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(BeveledSheetRepresentation : <sch:value-of select="$uid"/>) The BeveledSheetRepresentation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Representation.Items : SET[1:unbounded] OF RepresentationItem (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BeveledSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='BeveledSheetRepresentation'))]/Items/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(BeveledSheetRepresentation : <sch:value-of select="$uid"/>) The BeveledSheetRepresentation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BeveledSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='BeveledSheetRepresentation'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(BeveledSheetRepresentation : <sch:value-of select="$uid"/>) The BeveledSheetRepresentation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="BooleanRepresentationItem"/>
   <sch:pattern id="BoundaryCurveSet"><!--(Ref to E) BoundaryCurveSet.Bounds : SET[1:unbounded] OF Curve (kind=AGGREGATE - redefined=GeometricCurveSet.Elements)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BoundaryCurveSet') or (self::RepresentationItem and substring-after(@xsi:type,':')='BoundaryCurveSet'))]/Elements/Curve">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Curve'] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))]">(BoundaryCurveSet : <sch:value-of select="$uid"/>) The BoundaryCurveSet.Elements contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Curve.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BoundedCurve"/>
   <sch:pattern id="BoundedCurveWithLength"/>
   <sch:pattern id="BoundingBox"><!--(Ref to E) BoundingBox.DefinedIn : GeometricCoordinateSpace (kind=SINGLE - redefined=ShapeDependentProperty.DefinedIn)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BoundingBox') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='BoundingBox'))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricCoordinateSpace'] or //RepresentationContext[@uid = $uidRef and contains(' GeometricCoordinateSpace ',substring-after(@xsi:type,':'))]">(BoundingBox : <sch:value-of select="$uid"/>) The BoundingBox.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricCoordinateSpace.</sch:assert>
      </sch:rule>
      <!--(Ref to E) BoundingBox.PointMax : CartesianPoint (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BoundingBox') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='BoundingBox'))]/PointMax">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'CartesianPoint'] or //RepresentationItem[@uid = $uidRef and contains(' CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface ',substring-after(@xsi:type,':'))]">(BoundingBox : <sch:value-of select="$uid"/>) The BoundingBox.PointMax contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type CartesianPoint.</sch:assert>
      </sch:rule>
      <!--(Ref to E) BoundingBox.PointMin : CartesianPoint (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BoundingBox') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='BoundingBox'))]/PointMin">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'CartesianPoint'] or //RepresentationItem[@uid = $uidRef and contains(' CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface ',substring-after(@xsi:type,':'))]">(BoundingBox : <sch:value-of select="$uid"/>) The BoundingBox.PointMin contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type CartesianPoint.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeDependentProperty.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BoundingBox') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='BoundingBox'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(BoundingBox : <sch:value-of select="$uid"/>) The BoundingBox.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeDependentProperty.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BoundingBox') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='BoundingBox'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(BoundingBox : <sch:value-of select="$uid"/>) The BoundingBox.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeDependentProperty.ValueDetermination : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BoundingBox') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='BoundingBox'))]/ValueDetermination/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(BoundingBox : <sch:value-of select="$uid"/>) The BoundingBox.ValueDetermination contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Breakdown"><!--(Ref to S) Breakdown.BreakdownType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Breakdown') or (self::Breakdown and not(@xsi:type)))]/BreakdownType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Breakdown : <sch:value-of select="$uid"/>) The Breakdown.BreakdownType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Breakdown.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Breakdown') or (self::Breakdown and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Breakdown : <sch:value-of select="$uid"/>) The Breakdown.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownContext"><!--(Ref to E) BreakdownContext.BreakdownElement : BreakdownElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownContext') or (self::BreakdownContext and not(@xsi:type)))]/BreakdownElement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElement'] or //BreakdownElement[@uid = $uidRef]">(BreakdownContext : <sch:value-of select="$uid"/>) The BreakdownContext.BreakdownElement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) BreakdownContext.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownContext') or (self::BreakdownContext and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(BreakdownContext : <sch:value-of select="$uid"/>) The BreakdownContext.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownElement"><!--(Ref to E) BreakdownElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElement') or (self::BreakdownElement and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(BreakdownElement : <sch:value-of select="$uid"/>) The BreakdownElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownElementRealization"><!--(Ref to E) BreakdownElementRealization.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementRealization') or (self::BreakdownElementRealization and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(BreakdownElementRealization : <sch:value-of select="$uid"/>) The BreakdownElementRealization.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) BreakdownElementRealization.Related : BreakdownElementOrOccurrenceSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementRealization') or (self::BreakdownElementRealization and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)] or //BreakdownElement[@uid = $uidRef] or //Occurrence[@uid = $uidRef]">(BreakdownElementRealization : <sch:value-of select="$uid"/>) The BreakdownElementRealization.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of BreakdownElementOrOccurrenceSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) BreakdownElementRealization.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementRealization') or (self::BreakdownElementRealization and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(BreakdownElementRealization : <sch:value-of select="$uid"/>) The BreakdownElementRealization.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownElementRealization_WR1"><!--(Rule BreakdownElementRealization.WR1)-->
      <sch:rule context="//BreakdownElementRealization"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> BreakdownElementRealization WR1 Error on entity <sch:value-of select="$uid"/>: the related BreakdownElementRealization and the relating BreakdownElementRealization shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownElementRelationship"><!--(Ref to E) BreakdownElementRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementRelationship') or (self::BreakdownElementRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(BreakdownElementRelationship : <sch:value-of select="$uid"/>) The BreakdownElementRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) BreakdownElementRelationship.Related : BreakdownElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementRelationship') or (self::BreakdownElementRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElement'] or //BreakdownElement[@uid = $uidRef]">(BreakdownElementRelationship : <sch:value-of select="$uid"/>) The BreakdownElementRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElement.</sch:assert>
      </sch:rule>
      <!--(Ref to S) BreakdownElementRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementRelationship') or (self::BreakdownElementRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(BreakdownElementRelationship : <sch:value-of select="$uid"/>) The BreakdownElementRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownElementRelationship_WR1"><!--(Rule BreakdownElementRelationship.WR1)-->
      <sch:rule context="//BreakdownElementRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> BreakdownElementRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related BreakdownElement and the relating BreakdownElement shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownElementVersion"><!--(Ref to E) BreakdownElementVersion.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementVersion') or (self::BreakdownElementVersion and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(BreakdownElementVersion : <sch:value-of select="$uid"/>) The BreakdownElementVersion.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Inverse of BreakdownElement.Versions :: PartProperty) BreakdownElementVersion.VersionOf : BreakdownElement) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="BreakdownElementVersionRelationship"><!--(Ref to E) BreakdownElementVersionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementVersionRelationship') or (self::BreakdownElementVersionRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(BreakdownElementVersionRelationship : <sch:value-of select="$uid"/>) The BreakdownElementVersionRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) BreakdownElementVersionRelationship.Related : BreakdownElementVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementVersionRelationship') or (self::BreakdownElementVersionRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElementVersion'] or //BreakdownElementVersion[@uid = $uidRef]">(BreakdownElementVersionRelationship : <sch:value-of select="$uid"/>) The BreakdownElementVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElementVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) BreakdownElementVersionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementVersionRelationship') or (self::BreakdownElementVersionRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(BreakdownElementVersionRelationship : <sch:value-of select="$uid"/>) The BreakdownElementVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownElementVersionRelationship_WR1"><!--(Rule BreakdownElementVersionRelationship.WR1)-->
      <sch:rule context="//BreakdownElementVersionRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> BreakdownElementVersionRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related BreakdownElementVersion and the relating BreakdownElementVersion shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownElementView"><!--(Ref to E) BreakdownElementView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementView') or (self::BreakdownElementView and not(@xsi:type)))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(BreakdownElementView : <sch:value-of select="$uid"/>) The BreakdownElementView.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) BreakdownElementView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementView') or (self::BreakdownElementView and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(BreakdownElementView : <sch:value-of select="$uid"/>) The BreakdownElementView.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) BreakdownElementView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementView') or (self::BreakdownElementView and not(@xsi:type)))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(BreakdownElementView : <sch:value-of select="$uid"/>) The BreakdownElementView.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) BreakdownElementView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementView') or (self::BreakdownElementView and not(@xsi:type)))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(BreakdownElementView : <sch:value-of select="$uid"/>) The BreakdownElementView.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of BreakdownElementVersion.Views :: PartProperty) BreakdownElementView.ViewOf : BreakdownElementVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="BreakdownElementViewRelationship"><!--(Ref to E) BreakdownElementViewRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementViewRelationship') or (self::BreakdownElementViewRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(BreakdownElementViewRelationship : <sch:value-of select="$uid"/>) The BreakdownElementViewRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) BreakdownElementViewRelationship.Related : BreakdownElementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementViewRelationship') or (self::BreakdownElementViewRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElementView'] or //BreakdownElementView[@uid = $uidRef]">(BreakdownElementViewRelationship : <sch:value-of select="$uid"/>) The BreakdownElementViewRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElementView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) BreakdownElementViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownElementViewRelationship') or (self::BreakdownElementViewRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(BreakdownElementViewRelationship : <sch:value-of select="$uid"/>) The BreakdownElementViewRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownElementViewRelationship_WR1"><!--(Rule BreakdownElementViewRelationship.WR1)-->
      <sch:rule context="//BreakdownElementViewRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> BreakdownElementViewRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related BreakdownElementView and the relating BreakdownElementView shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownRelationship"><!--(Ref to E) BreakdownRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownRelationship') or (self::BreakdownRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(BreakdownRelationship : <sch:value-of select="$uid"/>) The BreakdownRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) BreakdownRelationship.Related : Breakdown (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownRelationship') or (self::BreakdownRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Breakdown'] or //Breakdown[@uid = $uidRef]">(BreakdownRelationship : <sch:value-of select="$uid"/>) The BreakdownRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Breakdown.</sch:assert>
      </sch:rule>
      <!--(Ref to S) BreakdownRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownRelationship') or (self::BreakdownRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(BreakdownRelationship : <sch:value-of select="$uid"/>) The BreakdownRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownRelationship_WR1"><!--(Rule BreakdownRelationship.WR1)-->
      <sch:rule context="//BreakdownRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> BreakdownRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Breakdown and the relating Breakdown shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownVersion"><!--(Ref to E) BreakdownVersion.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownVersion') or (self::BreakdownVersion and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(BreakdownVersion : <sch:value-of select="$uid"/>) The BreakdownVersion.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Inverse of Breakdown.Versions :: PartProperty) BreakdownVersion.VersionOf : Breakdown) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="BreakdownVersionAssignment"><!--(Ref to E) BreakdownVersionAssignment.AssignedBreakdownVersion : BreakdownVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownVersionAssignment') or (self::BreakdownVersionAssignment and not(@xsi:type)))]/AssignedBreakdownVersion">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownVersion'] or //BreakdownVersion[@uid = $uidRef]">(BreakdownVersionAssignment : <sch:value-of select="$uid"/>) The BreakdownVersionAssignment.AssignedBreakdownVersion contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to E) BreakdownVersionAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownVersionAssignment') or (self::BreakdownVersionAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(BreakdownVersionAssignment : <sch:value-of select="$uid"/>) The BreakdownVersionAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) BreakdownVersionAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownVersionAssignment') or (self::BreakdownVersionAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(BreakdownVersionAssignment : <sch:value-of select="$uid"/>) The BreakdownVersionAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownVersionRelationship"><!--(Ref to E) BreakdownVersionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownVersionRelationship') or (self::BreakdownVersionRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(BreakdownVersionRelationship : <sch:value-of select="$uid"/>) The BreakdownVersionRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) BreakdownVersionRelationship.Related : BreakdownVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownVersionRelationship') or (self::BreakdownVersionRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownVersion'] or //BreakdownVersion[@uid = $uidRef]">(BreakdownVersionRelationship : <sch:value-of select="$uid"/>) The BreakdownVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) BreakdownVersionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='BreakdownVersionRelationship') or (self::BreakdownVersionRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(BreakdownVersionRelationship : <sch:value-of select="$uid"/>) The BreakdownVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="BreakdownVersionRelationship_WR1"><!--(Rule BreakdownVersionRelationship.WR1)-->
      <sch:rule context="//BreakdownVersionRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> BreakdownVersionRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related BreakdownVersion and the relating BreakdownVersion shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="CableOccurrence"><!--(Ref to E) Occurrence.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CableOccurrence') or (self::Occurrence and substring-after(@xsi:type,':')='CableOccurrence'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CableOccurrence : <sch:value-of select="$uid"/>) The CableOccurrence.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Occurrence.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CableOccurrence') or (self::Occurrence and substring-after(@xsi:type,':')='CableOccurrence'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(CableOccurrence : <sch:value-of select="$uid"/>) The CableOccurrence.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CableOccurrenceTerminal"><!--(Ref to E) CableOccurrenceTerminal.AssociatedTransportFeature : WireOccurrenceIdentification (kind=SINGLE - redefined=OccurrenceTerminal.AssociatedTransportFeature)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CableOccurrenceTerminal') or (self::ShapeElement and substring-after(@xsi:type,':')='CableOccurrenceTerminal'))]/AssociatedTransportFeature">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'WireOccurrenceIdentification'] or //ShapeElement[@uid = $uidRef and contains(' WireOccurrenceIdentification ',substring-after(@xsi:type,':'))]">(CableOccurrenceTerminal : <sch:value-of select="$uid"/>) The CableOccurrenceTerminal.AssociatedTransportFeature contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type WireOccurrenceIdentification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) OccurrenceTerminal.Definition : OPTIONAL OccurrenceTerminalDefinitionSelect (kind=SINGLE - redefined=OccurrenceContactFeature.Definition)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CableOccurrenceTerminal') or (self::ShapeElement and substring-after(@xsi:type,':')='CableOccurrenceTerminal'))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartTerminal ',@typeRef)] or //ShapeFeatureDefinition[@uid = $uidRef and contains(' ContactFeatureDefinition ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartTerminal ',substring-after(@xsi:type,':'))]">(CableOccurrenceTerminal : <sch:value-of select="$uid"/>) The CableOccurrenceTerminal.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OccurrenceTerminalDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CableOccurrenceTerminal') or (self::ShapeElement and substring-after(@xsi:type,':')='CableOccurrenceTerminal'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CableOccurrenceTerminal : <sch:value-of select="$uid"/>) The CableOccurrenceTerminal.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CableOccurrenceTerminal') or (self::ShapeElement and substring-after(@xsi:type,':')='CableOccurrenceTerminal'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(CableOccurrenceTerminal : <sch:value-of select="$uid"/>) The CableOccurrenceTerminal.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CableOccurrenceTerminalLocationGroup"><!--(Ref to E) OccurrenceTerminal.AssociatedTransportFeature : OPTIONAL OccurrenceTransportFeature (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CableOccurrenceTerminalLocationGroup') or (self::ShapeElement and substring-after(@xsi:type,':')='CableOccurrenceTerminalLocationGroup'))]/AssociatedTransportFeature">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./AssociatedTransportFeature) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'OccurrenceTransportFeature'] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))]">(CableOccurrenceTerminalLocationGroup : <sch:value-of select="$uid"/>) The CableOccurrenceTerminalLocationGroup.AssociatedTransportFeature contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type OccurrenceTransportFeature.</sch:assert>
      </sch:rule>
      <!--(Ref to S) OccurrenceTerminal.Definition : OPTIONAL OccurrenceTerminalDefinitionSelect (kind=SINGLE - redefined=OccurrenceContactFeature.Definition)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CableOccurrenceTerminalLocationGroup') or (self::ShapeElement and substring-after(@xsi:type,':')='CableOccurrenceTerminalLocationGroup'))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartTerminal ',@typeRef)] or //ShapeFeatureDefinition[@uid = $uidRef and contains(' ContactFeatureDefinition ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartTerminal ',substring-after(@xsi:type,':'))]">(CableOccurrenceTerminalLocationGroup : <sch:value-of select="$uid"/>) The CableOccurrenceTerminalLocationGroup.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OccurrenceTerminalDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CableOccurrenceTerminalLocationGroup') or (self::ShapeElement and substring-after(@xsi:type,':')='CableOccurrenceTerminalLocationGroup'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CableOccurrenceTerminalLocationGroup : <sch:value-of select="$uid"/>) The CableOccurrenceTerminalLocationGroup.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CableOccurrenceTerminalLocationGroup') or (self::ShapeElement and substring-after(@xsi:type,':')='CableOccurrenceTerminalLocationGroup'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(CableOccurrenceTerminalLocationGroup : <sch:value-of select="$uid"/>) The CableOccurrenceTerminalLocationGroup.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Callout"><!--(Ref to S) Callout.Contents : SET[1:unbounded] OF CalloutElementSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Callout') or (self::RepresentationItem and substring-after(@xsi:type,':')='Callout'))]/Contents/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::AnnotationPlaceholderOccurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' AnnotationPlaceholderOccurrence ',@typeRef)]) or (self::ExternalTessellatedAnnotation and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalTessellatedAnnotation ',@typeRef)]) or (self::AnnotationPlaceholderOccurrence and //RepresentationItem[@uid = $uidRef and contains(' AnnotationPlaceholderOccurrence ',substring-after(@xsi:type,':'))]) or (self::ExternalTessellatedAnnotation and //RepresentationItem[@uid = $uidRef and contains(' ExternalTessellatedAnnotation ',substring-after(@xsi:type,':'))])">(Callout : <sch:value-of select="$uid"/>) The Callout.Contents contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of CalloutElementSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CalloutRelationship"><!--(Ref to E) CalloutRelationship.Related : Callout (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CalloutRelationship') or (self::CalloutRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Callout'] or //RepresentationItem[@uid = $uidRef and contains(' Callout ',substring-after(@xsi:type,':'))]">(CalloutRelationship : <sch:value-of select="$uid"/>) The CalloutRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Callout.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CameraModel3D"><!--(Ref to E) CameraModel3D.Clipping : OPTIONAL ClippingOperator (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CameraModel3D') or (self::RepresentationItem and substring-after(@xsi:type,':')='CameraModel3D'))]/Clipping">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Clipping) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ClippingOperator'] or //RepresentationItem[@uid = $uidRef and contains(' ClippingOperator ',substring-after(@xsi:type,':'))]">(CameraModel3D : <sch:value-of select="$uid"/>) The CameraModel3D.Clipping contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ClippingOperator.</sch:assert>
      </sch:rule>
      <!--(Ref to E) CameraModel3D.Sources : OPTIONAL SET[1:unbounded] OF LightSource (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CameraModel3D') or (self::RepresentationItem and substring-after(@xsi:type,':')='CameraModel3D'))]/Sources/LightSource">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Sources/LightSource) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'LightSource'] or //RepresentationItem[@uid = $uidRef and contains(' LightSource ',substring-after(@xsi:type,':'))]">(CameraModel3D : <sch:value-of select="$uid"/>) The CameraModel3D.Sources contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type LightSource.</sch:assert>
      </sch:rule>
      <!--(Ref to E) CameraModel3D.ViewWindow : PlanarBox (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CameraModel3D') or (self::RepresentationItem and substring-after(@xsi:type,':')='CameraModel3D'))]/ViewWindow">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlanarBox'] or //RepresentationItem[@uid = $uidRef and contains(' PlanarBox ',substring-after(@xsi:type,':'))]">(CameraModel3D : <sch:value-of select="$uid"/>) The CameraModel3D.ViewWindow contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlanarBox.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CameraModel3D_WR1"><!--(Rule CameraModel3D.WR1)--><sch:rule context="//RepresentationItem[ @uid and substring-after(@xsi:type,':')='CameraModel3D' and not(.//HiddenLineRemoval)]"> <sch:let name="uid" value="@uid"/> <sch:assert test="not(./HiddenElementAppearance)">(CameraModel3D : <sch:value-of select="$uid"/>) If the HiddenLineRemoval is not set, then the HiddenElementAppearance shall not be set as well.</sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="Cartesian11"><!--(Ref to E) Cartesian11.Placement : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Cartesian11') or (self::RepresentationItem and substring-after(@xsi:type,':')='Cartesian11'))]/Placement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(Cartesian11 : <sch:value-of select="$uid"/>) The Cartesian11.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CartesianPoint"/>
   <sch:pattern id="CartesianTransformation"/>
   <sch:pattern id="CentreOfMass"><!--(Ref to E) CentreOfMass.CentrePoint : CartesianPoint (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CentreOfMass') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='CentreOfMass'))]/CentrePoint">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'CartesianPoint'] or //RepresentationItem[@uid = $uidRef and contains(' CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface ',substring-after(@xsi:type,':'))]">(CentreOfMass : <sch:value-of select="$uid"/>) The CentreOfMass.CentrePoint contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type CartesianPoint.</sch:assert>
      </sch:rule>
      <!--(Ref to E) CentreOfMass.DefinedIn : GeometricCoordinateSpace (kind=SINGLE - redefined=ShapeDependentProperty.DefinedIn)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CentreOfMass') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='CentreOfMass'))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricCoordinateSpace'] or //RepresentationContext[@uid = $uidRef and contains(' GeometricCoordinateSpace ',substring-after(@xsi:type,':'))]">(CentreOfMass : <sch:value-of select="$uid"/>) The CentreOfMass.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricCoordinateSpace.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeDependentProperty.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CentreOfMass') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='CentreOfMass'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CentreOfMass : <sch:value-of select="$uid"/>) The CentreOfMass.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeDependentProperty.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CentreOfMass') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='CentreOfMass'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(CentreOfMass : <sch:value-of select="$uid"/>) The CentreOfMass.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeDependentProperty.ValueDetermination : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CentreOfMass') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='CentreOfMass'))]/ValueDetermination/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(CentreOfMass : <sch:value-of select="$uid"/>) The CentreOfMass.ValueDetermination contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CentreOfSymmetry"><!--(Ref to E) DerivedShapeElement.DerivedFrom : SET[1:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CentreOfSymmetry') or (self::ShapeElement and substring-after(@xsi:type,':')='CentreOfSymmetry'))]/DerivedFrom/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(CentreOfSymmetry : <sch:value-of select="$uid"/>) The CentreOfSymmetry.DerivedFrom contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CentreOfSymmetry') or (self::ShapeElement and substring-after(@xsi:type,':')='CentreOfSymmetry'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CentreOfSymmetry : <sch:value-of select="$uid"/>) The CentreOfSymmetry.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CentreOfSymmetry') or (self::ShapeElement and substring-after(@xsi:type,':')='CentreOfSymmetry'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(CentreOfSymmetry : <sch:value-of select="$uid"/>) The CentreOfSymmetry.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Certification"><!--(Ref to S) Certification.CertificationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Certification') or (self::Certification and not(@xsi:type)))]/CertificationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Certification : <sch:value-of select="$uid"/>) The Certification.CertificationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Certification.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Certification') or (self::Certification and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Certification : <sch:value-of select="$uid"/>) The Certification.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CertificationAssignment"><!--(Ref to E) CertificationAssignment.AssignedCertification : Certification (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CertificationAssignment') or (self::CertificationAssignment and not(@xsi:type)))]/AssignedCertification">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Certification'] or //Certification[@uid = $uidRef]">(CertificationAssignment : <sch:value-of select="$uid"/>) The CertificationAssignment.AssignedCertification contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Certification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) CertificationAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CertificationAssignment') or (self::CertificationAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CertificationAssignment : <sch:value-of select="$uid"/>) The CertificationAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) CertificationAssignment.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CertificationAssignment') or (self::CertificationAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(CertificationAssignment : <sch:value-of select="$uid"/>) The CertificationAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ChangeElementSequence"><!--(Ref to E) ChangeElementSequence.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ChangeElementSequence') or (self::ChangeElementSequence and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ChangeElementSequence : <sch:value-of select="$uid"/>) The ChangeElementSequence.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ChangeElementSequence.Related : DeltaChangeActivity (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ChangeElementSequence') or (self::ChangeElementSequence and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DeltaChangeActivity'] or //DeltaChangeActivity[@uid = $uidRef]">(ChangeElementSequence : <sch:value-of select="$uid"/>) The ChangeElementSequence.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DeltaChangeActivity.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CircularPath"><!--(Ref to E) CircularPath.ViaPoint : CartesianPoint (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CircularPath') or (self::PathSegment and substring-after(@xsi:type,':')='CircularPath'))]/ViaPoint">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'CartesianPoint'] or //RepresentationItem[@uid = $uidRef and contains(' CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface ',substring-after(@xsi:type,':'))]">(CircularPath : <sch:value-of select="$uid"/>) The CircularPath.ViaPoint contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type CartesianPoint.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PathSegment.PlacementEnd : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CircularPath') or (self::PathSegment and substring-after(@xsi:type,':')='CircularPath'))]/PlacementEnd">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(CircularPath : <sch:value-of select="$uid"/>) The CircularPath.PlacementEnd contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CircularRunoutTolerance"><!--(Ref to E) CircularRunoutTolerance.DatumSystem : DatumSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CircularRunoutTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='CircularRunoutTolerance'))]/DatumSystem">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DatumSystem'] or //ShapeElement[@uid = $uidRef and contains(' DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem ',substring-after(@xsi:type,':'))]">(CircularRunoutTolerance : <sch:value-of select="$uid"/>) The CircularRunoutTolerance.DatumSystem contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DatumSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricTolerance.AppliedTo : GeometricToleranceTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CircularRunoutTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='CircularRunoutTolerance'))]/AppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //PartView[@uid = $uidRef]">(CircularRunoutTolerance : <sch:value-of select="$uid"/>) The CircularRunoutTolerance.AppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricToleranceTargetSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CircularRunoutTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='CircularRunoutTolerance'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CircularRunoutTolerance : <sch:value-of select="$uid"/>) The CircularRunoutTolerance.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.GeometricToleranceContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CircularRunoutTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='CircularRunoutTolerance'))]/GeometricToleranceContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricToleranceContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(CircularRunoutTolerance : <sch:value-of select="$uid"/>) The CircularRunoutTolerance.GeometricToleranceContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CircularRunoutTolerance_WR1"><!--(Rule CircularRunoutTolerance.WR1)--><sch:rule context="//GeometricTolerance[substring-after(@xsi:type,':')='CircularRunoutTolerance']/Angle"> <sch:let name="uid" value="../@uid"/> <sch:let name="unitRef" value="./Unit/@uidRef"/> <sch:assert test="//Unit[@uid=$unitRef]/Quantity/ClassString ='plane angle'">(CircularRunoutTolerance <sch:value-of select="$uid"/>) The unit of Angle shall be a plane angle measure unit. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="Class"><!--(Ref to E) Class.DefinedIn : OPTIONAL ExternalClassSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Class') or (self::Class and not(@xsi:type)))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefinedIn) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExternalClassSystem'] or //ExternalClassSystem[@uid = $uidRef]">(Class : <sch:value-of select="$uid"/>) The Class.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExternalClassSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Class.Source : OPTIONAL ExternalSourceSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Class') or (self::Class and not(@xsi:type)))]/Source/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DigitalFile and //ExternalRefBaseObject[@uid = $uidRef and contains(' DigitalFile ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::DigitalFile and //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]) or (self::Document and //Document[@uid = $uidRef]) or (self::IdentifierSet) or (self::Identifier) or (self::IdentifierString)">(Class : <sch:value-of select="$uid"/>) The Class.Source contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ExternalSourceSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ClassAttribute"><!--(Ref to E) ClassAttribute.AttributeDefinition : PropertyDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ClassAttribute') or (self::ClassAttribute and not(@xsi:type)))]/AttributeDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinition'] or //PropertyDefinition[@uid = $uidRef]">(ClassAttribute : <sch:value-of select="$uid"/>) The ClassAttribute.AttributeDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Classification"><!--(Ref to S) Classification.Class : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Classification') or (self::Classification and not(@xsi:type)))]/Class/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Classification : <sch:value-of select="$uid"/>) The Classification.Class contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ClassificationRelationship"><!--(Ref to E) ClassificationRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ClassificationRelationship') or (self::ClassificationRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ClassificationRelationship : <sch:value-of select="$uid"/>) The ClassificationRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ClassificationRelationship.Related : Classification (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ClassificationRelationship') or (self::ClassificationRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ClassificationRelationship : <sch:value-of select="$uid"/>) The ClassificationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ClassificationRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ClassificationRelationship') or (self::ClassificationRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ClassificationRelationship : <sch:value-of select="$uid"/>) The ClassificationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ClassificationRelationship_WR1"><!--(Rule ClassificationRelationship.WR1)-->
      <sch:rule context="//ClassificationRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> ClassificationRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Classification and the relating Classification shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="ClippingOperator"><!--(Ref to S) ClippingOperator.Elements : SET[1:unbounded] OF ClippingElementSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ClippingOperator') or (self::RepresentationItem and substring-after(@xsi:type,':')='ClippingOperator'))]/Elements/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ClippingOperator and //ExternalRefBaseObject[@uid = $uidRef and contains(' ClippingOperator ',@typeRef)]) or (self::Plane and //ExternalRefBaseObject[@uid = $uidRef and contains(' Plane ',@typeRef)]) or (self::ClippingOperator and //RepresentationItem[@uid = $uidRef and contains(' ClippingOperator ',substring-after(@xsi:type,':'))]) or (self::Plane and //RepresentationItem[@uid = $uidRef and contains(' Plane ',substring-after(@xsi:type,':'))])">(ClippingOperator : <sch:value-of select="$uid"/>) The ClippingOperator.Elements contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClippingElementSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CoatingLayer"><!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CoatingLayer') or (self::ShapeElement and substring-after(@xsi:type,':')='CoatingLayer'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CoatingLayer : <sch:value-of select="$uid"/>) The CoatingLayer.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CoatingLayer') or (self::ShapeElement and substring-after(@xsi:type,':')='CoatingLayer'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(CoatingLayer : <sch:value-of select="$uid"/>) The CoatingLayer.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CoaxialityTolerance"><!--(Ref to E) CoaxialityTolerance.DatumSystem : DatumSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CoaxialityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='CoaxialityTolerance'))]/DatumSystem">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DatumSystem'] or //ShapeElement[@uid = $uidRef and contains(' DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem ',substring-after(@xsi:type,':'))]">(CoaxialityTolerance : <sch:value-of select="$uid"/>) The CoaxialityTolerance.DatumSystem contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DatumSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricTolerance.AppliedTo : GeometricToleranceTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CoaxialityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='CoaxialityTolerance'))]/AppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //PartView[@uid = $uidRef]">(CoaxialityTolerance : <sch:value-of select="$uid"/>) The CoaxialityTolerance.AppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricToleranceTargetSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CoaxialityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='CoaxialityTolerance'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CoaxialityTolerance : <sch:value-of select="$uid"/>) The CoaxialityTolerance.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.GeometricToleranceContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CoaxialityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='CoaxialityTolerance'))]/GeometricToleranceContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricToleranceContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(CoaxialityTolerance : <sch:value-of select="$uid"/>) The CoaxialityTolerance.GeometricToleranceContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CollectedPartRelationship"><!--(Default Value) CollectedPartRelationship.RelationType : String = 'collected part view' (kind=SINGLE - redefined=ViewOccurrenceRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectedPartRelationship') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='CollectedPartRelationship'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'collected part view'">(CollectedPartRelationship : <sch:value-of select="$uid"/>) The CollectedPartRelationship.RelationType contains the wrong value () must be 'collected part view'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ViewOccurrenceRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectedPartRelationship') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='CollectedPartRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CollectedPartRelationship : <sch:value-of select="$uid"/>) The CollectedPartRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ViewOccurrenceRelationship.Related : DefinitionBasedOccurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectedPartRelationship') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='CollectedPartRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DefinitionBasedOccurrence'] or //Occurrence[@uid = $uidRef and contains(' DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence ',substring-after(@xsi:type,':'))]">(CollectedPartRelationship : <sch:value-of select="$uid"/>) The CollectedPartRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DefinitionBasedOccurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ViewOccurrenceRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectedPartRelationship') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='CollectedPartRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(CollectedPartRelationship : <sch:value-of select="$uid"/>) The CollectedPartRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CollectionDefinition"><!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionDefinition') or (self::PartView and substring-after(@xsi:type,':')='CollectionDefinition'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(CollectionDefinition : <sch:value-of select="$uid"/>) The CollectionDefinition.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionDefinition') or (self::PartView and substring-after(@xsi:type,':')='CollectionDefinition'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(CollectionDefinition : <sch:value-of select="$uid"/>) The CollectionDefinition.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionDefinition') or (self::PartView and substring-after(@xsi:type,':')='CollectionDefinition'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CollectionDefinition : <sch:value-of select="$uid"/>) The CollectionDefinition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionDefinition') or (self::PartView and substring-after(@xsi:type,':')='CollectionDefinition'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(CollectionDefinition : <sch:value-of select="$uid"/>) The CollectionDefinition.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CollectionDefinition') or (self::PartView and substring-after(@xsi:type,':')='CollectionDefinition'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(CollectionDefinition : <sch:value-of select="$uid"/>) The CollectionDefinition.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="Colour"/>
   <sch:pattern id="ComponentPathShapeElement"><!--(Ref to S) ComponentPathShapeElement.ComponentShapeElement : ComponentShapeElementSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ComponentPathShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='ComponentPathShapeElement'))]/ComponentShapeElement/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::ShapeElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeElement  AxisPlacementShapeElement  CoatingLayer  CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement  ContactingFeature  Datum  DatumFeature  DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem  DatumTarget  PlacedTarget  TargetCircle  TargetCircularCurve  TargetPoint  TargetRectangle  TargetStraightLine  TargetArea  TargetCurve  DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent  OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification  PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification  PlaneShapeElement  PointShapeElement  ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement  ToleranceZone  DirectedOrOrientedToleranceZone  AffectedPlaneToleranceZone  ToleranceZoneWithDatum  DirectedToleranceZone  DirectionFeatureToleranceZone  OrientedToleranceZone ',@typeRef)]) or (self::IdentifierSet) or (self::Identifier) or (self::IdentifierString) or (self::ShapeElement and //ShapeElement[@uid = $uidRef])">(ComponentPathShapeElement : <sch:value-of select="$uid"/>) The ComponentPathShapeElement.ComponentShapeElement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ComponentShapeElementSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ComponentPathShapeElement.Location : Occurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ComponentPathShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='ComponentPathShapeElement'))]/Location">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Occurrence'] or //Occurrence[@uid = $uidRef]">(ComponentPathShapeElement : <sch:value-of select="$uid"/>) The ComponentPathShapeElement.Location contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Occurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartShapeElement.PartDefinition : OPTIONAL PartShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ComponentPathShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='ComponentPathShapeElement'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(ComponentPathShapeElement : <sch:value-of select="$uid"/>) The ComponentPathShapeElement.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ComponentPathShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='ComponentPathShapeElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ComponentPathShapeElement : <sch:value-of select="$uid"/>) The ComponentPathShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ComponentPathShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='ComponentPathShapeElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(ComponentPathShapeElement : <sch:value-of select="$uid"/>) The ComponentPathShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ComponentPlacement"><!--(Ref to E) ComponentPlacement.PlacedComponent : BreakdownElementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ComponentPlacement') or (self::ComponentPlacement and not(@xsi:type)))]/PlacedComponent">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElementView'] or //BreakdownElementView[@uid = $uidRef]">(ComponentPlacement : <sch:value-of select="$uid"/>) The ComponentPlacement.PlacedComponent contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElementView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ComponentPlacement.Placement : TransformationSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ComponentPlacement') or (self::ComponentPlacement and not(@xsi:type)))]/Placement/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::CartesianTransformation or (self::Transformation and contains(' CartesianTransformation ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)]) or (self::GeometricRepresentationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',@typeRef)]) or (self::CartesianTransformation) or (self::GeometricRepresentationRelationship and //RepresentationRelationship[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',substring-after(@xsi:type,':'))])">(ComponentPlacement : <sch:value-of select="$uid"/>) The ComponentPlacement.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of TransformationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ComponentPlacement.ReferenceComponent : BreakdownElementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ComponentPlacement') or (self::ComponentPlacement and not(@xsi:type)))]/ReferenceComponent">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElementView'] or //BreakdownElementView[@uid = $uidRef]">(ComponentPlacement : <sch:value-of select="$uid"/>) The ComponentPlacement.ReferenceComponent contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElementView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ComposedGeometricModel"><!--(Ref to S) ComposedGeometricModel.Items : SET[1:unbounded] OF AxisPlacementOrTransformationSelect (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ComposedGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='ComposedGeometricModel'))]/Items/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::AxisPlacement and //ExternalRefBaseObject[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',@typeRef)]) or (*[(self::CartesianTransformation or (self::Transformation and contains(' CartesianTransformation ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)]) or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))] or //*[(self::CartesianTransformation or (self::Transformation and contains(' CartesianTransformation ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]">(ComposedGeometricModel : <sch:value-of select="$uid"/>) The ComposedGeometricModel.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AxisPlacementOrTransformationSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ComposedGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='ComposedGeometricModel'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ComposedGeometricModel : <sch:value-of select="$uid"/>) The ComposedGeometricModel.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ComposedGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='ComposedGeometricModel'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ComposedGeometricModel : <sch:value-of select="$uid"/>) The ComposedGeometricModel.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="CompositeAssembly"><!--(Ref to S) CompositeAssembly.CompositeAssemblyShape : OPTIONAL CompositeAssemblyShapeSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeAssembly') or (self::PartView and substring-after(@xsi:type,':')='CompositeAssembly'))]/CompositeAssemblyShape">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalAdvancedBrepShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalEdgeBasedWireframeShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalFacetedBrepShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalGeometricallyBoundedSurfaceShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalGeometricallyBoundedWireframeShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalManifoldSurfaceShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalShellBasedWireframeShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ThreeDGeometrySet ',@typeRef)] or //Representation[@uid = $uidRef and contains(' ExternalAdvancedBrepShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalEdgeBasedWireframeShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalFacetedBrepShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalGeometricallyBoundedSurfaceShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalGeometricallyBoundedWireframeShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalManifoldSurfaceShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalShellBasedWireframeShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ThreeDGeometrySet ',substring-after(@xsi:type,':'))]">(CompositeAssembly : <sch:value-of select="$uid"/>) The CompositeAssembly.CompositeAssemblyShape contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of CompositeAssemblyShapeSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) CompositeAssembly.LayupPart : CompositeAssemblyTable (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeAssembly') or (self::PartView and substring-after(@xsi:type,':')='CompositeAssembly'))]/LayupPart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'CompositeAssemblyTable'] or //PartView[@uid = $uidRef and contains(' CompositeAssemblyTable ',substring-after(@xsi:type,':'))]">(CompositeAssembly : <sch:value-of select="$uid"/>) The CompositeAssembly.LayupPart contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type CompositeAssemblyTable.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeAssembly') or (self::PartView and substring-after(@xsi:type,':')='CompositeAssembly'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(CompositeAssembly : <sch:value-of select="$uid"/>) The CompositeAssembly.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeAssembly') or (self::PartView and substring-after(@xsi:type,':')='CompositeAssembly'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(CompositeAssembly : <sch:value-of select="$uid"/>) The CompositeAssembly.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeAssembly') or (self::PartView and substring-after(@xsi:type,':')='CompositeAssembly'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CompositeAssembly : <sch:value-of select="$uid"/>) The CompositeAssembly.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeAssembly') or (self::PartView and substring-after(@xsi:type,':')='CompositeAssembly'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(CompositeAssembly : <sch:value-of select="$uid"/>) The CompositeAssembly.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeAssembly') or (self::PartView and substring-after(@xsi:type,':')='CompositeAssembly'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(CompositeAssembly : <sch:value-of select="$uid"/>) The CompositeAssembly.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="CompositeAssemblySequenceDefinition"><!--(Ref to S) CompositeAssemblySequenceDefinition.ComponentsInSequence : BAG[1:unbounded] OF ComponentClassForAssemblySelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeAssemblySequenceDefinition') or (self::CompositeAssemblySequenceDefinition and not(@xsi:type)))]/ComponentsInSequence/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::CompositeAssembly and //ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeAssembly ',@typeRef)]) or (self::FilamentLaminate and //ExternalRefBaseObject[@uid = $uidRef and contains(' FilamentLaminate ',@typeRef)]) or (self::Ply and //ExternalRefBaseObject[@uid = $uidRef and contains(' Ply ',@typeRef)]) or (self::PlyLaminate and //ExternalRefBaseObject[@uid = $uidRef and contains(' PlyLaminate ',@typeRef)]) or (self::ProcessedCore and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessedCore ',@typeRef)]) or (self::CompositeAssembly and //PartView[@uid = $uidRef and contains(' CompositeAssembly ',substring-after(@xsi:type,':'))]) or (self::FilamentLaminate and //PartView[@uid = $uidRef and contains(' FilamentLaminate ',substring-after(@xsi:type,':'))]) or (self::Ply and //PartView[@uid = $uidRef and contains(' Ply ',substring-after(@xsi:type,':'))]) or (self::PlyLaminate and //PartView[@uid = $uidRef and contains(' PlyLaminate ',substring-after(@xsi:type,':'))]) or (self::ProcessedCore and //PartView[@uid = $uidRef and contains(' ProcessedCore ',substring-after(@xsi:type,':'))])">(CompositeAssemblySequenceDefinition : <sch:value-of select="$uid"/>) The CompositeAssemblySequenceDefinition.ComponentsInSequence contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ComponentClassForAssemblySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CompositeAssemblyTable"><!--(Ref to E) LaminateTable.Basis : SET[1:unbounded] OF ReinforcementOrientationBasis (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeAssemblyTable') or (self::PartView and substring-after(@xsi:type,':')='CompositeAssemblyTable'))]/Basis/ReinforcementOrientationBasis">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ReinforcementOrientationBasis'] or //Representation[@uid = $uidRef and contains(' ReinforcementOrientationBasis ',substring-after(@xsi:type,':'))]">(CompositeAssemblyTable : <sch:value-of select="$uid"/>) The CompositeAssemblyTable.Basis contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ReinforcementOrientationBasis.</sch:assert>
      </sch:rule>
      <!--(Ref to E) LaminateTable.ResultingBoundary : PlyShape (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeAssemblyTable') or (self::PartView and substring-after(@xsi:type,':')='CompositeAssemblyTable'))]/ResultingBoundary">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlyShape'] or //PlyShape[@uid = $uidRef]">(CompositeAssemblyTable : <sch:value-of select="$uid"/>) The CompositeAssemblyTable.ResultingBoundary contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlyShape.</sch:assert>
      </sch:rule>
      <!--(Ref to E) LaminateTable.ResultingSurface : Surface (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeAssemblyTable') or (self::PartView and substring-after(@xsi:type,':')='CompositeAssemblyTable'))]/ResultingSurface">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Surface'] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(CompositeAssemblyTable : <sch:value-of select="$uid"/>) The CompositeAssemblyTable.ResultingSurface contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Surface.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeAssemblyTable') or (self::PartView and substring-after(@xsi:type,':')='CompositeAssemblyTable'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(CompositeAssemblyTable : <sch:value-of select="$uid"/>) The CompositeAssemblyTable.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeAssemblyTable') or (self::PartView and substring-after(@xsi:type,':')='CompositeAssemblyTable'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(CompositeAssemblyTable : <sch:value-of select="$uid"/>) The CompositeAssemblyTable.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeAssemblyTable') or (self::PartView and substring-after(@xsi:type,':')='CompositeAssemblyTable'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CompositeAssemblyTable : <sch:value-of select="$uid"/>) The CompositeAssemblyTable.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeAssemblyTable') or (self::PartView and substring-after(@xsi:type,':')='CompositeAssemblyTable'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(CompositeAssemblyTable : <sch:value-of select="$uid"/>) The CompositeAssemblyTable.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeAssemblyTable') or (self::PartView and substring-after(@xsi:type,':')='CompositeAssemblyTable'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(CompositeAssemblyTable : <sch:value-of select="$uid"/>) The CompositeAssemblyTable.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="CompositeCurveOnSurface"/>
   <sch:pattern id="CompositeGroupShapeElement"><!--(Ref to E) CompositeShapeElement.Components : SET[2:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeGroupShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CompositeGroupShapeElement'))]/Components/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(CompositeGroupShapeElement : <sch:value-of select="$uid"/>) The CompositeGroupShapeElement.Components contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeGroupShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CompositeGroupShapeElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CompositeGroupShapeElement : <sch:value-of select="$uid"/>) The CompositeGroupShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeGroupShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CompositeGroupShapeElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(CompositeGroupShapeElement : <sch:value-of select="$uid"/>) The CompositeGroupShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CompositeSheetRepresentation"><!--(Ref to E) CompositeSheetRepresentation.ThreeDGeometry : ExternalGeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='CompositeSheetRepresentation'))]/ThreeDGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExternalGeometricModel'] or //Representation[@uid = $uidRef and contains(' ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation ',substring-after(@xsi:type,':'))]">(CompositeSheetRepresentation : <sch:value-of select="$uid"/>) The CompositeSheetRepresentation.ThreeDGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExternalGeometricModel.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='CompositeSheetRepresentation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CompositeSheetRepresentation : <sch:value-of select="$uid"/>) The CompositeSheetRepresentation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Representation.Items : SET[1:unbounded] OF RepresentationItem (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='CompositeSheetRepresentation'))]/Items/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(CompositeSheetRepresentation : <sch:value-of select="$uid"/>) The CompositeSheetRepresentation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='CompositeSheetRepresentation'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(CompositeSheetRepresentation : <sch:value-of select="$uid"/>) The CompositeSheetRepresentation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="CompositeUnitShapeElement"><!--(Ref to E) CompositeShapeElement.Components : SET[2:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeUnitShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CompositeUnitShapeElement'))]/Components/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(CompositeUnitShapeElement : <sch:value-of select="$uid"/>) The CompositeUnitShapeElement.Components contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeUnitShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CompositeUnitShapeElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CompositeUnitShapeElement : <sch:value-of select="$uid"/>) The CompositeUnitShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CompositeUnitShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CompositeUnitShapeElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(CompositeUnitShapeElement : <sch:value-of select="$uid"/>) The CompositeUnitShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConcentricityTolerance"><!--(Ref to E) ConcentricityTolerance.DatumSystem : DatumSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConcentricityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='ConcentricityTolerance'))]/DatumSystem">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DatumSystem'] or //ShapeElement[@uid = $uidRef and contains(' DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem ',substring-after(@xsi:type,':'))]">(ConcentricityTolerance : <sch:value-of select="$uid"/>) The ConcentricityTolerance.DatumSystem contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DatumSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricTolerance.AppliedTo : GeometricToleranceTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConcentricityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='ConcentricityTolerance'))]/AppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //PartView[@uid = $uidRef]">(ConcentricityTolerance : <sch:value-of select="$uid"/>) The ConcentricityTolerance.AppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricToleranceTargetSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConcentricityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='ConcentricityTolerance'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ConcentricityTolerance : <sch:value-of select="$uid"/>) The ConcentricityTolerance.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.GeometricToleranceContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConcentricityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='ConcentricityTolerance'))]/GeometricToleranceContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricToleranceContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(ConcentricityTolerance : <sch:value-of select="$uid"/>) The ConcentricityTolerance.GeometricToleranceContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Condition"><!--(Ref to E) Condition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Condition') or (self::Condition or (self::AssignedCondition and substring-after(@xsi:type,':')='Condition') or (self::AssignedCondition and substring-after(@xsi:type,':')='Condition')))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Condition : <sch:value-of select="$uid"/>) The Condition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Condition.ConditionType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Condition') or (self::Condition or (self::AssignedCondition and substring-after(@xsi:type,':')='Condition') or (self::AssignedCondition and substring-after(@xsi:type,':')='Condition')))]/ConditionType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Condition : <sch:value-of select="$uid"/>) The Condition.ConditionType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Condition.Parameters : SET[1:unbounded] OF ParameterSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Condition') or (self::Condition or (self::AssignedCondition and substring-after(@xsi:type,':')='Condition') or (self::AssignedCondition and substring-after(@xsi:type,':')='Condition')))]/Parameters/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ConditionParameter and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionParameter ',@typeRef)]) or (self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternativeSolutionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolutionRelationship ',@typeRef)]) or (self::Approval and //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConditionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionRelationship ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::Descriptor and //ExternalRefBaseObject[@uid = $uidRef and contains(' Descriptor ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::EffectivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::FileRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::Observation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::ObservationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::ProcessOperationDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinitionRelationship ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlanRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlanRelationship ',@typeRef)]) or (self::ProductClassRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClassRelationship ',@typeRef)]) or (self::ProductConcept and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::ProductConfigurationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkOrderRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderRelationship ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::WorkRequestRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestRelationship ',@typeRef)]) or (self::ConditionParameter) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternativeSolutionRelationship and //AlternativeSolutionRelationship[@uid = $uidRef]) or (self::Approval and //Approval[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::Condition) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConditionRelationship and //ConditionRelationship[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DateTimeString) or (self::Descriptor and //Descriptor[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::EffectivityRelationship and //EffectivityRelationship[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::FileRelationship and //FileRelationship[@uid = $uidRef]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::Observation and //Observation[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::ObservationRelationship and //ObservationRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::ProcessOperationDefinitionRelationship and //ProcessOperationDefinitionRelationship[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlanRelationship and //ProcessPlanRelationship[@uid = $uidRef]) or (self::ProductClassRelationship and //ProductClassRelationship[@uid = $uidRef]) or (self::ProductConcept and //ProductConcept[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProductConfigurationRelationship and //ProductConfigurationRelationship[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkOrderRelationship and //WorkOrderRelationship[@uid = $uidRef]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef]) or (self::WorkRequestRelationship and //WorkRequestRelationship[@uid = $uidRef])">(Condition : <sch:value-of select="$uid"/>) The Condition.Parameters contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ParameterSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConditionAssignment"><!--(Ref to E) ConditionAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionAssignment') or (self::ConditionAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ConditionAssignment : <sch:value-of select="$uid"/>) The ConditionAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ConditionAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionAssignment') or (self::ConditionAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ConditionAssignment : <sch:value-of select="$uid"/>) The ConditionAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConditionParameter"><!--(Ref to E) ConditionParameter.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionParameter') or (self::ConditionParameter and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ConditionParameter : <sch:value-of select="$uid"/>) The ConditionParameter.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ConditionParameter.Parameter : OPTIONAL ConditionParameterSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionParameter') or (self::ConditionParameter and not(@xsi:type)))]/Parameter/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternativeSolutionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolutionRelationship ',@typeRef)]) or (self::Approval and //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConditionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionRelationship ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::Descriptor and //ExternalRefBaseObject[@uid = $uidRef and contains(' Descriptor ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::EffectivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::FileRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::Observation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::ObservationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::ProcessOperationDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinitionRelationship ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlanRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlanRelationship ',@typeRef)]) or (self::ProductClassRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClassRelationship ',@typeRef)]) or (self::ProductConcept and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::ProductConfigurationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkOrderRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderRelationship ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::WorkRequestRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestRelationship ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternativeSolutionRelationship and //AlternativeSolutionRelationship[@uid = $uidRef]) or (self::Approval and //Approval[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::Condition) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConditionRelationship and //ConditionRelationship[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DateTimeString) or (self::Descriptor and //Descriptor[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::EffectivityRelationship and //EffectivityRelationship[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::FileRelationship and //FileRelationship[@uid = $uidRef]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::Observation and //Observation[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::ObservationRelationship and //ObservationRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::ProcessOperationDefinitionRelationship and //ProcessOperationDefinitionRelationship[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlanRelationship and //ProcessPlanRelationship[@uid = $uidRef]) or (self::ProductClassRelationship and //ProductClassRelationship[@uid = $uidRef]) or (self::ProductConcept and //ProductConcept[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProductConfigurationRelationship and //ProductConfigurationRelationship[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkOrderRelationship and //WorkOrderRelationship[@uid = $uidRef]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef]) or (self::WorkRequestRelationship and //WorkRequestRelationship[@uid = $uidRef])">(ConditionParameter : <sch:value-of select="$uid"/>) The ConditionParameter.Parameter contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ConditionParameterSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConditionRelationship"><!--(Ref to E) ConditionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionRelationship') or (self::ConditionRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ConditionRelationship : <sch:value-of select="$uid"/>) The ConditionRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ConditionRelationship.Related : Condition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionRelationship') or (self::ConditionRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Condition'] or //Condition[@uid = $uidRef] or //*[@uid = $uidRef and (self::AssignedCondition or self::AssignedCondition)]">(ConditionRelationship : <sch:value-of select="$uid"/>) The ConditionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Condition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ConditionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionRelationship') or (self::ConditionRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ConditionRelationship : <sch:value-of select="$uid"/>) The ConditionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConditionRelationship_WR1"><!--(Rule ConditionRelationship.WR1)-->
      <sch:rule context="//ConditionRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> ConditionRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Condition and the relating Condition shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConditionalConfiguration"><!--(Ref to S) ConditionalConfiguration.ConfigurationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionalConfiguration') or (self::Effectivity and substring-after(@xsi:type,':')='ConditionalConfiguration'))]/ConfigurationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ConditionalConfiguration : <sch:value-of select="$uid"/>) The ConditionalConfiguration.ConfigurationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ConditionalConfiguration.InheritanceType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionalConfiguration') or (self::Effectivity and substring-after(@xsi:type,':')='ConditionalConfiguration'))]/InheritanceType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ConditionalConfiguration : <sch:value-of select="$uid"/>) The ConditionalConfiguration.InheritanceType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ConditionalEffectivity.Condition : Condition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionalConfiguration') or (self::Effectivity and substring-after(@xsi:type,':')='ConditionalConfiguration'))]/Condition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Condition'] or //Condition[@uid = $uidRef] or //*[@uid = $uidRef and (self::AssignedCondition or self::AssignedCondition)]">(ConditionalConfiguration : <sch:value-of select="$uid"/>) The ConditionalConfiguration.Condition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Condition.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionalConfiguration') or (self::Effectivity and substring-after(@xsi:type,':')='ConditionalConfiguration'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ConditionalConfiguration : <sch:value-of select="$uid"/>) The ConditionalConfiguration.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionalConfiguration') or (self::Effectivity and substring-after(@xsi:type,':')='ConditionalConfiguration'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(ConditionalConfiguration : <sch:value-of select="$uid"/>) The ConditionalConfiguration.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Effectivity.EffectivityContext : OPTIONAL EffectivityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionalConfiguration') or (self::Effectivity and substring-after(@xsi:type,':')='ConditionalConfiguration'))]/EffectivityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //Activity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef]">(ConditionalConfiguration : <sch:value-of select="$uid"/>) The ConditionalConfiguration.EffectivityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EffectivityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConditionalEffectivity"><!--(Ref to E) ConditionalEffectivity.Condition : Condition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionalEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='ConditionalEffectivity'))]/Condition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Condition'] or //Condition[@uid = $uidRef] or //*[@uid = $uidRef and (self::AssignedCondition or self::AssignedCondition)]">(ConditionalEffectivity : <sch:value-of select="$uid"/>) The ConditionalEffectivity.Condition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Condition.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionalEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='ConditionalEffectivity'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ConditionalEffectivity : <sch:value-of select="$uid"/>) The ConditionalEffectivity.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionalEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='ConditionalEffectivity'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(ConditionalEffectivity : <sch:value-of select="$uid"/>) The ConditionalEffectivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Effectivity.EffectivityContext : OPTIONAL EffectivityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConditionalEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='ConditionalEffectivity'))]/EffectivityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //Activity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef]">(ConditionalEffectivity : <sch:value-of select="$uid"/>) The ConditionalEffectivity.EffectivityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EffectivityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConfiguredAssemblyEffectivity"><!--(Ref to E) ConfiguredAssemblyEffectivity.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConfiguredAssemblyEffectivity') or (self::ConfiguredAssemblyEffectivity and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ConfiguredAssemblyEffectivity : <sch:value-of select="$uid"/>) The ConfiguredAssemblyEffectivity.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ConfiguredAssemblyEffectivity.ConfiguredElements : SET[1:unbounded] OF AssemblyDesignSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConfiguredAssemblyEffectivity') or (self::ConfiguredAssemblyEffectivity and not(@xsi:type)))]/ConfiguredElements/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::AssemblyViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',@typeRef)]) or (self::DefinitionalPartViewUsage and //ExternalRefBaseObject[@uid = $uidRef and contains(' DefinitionalPartViewUsage ',@typeRef)]) or (self::Occurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)]) or (self::PartShapeElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)]) or (self::AssemblyViewRelationship and //PartViewRelationship[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',substring-after(@xsi:type,':'))]) or (self::DefinitionalPartViewUsage and //PartViewRelationship[@uid = $uidRef and contains(' DefinitionalPartViewUsage ',substring-after(@xsi:type,':'))]) or (self::Occurrence and //Occurrence[@uid = $uidRef]) or (self::PartShapeElement and //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))])">(ConfiguredAssemblyEffectivity : <sch:value-of select="$uid"/>) The ConfiguredAssemblyEffectivity.ConfiguredElements contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AssemblyDesignSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ConfiguredAssemblyEffectivity.EffectivityDomain : OPTIONAL Effectivity (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConfiguredAssemblyEffectivity') or (self::ConfiguredAssemblyEffectivity and not(@xsi:type)))]/EffectivityDomain">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./EffectivityDomain) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Effectivity'] or //Effectivity[@uid = $uidRef]">(ConfiguredAssemblyEffectivity : <sch:value-of select="$uid"/>) The ConfiguredAssemblyEffectivity.EffectivityDomain contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Effectivity.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConnectedEdgeSet"><!--(Ref to E) ConnectedEdgeSet.ConnectedEdges : SET[1:unbounded] OF Edge (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConnectedEdgeSet') or (self::RepresentationItem and substring-after(@xsi:type,':')='ConnectedEdgeSet'))]/ConnectedEdges/Edge">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Edge'] or //RepresentationItem[@uid = $uidRef and contains(' Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge ',substring-after(@xsi:type,':'))]">(ConnectedEdgeSet : <sch:value-of select="$uid"/>) The ConnectedEdgeSet.ConnectedEdges contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Edge.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConnectedEdgeSubSet"><!--(Ref to E) ConnectedEdgeSubSet.ParentEdgeSet : ConnectedEdgeSet (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConnectedEdgeSubSet') or (self::RepresentationItem and substring-after(@xsi:type,':')='ConnectedEdgeSubSet'))]/ParentEdgeSet">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ConnectedEdgeSet'] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedEdgeSet  ConnectedEdgeSubSet ',substring-after(@xsi:type,':'))]">(ConnectedEdgeSubSet : <sch:value-of select="$uid"/>) The ConnectedEdgeSubSet.ParentEdgeSet contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ConnectedEdgeSet.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ConnectedEdgeSet.ConnectedEdges : SET[1:unbounded] OF Edge (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConnectedEdgeSubSet') or (self::RepresentationItem and substring-after(@xsi:type,':')='ConnectedEdgeSubSet'))]/ConnectedEdges/Edge">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Edge'] or //RepresentationItem[@uid = $uidRef and contains(' Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge ',substring-after(@xsi:type,':'))]">(ConnectedEdgeSubSet : <sch:value-of select="$uid"/>) The ConnectedEdgeSubSet.ConnectedEdges contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Edge.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ConnectedFaceSet"/>
   <sch:pattern id="ConstituentPart"><!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConstituentPart') or (self::PartView and substring-after(@xsi:type,':')='ConstituentPart'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(ConstituentPart : <sch:value-of select="$uid"/>) The ConstituentPart.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConstituentPart') or (self::PartView and substring-after(@xsi:type,':')='ConstituentPart'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(ConstituentPart : <sch:value-of select="$uid"/>) The ConstituentPart.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConstituentPart') or (self::PartView and substring-after(@xsi:type,':')='ConstituentPart'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ConstituentPart : <sch:value-of select="$uid"/>) The ConstituentPart.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConstituentPart') or (self::PartView and substring-after(@xsi:type,':')='ConstituentPart'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(ConstituentPart : <sch:value-of select="$uid"/>) The ConstituentPart.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ConstituentPart') or (self::PartView and substring-after(@xsi:type,':')='ConstituentPart'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(ConstituentPart : <sch:value-of select="$uid"/>) The ConstituentPart.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ContactFeatureDefinition"><!--(Ref to E) ShapeFeatureDefinition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContactFeatureDefinition') or (self::ShapeFeatureDefinition and substring-after(@xsi:type,':')='ContactFeatureDefinition'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ContactFeatureDefinition : <sch:value-of select="$uid"/>) The ContactFeatureDefinition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeFeatureDefinition.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContactFeatureDefinition') or (self::ShapeFeatureDefinition and substring-after(@xsi:type,':')='ContactFeatureDefinition'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(ContactFeatureDefinition : <sch:value-of select="$uid"/>) The ContactFeatureDefinition.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ContactFeatureDefinitionFitRelationship"><!--(Ref to E) ContactFeatureDefinitionFitRelationship.Related : ContactFeatureDefinition (kind=SINGLE - redefined=ShapeFeatureDefinitionRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContactFeatureDefinitionFitRelationship') or (self::ShapeFeatureDefinitionRelationship and substring-after(@xsi:type,':')='ContactFeatureDefinitionFitRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ContactFeatureDefinition'] or //ShapeFeatureDefinition[@uid = $uidRef and contains(' ContactFeatureDefinition ',substring-after(@xsi:type,':'))]">(ContactFeatureDefinitionFitRelationship : <sch:value-of select="$uid"/>) The ContactFeatureDefinitionFitRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ContactFeatureDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeFeatureDefinitionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContactFeatureDefinitionFitRelationship') or (self::ShapeFeatureDefinitionRelationship and substring-after(@xsi:type,':')='ContactFeatureDefinitionFitRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ContactFeatureDefinitionFitRelationship : <sch:value-of select="$uid"/>) The ContactFeatureDefinitionFitRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ContactingFeature"><!--(Default Value) ContactingFeature.ProductDefinitional : OPTIONAL Boolean = 'false' (kind=SINGLE - redefined=ShapeElement.ProductDefinitional)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContactingFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='ContactingFeature'))]/ProductDefinitional">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="count(./ProductDefinitional) = 0 or text() = 'false'">(ContactingFeature : <sch:value-of select="$uid"/>) The ContactingFeature.ProductDefinitional contains the wrong value () must be 'false'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContactingFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='ContactingFeature'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ContactingFeature : <sch:value-of select="$uid"/>) The ContactingFeature.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContactingFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='ContactingFeature'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(ContactingFeature : <sch:value-of select="$uid"/>) The ContactingFeature.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ContentProperty"><!--(Ref to E) ContentProperty.GeometryTypes : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContentProperty') or (self::ContentProperty or (self::DocumentContent and substring-after(@xsi:type,':')='ContentProperty') or (self::FileContent and substring-after(@xsi:type,':')='ContentProperty')))]/GeometryTypes/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../GeometryTypes/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ContentProperty : <sch:value-of select="$uid"/>) The ContentProperty.GeometryTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ContextDependentOverRidingStyledElement"><!--(Ref to S) ContextDependentOverRidingStyledElement.ContextDefinition : SET[1:unbounded] OF OverridingStyleContextSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContextDependentOverRidingStyledElement') or (self::RepresentationItem and substring-after(@xsi:type,':')='ContextDependentOverRidingStyledElement'))]/ContextDefinition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DetailedGeometricModelItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)]) or (self::GeometricRepresentationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',@typeRef)]) or (self::StyledModel and //ExternalRefBaseObject[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',@typeRef)]) or (self::DetailedGeometricModelItem and //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]) or (self::GeometricRepresentationRelationship and //RepresentationRelationship[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',substring-after(@xsi:type,':'))]) or (self::StyledModel and //Representation[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',substring-after(@xsi:type,':'))])">(ContextDependentOverRidingStyledElement : <sch:value-of select="$uid"/>) The ContextDependentOverRidingStyledElement.ContextDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OverridingStyleContextSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) OverRidingStyledElement.OverRiddenElement : StyledElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContextDependentOverRidingStyledElement') or (self::RepresentationItem and substring-after(@xsi:type,':')='ContextDependentOverRidingStyledElement'))]/OverRiddenElement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StyledElement'] or //RepresentationItem[@uid = $uidRef and contains(' StyledElement  AnnotationElement  AnnotationPlaceholderOccurrence  AnnotationPlane  OverRidingStyledElement  ContextDependentOverRidingStyledElement ',substring-after(@xsi:type,':'))]">(ContextDependentOverRidingStyledElement : <sch:value-of select="$uid"/>) The ContextDependentOverRidingStyledElement.OverRiddenElement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StyledElement.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StyledElement.Element : StyledElementTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContextDependentOverRidingStyledElement') or (self::RepresentationItem and substring-after(@xsi:type,':')='ContextDependentOverRidingStyledElement'))]/Element">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel  PlyAngleRepresentation  ReinforcementOrientationBasis ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef]">(ContextDependentOverRidingStyledElement : <sch:value-of select="$uid"/>) The ContextDependentOverRidingStyledElement.Element contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of StyledElementTargetSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ContinuousShapeElement"><!--(Ref to E) CompositeShapeElement.Components : SET[2:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContinuousShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='ContinuousShapeElement'))]/Components/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(ContinuousShapeElement : <sch:value-of select="$uid"/>) The ContinuousShapeElement.Components contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContinuousShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='ContinuousShapeElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ContinuousShapeElement : <sch:value-of select="$uid"/>) The ContinuousShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContinuousShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='ContinuousShapeElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(ContinuousShapeElement : <sch:value-of select="$uid"/>) The ContinuousShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Contract"><!--(Ref to E) Contract.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Contract') or (self::Contract and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Contract : <sch:value-of select="$uid"/>) The Contract.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Contract.ContractType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Contract') or (self::Contract and not(@xsi:type)))]/ContractType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Contract : <sch:value-of select="$uid"/>) The Contract.ContractType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of OrganizationInContract.SignedContracts :: ReferenceProperty) Contract.Releases : OPTIONAL SET[1:unbounded] OF OrganizationInContract) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ContractAssignment"><!--(Ref to E) ContractAssignment.AssignedContract : Contract (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContractAssignment') or (self::ContractAssignment and not(@xsi:type)))]/AssignedContract">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Contract'] or //Contract[@uid = $uidRef]">(ContractAssignment : <sch:value-of select="$uid"/>) The ContractAssignment.AssignedContract contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Contract.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ContractAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContractAssignment') or (self::ContractAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ContractAssignment : <sch:value-of select="$uid"/>) The ContractAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ContractAssignment.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContractAssignment') or (self::ContractAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ContractAssignment : <sch:value-of select="$uid"/>) The ContractAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ContractRelationship"><!--(Ref to E) ContractRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContractRelationship') or (self::ContractRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ContractRelationship : <sch:value-of select="$uid"/>) The ContractRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ContractRelationship.Related : Contract (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContractRelationship') or (self::ContractRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Contract'] or //Contract[@uid = $uidRef]">(ContractRelationship : <sch:value-of select="$uid"/>) The ContractRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Contract.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ContractRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ContractRelationship') or (self::ContractRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ContractRelationship : <sch:value-of select="$uid"/>) The ContractRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ContractRelationship_WR1"><!--(Rule ContractRelationship.WR1)-->
      <sch:rule context="//ContractRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> ContractRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Contract and the relating Contract shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="Copyright"><!--(Ref to E) InformationRight.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Copyright') or (self::InformationRight and substring-after(@xsi:type,':')='Copyright'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Copyright : <sch:value-of select="$uid"/>) The Copyright.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) InformationRight.Owners : SET[1:unbounded] OF OrganizationOrPersonInOrganizationSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Copyright') or (self::InformationRight and substring-after(@xsi:type,':')='Copyright'))]/Owners/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef])">(Copyright : <sch:value-of select="$uid"/>) The Copyright.Owners contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OrganizationOrPersonInOrganizationSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CreationProperty"/>
   <sch:pattern id="CrossSectionalAlternativePartShapeElement"><!--(Ref to S) CrossSectionalAlternativePartShapeElement.Items : SET[1:unbounded] OF CrossSectionalConstituentElementSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalAlternativePartShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalAlternativePartShapeElement'))]/Items/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::CrossSectionalOccurrenceShapeElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' CrossSectionalOccurrenceShapeElement ',@typeRef)]) or (self::CrossSectionalPartShapeElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement ',@typeRef)]) or (self::CrossSectionalOccurrenceShapeElement and //ShapeElement[@uid = $uidRef and contains(' CrossSectionalOccurrenceShapeElement ',substring-after(@xsi:type,':'))]) or (self::CrossSectionalPartShapeElement and //ShapeElement[@uid = $uidRef and contains(' CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement ',substring-after(@xsi:type,':'))])">(CrossSectionalAlternativePartShapeElement : <sch:value-of select="$uid"/>) The CrossSectionalAlternativePartShapeElement.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of CrossSectionalConstituentElementSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartShapeElement.PartDefinition : OPTIONAL PartShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalAlternativePartShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalAlternativePartShapeElement'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(CrossSectionalAlternativePartShapeElement : <sch:value-of select="$uid"/>) The CrossSectionalAlternativePartShapeElement.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalAlternativePartShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalAlternativePartShapeElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CrossSectionalAlternativePartShapeElement : <sch:value-of select="$uid"/>) The CrossSectionalAlternativePartShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalAlternativePartShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalAlternativePartShapeElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(CrossSectionalAlternativePartShapeElement : <sch:value-of select="$uid"/>) The CrossSectionalAlternativePartShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CrossSectionalGroupShapeElement"><!--(Ref to S) CrossSectionalGroupShapeElement.Items : SET[1:unbounded] OF CrossSectionalConstituentElementSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElement'))]/Items/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::CrossSectionalOccurrenceShapeElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' CrossSectionalOccurrenceShapeElement ',@typeRef)]) or (self::CrossSectionalPartShapeElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement ',@typeRef)]) or (self::CrossSectionalOccurrenceShapeElement and //ShapeElement[@uid = $uidRef and contains(' CrossSectionalOccurrenceShapeElement ',substring-after(@xsi:type,':'))]) or (self::CrossSectionalPartShapeElement and //ShapeElement[@uid = $uidRef and contains(' CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement ',substring-after(@xsi:type,':'))])">(CrossSectionalGroupShapeElement : <sch:value-of select="$uid"/>) The CrossSectionalGroupShapeElement.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of CrossSectionalConstituentElementSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartShapeElement.PartDefinition : OPTIONAL PartShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElement'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(CrossSectionalGroupShapeElement : <sch:value-of select="$uid"/>) The CrossSectionalGroupShapeElement.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CrossSectionalGroupShapeElement : <sch:value-of select="$uid"/>) The CrossSectionalGroupShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(CrossSectionalGroupShapeElement : <sch:value-of select="$uid"/>) The CrossSectionalGroupShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CrossSectionalGroupShapeElementWithLacing"><!--(Ref to E) CrossSectionalGroupShapeElementWithLacing.LacingMaterial : OPTIONAL Occurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithLacing') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithLacing'))]/LacingMaterial">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./LacingMaterial) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Occurrence'] or //Occurrence[@uid = $uidRef]">(CrossSectionalGroupShapeElementWithLacing : <sch:value-of select="$uid"/>) The CrossSectionalGroupShapeElementWithLacing.LacingMaterial contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Occurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) CrossSectionalGroupShapeElement.Items : SET[1:unbounded] OF CrossSectionalConstituentElementSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithLacing') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithLacing'))]/Items/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::CrossSectionalOccurrenceShapeElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' CrossSectionalOccurrenceShapeElement ',@typeRef)]) or (self::CrossSectionalPartShapeElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement ',@typeRef)]) or (self::CrossSectionalOccurrenceShapeElement and //ShapeElement[@uid = $uidRef and contains(' CrossSectionalOccurrenceShapeElement ',substring-after(@xsi:type,':'))]) or (self::CrossSectionalPartShapeElement and //ShapeElement[@uid = $uidRef and contains(' CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement ',substring-after(@xsi:type,':'))])">(CrossSectionalGroupShapeElementWithLacing : <sch:value-of select="$uid"/>) The CrossSectionalGroupShapeElementWithLacing.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of CrossSectionalConstituentElementSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartShapeElement.PartDefinition : OPTIONAL PartShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithLacing') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithLacing'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(CrossSectionalGroupShapeElementWithLacing : <sch:value-of select="$uid"/>) The CrossSectionalGroupShapeElementWithLacing.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithLacing') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithLacing'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CrossSectionalGroupShapeElementWithLacing : <sch:value-of select="$uid"/>) The CrossSectionalGroupShapeElementWithLacing.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithLacing') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithLacing'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(CrossSectionalGroupShapeElementWithLacing : <sch:value-of select="$uid"/>) The CrossSectionalGroupShapeElementWithLacing.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CrossSectionalGroupShapeElementWithTubularCover"><!--(Ref to S) CrossSectionalGroupShapeElementWithTubularCover.Cover : CrossSectionalConstituentElementSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithTubularCover') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithTubularCover'))]/Cover">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CrossSectionalOccurrenceShapeElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' CrossSectionalOccurrenceShapeElement ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement ',substring-after(@xsi:type,':'))]">(CrossSectionalGroupShapeElementWithTubularCover : <sch:value-of select="$uid"/>) The CrossSectionalGroupShapeElementWithTubularCover.Cover contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of CrossSectionalConstituentElementSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) CrossSectionalGroupShapeElement.Items : SET[1:unbounded] OF CrossSectionalConstituentElementSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithTubularCover') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithTubularCover'))]/Items/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::CrossSectionalOccurrenceShapeElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' CrossSectionalOccurrenceShapeElement ',@typeRef)]) or (self::CrossSectionalPartShapeElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement ',@typeRef)]) or (self::CrossSectionalOccurrenceShapeElement and //ShapeElement[@uid = $uidRef and contains(' CrossSectionalOccurrenceShapeElement ',substring-after(@xsi:type,':'))]) or (self::CrossSectionalPartShapeElement and //ShapeElement[@uid = $uidRef and contains(' CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement ',substring-after(@xsi:type,':'))])">(CrossSectionalGroupShapeElementWithTubularCover : <sch:value-of select="$uid"/>) The CrossSectionalGroupShapeElementWithTubularCover.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of CrossSectionalConstituentElementSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartShapeElement.PartDefinition : OPTIONAL PartShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithTubularCover') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithTubularCover'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(CrossSectionalGroupShapeElementWithTubularCover : <sch:value-of select="$uid"/>) The CrossSectionalGroupShapeElementWithTubularCover.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithTubularCover') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithTubularCover'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CrossSectionalGroupShapeElementWithTubularCover : <sch:value-of select="$uid"/>) The CrossSectionalGroupShapeElementWithTubularCover.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithTubularCover') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalGroupShapeElementWithTubularCover'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(CrossSectionalGroupShapeElementWithTubularCover : <sch:value-of select="$uid"/>) The CrossSectionalGroupShapeElementWithTubularCover.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CrossSectionalOccurrenceShapeElement"><!--(Ref to S) OccurrenceShapeFeature.Definition : OPTIONAL OccurrenceShapeFeatureDefinitionSelect (kind=SINGLE - redefined=OccurrenceShapeElement.Definition)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalOccurrenceShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalOccurrenceShapeElement'))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef]">(CrossSectionalOccurrenceShapeElement : <sch:value-of select="$uid"/>) The CrossSectionalOccurrenceShapeElement.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OccurrenceShapeFeatureDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalOccurrenceShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalOccurrenceShapeElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CrossSectionalOccurrenceShapeElement : <sch:value-of select="$uid"/>) The CrossSectionalOccurrenceShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalOccurrenceShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalOccurrenceShapeElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(CrossSectionalOccurrenceShapeElement : <sch:value-of select="$uid"/>) The CrossSectionalOccurrenceShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CrossSectionalPartShapeElement"><!--(Ref to S) PartShapeElement.PartDefinition : OPTIONAL PartShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalPartShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalPartShapeElement'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(CrossSectionalPartShapeElement : <sch:value-of select="$uid"/>) The CrossSectionalPartShapeElement.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalPartShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalPartShapeElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CrossSectionalPartShapeElement : <sch:value-of select="$uid"/>) The CrossSectionalPartShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CrossSectionalPartShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='CrossSectionalPartShapeElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(CrossSectionalPartShapeElement : <sch:value-of select="$uid"/>) The CrossSectionalPartShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Curve"/>
   <sch:pattern id="Curve11"><!--(Ref to E) Curve11.GuideCurves : SET[1:unbounded] OF Curve (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Curve11') or (self::RepresentationItem and substring-after(@xsi:type,':')='Curve11'))]/GuideCurves/Curve">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Curve'] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))]">(Curve11 : <sch:value-of select="$uid"/>) The Curve11.GuideCurves contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Curve.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CurveAppearance"/>
   <sch:pattern id="CurveFont"/>
   <sch:pattern id="CurvedDistance"><!--(Ref to E) DimensionalLocation.Origin : ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CurvedDistance') or (self::GeometricDimension and substring-after(@xsi:type,':')='CurvedDistance'))]/Origin">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(CurvedDistance : <sch:value-of select="$uid"/>) The CurvedDistance.Origin contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DimensionalLocation.Target : ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CurvedDistance') or (self::GeometricDimension and substring-after(@xsi:type,':')='CurvedDistance'))]/Target">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(CurvedDistance : <sch:value-of select="$uid"/>) The CurvedDistance.Target contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CurvedDistance') or (self::GeometricDimension and substring-after(@xsi:type,':')='CurvedDistance'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CurvedDistance : <sch:value-of select="$uid"/>) The CurvedDistance.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.GeometricDimensionContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CurvedDistance') or (self::GeometricDimension and substring-after(@xsi:type,':')='CurvedDistance'))]/GeometricDimensionContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricDimensionContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(CurvedDistance : <sch:value-of select="$uid"/>) The CurvedDistance.GeometricDimensionContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CurvedSize"><!--(Ref to E) DimensionalSize.IsAppliedTo : ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CurvedSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='CurvedSize'))]/IsAppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(CurvedSize : <sch:value-of select="$uid"/>) The CurvedSize.IsAppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CurvedSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='CurvedSize'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CurvedSize : <sch:value-of select="$uid"/>) The CurvedSize.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.GeometricDimensionContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CurvedSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='CurvedSize'))]/GeometricDimensionContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricDimensionContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(CurvedSize : <sch:value-of select="$uid"/>) The CurvedSize.GeometricDimensionContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Cylindrical11"><!--(Ref to E) Cylindrical11.GuideCurves : SET[1:unbounded] OF Curve (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Cylindrical11') or (self::RepresentationItem and substring-after(@xsi:type,':')='Cylindrical11'))]/GuideCurves/Curve">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Curve'] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))]">(Cylindrical11 : <sch:value-of select="$uid"/>) The Cylindrical11.GuideCurves contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Curve.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="CylindricityTolerance"><!--(Ref to S) GeometricTolerance.AppliedTo : GeometricToleranceTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CylindricityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='CylindricityTolerance'))]/AppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //PartView[@uid = $uidRef]">(CylindricityTolerance : <sch:value-of select="$uid"/>) The CylindricityTolerance.AppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricToleranceTargetSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CylindricityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='CylindricityTolerance'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(CylindricityTolerance : <sch:value-of select="$uid"/>) The CylindricityTolerance.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.GeometricToleranceContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='CylindricityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='CylindricityTolerance'))]/GeometricToleranceContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricToleranceContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(CylindricityTolerance : <sch:value-of select="$uid"/>) The CylindricityTolerance.GeometricToleranceContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DataEnvironment"/>
   <sch:pattern id="DateAndPersonAssignment"><!--(Ref to E) DateAndPersonAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DateAndPersonAssignment') or (self::DateAndPersonAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DateAndPersonAssignment : <sch:value-of select="$uid"/>) The DateAndPersonAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DateAndPersonAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DateAndPersonAssignment') or (self::DateAndPersonAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DateAndPersonAssignment : <sch:value-of select="$uid"/>) The DateAndPersonAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DateAndPersonOrganization"><!--(Ref to S) DateAndPersonOrganization.PersonOrOrganization : OrganizationOrPersonInOrganizationSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DateAndPersonOrganization') or (self::DateAndPersonOrganization or (self::Requestor and substring-after(@xsi:type,':')='DateAndPersonOrganization') or (self::AssignedDateAndPerson and substring-after(@xsi:type,':')='DateAndPersonOrganization') or (self::Requestor and substring-after(@xsi:type,':')='DateAndPersonOrganization')))]/PersonOrOrganization">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef]">(DateAndPersonOrganization : <sch:value-of select="$uid"/>) The DateAndPersonOrganization.PersonOrOrganization contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OrganizationOrPersonInOrganizationSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DateTimeAssignment"><!--(Ref to E) DateTimeAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DateTimeAssignment') or (self::DateTimeAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DateTimeAssignment : <sch:value-of select="$uid"/>) The DateTimeAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DateTimeAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DateTimeAssignment') or (self::DateTimeAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DateTimeAssignment : <sch:value-of select="$uid"/>) The DateTimeAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DateTimeRepresentationItem"/>
   <sch:pattern id="DatedEffectivity"><!--(Ref to S) DatedEffectivity.EndDefinition : OPTIONAL EventOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatedEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='DatedEffectivity'))]/EndDefinition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(DatedEffectivity : <sch:value-of select="$uid"/>) The DatedEffectivity.EndDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EventOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DatedEffectivity.StartDefinition : OPTIONAL EventOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatedEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='DatedEffectivity'))]/StartDefinition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(DatedEffectivity : <sch:value-of select="$uid"/>) The DatedEffectivity.StartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EventOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatedEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='DatedEffectivity'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DatedEffectivity : <sch:value-of select="$uid"/>) The DatedEffectivity.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatedEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='DatedEffectivity'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(DatedEffectivity : <sch:value-of select="$uid"/>) The DatedEffectivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Effectivity.EffectivityContext : OPTIONAL EffectivityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatedEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='DatedEffectivity'))]/EffectivityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //Activity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef]">(DatedEffectivity : <sch:value-of select="$uid"/>) The DatedEffectivity.EffectivityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EffectivityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Datum"><!--(Ref to E) Datum.Targets : OPTIONAL SET[1:unbounded] OF DatumTarget (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Datum') or (self::ShapeElement and substring-after(@xsi:type,':')='Datum'))]/Targets/DatumTarget">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Targets/DatumTarget) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DatumTarget'] or //ShapeElement[@uid = $uidRef and contains(' DatumTarget  PlacedTarget  TargetCircle  TargetCircularCurve  TargetPoint  TargetRectangle  TargetStraightLine  TargetArea  TargetCurve ',substring-after(@xsi:type,':'))]">(Datum : <sch:value-of select="$uid"/>) The Datum.Targets contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DatumTarget.</sch:assert>
      </sch:rule>
      <!--(Default Value) Datum.Name : String = '' (kind=SINGLE - redefined=ShapeElement.Name)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Datum') or (self::ShapeElement and substring-after(@xsi:type,':')='Datum'))]/Name">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="CharacterString and not(CharacterString/text())">(Datum : <sch:value-of select="$uid"/>) The Datum.Name contains the wrong value () must be ''.</sch:assert>
      </sch:rule>
      <!--(Default Value) Datum.ProductDefinitional : Boolean = 'false' (kind=SINGLE - redefined=ShapeElement.ProductDefinitional)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Datum') or (self::ShapeElement and substring-after(@xsi:type,':')='Datum'))]/ProductDefinitional">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="text() = 'false'">(Datum : <sch:value-of select="$uid"/>) The Datum.ProductDefinitional contains the wrong value () must be 'false'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Datum') or (self::ShapeElement and substring-after(@xsi:type,':')='Datum'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Datum : <sch:value-of select="$uid"/>) The Datum.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Datum') or (self::ShapeElement and substring-after(@xsi:type,':')='Datum'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(Datum : <sch:value-of select="$uid"/>) The Datum.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Datum_UR1"><!--(Rule Datum.UR1)--><sch:rule context="//ShapeElement[substring-after(@xsi:type,':')='Datum']"> <sch:let name="uid" value="@uid"/> <sch:let name="id" value="./Identification/IdentifierString"/> <sch:let name="followingIds" value="(following-sibling::ShapeElement[substring-after(@xsi:type,':')='Datum']/Identification/IdentifierString)"/> <sch:let name="precedingIds" value="(preceding-sibling::ShapeElement[substring-after(@xsi:type,':')='Datum']/Identification/IdentifierString)"/> <sch:assert test="not (($id = $followingIds) or ($id = $precedingIds))"> (Datum <sch:value-of select="$uid"/>) The combination of Identification and ElementOf shall be unique within a population of datum. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="Datum_WR1"><!--(Rule Datum.WR1)--><sch:rule context="//ShapeElement[substring-after(@xsi:type,':')='Datum']"> <sch:let name="uid" value="@uid"/> <sch:assert test="(count (./Targets) ge 1) or (count(//ShapeElement[substring-after(@xsi:type,':')='DatumFeature']/OfDatum[@uidRef=$uid]) = 1)"> (Datum <sch:value-of select="$uid"/>) A datum shall be related to one or more DatumTargets or related to one DatumFeature. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="Datum_UR2"><!--(Rule Datum.UR2)--><sch:rule context="//ShapeElement[substring-after(@xsi:type,':')='Datum']/Targets/DatumTarget"> <sch:let name="uid" value="../../@uid"/> <sch:let name="uidRef" value="./@uidRef"/> <sch:let name="targetId" value="//ShapeElement[@uid=$uidRef]/TargetId/IdentifierString"/> <sch:let name="following" value="(following-sibling::DatumTarget)/@uidRef"/> <sch:let name="preceding" value="(preceding-sibling::DatumTarget)/@uidRef"/> <sch:let name="targetIds" value="//ShapeElement[@uid=$following or @uid=$preceding ]/TargetId/IdentifierString"/> <sch:assert test="not ($targetId = $targetIds)"> (Datum <sch:value-of select="$uid"/>) TargetId (<sch:value-of select="$targetId"/>) shall be unique within a population of Targets. </sch:assert> </sch:rule> </sch:pattern>
   <sch:pattern id="Datum_WR2"><!--(Rule Datum.WR2)--><sch:rule context="//ShapeElement[substring-after(@xsi:type,':')='Datum']"> <sch:let name="uid" value="@uid"/> <sch:assert test="count(//ShapeElement[substring-after(@xsi:type,':')='DatumFeature']/OfDatum[@uidRef=$uid]) le 1"> (Datum <sch:value-of select="$uid"/>) There shall be at most one DatumFeature related to the Datum. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="DatumFeature"><!--(Ref to E) DatumFeature.OfDatum : Datum (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatumFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='DatumFeature'))]/OfDatum">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Datum'] or //ShapeElement[@uid = $uidRef and contains(' Datum ',substring-after(@xsi:type,':'))]">(DatumFeature : <sch:value-of select="$uid"/>) The DatumFeature.OfDatum contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Datum.</sch:assert>
      </sch:rule>
      <!--(Default Value) DatumFeature.ProductDefinitional : OPTIONAL Boolean = 'true' (kind=SINGLE - redefined=ShapeElement.ProductDefinitional)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatumFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='DatumFeature'))]/ProductDefinitional">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="count(./ProductDefinitional) = 0 or text() = 'true'">(DatumFeature : <sch:value-of select="$uid"/>) The DatumFeature.ProductDefinitional contains the wrong value () must be 'true'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatumFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='DatumFeature'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DatumFeature : <sch:value-of select="$uid"/>) The DatumFeature.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatumFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='DatumFeature'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(DatumFeature : <sch:value-of select="$uid"/>) The DatumFeature.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DatumFeature_UR1"><!--(Rule DatumFeature.UR1)--><sch:rule context="//ShapeElement[substring-after(@xsi:type,':')='DatumFeature']"> <sch:let name="uid" value="@uid"/> <sch:let name="uidRef" value="./OfDatum/@uidRef"/> <sch:assert test=" not (($uidRef = following::ShapeElement[substring-after(@xsi:type,':')='DatumFeature']/OfDatum/@uidRef) or ($uidRef =preceding::ShapeElement[substring-after(@xsi:type,':')='DatumFeature']/OfDatum/@uidRef))"> (DatumFeature <sch:value-of select="$uid"/>) The OfDatum shall be unique within a population of DatumFeature OfDatum=$uidRef. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="DatumReferenceCompartment"><!--(Ref to E) DatumReferenceCompartment.PlaneSituationFeature : OPTIONAL PlaneShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatumReferenceCompartment') or (self::GeneralDatumReference and substring-after(@xsi:type,':')='DatumReferenceCompartment'))]/PlaneSituationFeature">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./PlaneSituationFeature) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlaneShapeElement'] or //ShapeElement[@uid = $uidRef and contains(' PlaneShapeElement ',substring-after(@xsi:type,':'))]">(DatumReferenceCompartment : <sch:value-of select="$uid"/>) The DatumReferenceCompartment.PlaneSituationFeature contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlaneShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DatumReferenceCompartment.PointSituationFeature : OPTIONAL PointShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatumReferenceCompartment') or (self::GeneralDatumReference and substring-after(@xsi:type,':')='DatumReferenceCompartment'))]/PointSituationFeature">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./PointSituationFeature) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PointShapeElement'] or //ShapeElement[@uid = $uidRef and contains(' PointShapeElement ',substring-after(@xsi:type,':'))]">(DatumReferenceCompartment : <sch:value-of select="$uid"/>) The DatumReferenceCompartment.PointSituationFeature contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PointShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DatumReferenceCompartment.StraightLineSituationFeature : OPTIONAL AxisPlacementShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatumReferenceCompartment') or (self::GeneralDatumReference and substring-after(@xsi:type,':')='DatumReferenceCompartment'))]/StraightLineSituationFeature">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./StraightLineSituationFeature) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacementShapeElement'] or //ShapeElement[@uid = $uidRef and contains(' AxisPlacementShapeElement ',substring-after(@xsi:type,':'))]">(DatumReferenceCompartment : <sch:value-of select="$uid"/>) The DatumReferenceCompartment.StraightLineSituationFeature contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacementShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeneralDatumReference.Base : OPTIONAL Datum (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatumReferenceCompartment') or (self::GeneralDatumReference and substring-after(@xsi:type,':')='DatumReferenceCompartment'))]/Base">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Base) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Datum'] or //ShapeElement[@uid = $uidRef and contains(' Datum ',substring-after(@xsi:type,':'))]">(DatumReferenceCompartment : <sch:value-of select="$uid"/>) The DatumReferenceCompartment.Base contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Datum.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DatumReferenceElement"><!--(Ref to E) GeneralDatumReference.Base : OPTIONAL Datum (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatumReferenceElement') or (self::GeneralDatumReference and substring-after(@xsi:type,':')='DatumReferenceElement'))]/Base">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Base) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Datum'] or //ShapeElement[@uid = $uidRef and contains(' Datum ',substring-after(@xsi:type,':'))]">(DatumReferenceElement : <sch:value-of select="$uid"/>) The DatumReferenceElement.Base contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Datum.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DatumReferenceModifierWithValue"/>
   <sch:pattern id="DatumReferenceModifierWithValue_WR1"><!--(Rule DatumReferenceModifierWithValue.WR1)--><sch:rule context="//DatumReferenceModifierWithValue/ModifierValue"> <sch:let name="uid" value="../@uid"/> <sch:let name="unitRef" value="./Unit/@uidRef"/> <sch:assert test="//Unit[@uid=$unitRef]/Quantity/ClassString ='length'">(DatumReferenceModifierWithValue <sch:value-of select="$uid"/>) The unit of ModifierValue shall be a length measure unit. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="DatumSystem"><!--(Default Value) DatumSystem.ProductDefinitional : OPTIONAL Boolean = 'false' (kind=SINGLE - redefined=ShapeElement.ProductDefinitional)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatumSystem') or (self::ShapeElement and substring-after(@xsi:type,':')='DatumSystem'))]/ProductDefinitional">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="count(./ProductDefinitional) = 0 or text() = 'false'">(DatumSystem : <sch:value-of select="$uid"/>) The DatumSystem.ProductDefinitional contains the wrong value () must be 'false'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatumSystem') or (self::ShapeElement and substring-after(@xsi:type,':')='DatumSystem'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DatumSystem : <sch:value-of select="$uid"/>) The DatumSystem.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatumSystem') or (self::ShapeElement and substring-after(@xsi:type,':')='DatumSystem'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(DatumSystem : <sch:value-of select="$uid"/>) The DatumSystem.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DatumSystemWithAssociatedModelCoordinateSystem"><!--(Ref to E) DatumSystemWithAssociatedModelCoordinateSystem.RepresentedGeometry : AxisPlacement (kind=SINGLE - redefined=ShapeElement.RepresentedGeometry)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatumSystemWithAssociatedModelCoordinateSystem') or (self::ShapeElement and substring-after(@xsi:type,':')='DatumSystemWithAssociatedModelCoordinateSystem'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(DatumSystemWithAssociatedModelCoordinateSystem : <sch:value-of select="$uid"/>) The DatumSystemWithAssociatedModelCoordinateSystem.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Default Value) DatumSystem.ProductDefinitional : OPTIONAL Boolean = 'false' (kind=SINGLE - redefined=ShapeElement.ProductDefinitional)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatumSystemWithAssociatedModelCoordinateSystem') or (self::ShapeElement and substring-after(@xsi:type,':')='DatumSystemWithAssociatedModelCoordinateSystem'))]/ProductDefinitional">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="count(./ProductDefinitional) = 0 or text() = 'false'">(DatumSystemWithAssociatedModelCoordinateSystem : <sch:value-of select="$uid"/>) The DatumSystemWithAssociatedModelCoordinateSystem.ProductDefinitional contains the wrong value () must be 'false'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DatumSystemWithAssociatedModelCoordinateSystem') or (self::ShapeElement and substring-after(@xsi:type,':')='DatumSystemWithAssociatedModelCoordinateSystem'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DatumSystemWithAssociatedModelCoordinateSystem : <sch:value-of select="$uid"/>) The DatumSystemWithAssociatedModelCoordinateSystem.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DefinitionalPartViewUsage"><!--(Ref to E) PartViewRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DefinitionalPartViewUsage') or (self::PartViewRelationship and substring-after(@xsi:type,':')='DefinitionalPartViewUsage'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DefinitionalPartViewUsage : <sch:value-of select="$uid"/>) The DefinitionalPartViewUsage.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.Related : PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DefinitionalPartViewUsage') or (self::PartViewRelationship and substring-after(@xsi:type,':')='DefinitionalPartViewUsage'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(DefinitionalPartViewUsage : <sch:value-of select="$uid"/>) The DefinitionalPartViewUsage.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DefinitionalPartViewUsage') or (self::PartViewRelationship and substring-after(@xsi:type,':')='DefinitionalPartViewUsage'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DefinitionalPartViewUsage : <sch:value-of select="$uid"/>) The DefinitionalPartViewUsage.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DegeneratePcurve"/>
   <sch:pattern id="DeleteElement"><!--(Ref to S) DeleteElement.PreviousDesignObject : SET[1:unbounded] OF DeltaChangeManagementObjectSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DeleteElement') or (self::DeltaChangeActivity and substring-after(@xsi:type,':')='DeleteElement'))]/PreviousDesignObject/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternatePartRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternatePartRelationship ',@typeRef)]) or (self::AlternativeSolution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::AssemblyOccurrenceRelationshipSubstitution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyOccurrenceRelationshipSubstitution ',@typeRef)]) or (self::AssemblyViewRelationshipSubstitution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationshipSubstitution ',@typeRef)]) or (self::AssignmentObjectRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssignmentObjectRelationship ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementRealization and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRealization ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::BreakdownVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionRelationship ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConfiguredAssemblyEffectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConfiguredAssemblyEffectivity ',@typeRef)]) or (self::Contract and //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::DeltaChangeRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DeltaChangeRelationship ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::DocumentVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersionRelationship ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::File and //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)]) or (self::IndividualAssemblyRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualAssemblyRelationship ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialIdentification and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialIdentification ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::Occurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)]) or (self::OccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceRelationship  ReplacedUsageRelationship  SameTimeMachiningRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship  AlternatePartVersionRelationship ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::Person and //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::ProcessOperationDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinition ',@typeRef)]) or (self::ProcessOperationOccurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationOccurrence ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlan and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlan ',@typeRef)]) or (self::ProductClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::Project and //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::ProjectRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectRelationship ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (self::Representation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel  PlyAngleRepresentation  ReinforcementOrientationBasis ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersionRelationship ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategory and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategory ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusion ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::StyledModel and //ExternalRefBaseObject[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::ViewOccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternatePartRelationship and //PartRelationship[@uid = $uidRef and contains(' AlternatePartRelationship ',substring-after(@xsi:type,':'))]) or (self::AlternativeSolution and //AlternativeSolution[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::AssemblyOccurrenceRelationshipSubstitution and //AssemblyOccurrenceRelationshipSubstitution[@uid = $uidRef]) or (self::AssemblyViewRelationshipSubstitution and //AssemblyViewRelationshipSubstitution[@uid = $uidRef]) or (self::AssignmentObjectRelationship and //AssignmentObjectRelationship[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementRealization and //BreakdownElementRealization[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementVersionRelationship and //BreakdownElementVersionRelationship[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::BreakdownVersionRelationship and //BreakdownVersionRelationship[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Class and //Class[@uid = $uidRef]) or (self::Condition and //*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConfiguredAssemblyEffectivity and //ConfiguredAssemblyEffectivity[@uid = $uidRef]) or (self::Contract and //Contract[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DeltaChangeRelationship and //DeltaChangeRelationship[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::DocumentVersionRelationship and //DocumentVersionRelationship[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::Event and //Event[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef]) or (self::File and //File[@uid = $uidRef]) or (self::IndividualAssemblyRelationship and //IndividualAssemblyRelationship[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartVersionRelationship and //IndividualPartVersionRelationship[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialIdentification and //MaterialIdentification[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::Occurrence and //Occurrence[@uid = $uidRef]) or (self::OccurrenceRelationship and //OccurrenceRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartVersionRelationship and //PartVersionRelationship[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::Person and //Person[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef]) or (self::ProcessOperationDefinition and //ProcessOperationDefinition[@uid = $uidRef]) or (self::ProcessOperationOccurrence and //ProcessOperationOccurrence[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlan and //ProcessPlan[@uid = $uidRef]) or (self::ProductClass and //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::Project and //Project[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::ProjectRelationship and //ProjectRelationship[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Representation and //Representation[@uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementVersionRelationship and //RequirementVersionRelationship[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategory and //SpecificationCategory[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusion and //SpecificationInclusion[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::StyledModel and //Representation[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',substring-after(@xsi:type,':'))]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::ViewOccurrenceRelationship and //ViewOccurrenceRelationship[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef])">(DeleteElement : <sch:value-of select="$uid"/>) The DeleteElement.PreviousDesignObject contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of DeltaChangeManagementObjectSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of DeltaChange.ChangeActivities :: PartProperty) DeltaChangeActivity.ChangeSet : DeltaChange) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="DeltaChange"><!--(Ref to E) DeltaChange.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DeltaChange') or (self::DeltaChange and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DeltaChange : <sch:value-of select="$uid"/>) The DeltaChange.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DeltaChange.DescribedChange : OPTIONAL DeltaChangeRelationshipSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DeltaChange') or (self::DeltaChange and not(@xsi:type)))]/DescribedChange">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolutionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EventRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualAssemblyRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceRelationship  ReplacedUsageRelationship  SameTimeMachiningRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartRelationship  AlternatePartRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship  AlternatePartVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganizationRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinitionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationOccurrenceRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlanRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClassRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignmentRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignmentRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RepresentationRelationship  GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace  GeometryToTopologyModelAssociation  PlyOrientationAngle  DrapedOrientationAngle  LaidOrientationAngle  TopologyToGeometryModelAssociation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeElementRelationship  AssemblyShapeConstraintItemRelationship  AssemblyShapeJointItemRelationship  PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship  ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryHierarchy ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SuppliedObjectRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestRelationship ',@typeRef)] or //ActivityMethodRelationship[@uid = $uidRef] or //ActivityRelationship[@uid = $uidRef] or //AlternativeSolutionRelationship[@uid = $uidRef] or //BreakdownElementRelationship[@uid = $uidRef] or //BreakdownElementVersionRelationship[@uid = $uidRef] or //BreakdownElementViewRelationship[@uid = $uidRef] or //BreakdownRelationship[@uid = $uidRef] or //BreakdownVersionRelationship[@uid = $uidRef] or //ConditionRelationship[@uid = $uidRef] or //Contract[@uid = $uidRef] or //DocumentDefinitionRelationship[@uid = $uidRef] or //DocumentRelationship[@uid = $uidRef] or //DocumentVersionRelationship[@uid = $uidRef] or //EffectivityRelationship[@uid = $uidRef] or //EventRelationship[@uid = $uidRef] or //FileRelationship[@uid = $uidRef] or //IndividualAssemblyRelationship[@uid = $uidRef] or //IndividualPartRelationship[@uid = $uidRef] or //IndividualPartVersionRelationship[@uid = $uidRef] or //IndividualPartViewRelationship[@uid = $uidRef] or //ObservationRelationship[@uid = $uidRef] or //OccurrenceRelationship[@uid = $uidRef] or //OrganizationRelationship[@uid = $uidRef] or //PartRelationship[@uid = $uidRef] or //PartVersionRelationship[@uid = $uidRef] or //PartViewRelationship[@uid = $uidRef] or //PersonInOrganizationRelationship[@uid = $uidRef] or //ProcessOperationDefinitionRelationship[@uid = $uidRef] or //ProcessOperationOccurrenceRelationship[@uid = $uidRef] or //ProcessPlanRelationship[@uid = $uidRef] or //ProductClassRelationship[@uid = $uidRef] or //ProductConfigurationRelationship[@uid = $uidRef] or //ProjectRelationship[@uid = $uidRef] or //PropertyDefinitionAssignmentRelationship[@uid = $uidRef] or //PropertyDefinitionRelationship[@uid = $uidRef] or //PropertyValueAssignmentRelationship[@uid = $uidRef] or //PropertyValueRelationship[@uid = $uidRef] or //RepresentationRelationship[@uid = $uidRef] or //RequirementRelationship[@uid = $uidRef] or //RequirementVersionRelationship[@uid = $uidRef] or //RequirementViewRelationship[@uid = $uidRef] or //ShapeElementRelationship[@uid = $uidRef] or //SpecificationCategoryHierarchy[@uid = $uidRef] or //SuppliedObjectRelationship[@uid = $uidRef] or //ViewOccurrenceRelationship[@uid = $uidRef] or //WorkOrderRelationship[@uid = $uidRef] or //WorkRequestRelationship[@uid = $uidRef]">(DeltaChange : <sch:value-of select="$uid"/>) The DeltaChange.DescribedChange contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of DeltaChangeRelationshipSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DeltaChangeRelationship"><!--(Ref to E) DeltaChangeRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DeltaChangeRelationship') or (self::DeltaChangeRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DeltaChangeRelationship : <sch:value-of select="$uid"/>) The DeltaChangeRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DeltaChangeRelationship.Related : DeltaChange (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DeltaChangeRelationship') or (self::DeltaChangeRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DeltaChange'] or //DeltaChange[@uid = $uidRef]">(DeltaChangeRelationship : <sch:value-of select="$uid"/>) The DeltaChangeRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DeltaChange.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DeltaChangeRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DeltaChangeRelationship') or (self::DeltaChangeRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DeltaChangeRelationship : <sch:value-of select="$uid"/>) The DeltaChangeRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DeltaChangeRelationship_WR1"><!--(Rule DeltaChangeRelationship.WR1)-->
      <sch:rule context="//DeltaChangeRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> BreakdownVersionRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related BreakdownVersion and the relating BreakdownVersion shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="DerivedShapeElement"><!--(Ref to E) DerivedShapeElement.DerivedFrom : SET[1:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DerivedShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='DerivedShapeElement'))]/DerivedFrom/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(DerivedShapeElement : <sch:value-of select="$uid"/>) The DerivedShapeElement.DerivedFrom contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DerivedShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='DerivedShapeElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DerivedShapeElement : <sch:value-of select="$uid"/>) The DerivedShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DerivedShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='DerivedShapeElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(DerivedShapeElement : <sch:value-of select="$uid"/>) The DerivedShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Descriptor"><!--(Ref to E) Descriptor.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Descriptor') or (self::Descriptor and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Descriptor : <sch:value-of select="$uid"/>) The Descriptor.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Descriptor.DescriptionContext : OPTIONAL SET[1:unbounded] OF IdentificationContextSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Descriptor') or (self::Descriptor and not(@xsi:type)))]/DescriptionContext/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef])">(Descriptor : <sch:value-of select="$uid"/>) The Descriptor.DescriptionContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of IdentificationContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DescriptorRelationship"><!--(Ref to E) DescriptorRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DescriptorRelationship') or (self::DescriptorRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DescriptorRelationship : <sch:value-of select="$uid"/>) The DescriptorRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DescriptorRelationship.Related : Descriptor (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DescriptorRelationship') or (self::DescriptorRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Descriptor'] or //Descriptor[@uid = $uidRef]">(DescriptorRelationship : <sch:value-of select="$uid"/>) The DescriptorRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Descriptor.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DescriptorRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DescriptorRelationship') or (self::DescriptorRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DescriptorRelationship : <sch:value-of select="$uid"/>) The DescriptorRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DescriptorRelationship_WR1"><!--(Rule DescriptorRelationship.WR1)-->
      <sch:rule context="//DescriptorRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> DescriptorRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Descriptor and the relating Descriptor shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="DiameterSize"><!--(Ref to E) DimensionalSize.IsAppliedTo : ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DiameterSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='DiameterSize'))]/IsAppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(DiameterSize : <sch:value-of select="$uid"/>) The DiameterSize.IsAppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DiameterSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='DiameterSize'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DiameterSize : <sch:value-of select="$uid"/>) The DiameterSize.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.GeometricDimensionContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DiameterSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='DiameterSize'))]/GeometricDimensionContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricDimensionContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(DiameterSize : <sch:value-of select="$uid"/>) The DiameterSize.GeometricDimensionContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DigitalDocumentDefinition"><!--(Ref to E) DigitalDocumentDefinition.Files : OPTIONAL SET[1:unbounded] OF DigitalFile (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DigitalDocumentDefinition') or (self::DocumentDefinition and substring-after(@xsi:type,':')='DigitalDocumentDefinition'))]/Files/DigitalFile">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Files/DigitalFile) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(DigitalDocumentDefinition : <sch:value-of select="$uid"/>) The DigitalDocumentDefinition.Files contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DocumentDefinition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DigitalDocumentDefinition') or (self::DocumentDefinition and substring-after(@xsi:type,':')='DigitalDocumentDefinition'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DigitalDocumentDefinition : <sch:value-of select="$uid"/>) The DigitalDocumentDefinition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DocumentDefinition.DocumentCreation : OPTIONAL CreationProperty (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DigitalDocumentDefinition') or (self::DocumentDefinition and substring-after(@xsi:type,':')='DigitalDocumentDefinition'))]/DocumentCreation">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DocumentCreation) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'CreationProperty'] or //CreationProperty[@uid = $uidRef]">(DigitalDocumentDefinition : <sch:value-of select="$uid"/>) The DigitalDocumentDefinition.DocumentCreation contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type CreationProperty.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DocumentDefinition.DocumentFormat : OPTIONAL SET[1:unbounded] OF FormatProperty (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DigitalDocumentDefinition') or (self::DocumentDefinition and substring-after(@xsi:type,':')='DigitalDocumentDefinition'))]/DocumentFormat/FormatProperty">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../DocumentFormat/FormatProperty) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'FormatProperty'] or //FormatProperty[@uid = $uidRef]">(DigitalDocumentDefinition : <sch:value-of select="$uid"/>) The DigitalDocumentDefinition.DocumentFormat contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type FormatProperty.</sch:assert>
      </sch:rule>
      <!--(Inverse of DocumentVersion.Views :: PartProperty) DocumentDefinition.ViewOf : DocumentVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="DigitalFile"><!--(Inverse of ExternalGeometricModel.ExternalFile :: ReferenceProperty) DigitalFile.AssociatedModelSpace : OPTIONAL SET[1:unbounded] OF ExternalGeometricModel) => no rule needed when PartProperty or Optional--><!--(Ref to E) File.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DigitalFile') or (self::File and substring-after(@xsi:type,':')='DigitalFile'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DigitalFile : <sch:value-of select="$uid"/>) The DigitalFile.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) File.FileCreation : OPTIONAL CreationProperty (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DigitalFile') or (self::File and substring-after(@xsi:type,':')='DigitalFile'))]/FileCreation">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./FileCreation) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'CreationProperty'] or //CreationProperty[@uid = $uidRef]">(DigitalFile : <sch:value-of select="$uid"/>) The DigitalFile.FileCreation contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type CreationProperty.</sch:assert>
      </sch:rule>
      <!--(Ref to E) File.FileFormat : OPTIONAL FormatProperty (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DigitalFile') or (self::File and substring-after(@xsi:type,':')='DigitalFile'))]/FileFormat">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./FileFormat) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'FormatProperty'] or //FormatProperty[@uid = $uidRef]">(DigitalFile : <sch:value-of select="$uid"/>) The DigitalFile.FileFormat contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type FormatProperty.</sch:assert>
      </sch:rule>
      <!--(Ref to S) File.FileType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DigitalFile') or (self::File and substring-after(@xsi:type,':')='DigitalFile'))]/FileType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DigitalFile : <sch:value-of select="$uid"/>) The DigitalFile.FileType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DirectedActualActivity"><!--(Ref to E) DirectedActualActivity.Directive : WorkOrder (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedActualActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedActualActivity'))]/Directive">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'WorkOrder'] or //WorkOrder[@uid = $uidRef]">(DirectedActualActivity : <sch:value-of select="$uid"/>) The DirectedActualActivity.Directive contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type WorkOrder.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Activity.ActivityType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedActualActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedActualActivity'))]/ActivityType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DirectedActualActivity : <sch:value-of select="$uid"/>) The DirectedActualActivity.ActivityType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.ChosenMethod : OPTIONAL ActivityMethod (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedActualActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedActualActivity'))]/ChosenMethod">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ChosenMethod) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(DirectedActualActivity : <sch:value-of select="$uid"/>) The DirectedActualActivity.ChosenMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedActualActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedActualActivity'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DirectedActualActivity : <sch:value-of select="$uid"/>) The DirectedActualActivity.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedActualActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedActualActivity'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(DirectedActualActivity : <sch:value-of select="$uid"/>) The DirectedActualActivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.PossibleMethods : OPTIONAL SET[1:unbounded] OF ActivityMethod (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedActualActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedActualActivity'))]/PossibleMethods/ActivityMethod">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../PossibleMethods/ActivityMethod) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(DirectedActualActivity : <sch:value-of select="$uid"/>) The DirectedActualActivity.PossibleMethods contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Activity.Status : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedActualActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedActualActivity'))]/Status/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DirectedActualActivity : <sch:value-of select="$uid"/>) The DirectedActualActivity.Status contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.SupplyingOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedActualActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedActualActivity'))]/SupplyingOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../SupplyingOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(DirectedActualActivity : <sch:value-of select="$uid"/>) The DirectedActualActivity.SupplyingOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DirectedPlannedActivity"><!--(Ref to E) DirectedPlannedActivity.Directive : WorkOrder (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedPlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedPlannedActivity'))]/Directive">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'WorkOrder'] or //WorkOrder[@uid = $uidRef]">(DirectedPlannedActivity : <sch:value-of select="$uid"/>) The DirectedPlannedActivity.Directive contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type WorkOrder.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PlannedActivity.PlannedEndDate : OPTIONAL PeriodOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedPlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedPlannedActivity'))]/PlannedEndDate/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::DateTimeString) or (self::Duration) or (self::Event and //Event[@uid = $uidRef])">(DirectedPlannedActivity : <sch:value-of select="$uid"/>) The DirectedPlannedActivity.PlannedEndDate contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PeriodOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PlannedActivity.PlannedStartDate : OPTIONAL EventOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedPlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedPlannedActivity'))]/PlannedStartDate/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(DirectedPlannedActivity : <sch:value-of select="$uid"/>) The DirectedPlannedActivity.PlannedStartDate contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EventOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Activity.ActivityType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedPlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedPlannedActivity'))]/ActivityType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DirectedPlannedActivity : <sch:value-of select="$uid"/>) The DirectedPlannedActivity.ActivityType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.ChosenMethod : OPTIONAL ActivityMethod (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedPlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedPlannedActivity'))]/ChosenMethod">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ChosenMethod) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(DirectedPlannedActivity : <sch:value-of select="$uid"/>) The DirectedPlannedActivity.ChosenMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedPlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedPlannedActivity'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DirectedPlannedActivity : <sch:value-of select="$uid"/>) The DirectedPlannedActivity.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedPlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedPlannedActivity'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(DirectedPlannedActivity : <sch:value-of select="$uid"/>) The DirectedPlannedActivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.PossibleMethods : OPTIONAL SET[1:unbounded] OF ActivityMethod (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedPlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedPlannedActivity'))]/PossibleMethods/ActivityMethod">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../PossibleMethods/ActivityMethod) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(DirectedPlannedActivity : <sch:value-of select="$uid"/>) The DirectedPlannedActivity.PossibleMethods contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Activity.Status : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedPlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedPlannedActivity'))]/Status/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DirectedPlannedActivity : <sch:value-of select="$uid"/>) The DirectedPlannedActivity.Status contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.SupplyingOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedPlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='DirectedPlannedActivity'))]/SupplyingOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../SupplyingOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(DirectedPlannedActivity : <sch:value-of select="$uid"/>) The DirectedPlannedActivity.SupplyingOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DirectedToleranceZone"><!--(Ref to E) ToleranceZoneWithDatum.DatumReference : DatumSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='DirectedToleranceZone'))]/DatumReference">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DatumSystem'] or //ShapeElement[@uid = $uidRef and contains(' DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem ',substring-after(@xsi:type,':'))]">(DirectedToleranceZone : <sch:value-of select="$uid"/>) The DirectedToleranceZone.DatumReference contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DatumSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DirectedOrOrientedToleranceZone.ZoneFor : SET[1:unbounded] OF DirectedOrOrientedGeometricToleranceSelect (kind=AGGREGATE - redefined=ToleranceZone.ZoneFor)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='DirectedToleranceZone'))]/ZoneFor/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DimensionalLocation and //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)]) or (self::DimensionalSize and //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)]) or (self::LineProfileTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' LineProfileTolerance ',@typeRef)]) or (self::ParallelismTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' ParallelismTolerance ',@typeRef)]) or (self::PerpendicularityTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' PerpendicularityTolerance ',@typeRef)]) or (self::PositionTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionTolerance ',@typeRef)]) or (self::StraightnessTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' StraightnessTolerance ',@typeRef)]) or (self::SymmetryTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' SymmetryTolerance ',@typeRef)]) or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' LineProfileTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' ParallelismTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' PerpendicularityTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' PositionTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' StraightnessTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' SymmetryTolerance ',substring-after(@xsi:type,':'))]">(DirectedToleranceZone : <sch:value-of select="$uid"/>) The DirectedToleranceZone.ZoneFor contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of DirectedOrOrientedGeometricToleranceSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='DirectedToleranceZone'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DirectedToleranceZone : <sch:value-of select="$uid"/>) The DirectedToleranceZone.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectedToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='DirectedToleranceZone'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(DirectedToleranceZone : <sch:value-of select="$uid"/>) The DirectedToleranceZone.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Direction"/>
   <sch:pattern id="DirectionFeatureToleranceZone"><!--(Ref to E) ToleranceZoneWithDatum.DatumReference : DatumSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectionFeatureToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='DirectionFeatureToleranceZone'))]/DatumReference">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DatumSystem'] or //ShapeElement[@uid = $uidRef and contains(' DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem ',substring-after(@xsi:type,':'))]">(DirectionFeatureToleranceZone : <sch:value-of select="$uid"/>) The DirectionFeatureToleranceZone.DatumReference contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DatumSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DirectedOrOrientedToleranceZone.ZoneFor : SET[1:unbounded] OF DirectedOrOrientedGeometricToleranceSelect (kind=AGGREGATE - redefined=ToleranceZone.ZoneFor)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectionFeatureToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='DirectionFeatureToleranceZone'))]/ZoneFor/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DimensionalLocation and //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)]) or (self::DimensionalSize and //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)]) or (self::LineProfileTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' LineProfileTolerance ',@typeRef)]) or (self::ParallelismTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' ParallelismTolerance ',@typeRef)]) or (self::PerpendicularityTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' PerpendicularityTolerance ',@typeRef)]) or (self::PositionTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionTolerance ',@typeRef)]) or (self::StraightnessTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' StraightnessTolerance ',@typeRef)]) or (self::SymmetryTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' SymmetryTolerance ',@typeRef)]) or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' LineProfileTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' ParallelismTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' PerpendicularityTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' PositionTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' StraightnessTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' SymmetryTolerance ',substring-after(@xsi:type,':'))]">(DirectionFeatureToleranceZone : <sch:value-of select="$uid"/>) The DirectionFeatureToleranceZone.ZoneFor contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of DirectedOrOrientedGeometricToleranceSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectionFeatureToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='DirectionFeatureToleranceZone'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DirectionFeatureToleranceZone : <sch:value-of select="$uid"/>) The DirectionFeatureToleranceZone.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DirectionFeatureToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='DirectionFeatureToleranceZone'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(DirectionFeatureToleranceZone : <sch:value-of select="$uid"/>) The DirectionFeatureToleranceZone.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DirectionFeatureToleranceZone_WR1"><!--(Rule DirectionFeatureToleranceZone.WR1)--><sch:rule context="//ShapeElement[substring-after(@xsi:type,':')='DirectionFeatureToleranceZone']/Angle"> <sch:let name="uid" value="../@uid"/> <sch:let name="unitRef" value="./Unit/@uidRef"/> <sch:assert test="//Unit[@uid=$unitRef]/Quantity/ClassString ='plane angle'">(DirectionFeatureToleranceZone <sch:value-of select="$uid"/>) The unit of Angle shall be a plane angle measure unit. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="Document"><!--(Ref to E) Document.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Document') or (self::Document and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Document : <sch:value-of select="$uid"/>) The Document.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Document.DocumentTypes : SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Document') or (self::Document and not(@xsi:type)))]/DocumentTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Document : <sch:value-of select="$uid"/>) The Document.DocumentTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DocumentAssignment"><!--(Ref to S) DocumentAssignment.AssignedDocument : AssignedDocumentSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentAssignment') or (self::DocumentAssignment and not(@xsi:type)))]/AssignedDocument">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)] or //Document[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //DocumentVersion[@uid = $uidRef] or //File[@uid = $uidRef]">(DocumentAssignment : <sch:value-of select="$uid"/>) The DocumentAssignment.AssignedDocument contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AssignedDocumentSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DocumentAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentAssignment') or (self::DocumentAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DocumentAssignment : <sch:value-of select="$uid"/>) The DocumentAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DocumentAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentAssignment') or (self::DocumentAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DocumentAssignment : <sch:value-of select="$uid"/>) The DocumentAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DocumentDefinition"><!--(Ref to E) DocumentDefinition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentDefinition') or (self::DocumentDefinition and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DocumentDefinition : <sch:value-of select="$uid"/>) The DocumentDefinition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DocumentDefinition.DocumentCreation : OPTIONAL CreationProperty (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentDefinition') or (self::DocumentDefinition and not(@xsi:type)))]/DocumentCreation">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DocumentCreation) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'CreationProperty'] or //CreationProperty[@uid = $uidRef]">(DocumentDefinition : <sch:value-of select="$uid"/>) The DocumentDefinition.DocumentCreation contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type CreationProperty.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DocumentDefinition.DocumentFormat : OPTIONAL SET[1:unbounded] OF FormatProperty (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentDefinition') or (self::DocumentDefinition and not(@xsi:type)))]/DocumentFormat/FormatProperty">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../DocumentFormat/FormatProperty) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'FormatProperty'] or //FormatProperty[@uid = $uidRef]">(DocumentDefinition : <sch:value-of select="$uid"/>) The DocumentDefinition.DocumentFormat contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type FormatProperty.</sch:assert>
      </sch:rule>
      <!--(Inverse of DocumentVersion.Views :: PartProperty) DocumentDefinition.ViewOf : DocumentVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="DocumentDefinitionRelationship"><!--(Ref to E) DocumentDefinitionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentDefinitionRelationship') or (self::DocumentDefinitionRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DocumentDefinitionRelationship : <sch:value-of select="$uid"/>) The DocumentDefinitionRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DocumentDefinitionRelationship.Related : DocumentDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentDefinitionRelationship') or (self::DocumentDefinitionRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DocumentDefinition'] or //DocumentDefinition[@uid = $uidRef]">(DocumentDefinitionRelationship : <sch:value-of select="$uid"/>) The DocumentDefinitionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DocumentDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DocumentDefinitionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentDefinitionRelationship') or (self::DocumentDefinitionRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DocumentDefinitionRelationship : <sch:value-of select="$uid"/>) The DocumentDefinitionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DocumentDefinitionRelationship_WR1"><!--(Rule DocumentDefinitionRelationship.WR1)-->
      <sch:rule context="//DocumentDefinitionRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> DocumentDefinitionRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related DocumentDefinition and the relating DocumentDefinition shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="DocumentRelationship"><!--(Ref to E) DocumentRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentRelationship') or (self::DocumentRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DocumentRelationship : <sch:value-of select="$uid"/>) The DocumentRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DocumentRelationship.Related : Document (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentRelationship') or (self::DocumentRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Document'] or //Document[@uid = $uidRef]">(DocumentRelationship : <sch:value-of select="$uid"/>) The DocumentRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Document.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DocumentRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentRelationship') or (self::DocumentRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DocumentRelationship : <sch:value-of select="$uid"/>) The DocumentRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DocumentRelationship_WR1"><!--(Rule DocumentRelationship.WR1)-->
      <sch:rule context="//DocumentRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> DocumentRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Document and the relating Document shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="DocumentVersion"><!--(Ref to E) DocumentVersion.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentVersion') or (self::DocumentVersion and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DocumentVersion : <sch:value-of select="$uid"/>) The DocumentVersion.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Inverse of Document.Versions :: PartProperty) DocumentVersion.VersionOf : Document) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="DocumentVersionRelationship"><!--(Ref to E) DocumentVersionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentVersionRelationship') or (self::DocumentVersionRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DocumentVersionRelationship : <sch:value-of select="$uid"/>) The DocumentVersionRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DocumentVersionRelationship.Related : DocumentVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentVersionRelationship') or (self::DocumentVersionRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DocumentVersion'] or //DocumentVersion[@uid = $uidRef]">(DocumentVersionRelationship : <sch:value-of select="$uid"/>) The DocumentVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DocumentVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DocumentVersionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DocumentVersionRelationship') or (self::DocumentVersionRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(DocumentVersionRelationship : <sch:value-of select="$uid"/>) The DocumentVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="DocumentVersionRelationship_WR1"><!--(Rule DocumentVersionRelationship.WR1)-->
      <sch:rule context="//DocumentVersionRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> DocumentVersionRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related DocumentVersion and the relating DocumentVersion shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="DrapedOrientationAngle"><!--(Ref to E) PlyOrientationAngle.ReinforcementDirection : ReinforcementOrientationBasis (kind=SINGLE - redefined=RepresentationRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DrapedOrientationAngle') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='DrapedOrientationAngle'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ReinforcementOrientationBasis'] or //Representation[@uid = $uidRef and contains(' ReinforcementOrientationBasis ',substring-after(@xsi:type,':'))]">(DrapedOrientationAngle : <sch:value-of select="$uid"/>) The DrapedOrientationAngle.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ReinforcementOrientationBasis.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RepresentationRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='DrapedOrientationAngle') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='DrapedOrientationAngle'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(DrapedOrientationAngle : <sch:value-of select="$uid"/>) The DrapedOrientationAngle.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Duration"/>
   <sch:pattern id="Edge"><!--(Ref to E) Edge.EdgeEnd : Vertex (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Edge') or (self::RepresentationItem and substring-after(@xsi:type,':')='Edge'))]/EdgeEnd">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Vertex'] or //RepresentationItem[@uid = $uidRef and contains(' Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(Edge : <sch:value-of select="$uid"/>) The Edge.EdgeEnd contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Vertex.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Edge.EdgeStart : Vertex (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Edge') or (self::RepresentationItem and substring-after(@xsi:type,':')='Edge'))]/EdgeStart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Vertex'] or //RepresentationItem[@uid = $uidRef and contains(' Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(Edge : <sch:value-of select="$uid"/>) The Edge.EdgeStart contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Vertex.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EdgeBasedTopologicalRepresentationWithLengthConstraint"><!--(Ref to S) EdgeBasedTopologicalRepresentationWithLengthConstraint.Items : SET[1:unbounded] OF EdgeBasedWeightedGraphRepresentationItemsSelect (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EdgeBasedTopologicalRepresentationWithLengthConstraint') or (self::Representation and substring-after(@xsi:type,':')='EdgeBasedTopologicalRepresentationWithLengthConstraint'))]/Items/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ConnectedEdgeSet and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedEdgeSet  ConnectedEdgeSubSet ',@typeRef)]) or (self::Path and //ExternalRefBaseObject[@uid = $uidRef and contains(' Path ',@typeRef)]) or (self::VertexPoint and //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)]) or //RepresentationItem[@uid = $uidRef and contains(' ConnectedEdgeSet  ConnectedEdgeSubSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Path ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))]">(EdgeBasedTopologicalRepresentationWithLengthConstraint : <sch:value-of select="$uid"/>) The EdgeBasedTopologicalRepresentationWithLengthConstraint.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EdgeBasedWeightedGraphRepresentationItemsSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EdgeBasedTopologicalRepresentationWithLengthConstraint') or (self::Representation and substring-after(@xsi:type,':')='EdgeBasedTopologicalRepresentationWithLengthConstraint'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(EdgeBasedTopologicalRepresentationWithLengthConstraint : <sch:value-of select="$uid"/>) The EdgeBasedTopologicalRepresentationWithLengthConstraint.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EdgeBasedTopologicalRepresentationWithLengthConstraint') or (self::Representation and substring-after(@xsi:type,':')='EdgeBasedTopologicalRepresentationWithLengthConstraint'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(EdgeBasedTopologicalRepresentationWithLengthConstraint : <sch:value-of select="$uid"/>) The EdgeBasedTopologicalRepresentationWithLengthConstraint.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="EdgeBoundedCurveWithLength"><!--(Ref to E) EdgeCurve.EdgeGeometry : BoundedCurve (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EdgeBoundedCurveWithLength') or (self::RepresentationItem and substring-after(@xsi:type,':')='EdgeBoundedCurveWithLength'))]/EdgeGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BoundedCurve'] or //RepresentationItem[@uid = $uidRef and contains(' BoundedCurve  BoundedCurveWithLength ',substring-after(@xsi:type,':'))]">(EdgeBoundedCurveWithLength : <sch:value-of select="$uid"/>) The EdgeBoundedCurveWithLength.EdgeGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BoundedCurve.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Edge.EdgeEnd : Vertex (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EdgeBoundedCurveWithLength') or (self::RepresentationItem and substring-after(@xsi:type,':')='EdgeBoundedCurveWithLength'))]/EdgeEnd">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Vertex'] or //RepresentationItem[@uid = $uidRef and contains(' Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(EdgeBoundedCurveWithLength : <sch:value-of select="$uid"/>) The EdgeBoundedCurveWithLength.EdgeEnd contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Vertex.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Edge.EdgeStart : Vertex (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EdgeBoundedCurveWithLength') or (self::RepresentationItem and substring-after(@xsi:type,':')='EdgeBoundedCurveWithLength'))]/EdgeStart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Vertex'] or //RepresentationItem[@uid = $uidRef and contains(' Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(EdgeBoundedCurveWithLength : <sch:value-of select="$uid"/>) The EdgeBoundedCurveWithLength.EdgeStart contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Vertex.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EdgeCurve"><!--(Ref to E) EdgeCurve.EdgeGeometry : BoundedCurve (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EdgeCurve') or (self::RepresentationItem and substring-after(@xsi:type,':')='EdgeCurve'))]/EdgeGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BoundedCurve'] or //RepresentationItem[@uid = $uidRef and contains(' BoundedCurve  BoundedCurveWithLength ',substring-after(@xsi:type,':'))]">(EdgeCurve : <sch:value-of select="$uid"/>) The EdgeCurve.EdgeGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BoundedCurve.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Edge.EdgeEnd : Vertex (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EdgeCurve') or (self::RepresentationItem and substring-after(@xsi:type,':')='EdgeCurve'))]/EdgeEnd">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Vertex'] or //RepresentationItem[@uid = $uidRef and contains(' Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(EdgeCurve : <sch:value-of select="$uid"/>) The EdgeCurve.EdgeEnd contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Vertex.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Edge.EdgeStart : Vertex (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EdgeCurve') or (self::RepresentationItem and substring-after(@xsi:type,':')='EdgeCurve'))]/EdgeStart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Vertex'] or //RepresentationItem[@uid = $uidRef and contains(' Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(EdgeCurve : <sch:value-of select="$uid"/>) The EdgeCurve.EdgeStart contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Vertex.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EdgeLoop"/>
   <sch:pattern id="EdgeOfUndefinedShapeSize"><!--(Ref to S) EdgeOfUndefinedShapeSize.IsAppliedTo : EdgeOfUndefinedShapeSizeElementSelect (kind=SINGLE - redefined=DimensionalSize.IsAppliedTo)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EdgeOfUndefinedShapeSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='EdgeOfUndefinedShapeSize'))]/IsAppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Nominal3dEdge ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' Nominal3dEdge ',substring-after(@xsi:type,':'))]">(EdgeOfUndefinedShapeSize : <sch:value-of select="$uid"/>) The EdgeOfUndefinedShapeSize.IsAppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EdgeOfUndefinedShapeSizeElementSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EdgeOfUndefinedShapeSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='EdgeOfUndefinedShapeSize'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(EdgeOfUndefinedShapeSize : <sch:value-of select="$uid"/>) The EdgeOfUndefinedShapeSize.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.GeometricDimensionContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EdgeOfUndefinedShapeSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='EdgeOfUndefinedShapeSize'))]/GeometricDimensionContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricDimensionContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(EdgeOfUndefinedShapeSize : <sch:value-of select="$uid"/>) The EdgeOfUndefinedShapeSize.GeometricDimensionContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EdgeOfUndefinedShapeSize_UR1"><!--(Rule EdgeOfUndefinedShapeSize.UR1)--><sch:rule context="//GeometricDimension[substring-after(@xsi:type,':')='EdgeOfUndefinedShapeSize']"> <sch:let name="uid" value="@uid"/> <sch:let name="isAppliedToRef" value="./IsAppliedTo/@uidRef"/> <sch:let name="orientation" value="./Orientation"/> <sch:assert test="not (($isAppliedToRef = following::GeometricDimension[substring-after(@xsi:type,':')='EdgeOfUndefinedShapeSize'][./Orientation=$orientation]/IsAppliedTo/@uidRef) or ($isAppliedToRef = preceding::GeometricDimension[substring-after(@xsi:type,':')='EdgeOfUndefinedShapeSize'][./Orientation=$orientation]/IsAppliedTo/@uidRef))"> (EdgeOfUndefinedShapeSize <sch:value-of select="$uid"/>) A geometric edge object shall not have more than one EdgeOfUndefinedShapeSize for an orientation. <sch:value-of select="$isAppliedToRef"/> / <sch:value-of select="$orientation"/> </sch:assert> </sch:rule> </sch:pattern>
   <sch:pattern id="EdgeZoneShape"><!--(Ref to S) EdgeZoneShape.Boundary : BoundaryClassZoneSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EdgeZoneShape') or (self::ZoneStructuralMakeupShapeRepresentation and substring-after(@xsi:type,':')='EdgeZoneShape'))]/Boundary">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' BoundaryCurveSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Loop ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' BoundaryCurveSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Loop ',substring-after(@xsi:type,':'))]">(EdgeZoneShape : <sch:value-of select="$uid"/>) The EdgeZoneShape.Boundary contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of BoundaryClassZoneSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Effectivity"><!--(Ref to E) Effectivity.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Effectivity') or (self::Effectivity and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Effectivity : <sch:value-of select="$uid"/>) The Effectivity.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Effectivity') or (self::Effectivity and not(@xsi:type)))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(Effectivity : <sch:value-of select="$uid"/>) The Effectivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Effectivity.EffectivityContext : OPTIONAL EffectivityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Effectivity') or (self::Effectivity and not(@xsi:type)))]/EffectivityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //Activity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef]">(Effectivity : <sch:value-of select="$uid"/>) The Effectivity.EffectivityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EffectivityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EffectivityAssignment"><!--(Ref to E) EffectivityAssignment.AssignedEffectivity : Effectivity (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EffectivityAssignment') or (self::EffectivityAssignment and not(@xsi:type)))]/AssignedEffectivity">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Effectivity'] or //Effectivity[@uid = $uidRef]">(EffectivityAssignment : <sch:value-of select="$uid"/>) The EffectivityAssignment.AssignedEffectivity contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Effectivity.</sch:assert>
      </sch:rule>
      <!--(Ref to E) EffectivityAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EffectivityAssignment') or (self::EffectivityAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(EffectivityAssignment : <sch:value-of select="$uid"/>) The EffectivityAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) EffectivityAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EffectivityAssignment') or (self::EffectivityAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(EffectivityAssignment : <sch:value-of select="$uid"/>) The EffectivityAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EffectivityControlledProductConfiguration"><!--(Ref to E) EffectivityControlledProductConfiguration.Definition : OPTIONAL Effectivity (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EffectivityControlledProductConfiguration') or (self::ProductConfiguration and substring-after(@xsi:type,':')='EffectivityControlledProductConfiguration'))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Definition) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Effectivity'] or //Effectivity[@uid = $uidRef]">(EffectivityControlledProductConfiguration : <sch:value-of select="$uid"/>) The EffectivityControlledProductConfiguration.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Effectivity.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductConfiguration.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EffectivityControlledProductConfiguration') or (self::ProductConfiguration and substring-after(@xsi:type,':')='EffectivityControlledProductConfiguration'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(EffectivityControlledProductConfiguration : <sch:value-of select="$uid"/>) The EffectivityControlledProductConfiguration.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductConfiguration.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EffectivityControlledProductConfiguration') or (self::ProductConfiguration and substring-after(@xsi:type,':')='EffectivityControlledProductConfiguration'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(EffectivityControlledProductConfiguration : <sch:value-of select="$uid"/>) The EffectivityControlledProductConfiguration.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductConfiguration.DefiningSpecifications : OPTIONAL SET[1:unbounded] OF Specification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EffectivityControlledProductConfiguration') or (self::ProductConfiguration and substring-after(@xsi:type,':')='EffectivityControlledProductConfiguration'))]/DefiningSpecifications/Specification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../DefiningSpecifications/Specification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Specification'] or //Specification[@uid = $uidRef]">(EffectivityControlledProductConfiguration : <sch:value-of select="$uid"/>) The EffectivityControlledProductConfiguration.DefiningSpecifications contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Specification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EffectivityRelationship"><!--(Ref to E) EffectivityRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EffectivityRelationship') or (self::EffectivityRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(EffectivityRelationship : <sch:value-of select="$uid"/>) The EffectivityRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) EffectivityRelationship.Related : Effectivity (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EffectivityRelationship') or (self::EffectivityRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Effectivity'] or //Effectivity[@uid = $uidRef]">(EffectivityRelationship : <sch:value-of select="$uid"/>) The EffectivityRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Effectivity.</sch:assert>
      </sch:rule>
      <!--(Ref to S) EffectivityRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EffectivityRelationship') or (self::EffectivityRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(EffectivityRelationship : <sch:value-of select="$uid"/>) The EffectivityRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EffectivityRelationship_WR1"><!--(Rule EffectivityRelationship.WR1)-->
      <sch:rule context="//EffectivityRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> EffectivityRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Effectivity and the relating Effectivity shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="ElementDelivery"><!--(Ref to S) ElementDelivery.DeliverableElements : SET[1:unbounded] OF ActivityAssignmentSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ElementDelivery') or (self::ElementDelivery and not(@xsi:type)))]/DeliverableElements/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternatePartRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternatePartRelationship ',@typeRef)]) or (self::AlternativeSolution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)]) or (self::AlternativeSolutionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolutionRelationship ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::AssemblyOccurrenceRelationshipSubstitution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyOccurrenceRelationshipSubstitution ',@typeRef)]) or (self::AssemblyViewRelationshipSubstitution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationshipSubstitution ',@typeRef)]) or (self::AssignmentObjectRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssignmentObjectRelationship ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementRealization and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRealization ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::BreakdownVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionRelationship ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConfiguredAssemblyEffectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConfiguredAssemblyEffectivity ',@typeRef)]) or (self::Contract and //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::DeltaChangeRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DeltaChangeRelationship ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::DocumentVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersionRelationship ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::EffectivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)]) or (self::Envelope and //ExternalRefBaseObject[@uid = $uidRef and contains(' Envelope ',@typeRef)]) or (self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::File and //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)]) or (self::FileRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)]) or (self::IndividualAssemblyRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualAssemblyRelationship ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialIdentification and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialIdentification ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::Message and //ExternalRefBaseObject[@uid = $uidRef and contains(' Message ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::Observation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::ObservationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)]) or (self::Occurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)]) or (self::OccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceRelationship  ReplacedUsageRelationship  SameTimeMachiningRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship  AlternatePartVersionRelationship ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::Person and //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::ProcessOperationDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinition ',@typeRef)]) or (self::ProcessOperationDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinitionRelationship ',@typeRef)]) or (self::ProcessOperationOccurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationOccurrence ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlan and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlan ',@typeRef)]) or (self::ProcessPlanRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlanRelationship ',@typeRef)]) or (self::ProductClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)]) or (self::ProductClassRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClassRelationship ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::ProductConfigurationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)]) or (self::Project and //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::ProjectRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectRelationship ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (self::Representation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel  PlyAngleRepresentation  ReinforcementOrientationBasis ',@typeRef)]) or (self::RepresentationItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' RepresentationItem  BooleanRepresentationItem  Callout  CompoundRepresentationItem  SequenceRepresentationItem  SetRepresentationItem  DateTimeRepresentationItem  DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface  ExternalRepresentationItem  ExternalTessellatedAnnotation  IntegerRepresentationItem  LogicalRepresentationItem  RationalRepresentationItem  RealRepresentationItem  StyledElement  AnnotationElement  AnnotationPlaceholderOccurrence  AnnotationPlane  OverRidingStyledElement  ContextDependentOverRidingStyledElement  StyledModelReplication  TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint  UserDefined11 ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersionRelationship ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategory and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategory ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusion ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::StyledModel and //ExternalRefBaseObject[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::ViewOccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkOrderRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderRelationship ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::WorkRequestRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestRelationship ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternatePartRelationship and //PartRelationship[@uid = $uidRef and contains(' AlternatePartRelationship ',substring-after(@xsi:type,':'))]) or (self::AlternativeSolution and //AlternativeSolution[@uid = $uidRef]) or (self::AlternativeSolutionRelationship and //AlternativeSolutionRelationship[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::AssemblyOccurrenceRelationshipSubstitution and //AssemblyOccurrenceRelationshipSubstitution[@uid = $uidRef]) or (self::AssemblyViewRelationshipSubstitution and //AssemblyViewRelationshipSubstitution[@uid = $uidRef]) or (self::AssignmentObjectRelationship and //AssignmentObjectRelationship[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementRealization and //BreakdownElementRealization[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementVersionRelationship and //BreakdownElementVersionRelationship[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::BreakdownVersionRelationship and //BreakdownVersionRelationship[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Class and //Class[@uid = $uidRef]) or (self::Condition and //*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConfiguredAssemblyEffectivity and //ConfiguredAssemblyEffectivity[@uid = $uidRef]) or (self::Contract and //Contract[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DeltaChangeRelationship and //DeltaChangeRelationship[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::DocumentVersionRelationship and //DocumentVersionRelationship[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::EffectivityRelationship and //EffectivityRelationship[@uid = $uidRef]) or (self::Envelope and //Envelope[@uid = $uidRef]) or (self::Event and //Event[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef]) or (self::File and //File[@uid = $uidRef]) or (self::FileRelationship and //FileRelationship[@uid = $uidRef]) or (self::IndividualAssemblyRelationship and //IndividualAssemblyRelationship[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartVersionRelationship and //IndividualPartVersionRelationship[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialIdentification and //MaterialIdentification[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::Message and //Message[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::Observation and //Observation[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::ObservationRelationship and //ObservationRelationship[@uid = $uidRef]) or (self::Occurrence and //Occurrence[@uid = $uidRef]) or (self::OccurrenceRelationship and //OccurrenceRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartVersionRelationship and //PartVersionRelationship[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::Person and //Person[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef]) or (self::ProcessOperationDefinition and //ProcessOperationDefinition[@uid = $uidRef]) or (self::ProcessOperationDefinitionRelationship and //ProcessOperationDefinitionRelationship[@uid = $uidRef]) or (self::ProcessOperationOccurrence and //ProcessOperationOccurrence[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlan and //ProcessPlan[@uid = $uidRef]) or (self::ProcessPlanRelationship and //ProcessPlanRelationship[@uid = $uidRef]) or (self::ProductClass and //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))]) or (self::ProductClassRelationship and //ProductClassRelationship[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProductConfigurationRelationship and //ProductConfigurationRelationship[@uid = $uidRef]) or (self::Project and //Project[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::ProjectRelationship and //ProjectRelationship[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Representation and //Representation[@uid = $uidRef]) or (self::RepresentationItem and //RepresentationItem[@uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementVersionRelationship and //RequirementVersionRelationship[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategory and //SpecificationCategory[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusion and //SpecificationInclusion[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::StyledModel and //Representation[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',substring-after(@xsi:type,':'))]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::ViewOccurrenceRelationship and //ViewOccurrenceRelationship[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkOrderRelationship and //WorkOrderRelationship[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef]) or (self::WorkRequestRelationship and //WorkRequestRelationship[@uid = $uidRef])">(ElementDelivery : <sch:value-of select="$uid"/>) The ElementDelivery.DeliverableElements contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ActivityAssignmentSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ElementDelivery.Destination : Organization (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ElementDelivery') or (self::ElementDelivery and not(@xsi:type)))]/Destination">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(ElementDelivery : <sch:value-of select="$uid"/>) The ElementDelivery.Destination contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ElementDelivery.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ElementDelivery') or (self::ElementDelivery and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ElementDelivery : <sch:value-of select="$uid"/>) The ElementDelivery.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Envelope"><!--(Ref to E) Envelope.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Envelope') or (self::Envelope and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Envelope : <sch:value-of select="$uid"/>) The Envelope.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Envelope.Wrapping : OPTIONAL Message (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Envelope') or (self::Envelope and not(@xsi:type)))]/Wrapping">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Wrapping) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Message'] or //Message[@uid = $uidRef]">(Envelope : <sch:value-of select="$uid"/>) The Envelope.Wrapping contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Message.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EnvelopeRelationship"><!--(Ref to E) EnvelopeRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EnvelopeRelationship') or (self::EnvelopeRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(EnvelopeRelationship : <sch:value-of select="$uid"/>) The EnvelopeRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) EnvelopeRelationship.Related : Envelope (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EnvelopeRelationship') or (self::EnvelopeRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Envelope'] or //Envelope[@uid = $uidRef]">(EnvelopeRelationship : <sch:value-of select="$uid"/>) The EnvelopeRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Envelope.</sch:assert>
      </sch:rule>
      <!--(Ref to S) EnvelopeRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EnvelopeRelationship') or (self::EnvelopeRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(EnvelopeRelationship : <sch:value-of select="$uid"/>) The EnvelopeRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EqualsCondition"><!--(Default Value) EqualsCondition.ConditionType : String = 'equals' (kind=SINGLE - redefined=Condition.ConditionType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EqualsCondition') or (self::Condition and substring-after(@xsi:type,':')='EqualsCondition'))]/ConditionType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'equals'">(EqualsCondition : <sch:value-of select="$uid"/>) The EqualsCondition.ConditionType contains the wrong value () must be 'equals'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Condition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EqualsCondition') or (self::EqualsCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='EqualsCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='EqualsCondition')))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(EqualsCondition : <sch:value-of select="$uid"/>) The EqualsCondition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Condition.ConditionType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EqualsCondition') or (self::EqualsCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='EqualsCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='EqualsCondition')))]/ConditionType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(EqualsCondition : <sch:value-of select="$uid"/>) The EqualsCondition.ConditionType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Condition.Parameters : SET[1:unbounded] OF ParameterSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EqualsCondition') or (self::EqualsCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='EqualsCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='EqualsCondition')))]/Parameters/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ConditionParameter and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionParameter ',@typeRef)]) or (self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternativeSolutionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolutionRelationship ',@typeRef)]) or (self::Approval and //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConditionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionRelationship ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::Descriptor and //ExternalRefBaseObject[@uid = $uidRef and contains(' Descriptor ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::EffectivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::FileRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::Observation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::ObservationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::ProcessOperationDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinitionRelationship ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlanRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlanRelationship ',@typeRef)]) or (self::ProductClassRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClassRelationship ',@typeRef)]) or (self::ProductConcept and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::ProductConfigurationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkOrderRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderRelationship ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::WorkRequestRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestRelationship ',@typeRef)]) or (self::ConditionParameter) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternativeSolutionRelationship and //AlternativeSolutionRelationship[@uid = $uidRef]) or (self::Approval and //Approval[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::Condition) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConditionRelationship and //ConditionRelationship[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DateTimeString) or (self::Descriptor and //Descriptor[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::EffectivityRelationship and //EffectivityRelationship[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::FileRelationship and //FileRelationship[@uid = $uidRef]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::Observation and //Observation[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::ObservationRelationship and //ObservationRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::ProcessOperationDefinitionRelationship and //ProcessOperationDefinitionRelationship[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlanRelationship and //ProcessPlanRelationship[@uid = $uidRef]) or (self::ProductClassRelationship and //ProductClassRelationship[@uid = $uidRef]) or (self::ProductConcept and //ProductConcept[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProductConfigurationRelationship and //ProductConfigurationRelationship[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkOrderRelationship and //WorkOrderRelationship[@uid = $uidRef]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef]) or (self::WorkRequestRelationship and //WorkRequestRelationship[@uid = $uidRef])">(EqualsCondition : <sch:value-of select="$uid"/>) The EqualsCondition.Parameters contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ParameterSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EvaluatedCharacteristic"><!--(Ref to E) EvaluatedCharacteristic.ActualCharacteristic : MeasuredCharacteristic (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EvaluatedCharacteristic') or (self::EvaluatedCharacteristic and not(@xsi:type)))]/ActualCharacteristic">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'MeasuredCharacteristic'] or //MeasuredCharacteristic[@uid = $uidRef]">(EvaluatedCharacteristic : <sch:value-of select="$uid"/>) The EvaluatedCharacteristic.ActualCharacteristic contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type MeasuredCharacteristic.</sch:assert>
      </sch:rule>
      <!--(Ref to E) EvaluatedCharacteristic.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EvaluatedCharacteristic') or (self::EvaluatedCharacteristic and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(EvaluatedCharacteristic : <sch:value-of select="$uid"/>) The EvaluatedCharacteristic.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) EvaluatedCharacteristic.PlannedCharacteristic : PlannedCharacteristic (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EvaluatedCharacteristic') or (self::EvaluatedCharacteristic and not(@xsi:type)))]/PlannedCharacteristic">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlannedCharacteristic'] or //PlannedCharacteristic[@uid = $uidRef]">(EvaluatedCharacteristic : <sch:value-of select="$uid"/>) The EvaluatedCharacteristic.PlannedCharacteristic contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlannedCharacteristic.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EvaluatedRequirement"><!--(Ref to E) EvaluatedRequirement.AnalysisModel : AnalysisModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EvaluatedRequirement') or (self::EvaluatedRequirement and not(@xsi:type)))]/AnalysisModel">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AnalysisModel'] or //AnalysisModelObject[@uid = $uidRef and contains(' AnalysisModel ',substring-after(@xsi:type,':'))]">(EvaluatedRequirement : <sch:value-of select="$uid"/>) The EvaluatedRequirement.AnalysisModel contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AnalysisModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) EvaluatedRequirement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EvaluatedRequirement') or (self::EvaluatedRequirement and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(EvaluatedRequirement : <sch:value-of select="$uid"/>) The EvaluatedRequirement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) EvaluatedRequirement.EvaluationResults : StateObserved (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EvaluatedRequirement') or (self::EvaluatedRequirement and not(@xsi:type)))]/EvaluationResults">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateObserved'] or //State[@uid = $uidRef and contains(' StateObserved ',substring-after(@xsi:type,':'))]">(EvaluatedRequirement : <sch:value-of select="$uid"/>) The EvaluatedRequirement.EvaluationResults contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateObserved.</sch:assert>
      </sch:rule>
      <!--(Ref to E) EvaluatedRequirement.EvaluationStatus : StateObserved (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EvaluatedRequirement') or (self::EvaluatedRequirement and not(@xsi:type)))]/EvaluationStatus">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateObserved'] or //State[@uid = $uidRef and contains(' StateObserved ',substring-after(@xsi:type,':'))]">(EvaluatedRequirement : <sch:value-of select="$uid"/>) The EvaluatedRequirement.EvaluationStatus contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateObserved.</sch:assert>
      </sch:rule>
      <!--(Ref to E) EvaluatedRequirement.RequiredFor : RequirementAssignment (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EvaluatedRequirement') or (self::EvaluatedRequirement and not(@xsi:type)))]/RequiredFor">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementAssignment'] or //RequirementAssignment[@uid = $uidRef]">(EvaluatedRequirement : <sch:value-of select="$uid"/>) The EvaluatedRequirement.RequiredFor contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementAssignment.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Event"><!--(Ref to E) Event.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Event') or (self::Event and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Event : <sch:value-of select="$uid"/>) The Event.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Event.EventType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Event') or (self::Event and not(@xsi:type)))]/EventType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Event : <sch:value-of select="$uid"/>) The Event.EventType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EventAssignment"><!--(Ref to E) EventAssignment.AssignedEvent : Event (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EventAssignment') or (self::EventAssignment and not(@xsi:type)))]/AssignedEvent">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Event'] or //Event[@uid = $uidRef]">(EventAssignment : <sch:value-of select="$uid"/>) The EventAssignment.AssignedEvent contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Event.</sch:assert>
      </sch:rule>
      <!--(Ref to E) EventAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EventAssignment') or (self::EventAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(EventAssignment : <sch:value-of select="$uid"/>) The EventAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) EventAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EventAssignment') or (self::EventAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(EventAssignment : <sch:value-of select="$uid"/>) The EventAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EventRelationship"><!--(Ref to E) EventRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EventRelationship') or (self::EventRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(EventRelationship : <sch:value-of select="$uid"/>) The EventRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) EventRelationship.Related : Event (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EventRelationship') or (self::EventRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Event'] or //Event[@uid = $uidRef]">(EventRelationship : <sch:value-of select="$uid"/>) The EventRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Event.</sch:assert>
      </sch:rule>
      <!--(Ref to S) EventRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='EventRelationship') or (self::EventRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(EventRelationship : <sch:value-of select="$uid"/>) The EventRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="EventRelationship_WR1"><!--(Rule EventRelationship.WR1)-->
      <sch:rule context="//EventRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> EventRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Event and the relating Event shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="Evidence"><!--(Ref to E) Evidence.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Evidence') or (self::Evidence and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Evidence : <sch:value-of select="$uid"/>) The Evidence.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Evidence.Items : SET[1:unbounded] OF EvidenceSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Evidence') or (self::Evidence and not(@xsi:type)))]/Items/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::ActualActivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActualActivity  DirectedActualActivity ',@typeRef)]) or (self::AlternativeSolutionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolutionRelationship ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::EffectivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)]) or (self::EvaluatedRequirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' EvaluatedRequirement ',@typeRef)]) or (self::FileRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::ObservationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship  AlternatePartVersionRelationship ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::ProcessOperationDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinitionRelationship ',@typeRef)]) or (self::ProcessPlanRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlanRelationship ',@typeRef)]) or (self::ProductClassRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClassRelationship ',@typeRef)]) or (self::ProductConfigurationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::StateDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinition ',@typeRef)]) or (self::Validation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Validation ',@typeRef)]) or (self::Verification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Verification ',@typeRef)]) or (self::WorkOrderRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderRelationship ',@typeRef)]) or (self::WorkRequestRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestRelationship ',@typeRef)]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::ActualActivity and //Activity[@uid = $uidRef and contains(' ActualActivity  DirectedActualActivity ',substring-after(@xsi:type,':'))]) or (self::AlternativeSolutionRelationship and //AlternativeSolutionRelationship[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::EffectivityRelationship and //EffectivityRelationship[@uid = $uidRef]) or (self::EvaluatedRequirement and //EvaluatedRequirement[@uid = $uidRef]) or (self::FileRelationship and //FileRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::ObservationRelationship and //ObservationRelationship[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartVersionRelationship and //PartVersionRelationship[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef]) or (self::ProcessOperationDefinitionRelationship and //ProcessOperationDefinitionRelationship[@uid = $uidRef]) or (self::ProcessPlanRelationship and //ProcessPlanRelationship[@uid = $uidRef]) or (self::ProductClassRelationship and //ProductClassRelationship[@uid = $uidRef]) or (self::ProductConfigurationRelationship and //ProductConfigurationRelationship[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::StateDefinition and //StateDefinition[@uid = $uidRef]) or (self::Validation and //Validation[@uid = $uidRef]) or (self::Verification and //Verification[@uid = $uidRef]) or (self::WorkOrderRelationship and //WorkOrderRelationship[@uid = $uidRef]) or (self::WorkRequestRelationship and //WorkRequestRelationship[@uid = $uidRef])">(Evidence : <sch:value-of select="$uid"/>) The Evidence.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EvidenceSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Evidence.Supports : EvidenceSupportSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Evidence') or (self::Evidence and not(@xsi:type)))]/Supports">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Validation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Verification ',@typeRef)] or //Validation[@uid = $uidRef] or //Verification[@uid = $uidRef]">(Evidence : <sch:value-of select="$uid"/>) The Evidence.Supports contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EvidenceSupportSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExchangeContext"><!--(Ref to E) ExchangeContext.DefaultUnit : OPTIONAL Unit (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExchangeContext') or (self::ExchangeContext and not(@xsi:type)))]/DefaultUnit">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefaultUnit) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Unit'] or //Unit[@uid = $uidRef]">(ExchangeContext : <sch:value-of select="$uid"/>) The ExchangeContext.DefaultUnit contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Unit.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ExchangeContext.IdentificationContext : OPTIONAL IdentificationContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExchangeContext') or (self::ExchangeContext and not(@xsi:type)))]/IdentificationContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //Identifier[@uid = $uidRef] or //Organization[@uid = $uidRef]">(ExchangeContext : <sch:value-of select="$uid"/>) The ExchangeContext.IdentificationContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of IdentificationContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExpandedUncertainty"/>
   <sch:pattern id="Extension"><!--(Ref to E) Extension.DerivedFrom : ShapeElement (kind=SINGLE - redefined=DerivedShapeElement.DerivedFrom)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Extension') or (self::ShapeElement and substring-after(@xsi:type,':')='Extension'))]/DerivedFrom">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="count(../../DerivedFrom/ShapeElement) = 1">(Extension : <sch:value-of select="$uid"/>) The Extension.DerivedFrom contains wrong number of element must be 1.</sch:assert>
      </sch:rule>
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Extension') or (self::ShapeElement and substring-after(@xsi:type,':')='Extension'))]/DerivedFrom/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(Extension : <sch:value-of select="$uid"/>) The Extension.DerivedFrom contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Extension') or (self::ShapeElement and substring-after(@xsi:type,':')='Extension'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Extension : <sch:value-of select="$uid"/>) The Extension.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Extension') or (self::ShapeElement and substring-after(@xsi:type,':')='Extension'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(Extension : <sch:value-of select="$uid"/>) The Extension.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExternalAdvancedBrepShapeRepresentation"><!--(Ref to E) ExternalGeometricModel.ExternalFile : DigitalFile (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalAdvancedBrepShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalAdvancedBrepShapeRepresentation'))]/ExternalFile">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(ExternalAdvancedBrepShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalAdvancedBrepShapeRepresentation.ExternalFile contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ExternalGeometricModel.Items : SET[1:unbounded] OF DetailedGeometricModelItem (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalAdvancedBrepShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalAdvancedBrepShapeRepresentation'))]/Items/DetailedGeometricModelItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DetailedGeometricModelItem'] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(ExternalAdvancedBrepShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalAdvancedBrepShapeRepresentation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DetailedGeometricModelItem.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalAdvancedBrepShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalAdvancedBrepShapeRepresentation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ExternalAdvancedBrepShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalAdvancedBrepShapeRepresentation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalAdvancedBrepShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalAdvancedBrepShapeRepresentation'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ExternalAdvancedBrepShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalAdvancedBrepShapeRepresentation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ExternalAnalysisModel"><!--(Ref to E) ExternalAnalysisModel.ExternalFile : DigitalFile (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalAnalysisModel') or (self::AnalysisModelObject and substring-after(@xsi:type,':')='ExternalAnalysisModel'))]/ExternalFile">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(ExternalAnalysisModel : <sch:value-of select="$uid"/>) The ExternalAnalysisModel.ExternalFile contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AnalysisModelObject.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalAnalysisModel') or (self::AnalysisModelObject and substring-after(@xsi:type,':')='ExternalAnalysisModel'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ExternalAnalysisModel : <sch:value-of select="$uid"/>) The ExternalAnalysisModel.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExternalClassSystem"><!--(Ref to S) ExternalClassSystem.Source : OPTIONAL ExternalSourceSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalClassSystem') or (self::ExternalClassSystem and not(@xsi:type)))]/Source/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DigitalFile and //ExternalRefBaseObject[@uid = $uidRef and contains(' DigitalFile ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::DigitalFile and //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]) or (self::Document and //Document[@uid = $uidRef]) or (self::IdentifierSet) or (self::Identifier) or (self::IdentifierString)">(ExternalClassSystem : <sch:value-of select="$uid"/>) The ExternalClassSystem.Source contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ExternalSourceSelect.</sch:assert>
      </sch:rule>
      <!--(Rule for inverse of Class.DefinedIn :: ReferenceProperty) ExternalClassSystem.AllowedClasses : SET[1:unbounded] OF Class)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalClassSystem') or (self::ExternalClassSystem))]">
         <sch:let name="uid" value="./@uid"/>
         <sch:assert test="//Class/DefinedIn[@uidRef = $uid]">(ExternalClassSystem : <sch:value-of select="$uid"/>) The ExternalClassSystem.AllowedClasses inverse rule must be referenced by Class.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExternalCsgShapeRepresentation"><!--(Ref to E) ExternalGeometricModel.ExternalFile : DigitalFile (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalCsgShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalCsgShapeRepresentation'))]/ExternalFile">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(ExternalCsgShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalCsgShapeRepresentation.ExternalFile contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ExternalGeometricModel.Items : SET[1:unbounded] OF DetailedGeometricModelItem (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalCsgShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalCsgShapeRepresentation'))]/Items/DetailedGeometricModelItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DetailedGeometricModelItem'] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(ExternalCsgShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalCsgShapeRepresentation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DetailedGeometricModelItem.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalCsgShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalCsgShapeRepresentation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ExternalCsgShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalCsgShapeRepresentation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalCsgShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalCsgShapeRepresentation'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ExternalCsgShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalCsgShapeRepresentation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ExternalCurveSweptSolidShapeRepresentation"><!--(Ref to E) ExternalGeometricModel.ExternalFile : DigitalFile (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalCurveSweptSolidShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalCurveSweptSolidShapeRepresentation'))]/ExternalFile">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(ExternalCurveSweptSolidShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalCurveSweptSolidShapeRepresentation.ExternalFile contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ExternalGeometricModel.Items : SET[1:unbounded] OF DetailedGeometricModelItem (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalCurveSweptSolidShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalCurveSweptSolidShapeRepresentation'))]/Items/DetailedGeometricModelItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DetailedGeometricModelItem'] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(ExternalCurveSweptSolidShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalCurveSweptSolidShapeRepresentation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DetailedGeometricModelItem.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalCurveSweptSolidShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalCurveSweptSolidShapeRepresentation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ExternalCurveSweptSolidShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalCurveSweptSolidShapeRepresentation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalCurveSweptSolidShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalCurveSweptSolidShapeRepresentation'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ExternalCurveSweptSolidShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalCurveSweptSolidShapeRepresentation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ExternalEdgeBasedWireframeShapeRepresentation"><!--(Ref to E) ExternalGeometricModel.ExternalFile : DigitalFile (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalEdgeBasedWireframeShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalEdgeBasedWireframeShapeRepresentation'))]/ExternalFile">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(ExternalEdgeBasedWireframeShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalEdgeBasedWireframeShapeRepresentation.ExternalFile contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ExternalGeometricModel.Items : SET[1:unbounded] OF DetailedGeometricModelItem (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalEdgeBasedWireframeShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalEdgeBasedWireframeShapeRepresentation'))]/Items/DetailedGeometricModelItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DetailedGeometricModelItem'] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(ExternalEdgeBasedWireframeShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalEdgeBasedWireframeShapeRepresentation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DetailedGeometricModelItem.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalEdgeBasedWireframeShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalEdgeBasedWireframeShapeRepresentation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ExternalEdgeBasedWireframeShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalEdgeBasedWireframeShapeRepresentation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalEdgeBasedWireframeShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalEdgeBasedWireframeShapeRepresentation'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ExternalEdgeBasedWireframeShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalEdgeBasedWireframeShapeRepresentation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ExternalElementaryBrepShapeRepresentation"><!--(Ref to E) ExternalGeometricModel.ExternalFile : DigitalFile (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalElementaryBrepShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalElementaryBrepShapeRepresentation'))]/ExternalFile">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(ExternalElementaryBrepShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalElementaryBrepShapeRepresentation.ExternalFile contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ExternalGeometricModel.Items : SET[1:unbounded] OF DetailedGeometricModelItem (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalElementaryBrepShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalElementaryBrepShapeRepresentation'))]/Items/DetailedGeometricModelItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DetailedGeometricModelItem'] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(ExternalElementaryBrepShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalElementaryBrepShapeRepresentation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DetailedGeometricModelItem.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalElementaryBrepShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalElementaryBrepShapeRepresentation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ExternalElementaryBrepShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalElementaryBrepShapeRepresentation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalElementaryBrepShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalElementaryBrepShapeRepresentation'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ExternalElementaryBrepShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalElementaryBrepShapeRepresentation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ExternalEntityInstance"><!--(Ref to S) ExternalItem.Source : OPTIONAL ExternalSourceSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalEntityInstance') or (self::ExternalEntityInstance or (self::ExternalItem and substring-after(@xsi:type,':')='ExternalEntityInstance') or (self::NextInstance and substring-after(@xsi:type,':')='ExternalEntityInstance') or (self::NextInstance and substring-after(@xsi:type,':')='ExternalEntityInstance') or (self::External and substring-after(@xsi:type,':')='ExternalEntityInstance')))]/Source/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DigitalFile and //ExternalRefBaseObject[@uid = $uidRef and contains(' DigitalFile ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::DigitalFile and //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]) or (self::Document and //Document[@uid = $uidRef]) or (self::IdentifierSet) or (self::Identifier) or (self::IdentifierString)">(ExternalEntityInstance : <sch:value-of select="$uid"/>) The ExternalEntityInstance.Source contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ExternalSourceSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExternalFacetedBrepShapeRepresentation"><!--(Ref to E) ExternalGeometricModel.ExternalFile : DigitalFile (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalFacetedBrepShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalFacetedBrepShapeRepresentation'))]/ExternalFile">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(ExternalFacetedBrepShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalFacetedBrepShapeRepresentation.ExternalFile contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ExternalGeometricModel.Items : SET[1:unbounded] OF DetailedGeometricModelItem (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalFacetedBrepShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalFacetedBrepShapeRepresentation'))]/Items/DetailedGeometricModelItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DetailedGeometricModelItem'] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(ExternalFacetedBrepShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalFacetedBrepShapeRepresentation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DetailedGeometricModelItem.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalFacetedBrepShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalFacetedBrepShapeRepresentation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ExternalFacetedBrepShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalFacetedBrepShapeRepresentation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalFacetedBrepShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalFacetedBrepShapeRepresentation'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ExternalFacetedBrepShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalFacetedBrepShapeRepresentation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ExternalGeometricModel"><!--(Ref to E) ExternalGeometricModel.ExternalFile : DigitalFile (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='ExternalGeometricModel'))]/ExternalFile">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(ExternalGeometricModel : <sch:value-of select="$uid"/>) The ExternalGeometricModel.ExternalFile contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ExternalGeometricModel.Items : SET[1:unbounded] OF DetailedGeometricModelItem (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='ExternalGeometricModel'))]/Items/DetailedGeometricModelItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DetailedGeometricModelItem'] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(ExternalGeometricModel : <sch:value-of select="$uid"/>) The ExternalGeometricModel.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DetailedGeometricModelItem.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='ExternalGeometricModel'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ExternalGeometricModel : <sch:value-of select="$uid"/>) The ExternalGeometricModel.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='ExternalGeometricModel'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ExternalGeometricModel : <sch:value-of select="$uid"/>) The ExternalGeometricModel.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ExternalGeometricallyBoundedSurfaceShapeRepresentation"><!--(Ref to E) ExternalGeometricModel.ExternalFile : DigitalFile (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalGeometricallyBoundedSurfaceShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalGeometricallyBoundedSurfaceShapeRepresentation'))]/ExternalFile">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(ExternalGeometricallyBoundedSurfaceShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalGeometricallyBoundedSurfaceShapeRepresentation.ExternalFile contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ExternalGeometricModel.Items : SET[1:unbounded] OF DetailedGeometricModelItem (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalGeometricallyBoundedSurfaceShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalGeometricallyBoundedSurfaceShapeRepresentation'))]/Items/DetailedGeometricModelItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DetailedGeometricModelItem'] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(ExternalGeometricallyBoundedSurfaceShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalGeometricallyBoundedSurfaceShapeRepresentation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DetailedGeometricModelItem.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalGeometricallyBoundedSurfaceShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalGeometricallyBoundedSurfaceShapeRepresentation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ExternalGeometricallyBoundedSurfaceShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalGeometricallyBoundedSurfaceShapeRepresentation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalGeometricallyBoundedSurfaceShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalGeometricallyBoundedSurfaceShapeRepresentation'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ExternalGeometricallyBoundedSurfaceShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalGeometricallyBoundedSurfaceShapeRepresentation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ExternalGeometricallyBoundedWireframeShapeRepresentation"><!--(Ref to E) ExternalGeometricModel.ExternalFile : DigitalFile (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalGeometricallyBoundedWireframeShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalGeometricallyBoundedWireframeShapeRepresentation'))]/ExternalFile">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(ExternalGeometricallyBoundedWireframeShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalGeometricallyBoundedWireframeShapeRepresentation.ExternalFile contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ExternalGeometricModel.Items : SET[1:unbounded] OF DetailedGeometricModelItem (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalGeometricallyBoundedWireframeShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalGeometricallyBoundedWireframeShapeRepresentation'))]/Items/DetailedGeometricModelItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DetailedGeometricModelItem'] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(ExternalGeometricallyBoundedWireframeShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalGeometricallyBoundedWireframeShapeRepresentation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DetailedGeometricModelItem.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalGeometricallyBoundedWireframeShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalGeometricallyBoundedWireframeShapeRepresentation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ExternalGeometricallyBoundedWireframeShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalGeometricallyBoundedWireframeShapeRepresentation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalGeometricallyBoundedWireframeShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalGeometricallyBoundedWireframeShapeRepresentation'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ExternalGeometricallyBoundedWireframeShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalGeometricallyBoundedWireframeShapeRepresentation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ExternalItem"><!--(Ref to S) ExternalItem.Source : OPTIONAL ExternalSourceSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalItem') or (self::ExternalItem or (self::ExternalItem and substring-after(@xsi:type,':')='ExternalItem') or (self::NextInstance and substring-after(@xsi:type,':')='ExternalItem') or (self::NextInstance and substring-after(@xsi:type,':')='ExternalItem') or (self::External and substring-after(@xsi:type,':')='ExternalItem')))]/Source/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DigitalFile and //ExternalRefBaseObject[@uid = $uidRef and contains(' DigitalFile ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::DigitalFile and //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]) or (self::Document and //Document[@uid = $uidRef]) or (self::IdentifierSet) or (self::Identifier) or (self::IdentifierString)">(ExternalItem : <sch:value-of select="$uid"/>) The ExternalItem.Source contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ExternalSourceSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExternalManifoldSurfaceShapeRepresentation"><!--(Ref to E) ExternalGeometricModel.ExternalFile : DigitalFile (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalManifoldSurfaceShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalManifoldSurfaceShapeRepresentation'))]/ExternalFile">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(ExternalManifoldSurfaceShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalManifoldSurfaceShapeRepresentation.ExternalFile contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ExternalGeometricModel.Items : SET[1:unbounded] OF DetailedGeometricModelItem (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalManifoldSurfaceShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalManifoldSurfaceShapeRepresentation'))]/Items/DetailedGeometricModelItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DetailedGeometricModelItem'] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(ExternalManifoldSurfaceShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalManifoldSurfaceShapeRepresentation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DetailedGeometricModelItem.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalManifoldSurfaceShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalManifoldSurfaceShapeRepresentation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ExternalManifoldSurfaceShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalManifoldSurfaceShapeRepresentation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalManifoldSurfaceShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalManifoldSurfaceShapeRepresentation'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ExternalManifoldSurfaceShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalManifoldSurfaceShapeRepresentation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ExternalOwlClass"/>
   <sch:pattern id="ExternalOwlObject"/>
   <sch:pattern id="ExternalRepresentationItem"/>
   <sch:pattern id="ExternalShellBasedWireframeShapeRepresentation"><!--(Ref to E) ExternalGeometricModel.ExternalFile : DigitalFile (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalShellBasedWireframeShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalShellBasedWireframeShapeRepresentation'))]/ExternalFile">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(ExternalShellBasedWireframeShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalShellBasedWireframeShapeRepresentation.ExternalFile contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ExternalGeometricModel.Items : SET[1:unbounded] OF DetailedGeometricModelItem (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalShellBasedWireframeShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalShellBasedWireframeShapeRepresentation'))]/Items/DetailedGeometricModelItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DetailedGeometricModelItem'] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(ExternalShellBasedWireframeShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalShellBasedWireframeShapeRepresentation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DetailedGeometricModelItem.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalShellBasedWireframeShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalShellBasedWireframeShapeRepresentation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ExternalShellBasedWireframeShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalShellBasedWireframeShapeRepresentation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalShellBasedWireframeShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalShellBasedWireframeShapeRepresentation'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ExternalShellBasedWireframeShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalShellBasedWireframeShapeRepresentation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ExternalStyledModel"><!--(Ref to E) ExternalStyledModel.DefinedIn : DigitalFile (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalStyledModel') or (self::Representation and substring-after(@xsi:type,':')='ExternalStyledModel'))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(ExternalStyledModel : <sch:value-of select="$uid"/>) The ExternalStyledModel.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalStyledModel') or (self::Representation and substring-after(@xsi:type,':')='ExternalStyledModel'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ExternalStyledModel : <sch:value-of select="$uid"/>) The ExternalStyledModel.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Representation.Items : SET[1:unbounded] OF RepresentationItem (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalStyledModel') or (self::Representation and substring-after(@xsi:type,':')='ExternalStyledModel'))]/Items/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(ExternalStyledModel : <sch:value-of select="$uid"/>) The ExternalStyledModel.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalStyledModel') or (self::Representation and substring-after(@xsi:type,':')='ExternalStyledModel'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ExternalStyledModel : <sch:value-of select="$uid"/>) The ExternalStyledModel.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ExternalTessellatedAnnotation"/>
   <sch:pattern id="ExternalTessellatedShapeRepresentation"><!--(Ref to E) ExternalGeometricModel.ExternalFile : DigitalFile (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalTessellatedShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalTessellatedShapeRepresentation'))]/ExternalFile">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(ExternalTessellatedShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalTessellatedShapeRepresentation.ExternalFile contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ExternalGeometricModel.Items : SET[1:unbounded] OF DetailedGeometricModelItem (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalTessellatedShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalTessellatedShapeRepresentation'))]/Items/DetailedGeometricModelItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DetailedGeometricModelItem'] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(ExternalTessellatedShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalTessellatedShapeRepresentation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DetailedGeometricModelItem.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalTessellatedShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalTessellatedShapeRepresentation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ExternalTessellatedShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalTessellatedShapeRepresentation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalTessellatedShapeRepresentation') or (self::Representation and substring-after(@xsi:type,':')='ExternalTessellatedShapeRepresentation'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ExternalTessellatedShapeRepresentation : <sch:value-of select="$uid"/>) The ExternalTessellatedShapeRepresentation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ExternalTypeQualifier"/>
   <sch:pattern id="ExternalUnit"><!--(Ref to E) ExternalUnit.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalUnit') or (self::ExternalUnit and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ExternalUnit : <sch:value-of select="$uid"/>) The ExternalUnit.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ExternalUnit.Definition : ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternalUnit') or (self::ExternalUnit and not(@xsi:type)))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(ExternalUnit : <sch:value-of select="$uid"/>) The ExternalUnit.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExternallyDefinedColour"><!--(Ref to S) ExternallyDefinedColour.Source : ExternalSourceSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternallyDefinedColour') or (self::Colour and substring-after(@xsi:type,':')='ExternallyDefinedColour'))]/Source/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DigitalFile and //ExternalRefBaseObject[@uid = $uidRef and contains(' DigitalFile ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::DigitalFile and //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]) or (self::Document and //Document[@uid = $uidRef]) or (self::IdentifierSet) or (self::Identifier) or (self::IdentifierString)">(ExternallyDefinedColour : <sch:value-of select="$uid"/>) The ExternallyDefinedColour.Source contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ExternalSourceSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ExternallyDefinedCurveFont"><!--(Ref to S) ExternallyDefinedCurveFont.CurveFontReference : ExternalSourceSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ExternallyDefinedCurveFont') or (self::CurveFont and substring-after(@xsi:type,':')='ExternallyDefinedCurveFont'))]/CurveFontReference/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DigitalFile and //ExternalRefBaseObject[@uid = $uidRef and contains(' DigitalFile ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::DigitalFile and //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]) or (self::Document and //Document[@uid = $uidRef]) or (self::IdentifierSet) or (self::Identifier) or (self::IdentifierString)">(ExternallyDefinedCurveFont : <sch:value-of select="$uid"/>) The ExternallyDefinedCurveFont.CurveFontReference contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ExternalSourceSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="FaceBasedSheetRepresentation"><!--(Ref to E) FaceBasedSheetRepresentation.FaceSurface : Surface (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FaceBasedSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='FaceBasedSheetRepresentation'))]/FaceSurface">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Surface'] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(FaceBasedSheetRepresentation : <sch:value-of select="$uid"/>) The FaceBasedSheetRepresentation.FaceSurface contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Surface.</sch:assert>
      </sch:rule>
      <!--(Ref to E) FaceBasedSheetRepresentation.InnerBounds : OPTIONAL SET[1:unbounded] OF Loop (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FaceBasedSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='FaceBasedSheetRepresentation'))]/InnerBounds/Loop">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../InnerBounds/Loop) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Loop'] or //RepresentationItem[@uid = $uidRef and contains(' Loop ',substring-after(@xsi:type,':'))]">(FaceBasedSheetRepresentation : <sch:value-of select="$uid"/>) The FaceBasedSheetRepresentation.InnerBounds contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Loop.</sch:assert>
      </sch:rule>
      <!--(Ref to E) FaceBasedSheetRepresentation.OuterBound : Loop (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FaceBasedSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='FaceBasedSheetRepresentation'))]/OuterBound">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Loop'] or //RepresentationItem[@uid = $uidRef and contains(' Loop ',substring-after(@xsi:type,':'))]">(FaceBasedSheetRepresentation : <sch:value-of select="$uid"/>) The FaceBasedSheetRepresentation.OuterBound contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Loop.</sch:assert>
      </sch:rule>
      <!--(Ref to E) CompositeSheetRepresentation.ThreeDGeometry : ExternalGeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FaceBasedSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='FaceBasedSheetRepresentation'))]/ThreeDGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExternalGeometricModel'] or //Representation[@uid = $uidRef and contains(' ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation ',substring-after(@xsi:type,':'))]">(FaceBasedSheetRepresentation : <sch:value-of select="$uid"/>) The FaceBasedSheetRepresentation.ThreeDGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExternalGeometricModel.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FaceBasedSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='FaceBasedSheetRepresentation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(FaceBasedSheetRepresentation : <sch:value-of select="$uid"/>) The FaceBasedSheetRepresentation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Representation.Items : SET[1:unbounded] OF RepresentationItem (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FaceBasedSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='FaceBasedSheetRepresentation'))]/Items/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(FaceBasedSheetRepresentation : <sch:value-of select="$uid"/>) The FaceBasedSheetRepresentation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FaceBasedSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='FaceBasedSheetRepresentation'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(FaceBasedSheetRepresentation : <sch:value-of select="$uid"/>) The FaceBasedSheetRepresentation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="FaceSurface"><!--(Ref to E) FaceSurface.FaceGeometry : Surface (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FaceSurface') or (self::RepresentationItem and substring-after(@xsi:type,':')='FaceSurface'))]/FaceGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Surface'] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(FaceSurface : <sch:value-of select="$uid"/>) The FaceSurface.FaceGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Surface.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="FilamentLaminate"><!--(Ref to E) FilamentLaminate.MadeFrom : StockMaterial (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FilamentLaminate') or (self::PartView and substring-after(@xsi:type,':')='FilamentLaminate'))]/MadeFrom">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StockMaterial'] or //StockMaterial[@uid = $uidRef]">(FilamentLaminate : <sch:value-of select="$uid"/>) The FilamentLaminate.MadeFrom contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StockMaterial.</sch:assert>
      </sch:rule>
      <!--(Ref to E) FilamentLaminate.ShapeCrossSection : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FilamentLaminate') or (self::PartView and substring-after(@xsi:type,':')='FilamentLaminate'))]/ShapeCrossSection">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ShapeCrossSection) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(FilamentLaminate : <sch:value-of select="$uid"/>) The FilamentLaminate.ShapeCrossSection contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FilamentLaminate') or (self::PartView and substring-after(@xsi:type,':')='FilamentLaminate'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(FilamentLaminate : <sch:value-of select="$uid"/>) The FilamentLaminate.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FilamentLaminate') or (self::PartView and substring-after(@xsi:type,':')='FilamentLaminate'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(FilamentLaminate : <sch:value-of select="$uid"/>) The FilamentLaminate.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FilamentLaminate') or (self::PartView and substring-after(@xsi:type,':')='FilamentLaminate'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(FilamentLaminate : <sch:value-of select="$uid"/>) The FilamentLaminate.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FilamentLaminate') or (self::PartView and substring-after(@xsi:type,':')='FilamentLaminate'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(FilamentLaminate : <sch:value-of select="$uid"/>) The FilamentLaminate.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FilamentLaminate') or (self::PartView and substring-after(@xsi:type,':')='FilamentLaminate'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(FilamentLaminate : <sch:value-of select="$uid"/>) The FilamentLaminate.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="FileLocationIdentification"/>
   <sch:pattern id="FileRelationship"><!--(Ref to E) FileRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FileRelationship') or (self::FileRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(FileRelationship : <sch:value-of select="$uid"/>) The FileRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) FileRelationship.Related : File (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FileRelationship') or (self::FileRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'File'] or //File[@uid = $uidRef]">(FileRelationship : <sch:value-of select="$uid"/>) The FileRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type File.</sch:assert>
      </sch:rule>
      <!--(Ref to S) FileRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FileRelationship') or (self::FileRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(FileRelationship : <sch:value-of select="$uid"/>) The FileRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="FileRelationship_WR1"><!--(Rule FileRelationship.WR1)-->
      <sch:rule context="//FileRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> FileRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related File and the relating File shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="Filter"/>
   <sch:pattern id="FilterNestingIndex"/>
   <sch:pattern id="FinalSolution"><!--(Ref to S) FinalSolution.Specifications : SET[1:unbounded] OF FinalDefinitionSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FinalSolution') or (self::AlternativeSolution and substring-after(@xsi:type,':')='FinalSolution'))]/Specifications/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef])">(FinalSolution : <sch:value-of select="$uid"/>) The FinalSolution.Specifications contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of FinalDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) FinalSolution.Status : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FinalSolution') or (self::AlternativeSolution and substring-after(@xsi:type,':')='FinalSolution'))]/Status/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(FinalSolution : <sch:value-of select="$uid"/>) The FinalSolution.Status contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AlternativeSolution.BaseElement : BreakdownElementOrAlternativeSolutionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FinalSolution') or (self::AlternativeSolution and substring-after(@xsi:type,':')='FinalSolution'))]/BaseElement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //AlternativeSolution[@uid = $uidRef] or //BreakdownElement[@uid = $uidRef]">(FinalSolution : <sch:value-of select="$uid"/>) The FinalSolution.BaseElement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of BreakdownElementOrAlternativeSolutionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AlternativeSolution.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FinalSolution') or (self::AlternativeSolution and substring-after(@xsi:type,':')='FinalSolution'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(FinalSolution : <sch:value-of select="$uid"/>) The FinalSolution.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="FlatnessTolerance"><!--(Ref to S) GeometricTolerance.AppliedTo : GeometricToleranceTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FlatnessTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='FlatnessTolerance'))]/AppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //PartView[@uid = $uidRef]">(FlatnessTolerance : <sch:value-of select="$uid"/>) The FlatnessTolerance.AppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricToleranceTargetSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FlatnessTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='FlatnessTolerance'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(FlatnessTolerance : <sch:value-of select="$uid"/>) The FlatnessTolerance.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.GeometricToleranceContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FlatnessTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='FlatnessTolerance'))]/GeometricToleranceContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricToleranceContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(FlatnessTolerance : <sch:value-of select="$uid"/>) The FlatnessTolerance.GeometricToleranceContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="FormatProperty"><!--(Ref to S) FormatProperty.CharacterCode : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FormatProperty') or (self::FormatProperty and not(@xsi:type)))]/CharacterCode/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(FormatProperty : <sch:value-of select="$uid"/>) The FormatProperty.CharacterCode contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) FormatProperty.DataFormat : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FormatProperty') or (self::FormatProperty and not(@xsi:type)))]/DataFormat/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(FormatProperty : <sch:value-of select="$uid"/>) The FormatProperty.DataFormat contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="FrozenAssignment"><!--(Ref to S) FrozenAssignment.FrozenObject : SET[1:unbounded] OF DeltaChangeManagementObjectSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FrozenAssignment') or (self::ApprovalAssignment and substring-after(@xsi:type,':')='FrozenAssignment'))]/FrozenObject/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternatePartRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternatePartRelationship ',@typeRef)]) or (self::AlternativeSolution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::AssemblyOccurrenceRelationshipSubstitution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyOccurrenceRelationshipSubstitution ',@typeRef)]) or (self::AssemblyViewRelationshipSubstitution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationshipSubstitution ',@typeRef)]) or (self::AssignmentObjectRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssignmentObjectRelationship ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementRealization and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRealization ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::BreakdownVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionRelationship ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConfiguredAssemblyEffectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConfiguredAssemblyEffectivity ',@typeRef)]) or (self::Contract and //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::DeltaChangeRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DeltaChangeRelationship ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::DocumentVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersionRelationship ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::File and //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)]) or (self::IndividualAssemblyRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualAssemblyRelationship ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialIdentification and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialIdentification ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::Occurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)]) or (self::OccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceRelationship  ReplacedUsageRelationship  SameTimeMachiningRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship  AlternatePartVersionRelationship ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::Person and //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::ProcessOperationDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinition ',@typeRef)]) or (self::ProcessOperationOccurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationOccurrence ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlan and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlan ',@typeRef)]) or (self::ProductClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::Project and //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::ProjectRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectRelationship ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (self::Representation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel  PlyAngleRepresentation  ReinforcementOrientationBasis ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersionRelationship ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategory and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategory ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusion ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::StyledModel and //ExternalRefBaseObject[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::ViewOccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternatePartRelationship and //PartRelationship[@uid = $uidRef and contains(' AlternatePartRelationship ',substring-after(@xsi:type,':'))]) or (self::AlternativeSolution and //AlternativeSolution[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::AssemblyOccurrenceRelationshipSubstitution and //AssemblyOccurrenceRelationshipSubstitution[@uid = $uidRef]) or (self::AssemblyViewRelationshipSubstitution and //AssemblyViewRelationshipSubstitution[@uid = $uidRef]) or (self::AssignmentObjectRelationship and //AssignmentObjectRelationship[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementRealization and //BreakdownElementRealization[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementVersionRelationship and //BreakdownElementVersionRelationship[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::BreakdownVersionRelationship and //BreakdownVersionRelationship[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Class and //Class[@uid = $uidRef]) or (self::Condition and //*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConfiguredAssemblyEffectivity and //ConfiguredAssemblyEffectivity[@uid = $uidRef]) or (self::Contract and //Contract[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DeltaChangeRelationship and //DeltaChangeRelationship[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::DocumentVersionRelationship and //DocumentVersionRelationship[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::Event and //Event[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef]) or (self::File and //File[@uid = $uidRef]) or (self::IndividualAssemblyRelationship and //IndividualAssemblyRelationship[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartVersionRelationship and //IndividualPartVersionRelationship[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialIdentification and //MaterialIdentification[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::Occurrence and //Occurrence[@uid = $uidRef]) or (self::OccurrenceRelationship and //OccurrenceRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartVersionRelationship and //PartVersionRelationship[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::Person and //Person[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef]) or (self::ProcessOperationDefinition and //ProcessOperationDefinition[@uid = $uidRef]) or (self::ProcessOperationOccurrence and //ProcessOperationOccurrence[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlan and //ProcessPlan[@uid = $uidRef]) or (self::ProductClass and //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::Project and //Project[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::ProjectRelationship and //ProjectRelationship[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Representation and //Representation[@uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementVersionRelationship and //RequirementVersionRelationship[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategory and //SpecificationCategory[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusion and //SpecificationInclusion[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::StyledModel and //Representation[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',substring-after(@xsi:type,':'))]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::ViewOccurrenceRelationship and //ViewOccurrenceRelationship[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef])">(FrozenAssignment : <sch:value-of select="$uid"/>) The FrozenAssignment.FrozenObject contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of DeltaChangeManagementObjectSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ApprovalAssignment.AssignedApproval : Approval (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FrozenAssignment') or (self::ApprovalAssignment and substring-after(@xsi:type,':')='FrozenAssignment'))]/AssignedApproval">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Approval'] or //Approval[@uid = $uidRef]">(FrozenAssignment : <sch:value-of select="$uid"/>) The FrozenAssignment.AssignedApproval contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Approval.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ApprovalAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FrozenAssignment') or (self::ApprovalAssignment and substring-after(@xsi:type,':')='FrozenAssignment'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(FrozenAssignment : <sch:value-of select="$uid"/>) The FrozenAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ApprovalAssignment.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FrozenAssignment') or (self::ApprovalAssignment and substring-after(@xsi:type,':')='FrozenAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(FrozenAssignment : <sch:value-of select="$uid"/>) The FrozenAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="FunctionalBreakdown"><!--(Default Value) FunctionalBreakdown.BreakdownType : String = 'functional' (kind=SINGLE - redefined=Breakdown.BreakdownType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FunctionalBreakdown') or (self::Breakdown and substring-after(@xsi:type,':')='FunctionalBreakdown'))]/BreakdownType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'functional'">(FunctionalBreakdown : <sch:value-of select="$uid"/>) The FunctionalBreakdown.BreakdownType contains the wrong value () must be 'functional'.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Breakdown.BreakdownType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FunctionalBreakdown') or (self::Breakdown and substring-after(@xsi:type,':')='FunctionalBreakdown'))]/BreakdownType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(FunctionalBreakdown : <sch:value-of select="$uid"/>) The FunctionalBreakdown.BreakdownType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Breakdown.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FunctionalBreakdown') or (self::Breakdown and substring-after(@xsi:type,':')='FunctionalBreakdown'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(FunctionalBreakdown : <sch:value-of select="$uid"/>) The FunctionalBreakdown.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="FunctionalBreakdownElementViewAssociation"><!--(Ref to E) FunctionalBreakdownElementViewAssociation.AssociatedFunctionalElement : BreakdownElementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FunctionalBreakdownElementViewAssociation') or (self::FunctionalBreakdownElementViewAssociation and not(@xsi:type)))]/AssociatedFunctionalElement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElementView'] or //BreakdownElementView[@uid = $uidRef]">(FunctionalBreakdownElementViewAssociation : <sch:value-of select="$uid"/>) The FunctionalBreakdownElementViewAssociation.AssociatedFunctionalElement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElementView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) FunctionalBreakdownElementViewAssociation.AssociatedPhysicalElement : PhysicalElementSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FunctionalBreakdownElementViewAssociation') or (self::FunctionalBreakdownElementViewAssociation and not(@xsi:type)))]/AssociatedPhysicalElement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //AlternativeSolution[@uid = $uidRef] or //BreakdownElement[@uid = $uidRef] or //PartView[@uid = $uidRef]">(FunctionalBreakdownElementViewAssociation : <sch:value-of select="$uid"/>) The FunctionalBreakdownElementViewAssociation.AssociatedPhysicalElement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PhysicalElementSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) FunctionalBreakdownElementViewAssociation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FunctionalBreakdownElementViewAssociation') or (self::FunctionalBreakdownElementViewAssociation and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(FunctionalBreakdownElementViewAssociation : <sch:value-of select="$uid"/>) The FunctionalBreakdownElementViewAssociation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) FunctionalBreakdownElementViewAssociation.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='FunctionalBreakdownElementViewAssociation') or (self::FunctionalBreakdownElementViewAssociation and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(FunctionalBreakdownElementViewAssociation : <sch:value-of select="$uid"/>) The FunctionalBreakdownElementViewAssociation.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeneralDatumReference_WR1"><!--(Rule GeneralDatumReference.WR1)--><sch:rule context="//*[local-name()='DatumReferenceCompartment' or local-name()='DatumReferenceElement']"> <sch:let name="uid" value="@uid"/> <sch:assert test=" (not(./Base) and (count (./CommonDatumList/DatumReferenceElement) ge 2)) or ( ./Base and not(./CommonDatumList))"> (GeneralDatumReference <sch:value-of select="$uid"/>) Either Base is specified or CommonDatumList specified at least 2 elements </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="GeneralGeometricRepresentationRelationship"><!--(Ref to S) GeneralGeometricRepresentationRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeneralGeometricRepresentationRelationship') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='GeneralGeometricRepresentationRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(GeneralGeometricRepresentationRelationship : <sch:value-of select="$uid"/>) The GeneralGeometricRepresentationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricRepresentationRelationship.Related : GeometricRepresentationSelect (kind=SINGLE - redefined=RepresentationRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeneralGeometricRepresentationRelationship') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='GeneralGeometricRepresentationRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeBasedTopologicalRepresentationWithLengthConstraint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',@typeRef)] or //Representation[@uid = $uidRef and contains(' EdgeBasedTopologicalRepresentationWithLengthConstraint ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',substring-after(@xsi:type,':'))]">(GeneralGeometricRepresentationRelationship : <sch:value-of select="$uid"/>) The GeneralGeometricRepresentationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricRepresentationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RepresentationRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeneralGeometricRepresentationRelationship') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='GeneralGeometricRepresentationRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(GeneralGeometricRepresentationRelationship : <sch:value-of select="$uid"/>) The GeneralGeometricRepresentationRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeneralShapeDependentProperty"><!--(Ref to S) GeneralShapeDependentProperty.PropertyType : PropertyDefinitionSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeneralShapeDependentProperty') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='GeneralShapeDependentProperty'))]/PropertyType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionEnum) or (self::PropertyDefinitionString)">(GeneralShapeDependentProperty : <sch:value-of select="$uid"/>) The GeneralShapeDependentProperty.PropertyType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PropertyDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeneralShapeDependentProperty.Unit : OPTIONAL Unit (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeneralShapeDependentProperty') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='GeneralShapeDependentProperty'))]/Unit">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Unit) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Unit'] or //Unit[@uid = $uidRef]">(GeneralShapeDependentProperty : <sch:value-of select="$uid"/>) The GeneralShapeDependentProperty.Unit contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Unit.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeDependentProperty.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeneralShapeDependentProperty') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='GeneralShapeDependentProperty'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(GeneralShapeDependentProperty : <sch:value-of select="$uid"/>) The GeneralShapeDependentProperty.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeDependentProperty.DefinedIn : OPTIONAL GeometricCoordinateSpace (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeneralShapeDependentProperty') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='GeneralShapeDependentProperty'))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefinedIn) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricCoordinateSpace'] or //RepresentationContext[@uid = $uidRef and contains(' GeometricCoordinateSpace ',substring-after(@xsi:type,':'))]">(GeneralShapeDependentProperty : <sch:value-of select="$uid"/>) The GeneralShapeDependentProperty.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricCoordinateSpace.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeDependentProperty.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeneralShapeDependentProperty') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='GeneralShapeDependentProperty'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(GeneralShapeDependentProperty : <sch:value-of select="$uid"/>) The GeneralShapeDependentProperty.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeDependentProperty.ValueDetermination : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeneralShapeDependentProperty') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='GeneralShapeDependentProperty'))]/ValueDetermination/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(GeneralShapeDependentProperty : <sch:value-of select="$uid"/>) The GeneralShapeDependentProperty.ValueDetermination contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricAlignment"><!--(Ref to E) GeometricAlignment.DerivedFrom : SET[2:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=DerivedShapeElement.DerivedFrom)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricAlignment') or (self::ShapeElement and substring-after(@xsi:type,':')='GeometricAlignment'))]/DerivedFrom/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(GeometricAlignment : <sch:value-of select="$uid"/>) The GeometricAlignment.DerivedFrom contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricAlignment') or (self::ShapeElement and substring-after(@xsi:type,':')='GeometricAlignment'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(GeometricAlignment : <sch:value-of select="$uid"/>) The GeometricAlignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricAlignment') or (self::ShapeElement and substring-after(@xsi:type,':')='GeometricAlignment'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(GeometricAlignment : <sch:value-of select="$uid"/>) The GeometricAlignment.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricContact"><!--(Ref to E) GeometricContact.DerivedFrom : SET[2:2] OF ShapeElement (kind=AGGREGATE - redefined=DerivedShapeElement.DerivedFrom)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricContact') or (self::ShapeElement and substring-after(@xsi:type,':')='GeometricContact'))]/DerivedFrom/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(GeometricContact : <sch:value-of select="$uid"/>) The GeometricContact.DerivedFrom contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricContact') or (self::ShapeElement and substring-after(@xsi:type,':')='GeometricContact'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(GeometricContact : <sch:value-of select="$uid"/>) The GeometricContact.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricContact') or (self::ShapeElement and substring-after(@xsi:type,':')='GeometricContact'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(GeometricContact : <sch:value-of select="$uid"/>) The GeometricContact.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricCoordinateSpace"><!--(Ref to E) RepresentationContext.Accuracies : OPTIONAL SET[1:unbounded] OF MeasureQualification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricCoordinateSpace') or (self::RepresentationContext and substring-after(@xsi:type,':')='GeometricCoordinateSpace'))]/Accuracies/MeasureQualification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Accuracies/MeasureQualification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'MeasureQualification'] or //MeasureQualification[@uid = $uidRef]">(GeometricCoordinateSpace : <sch:value-of select="$uid"/>) The GeometricCoordinateSpace.Accuracies contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type MeasureQualification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RepresentationContext.Units : OPTIONAL SET[1:unbounded] OF Unit (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricCoordinateSpace') or (self::RepresentationContext and substring-after(@xsi:type,':')='GeometricCoordinateSpace'))]/Units/Unit">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Units/Unit) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Unit'] or //Unit[@uid = $uidRef]">(GeometricCoordinateSpace : <sch:value-of select="$uid"/>) The GeometricCoordinateSpace.Units contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Unit.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricCurveSet"><!--(Ref to S) GeometricCurveSet.Elements : SET[1:unbounded] OF CurveOrPointSelect (kind=AGGREGATE - redefined=GeometricSet.Elements)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricCurveSet') or (self::RepresentationItem and substring-after(@xsi:type,':')='GeometricCurveSet'))]/Elements/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Curve and //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)]) or (self::Point and //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)]) or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))]">(GeometricCurveSet : <sch:value-of select="$uid"/>) The GeometricCurveSet.Elements contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of CurveOrPointSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricDimension_WR1"><!--(Rule GeometricDimension.WR1)--><sch:rule context="//GeometricDimension/UnitLength"> <sch:let name="uid" value="../@uid"/> <sch:let name="unitRef" value="./Unit/@uidRef"/> <sch:assert test="//Unit[@uid=$unitRef]/Quantity/ClassString ='length'">(GeometricDimension <sch:value-of select="$uid"/>) The unit of UnitLength shall be a length measure unit.</sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="GeometricIntersection"><!--(Ref to E) GeometricIntersection.DerivedFrom : SET[2:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=DerivedShapeElement.DerivedFrom)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricIntersection') or (self::ShapeElement and substring-after(@xsi:type,':')='GeometricIntersection'))]/DerivedFrom/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(GeometricIntersection : <sch:value-of select="$uid"/>) The GeometricIntersection.DerivedFrom contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricIntersection') or (self::ShapeElement and substring-after(@xsi:type,':')='GeometricIntersection'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(GeometricIntersection : <sch:value-of select="$uid"/>) The GeometricIntersection.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricIntersection') or (self::ShapeElement and substring-after(@xsi:type,':')='GeometricIntersection'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(GeometricIntersection : <sch:value-of select="$uid"/>) The GeometricIntersection.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricModel"><!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional--><!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricModel') or (self::Representation and substring-after(@xsi:type,':')='GeometricModel'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(GeometricModel : <sch:value-of select="$uid"/>) The GeometricModel.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Representation.Items : SET[1:unbounded] OF RepresentationItem (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricModel') or (self::Representation and substring-after(@xsi:type,':')='GeometricModel'))]/Items/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(GeometricModel : <sch:value-of select="$uid"/>) The GeometricModel.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricModel') or (self::Representation and substring-after(@xsi:type,':')='GeometricModel'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(GeometricModel : <sch:value-of select="$uid"/>) The GeometricModel.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="GeometricPlaceholderSet"><!--(Ref to S) GeometricPlaceholderSet.Elements : SET[1:unbounded] OF GeometricPlaceholderSetSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricPlaceholderSet') or (self::RepresentationItem and substring-after(@xsi:type,':')='GeometricPlaceholderSet'))]/Elements/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::AxisPlacement and //ExternalRefBaseObject[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',@typeRef)]) or (self::CartesianPoint and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface ',@typeRef)]) or (self::PlanarBox and //ExternalRefBaseObject[@uid = $uidRef and contains(' PlanarBox ',@typeRef)]) or (self::PointOnCurve and //ExternalRefBaseObject[@uid = $uidRef and contains(' PointOnCurve ',@typeRef)]) or (self::PointOnSurface and //ExternalRefBaseObject[@uid = $uidRef and contains(' PointOnSurface ',@typeRef)]) or (self::AxisPlacement and //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]) or (self::CartesianPoint and //RepresentationItem[@uid = $uidRef and contains(' CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface ',substring-after(@xsi:type,':'))]) or (self::PlanarBox and //RepresentationItem[@uid = $uidRef and contains(' PlanarBox ',substring-after(@xsi:type,':'))]) or (self::PointOnCurve and //RepresentationItem[@uid = $uidRef and contains(' PointOnCurve ',substring-after(@xsi:type,':'))]) or (self::PointOnSurface and //RepresentationItem[@uid = $uidRef and contains(' PointOnSurface ',substring-after(@xsi:type,':'))])">(GeometricPlaceholderSet : <sch:value-of select="$uid"/>) The GeometricPlaceholderSet.Elements contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricPlaceholderSetSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricRepresentationRelationshipWithCartesianTransformation"><!--(Ref to S) GeometricRepresentationRelationship.Related : GeometricRepresentationSelect (kind=SINGLE - redefined=RepresentationRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithCartesianTransformation') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithCartesianTransformation'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeBasedTopologicalRepresentationWithLengthConstraint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',@typeRef)] or //Representation[@uid = $uidRef and contains(' EdgeBasedTopologicalRepresentationWithLengthConstraint ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',substring-after(@xsi:type,':'))]">(GeometricRepresentationRelationshipWithCartesianTransformation : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithCartesianTransformation.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricRepresentationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RepresentationRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithCartesianTransformation') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithCartesianTransformation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(GeometricRepresentationRelationshipWithCartesianTransformation : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithCartesianTransformation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricRepresentationRelationshipWithPlacementTransformation"><!--(Ref to E) GeometricRepresentationRelationshipWithPlacementTransformation.Origin : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithPlacementTransformation') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithPlacementTransformation'))]/Origin">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(GeometricRepresentationRelationshipWithPlacementTransformation : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithPlacementTransformation.Origin contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricRepresentationRelationshipWithPlacementTransformation.Target : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithPlacementTransformation') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithPlacementTransformation'))]/Target">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(GeometricRepresentationRelationshipWithPlacementTransformation : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithPlacementTransformation.Target contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricRepresentationRelationship.Related : GeometricRepresentationSelect (kind=SINGLE - redefined=RepresentationRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithPlacementTransformation') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithPlacementTransformation'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeBasedTopologicalRepresentationWithLengthConstraint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',@typeRef)] or //Representation[@uid = $uidRef and contains(' EdgeBasedTopologicalRepresentationWithLengthConstraint ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',substring-after(@xsi:type,':'))]">(GeometricRepresentationRelationshipWithPlacementTransformation : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithPlacementTransformation.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricRepresentationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RepresentationRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithPlacementTransformation') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithPlacementTransformation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(GeometricRepresentationRelationshipWithPlacementTransformation : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithPlacementTransformation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricRepresentationRelationshipWithSameCoordinateSpace"><!--(Default Value) GeometricRepresentationRelationshipWithSameCoordinateSpace.Definitional : Boolean = 'true' (kind=SINGLE - redefined=RepresentationRelationship.Definitional)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithSameCoordinateSpace') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithSameCoordinateSpace'))]/Definitional">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="text() = 'true'">(GeometricRepresentationRelationshipWithSameCoordinateSpace : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithSameCoordinateSpace.Definitional contains the wrong value () must be 'true'.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricRepresentationRelationship.Related : GeometricRepresentationSelect (kind=SINGLE - redefined=RepresentationRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithSameCoordinateSpace') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithSameCoordinateSpace'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeBasedTopologicalRepresentationWithLengthConstraint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',@typeRef)] or //Representation[@uid = $uidRef and contains(' EdgeBasedTopologicalRepresentationWithLengthConstraint ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',substring-after(@xsi:type,':'))]">(GeometricRepresentationRelationshipWithSameCoordinateSpace : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithSameCoordinateSpace.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricRepresentationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RepresentationRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithSameCoordinateSpace') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='GeometricRepresentationRelationshipWithSameCoordinateSpace'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(GeometricRepresentationRelationshipWithSameCoordinateSpace : <sch:value-of select="$uid"/>) The GeometricRepresentationRelationshipWithSameCoordinateSpace.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricSet"><!--(Ref to S) GeometricSet.Elements : SET[1:unbounded] OF GeometricSetSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricSet') or (self::RepresentationItem and substring-after(@xsi:type,':')='GeometricSet'))]/Elements/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Curve and //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)]) or (self::Point and //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)]) or (self::Surface and //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)]) or (self::Curve and //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))]) or (self::Point and //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))]) or (self::Surface and //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))])">(GeometricSet : <sch:value-of select="$uid"/>) The GeometricSet.Elements contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricSetSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricSheetRepresentation"><!--(Ref to E) GeometricSheetRepresentation.BasisSurface : Surface (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='GeometricSheetRepresentation'))]/BasisSurface">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Surface'] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(GeometricSheetRepresentation : <sch:value-of select="$uid"/>) The GeometricSheetRepresentation.BasisSurface contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Surface.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricSheetRepresentation.Cutouts : OPTIONAL SET[1:unbounded] OF BoundaryCurveSet (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='GeometricSheetRepresentation'))]/Cutouts/BoundaryCurveSet">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Cutouts/BoundaryCurveSet) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BoundaryCurveSet'] or //RepresentationItem[@uid = $uidRef and contains(' BoundaryCurveSet ',substring-after(@xsi:type,':'))]">(GeometricSheetRepresentation : <sch:value-of select="$uid"/>) The GeometricSheetRepresentation.Cutouts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BoundaryCurveSet.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricSheetRepresentation.OuterEdge : BoundaryCurveSet (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='GeometricSheetRepresentation'))]/OuterEdge">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BoundaryCurveSet'] or //RepresentationItem[@uid = $uidRef and contains(' BoundaryCurveSet ',substring-after(@xsi:type,':'))]">(GeometricSheetRepresentation : <sch:value-of select="$uid"/>) The GeometricSheetRepresentation.OuterEdge contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BoundaryCurveSet.</sch:assert>
      </sch:rule>
      <!--(Ref to E) CompositeSheetRepresentation.ThreeDGeometry : ExternalGeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='GeometricSheetRepresentation'))]/ThreeDGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExternalGeometricModel'] or //Representation[@uid = $uidRef and contains(' ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation ',substring-after(@xsi:type,':'))]">(GeometricSheetRepresentation : <sch:value-of select="$uid"/>) The GeometricSheetRepresentation.ThreeDGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExternalGeometricModel.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='GeometricSheetRepresentation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(GeometricSheetRepresentation : <sch:value-of select="$uid"/>) The GeometricSheetRepresentation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Representation.Items : SET[1:unbounded] OF RepresentationItem (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='GeometricSheetRepresentation'))]/Items/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(GeometricSheetRepresentation : <sch:value-of select="$uid"/>) The GeometricSheetRepresentation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricSheetRepresentation') or (self::Representation and substring-after(@xsi:type,':')='GeometricSheetRepresentation'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(GeometricSheetRepresentation : <sch:value-of select="$uid"/>) The GeometricSheetRepresentation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="GeometricTolerance_WR2"><!--(Rule GeometricTolerance.WR2)-->
      <sch:rule context="//GeometricTolerance"> <sch:let name="uid" value="@uid"/> <sch:let name="areaUnitTypeRCS" value="./AreaUnitType='rectangular' or ./AreaUnitType='cylindrical' or ./AreaUnitType='spherical'"/> <sch:assert test="(not(./SecondUnitSize) and not ($areaUnitTypeRCS)) or (./SecondUnitSize and $areaUnitTypeRCS)">(GeometricTolerance <sch:value-of select="$uid"/>) A value for SecondUnitSize shall be provided if and only if the AreaUnitType is rectangular, cylindrical, or spherical. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricTolerance_WR7"><!--(Rule GeometricTolerance.WR7)--><sch:rule context="//GeometricTolerance/UnequallyDisposedToleranceZoneDisplacement"> <sch:let name="uid" value="../@uid"/> <sch:let name="unitRef" value="./Unit/@uidRef"/> <sch:assert test="//Unit[@uid=$unitRef]/Quantity/ClassString ='length'">(GeometricTolerance <sch:value-of select="$uid"/>) The unit of UnequallyDisposedToleranceZoneDisplacement shall be a length measure. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="GeometricTolerance_WR6"><!--(Rule GeometricTolerance.WR6)--><sch:rule context="//GeometricTolerance[AreaUnitType='spherical']"> <sch:let name="uid" value="@uid"/> <sch:assert test="//ShapeElement[substring-after(@xsi:type,':')='OrientedToleranceZone' and ZoneFor/*/@uidRef=$uid]">(GeometricTolerance <sch:value-of select="$uid"/>) If the AreaUnitType is spherical, an OrientedToleranceZone shall be provided. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="GeometricTolerance_WR5"><!--(Rule GeometricTolerance.WR5)--><sch:rule context="//GeometricTolerance[AreaUnitType='spherical']"> <sch:let name="uid" value="@uid"/> <sch:let name="firstUnitSizeRef" value="./FirstUnitSize/Unit/@uidRef"/> <sch:let name="isFirstUnitSizePlaneAngle" value="//Unit[@uid=$firstUnitSizeRef]/Quantity/ClassString ='plane angle'"/> <sch:let name="secondUnitSizeRef" value="./SecondUnitSize/Unit/@uidRef"/> <sch:let name="isSecondUnitSizePlaneAngle" value="//Unit[@uid=$secondUnitSizeRef]/Quantity/ClassString ='plane angle'"/> <sch:assert test="$isFirstUnitSizePlaneAngle and $isSecondUnitSizePlaneAngle">(GeometricTolerance <sch:value-of select="$uid"/>) If the AreaUnitType is spherical, the FirstUnitSize shall be a value of plane angle measure and the SecondUnitSize shall be a value of plane angle measure. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="GeometricTolerance_WR4"><!--(Rule GeometricTolerance.WR4)--><sch:rule context="//GeometricTolerance[AreaUnitType='rectangular']"> <sch:let name="uid" value="@uid"/> <sch:let name="firstUnitSizeRef" value="./FirstUnitSize/Unit/@uidRef"/> <sch:let name="isFirstUnitSizeLength" value="//Unit[@uid=$firstUnitSizeRef]/Quantity/ClassString ='length'"/> <sch:let name="secondUnitSizeRef" value="./SecondUnitSize/Unit/@uidRef"/> <sch:let name="isSecondUnitSizeLength" value="//Unit[@uid=$secondUnitSizeRef]/Quantity/ClassString ='length'"/> <sch:assert test="$isFirstUnitSizeLength and $isSecondUnitSizeLength">(GeometricTolerance <sch:value-of select="$uid"/>) If the AreaUnitType is rectangular, the FirstUnitSize shall be a length measure and the SecondUnitSize shall be a length measure. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="GeometricTolerance_WR3"><!--(Rule GeometricTolerance.WR3)--><sch:rule context="//GeometricTolerance[AreaUnitType='cylindrical']"> <sch:let name="uid" value="@uid"/> <sch:let name="firstUnitSizeRef" value="./FirstUnitSize/Unit/@uidRef"/> <sch:let name="isFirstUnitSizeLength" value="//Unit[@uid=$firstUnitSizeRef]/Quantity/ClassString ='length'"/> <sch:let name="secondUnitSizeRef" value="./SecondUnitSize/Unit/@uidRef"/> <sch:let name="isSecondUnitSizePlaneAngle" value="//Unit[@uid=$secondUnitSizeRef]/Quantity/ClassString ='plane angle'"/> <sch:assert test="$isFirstUnitSizeLength and $isSecondUnitSizePlaneAngle">(GeometricTolerance <sch:value-of select="$uid"/>) If the AreaUnitType is cylindrical, the FirstUnitSize shall be a length measure and the SecondUnitSize shall be a value of plane angle measure. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="GeometricTolerance_WR1"><!--(Rule GeometricTolerance.WR1)--><sch:rule context="//GeometricTolerance/FirstUnitSize"> <sch:let name="uid" value="../@uid"/> <sch:let name="unitRef" value="Unit/@uidRef"/> <sch:assert test="//Unit[@uid=$unitRef]/Quantity[(ClassString ='length' or ClassString ='plane angle')]">(GeometricTolerance <sch:value-of select="$uid"/>) If specified, the FirstUnitSize shall be a value of a length measure or a value of plane angle measure. Unit <sch:value-of select="$unitRef"/> = <sch:value-of select="//Unit[@uid=$unitRef]/Quantity/ClassString"/> </sch:assert> </sch:rule> </sch:pattern>
   <sch:pattern id="GeometricToleranceRelationship"><!--(Ref to E) GeometricToleranceRelationship.Related : GeometricTolerance (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricToleranceRelationship') or (self::GeometricToleranceRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricTolerance'] or //GeometricTolerance[@uid = $uidRef]">(GeometricToleranceRelationship : <sch:value-of select="$uid"/>) The GeometricToleranceRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricTolerance.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricToleranceRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricToleranceRelationship') or (self::GeometricToleranceRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(GeometricToleranceRelationship : <sch:value-of select="$uid"/>) The GeometricToleranceRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometricalRelationship"><!--(Ref to S) GeometricalRelationship.Placement : TransformationSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricalRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='GeometricalRelationship'))]/Placement/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::CartesianTransformation or (self::Transformation and contains(' CartesianTransformation ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)]) or (self::GeometricRepresentationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',@typeRef)]) or (self::CartesianTransformation) or (self::GeometricRepresentationRelationship and //RepresentationRelationship[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',substring-after(@xsi:type,':'))])">(GeometricalRelationship : <sch:value-of select="$uid"/>) The GeometricalRelationship.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of TransformationSelect.</sch:assert>
      </sch:rule>
      <!--(Default Value) GeometricalRelationship.RelationType : String = 'geometrically related part view' (kind=SINGLE - redefined=PartViewRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricalRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='GeometricalRelationship'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'geometrically related part view'">(GeometricalRelationship : <sch:value-of select="$uid"/>) The GeometricalRelationship.RelationType contains the wrong value () must be 'geometrically related part view'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricalRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='GeometricalRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(GeometricalRelationship : <sch:value-of select="$uid"/>) The GeometricalRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.Related : PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricalRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='GeometricalRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(GeometricalRelationship : <sch:value-of select="$uid"/>) The GeometricalRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometricalRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='GeometricalRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(GeometricalRelationship : <sch:value-of select="$uid"/>) The GeometricalRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="GeometryToTopologyModelAssociation"><!--(Ref to S) GeometryToTopologyModelAssociation.Origin : LIST[1:unbounded] OF GeometryAssociationItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometryToTopologyModelAssociation') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='GeometryToTopologyModelAssociation'))]/Origin/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::AxisPlacement and //ExternalRefBaseObject[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',@typeRef)]) or (self::CartesianPoint and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface ',@typeRef)]) or (self::Curve and //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)]) or (self::EdgeCurve and //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)]) or (self::ExternalRepresentationItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalRepresentationItem  ExternalTessellatedAnnotation ',@typeRef)]) or (self::VertexPoint and //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)]) or (self::AxisPlacement and //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]) or (self::CartesianPoint and //RepresentationItem[@uid = $uidRef and contains(' CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface ',substring-after(@xsi:type,':'))]) or (self::Curve and //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))]) or (self::EdgeCurve and //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))]) or (self::ExternalRepresentationItem and //RepresentationItem[@uid = $uidRef and contains(' ExternalRepresentationItem  ExternalTessellatedAnnotation ',substring-after(@xsi:type,':'))]) or (self::VertexPoint and //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))])">(GeometryToTopologyModelAssociation : <sch:value-of select="$uid"/>) The GeometryToTopologyModelAssociation.Origin contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometryAssociationItemSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometryToTopologyModelAssociation.Target : LIST[1:unbounded] OF TopologyAssociationItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometryToTopologyModelAssociation') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='GeometryToTopologyModelAssociation'))]/Target/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Edge and //ExternalRefBaseObject[@uid = $uidRef and contains(' Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge ',@typeRef)]) or (self::Path and //ExternalRefBaseObject[@uid = $uidRef and contains(' Path ',@typeRef)]) or (self::Vertex and //ExternalRefBaseObject[@uid = $uidRef and contains(' Vertex  VertexPoint ',@typeRef)]) or (self::Edge and //RepresentationItem[@uid = $uidRef and contains(' Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge ',substring-after(@xsi:type,':'))]) or (self::Path and //RepresentationItem[@uid = $uidRef and contains(' Path ',substring-after(@xsi:type,':'))]) or (self::Vertex and //RepresentationItem[@uid = $uidRef and contains(' Vertex  VertexPoint ',substring-after(@xsi:type,':'))])">(GeometryToTopologyModelAssociation : <sch:value-of select="$uid"/>) The GeometryToTopologyModelAssociation.Target contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of TopologyAssociationItemSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RepresentationRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometryToTopologyModelAssociation') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='GeometryToTopologyModelAssociation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(GeometryToTopologyModelAssociation : <sch:value-of select="$uid"/>) The GeometryToTopologyModelAssociation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RepresentationRelationship.Related : Representation (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='GeometryToTopologyModelAssociation') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='GeometryToTopologyModelAssociation'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Representation'] or //Representation[@uid = $uidRef]">(GeometryToTopologyModelAssociation : <sch:value-of select="$uid"/>) The GeometryToTopologyModelAssociation.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Representation.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Hardcopy"><!--(Ref to E) File.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Hardcopy') or (self::File and substring-after(@xsi:type,':')='Hardcopy'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Hardcopy : <sch:value-of select="$uid"/>) The Hardcopy.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) File.FileCreation : OPTIONAL CreationProperty (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Hardcopy') or (self::File and substring-after(@xsi:type,':')='Hardcopy'))]/FileCreation">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./FileCreation) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'CreationProperty'] or //CreationProperty[@uid = $uidRef]">(Hardcopy : <sch:value-of select="$uid"/>) The Hardcopy.FileCreation contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type CreationProperty.</sch:assert>
      </sch:rule>
      <!--(Ref to E) File.FileFormat : OPTIONAL FormatProperty (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Hardcopy') or (self::File and substring-after(@xsi:type,':')='Hardcopy'))]/FileFormat">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./FileFormat) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'FormatProperty'] or //FormatProperty[@uid = $uidRef]">(Hardcopy : <sch:value-of select="$uid"/>) The Hardcopy.FileFormat contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type FormatProperty.</sch:assert>
      </sch:rule>
      <!--(Ref to S) File.FileType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Hardcopy') or (self::File and substring-after(@xsi:type,':')='Hardcopy'))]/FileType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Hardcopy : <sch:value-of select="$uid"/>) The Hardcopy.FileType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="HarnessNode"><!--(Ref to E) HarnessNode.AttachedFeature : OPTIONAL OccurrenceShapeFeature (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HarnessNode') or (self::ShapeElement and substring-after(@xsi:type,':')='HarnessNode'))]/AttachedFeature">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./AttachedFeature) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'OccurrenceShapeFeature'] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))]">(HarnessNode : <sch:value-of select="$uid"/>) The HarnessNode.AttachedFeature contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type OccurrenceShapeFeature.</sch:assert>
      </sch:rule>
      <!--(Ref to E) HarnessNode.RepresentedGeometry : Vertex (kind=SINGLE - redefined=ShapeElement.RepresentedGeometry)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HarnessNode') or (self::ShapeElement and substring-after(@xsi:type,':')='HarnessNode'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Vertex'] or //RepresentationItem[@uid = $uidRef and contains(' Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(HarnessNode : <sch:value-of select="$uid"/>) The HarnessNode.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Vertex.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartShapeElement.PartDefinition : OPTIONAL PartShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HarnessNode') or (self::ShapeElement and substring-after(@xsi:type,':')='HarnessNode'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(HarnessNode : <sch:value-of select="$uid"/>) The HarnessNode.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HarnessNode') or (self::ShapeElement and substring-after(@xsi:type,':')='HarnessNode'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(HarnessNode : <sch:value-of select="$uid"/>) The HarnessNode.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="HarnessSegment"><!--(Ref to S) HarnessSegment.CrossSection : OPTIONAL CrossSectionalConstituentElementSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HarnessSegment') or (self::ShapeElement and substring-after(@xsi:type,':')='HarnessSegment'))]/CrossSection">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CrossSectionalOccurrenceShapeElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' CrossSectionalOccurrenceShapeElement ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement ',substring-after(@xsi:type,':'))]">(HarnessSegment : <sch:value-of select="$uid"/>) The HarnessSegment.CrossSection contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of CrossSectionalConstituentElementSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) HarnessSegment.RepresentedGeometry : Edge (kind=SINGLE - redefined=ShapeElement.RepresentedGeometry)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HarnessSegment') or (self::ShapeElement and substring-after(@xsi:type,':')='HarnessSegment'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Edge'] or //RepresentationItem[@uid = $uidRef and contains(' Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge ',substring-after(@xsi:type,':'))]">(HarnessSegment : <sch:value-of select="$uid"/>) The HarnessSegment.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Edge.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartShapeElement.PartDefinition : OPTIONAL PartShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HarnessSegment') or (self::ShapeElement and substring-after(@xsi:type,':')='HarnessSegment'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(HarnessSegment : <sch:value-of select="$uid"/>) The HarnessSegment.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HarnessSegment') or (self::ShapeElement and substring-after(@xsi:type,':')='HarnessSegment'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(HarnessSegment : <sch:value-of select="$uid"/>) The HarnessSegment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="HierarchicalInterfaceConnection"><!--(Ref to E) InterfaceConnection.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HierarchicalInterfaceConnection') or (self::InterfaceConnection and substring-after(@xsi:type,':')='HierarchicalInterfaceConnection'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(HierarchicalInterfaceConnection : <sch:value-of select="$uid"/>) The HierarchicalInterfaceConnection.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) InterfaceConnection.Connected : ConnectionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HierarchicalInterfaceConnection') or (self::InterfaceConnection and substring-after(@xsi:type,':')='HierarchicalInterfaceConnection'))]/Connected">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)] or //InterfaceConnectorOccurrence[@uid = $uidRef] or //PartView[@uid = $uidRef] or //PartViewRelationship[@uid = $uidRef]">(HierarchicalInterfaceConnection : <sch:value-of select="$uid"/>) The HierarchicalInterfaceConnection.Connected contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ConnectionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) InterfaceConnection.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HierarchicalInterfaceConnection') or (self::InterfaceConnection and substring-after(@xsi:type,':')='HierarchicalInterfaceConnection'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(HierarchicalInterfaceConnection : <sch:value-of select="$uid"/>) The HierarchicalInterfaceConnection.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="HighOrderKinematicPair"><!--(Ref to S) HighOrderKinematicPair.CurveOrSurface1 : ExternalCurveOrSurfaceSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HighOrderKinematicPair') or (self::RepresentationItem and substring-after(@xsi:type,':')='HighOrderKinematicPair'))]/CurveOrSurface1">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(HighOrderKinematicPair : <sch:value-of select="$uid"/>) The HighOrderKinematicPair.CurveOrSurface1 contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ExternalCurveOrSurfaceSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) HighOrderKinematicPair.CurveOrSurface2 : OPTIONAL ExternalCurveOrSurfaceSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HighOrderKinematicPair') or (self::RepresentationItem and substring-after(@xsi:type,':')='HighOrderKinematicPair'))]/CurveOrSurface2">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(HighOrderKinematicPair : <sch:value-of select="$uid"/>) The HighOrderKinematicPair.CurveOrSurface2 contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ExternalCurveOrSurfaceSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) HighOrderKinematicPair.Model1 : ExternalGeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HighOrderKinematicPair') or (self::RepresentationItem and substring-after(@xsi:type,':')='HighOrderKinematicPair'))]/Model1">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExternalGeometricModel'] or //Representation[@uid = $uidRef and contains(' ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation ',substring-after(@xsi:type,':'))]">(HighOrderKinematicPair : <sch:value-of select="$uid"/>) The HighOrderKinematicPair.Model1 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExternalGeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) HighOrderKinematicPair.Model2 : OPTIONAL ExternalGeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HighOrderKinematicPair') or (self::RepresentationItem and substring-after(@xsi:type,':')='HighOrderKinematicPair'))]/Model2">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Model2) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExternalGeometricModel'] or //Representation[@uid = $uidRef and contains(' ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation ',substring-after(@xsi:type,':'))]">(HighOrderKinematicPair : <sch:value-of select="$uid"/>) The HighOrderKinematicPair.Model2 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExternalGeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to S) HighOrderKinematicPair.Range1 : OPTIONAL ExternalTrimmedCurveOrSurfaceSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HighOrderKinematicPair') or (self::RepresentationItem and substring-after(@xsi:type,':')='HighOrderKinematicPair'))]/Range1">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TrimmedCurve ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TrimmedCurve ',substring-after(@xsi:type,':'))]">(HighOrderKinematicPair : <sch:value-of select="$uid"/>) The HighOrderKinematicPair.Range1 contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ExternalTrimmedCurveOrSurfaceSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) HighOrderKinematicPair.Range2 : OPTIONAL ExternalTrimmedCurveOrSurfaceSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HighOrderKinematicPair') or (self::RepresentationItem and substring-after(@xsi:type,':')='HighOrderKinematicPair'))]/Range2">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TrimmedCurve ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TrimmedCurve ',substring-after(@xsi:type,':'))]">(HighOrderKinematicPair : <sch:value-of select="$uid"/>) The HighOrderKinematicPair.Range2 contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ExternalTrimmedCurveOrSurfaceSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) KinematicPair.Link1 : KinematicLink (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HighOrderKinematicPair') or (self::RepresentationItem and substring-after(@xsi:type,':')='HighOrderKinematicPair'))]/Link1">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'KinematicLink'] or //Representation[@uid = $uidRef and contains(' KinematicLink ',substring-after(@xsi:type,':'))]">(HighOrderKinematicPair : <sch:value-of select="$uid"/>) The HighOrderKinematicPair.Link1 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type KinematicLink.</sch:assert>
      </sch:rule>
      <!--(Ref to E) KinematicPair.Link2 : KinematicLink (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HighOrderKinematicPair') or (self::RepresentationItem and substring-after(@xsi:type,':')='HighOrderKinematicPair'))]/Link2">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'KinematicLink'] or //Representation[@uid = $uidRef and contains(' KinematicLink ',substring-after(@xsi:type,':'))]">(HighOrderKinematicPair : <sch:value-of select="$uid"/>) The HighOrderKinematicPair.Link2 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type KinematicLink.</sch:assert>
      </sch:rule>
      <!--(Ref to E) KinematicPair.PairFrame1 : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HighOrderKinematicPair') or (self::RepresentationItem and substring-after(@xsi:type,':')='HighOrderKinematicPair'))]/PairFrame1">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(HighOrderKinematicPair : <sch:value-of select="$uid"/>) The HighOrderKinematicPair.PairFrame1 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) KinematicPair.PairFrame2 : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='HighOrderKinematicPair') or (self::RepresentationItem and substring-after(@xsi:type,':')='HighOrderKinematicPair'))]/PairFrame2">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(HighOrderKinematicPair : <sch:value-of select="$uid"/>) The HighOrderKinematicPair.PairFrame2 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Identifier"><!--(Ref to E) Identifier.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Identifier') or (self::Identifier and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Identifier : <sch:value-of select="$uid"/>) The Identifier.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref specific) Identifier.IdentificationContext : OPTIONAL IdentificationContextSelect-->
      <!--(Ref specific) Identifier.Role : ClassSelect-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Identifier') or self::Identifier)]">
         <sch:let name="uid" value="./@uid"/>
         <sch:let name="idContextRef" value="./@idContextRef"/>
         <sch:let name="idRoleRef" value="./@idRoleRef"/>
         <sch:assert test="count($idContextRef) = 0 or (count($idContextRef) = 1 and (//Identifier[@uid = $idContextRef] or //Organization[@uid = $idContextRef]))">(Identifier : <sch:value-of select="$uid"/>) The Identifier.IdentificationContext contains a bad reference (<sch:value-of select="$idContextRef"/>).</sch:assert>
         <sch:assert test="//Class[@uid = $idRoleRef] or //ExternalOwlClass[@uid = $idRoleRef]">(Identifier : <sch:value-of select="$uid"/>) The Identifier.Role contains a bad reference (<sch:value-of select="$idRoleRef"/>).</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="IdentifierRelationship"><!--(Ref to E) IdentifierRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IdentifierRelationship') or (self::IdentifierRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(IdentifierRelationship : <sch:value-of select="$uid"/>) The IdentifierRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) IdentifierRelationship.Related : Identifier (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IdentifierRelationship') or (self::IdentifierRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Identifier'] or //Identifier[@uid = $uidRef]">(IdentifierRelationship : <sch:value-of select="$uid"/>) The IdentifierRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Identifier.</sch:assert>
      </sch:rule>
      <!--(Ref to S) IdentifierRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IdentifierRelationship') or (self::IdentifierRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(IdentifierRelationship : <sch:value-of select="$uid"/>) The IdentifierRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="IdentifierRelationship_WR1"><!--(Rule IdentifierRelationship.WR1)-->
      <sch:rule context="//IdentifierRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> IdentifierRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Identifier and the relating Identifier shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="InZone"><!--(Ref to E) InZone.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InZone') or (self::InZone and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(InZone : <sch:value-of select="$uid"/>) The InZone.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) InZone.Zone : BreakdownElementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InZone') or (self::InZone and not(@xsi:type)))]/Zone">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElementView'] or //BreakdownElementView[@uid = $uidRef]">(InZone : <sch:value-of select="$uid"/>) The InZone.Zone contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElementView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="IndividualAssemblyRelationship"><!--(Ref to E) IndividualAssemblyRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualAssemblyRelationship') or (self::IndividualAssemblyRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(IndividualAssemblyRelationship : <sch:value-of select="$uid"/>) The IndividualAssemblyRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) IndividualAssemblyRelationship.Related : IndividualOrPartViewSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualAssemblyRelationship') or (self::IndividualAssemblyRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //IndividualPartView[@uid = $uidRef] or //PartView[@uid = $uidRef]">(IndividualAssemblyRelationship : <sch:value-of select="$uid"/>) The IndividualAssemblyRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of IndividualOrPartViewSelect.</sch:assert>
      </sch:rule>
      <!--(Default Value) IndividualAssemblyRelationship.RelationType : OPTIONAL String = 'next assembly view' (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualAssemblyRelationship') or (self::IndividualAssemblyRelationship and not(@xsi:type)))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="count(./RelationType) = 0 or text() = 'next assembly view'">(IndividualAssemblyRelationship : <sch:value-of select="$uid"/>) The IndividualAssemblyRelationship.RelationType contains the wrong value () must be 'next assembly view'.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="IndividualAssemblyRelationship_WR1"><!--(Rule IndividualAssemblyRelationship.WR1)-->
      <sch:rule context="//IndividualAssemblyRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> IndividualAssemblyRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related IndividualAssembly and the relating IndividualAssembly shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="IndividualPart"><!--(Ref to E) IndividualPart.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPart') or (self::IndividualPart and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(IndividualPart : <sch:value-of select="$uid"/>) The IndividualPart.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="IndividualPartEffectivity"><!--(Ref to E) IndividualPartEffectivity.Items : SET[1:unbounded] OF IndividualPart (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='IndividualPartEffectivity'))]/Items/IndividualPart">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'IndividualPart'] or //IndividualPart[@uid = $uidRef]">(IndividualPartEffectivity : <sch:value-of select="$uid"/>) The IndividualPartEffectivity.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type IndividualPart.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='IndividualPartEffectivity'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(IndividualPartEffectivity : <sch:value-of select="$uid"/>) The IndividualPartEffectivity.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='IndividualPartEffectivity'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(IndividualPartEffectivity : <sch:value-of select="$uid"/>) The IndividualPartEffectivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Effectivity.EffectivityContext : OPTIONAL EffectivityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='IndividualPartEffectivity'))]/EffectivityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //Activity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef]">(IndividualPartEffectivity : <sch:value-of select="$uid"/>) The IndividualPartEffectivity.EffectivityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EffectivityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="IndividualPartRelationship"><!--(Ref to E) IndividualPartRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartRelationship') or (self::IndividualPartRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(IndividualPartRelationship : <sch:value-of select="$uid"/>) The IndividualPartRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) IndividualPartRelationship.Related : IndividualPart (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartRelationship') or (self::IndividualPartRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'IndividualPart'] or //IndividualPart[@uid = $uidRef]">(IndividualPartRelationship : <sch:value-of select="$uid"/>) The IndividualPartRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type IndividualPart.</sch:assert>
      </sch:rule>
      <!--(Ref to S) IndividualPartRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartRelationship') or (self::IndividualPartRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(IndividualPartRelationship : <sch:value-of select="$uid"/>) The IndividualPartRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="IndividualPartRelationship_WR1"><!--(Rule IndividualPartRelationship.WR1)-->
      <sch:rule context="//IndividualPartRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> IndividualPartRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related IndividualPart and the relating IndividualPart shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="IndividualPartVersion"><!--(Ref to E) IndividualPartVersion.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartVersion') or (self::IndividualPartVersion and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(IndividualPartVersion : <sch:value-of select="$uid"/>) The IndividualPartVersion.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Inverse of IndividualPart.Versions :: PartProperty) IndividualPartVersion.VersionOf : IndividualPart) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="IndividualPartVersionRelationship"><!--(Ref to E) IndividualPartVersionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartVersionRelationship') or (self::IndividualPartVersionRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(IndividualPartVersionRelationship : <sch:value-of select="$uid"/>) The IndividualPartVersionRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) IndividualPartVersionRelationship.Related : IndividualPartVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartVersionRelationship') or (self::IndividualPartVersionRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'IndividualPartVersion'] or //IndividualPartVersion[@uid = $uidRef]">(IndividualPartVersionRelationship : <sch:value-of select="$uid"/>) The IndividualPartVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type IndividualPartVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) IndividualPartVersionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartVersionRelationship') or (self::IndividualPartVersionRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(IndividualPartVersionRelationship : <sch:value-of select="$uid"/>) The IndividualPartVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="IndividualPartVersionRelationship_WR1"><!--(Rule IndividualPartVersionRelationship.WR1)-->
      <sch:rule context="//IndividualPartVersionRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> IndividualPartVersionRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related IndividualPartVersion and the relating IndividualPartVersion shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="IndividualPartView"><!--(Ref to E) IndividualPartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartView') or (self::IndividualPartView and not(@xsi:type)))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(IndividualPartView : <sch:value-of select="$uid"/>) The IndividualPartView.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) IndividualPartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartView') or (self::IndividualPartView and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(IndividualPartView : <sch:value-of select="$uid"/>) The IndividualPartView.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) IndividualPartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartView') or (self::IndividualPartView and not(@xsi:type)))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(IndividualPartView : <sch:value-of select="$uid"/>) The IndividualPartView.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) IndividualPartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartView') or (self::IndividualPartView and not(@xsi:type)))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(IndividualPartView : <sch:value-of select="$uid"/>) The IndividualPartView.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of IndividualPartVersion.Views :: PartProperty) IndividualPartView.ViewOf : IndividualPartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="IndividualPartViewRelationship"><!--(Ref to E) IndividualPartViewRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartViewRelationship') or (self::IndividualPartViewRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(IndividualPartViewRelationship : <sch:value-of select="$uid"/>) The IndividualPartViewRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) IndividualPartViewRelationship.Related : IndividualPartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartViewRelationship') or (self::IndividualPartViewRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'IndividualPartView'] or //IndividualPartView[@uid = $uidRef]">(IndividualPartViewRelationship : <sch:value-of select="$uid"/>) The IndividualPartViewRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type IndividualPartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) IndividualPartViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='IndividualPartViewRelationship') or (self::IndividualPartViewRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(IndividualPartViewRelationship : <sch:value-of select="$uid"/>) The IndividualPartViewRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="IndividualPartViewRelationship_WR1"><!--(Rule IndividualPartViewRelationship.WR1)-->
      <sch:rule context="//IndividualPartViewRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> IndividualPartViewRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related IndividualPartView and the relating IndividualPartView shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="InformationRight"><!--(Ref to E) InformationRight.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InformationRight') or (self::InformationRight and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(InformationRight : <sch:value-of select="$uid"/>) The InformationRight.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) InformationRight.Owners : SET[1:unbounded] OF OrganizationOrPersonInOrganizationSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InformationRight') or (self::InformationRight and not(@xsi:type)))]/Owners/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef])">(InformationRight : <sch:value-of select="$uid"/>) The InformationRight.Owners contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OrganizationOrPersonInOrganizationSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InformationUsageRight"><!--(Ref to E) InformationUsageRight.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InformationUsageRight') or (self::InformationUsageRight and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(InformationUsageRight : <sch:value-of select="$uid"/>) The InformationUsageRight.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) InformationUsageRight.GrantsRight : SET[1:unbounded] OF InformationRight (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InformationUsageRight') or (self::InformationUsageRight and not(@xsi:type)))]/GrantsRight/InformationRight">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'InformationRight'] or //InformationRight[@uid = $uidRef]">(InformationUsageRight : <sch:value-of select="$uid"/>) The InformationUsageRight.GrantsRight contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type InformationRight.</sch:assert>
      </sch:rule>
      <!--(Ref to S) InformationUsageRight.Owners : SET[1:unbounded] OF OrganizationOrPersonInOrganizationSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InformationUsageRight') or (self::InformationUsageRight and not(@xsi:type)))]/Owners/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef])">(InformationUsageRight : <sch:value-of select="$uid"/>) The InformationUsageRight.Owners contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OrganizationOrPersonInOrganizationSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InformationUsageRightAssignment"><!--(Ref to E) InformationUsageRightAssignment.AssignedRight : InformationUsageRight (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InformationUsageRightAssignment') or (self::InformationUsageRightAssignment and not(@xsi:type)))]/AssignedRight">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'InformationUsageRight'] or //InformationUsageRight[@uid = $uidRef]">(InformationUsageRightAssignment : <sch:value-of select="$uid"/>) The InformationUsageRightAssignment.AssignedRight contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type InformationUsageRight.</sch:assert>
      </sch:rule>
      <!--(Ref to E) InformationUsageRightAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InformationUsageRightAssignment') or (self::InformationUsageRightAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(InformationUsageRightAssignment : <sch:value-of select="$uid"/>) The InformationUsageRightAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) InformationUsageRightAssignment.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InformationUsageRightAssignment') or (self::InformationUsageRightAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(InformationUsageRightAssignment : <sch:value-of select="$uid"/>) The InformationUsageRightAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InformationUsageRightRelationship"><!--(Ref to E) InformationUsageRightRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InformationUsageRightRelationship') or (self::InformationUsageRightRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(InformationUsageRightRelationship : <sch:value-of select="$uid"/>) The InformationUsageRightRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) InformationUsageRightRelationship.Related : InformationUsageRight (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InformationUsageRightRelationship') or (self::InformationUsageRightRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'InformationUsageRight'] or //InformationUsageRight[@uid = $uidRef]">(InformationUsageRightRelationship : <sch:value-of select="$uid"/>) The InformationUsageRightRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type InformationUsageRight.</sch:assert>
      </sch:rule>
      <!--(Ref to S) InformationUsageRightRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InformationUsageRightRelationship') or (self::InformationUsageRightRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(InformationUsageRightRelationship : <sch:value-of select="$uid"/>) The InformationUsageRightRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InformationUsageRightRelationship_WR1"><!--(Rule InformationUsageRightRelationship.WR1)-->
      <sch:rule context="//InformationUsageRightRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> InformationUsageRightRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related InformationUsageRight and the relating InformationUsageRight shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="IntegerRepresentationItem"/>
   <sch:pattern id="InterfaceConnection"><!--(Ref to E) InterfaceConnection.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnection') or (self::InterfaceConnection and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(InterfaceConnection : <sch:value-of select="$uid"/>) The InterfaceConnection.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) InterfaceConnection.Connected : ConnectionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnection') or (self::InterfaceConnection and not(@xsi:type)))]/Connected">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)] or //InterfaceConnectorOccurrence[@uid = $uidRef] or //PartView[@uid = $uidRef] or //PartViewRelationship[@uid = $uidRef]">(InterfaceConnection : <sch:value-of select="$uid"/>) The InterfaceConnection.Connected contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ConnectionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) InterfaceConnection.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnection') or (self::InterfaceConnection and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(InterfaceConnection : <sch:value-of select="$uid"/>) The InterfaceConnection.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceConnector"><!--(Ref to E) InterfaceConnector.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnector') or (self::InterfaceConnector and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(InterfaceConnector : <sch:value-of select="$uid"/>) The InterfaceConnector.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceConnectorDefinition"><!--(Ref to E) InterfaceConnectorDefinition.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorDefinition') or (self::InterfaceConnectorDefinition and not(@xsi:type)))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(InterfaceConnectorDefinition : <sch:value-of select="$uid"/>) The InterfaceConnectorDefinition.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) InterfaceConnectorDefinition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorDefinition') or (self::InterfaceConnectorDefinition and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(InterfaceConnectorDefinition : <sch:value-of select="$uid"/>) The InterfaceConnectorDefinition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) InterfaceConnectorDefinition.ConnectorOn : InterfaceDefinitionConnectionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorDefinition') or (self::InterfaceConnectorDefinition and not(@xsi:type)))]/ConnectorOn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //InterfaceConnectorDefinition[@uid = $uidRef] or //PartView[@uid = $uidRef]">(InterfaceConnectorDefinition : <sch:value-of select="$uid"/>) The InterfaceConnectorDefinition.ConnectorOn contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of InterfaceDefinitionConnectionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) InterfaceConnectorDefinition.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorDefinition') or (self::InterfaceConnectorDefinition and not(@xsi:type)))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(InterfaceConnectorDefinition : <sch:value-of select="$uid"/>) The InterfaceConnectorDefinition.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of InterfaceConnectorVersion.Views :: PartProperty) InterfaceConnectorDefinition.ViewOf : InterfaceConnectorVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="InterfaceConnectorOccurrence"><!--(Ref to E) InterfaceConnectorOccurrence.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorOccurrence') or (self::InterfaceConnectorOccurrence and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(InterfaceConnectorOccurrence : <sch:value-of select="$uid"/>) The InterfaceConnectorOccurrence.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) InterfaceConnectorOccurrence.ConnectorOn : ConnectorOnSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorOccurrence') or (self::InterfaceConnectorOccurrence and not(@xsi:type)))]/ConnectorOn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)] or //PartView[@uid = $uidRef] or //PartViewRelationship[@uid = $uidRef]">(InterfaceConnectorOccurrence : <sch:value-of select="$uid"/>) The InterfaceConnectorOccurrence.ConnectorOn contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ConnectorOnSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceConnectorVersion"><!--(Ref to E) InterfaceConnectorVersion.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceConnectorVersion') or (self::InterfaceConnectorVersion and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(InterfaceConnectorVersion : <sch:value-of select="$uid"/>) The InterfaceConnectorVersion.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Inverse of InterfaceConnector.Versions :: PartProperty) InterfaceConnectorVersion.VersionOf : InterfaceConnector) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="InterfaceDefinitionConnection"><!--(Ref to E) InterfaceDefinitionConnection.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceDefinitionConnection') or (self::InterfaceDefinitionConnection and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(InterfaceDefinitionConnection : <sch:value-of select="$uid"/>) The InterfaceDefinitionConnection.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) InterfaceDefinitionConnection.Connected : InterfaceDefinitionConnectionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceDefinitionConnection') or (self::InterfaceDefinitionConnection and not(@xsi:type)))]/Connected">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //InterfaceConnectorDefinition[@uid = $uidRef] or //PartView[@uid = $uidRef]">(InterfaceDefinitionConnection : <sch:value-of select="$uid"/>) The InterfaceDefinitionConnection.Connected contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of InterfaceDefinitionConnectionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) InterfaceDefinitionConnection.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceDefinitionConnection') or (self::InterfaceDefinitionConnection and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(InterfaceDefinitionConnection : <sch:value-of select="$uid"/>) The InterfaceDefinitionConnection.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceDefinitionFor"><!--(Ref to E) InterfaceDefinitionFor.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceDefinitionFor') or (self::InterfaceDefinitionFor and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(InterfaceDefinitionFor : <sch:value-of select="$uid"/>) The InterfaceDefinitionFor.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) InterfaceDefinitionFor.InterfaceComponent : InterfaceDefinitionForSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceDefinitionFor') or (self::InterfaceDefinitionFor and not(@xsi:type)))]/InterfaceComponent">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnection  HierarchicalInterfaceConnection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceConnectorOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InterfaceDefinitionConnection ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //InterfaceConnection[@uid = $uidRef] or //InterfaceConnectorOccurrence[@uid = $uidRef] or //InterfaceDefinitionConnection[@uid = $uidRef] or //PartView[@uid = $uidRef]">(InterfaceDefinitionFor : <sch:value-of select="$uid"/>) The InterfaceDefinitionFor.InterfaceComponent contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of InterfaceDefinitionForSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceSpecification"><!--(Ref to E) InterfaceSpecification.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceSpecification') or (self::InterfaceSpecification and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(InterfaceSpecification : <sch:value-of select="$uid"/>) The InterfaceSpecification.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterfaceSpecificationDefinition"><!--(Ref to E) InterfaceSpecificationDefinition.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceSpecificationDefinition') or (self::InterfaceSpecificationDefinition and not(@xsi:type)))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(InterfaceSpecificationDefinition : <sch:value-of select="$uid"/>) The InterfaceSpecificationDefinition.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) InterfaceSpecificationDefinition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceSpecificationDefinition') or (self::InterfaceSpecificationDefinition and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(InterfaceSpecificationDefinition : <sch:value-of select="$uid"/>) The InterfaceSpecificationDefinition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) InterfaceSpecificationDefinition.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceSpecificationDefinition') or (self::InterfaceSpecificationDefinition and not(@xsi:type)))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(InterfaceSpecificationDefinition : <sch:value-of select="$uid"/>) The InterfaceSpecificationDefinition.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of InterfaceSpecificationVersion.Views :: PartProperty) InterfaceSpecificationDefinition.ViewOf : InterfaceSpecificationVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="InterfaceSpecificationVersion"><!--(Ref to E) InterfaceSpecificationVersion.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterfaceSpecificationVersion') or (self::InterfaceSpecificationVersion and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(InterfaceSpecificationVersion : <sch:value-of select="$uid"/>) The InterfaceSpecificationVersion.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Inverse of InterfaceSpecification.Versions :: PartProperty) InterfaceSpecificationVersion.VersionOf : InterfaceSpecification) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="InterpolatedConfigurationModel"><!--(Ref to E) InterpolatedConfigurationModel.ParameterUnit : Unit (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterpolatedConfigurationModel') or (self::Representation and substring-after(@xsi:type,':')='InterpolatedConfigurationModel'))]/ParameterUnit">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Unit'] or //Unit[@uid = $uidRef]">(InterpolatedConfigurationModel : <sch:value-of select="$uid"/>) The InterpolatedConfigurationModel.ParameterUnit contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Unit.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterpolatedConfigurationModel') or (self::Representation and substring-after(@xsi:type,':')='InterpolatedConfigurationModel'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(InterpolatedConfigurationModel : <sch:value-of select="$uid"/>) The InterpolatedConfigurationModel.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Representation.Items : SET[1:unbounded] OF RepresentationItem (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterpolatedConfigurationModel') or (self::Representation and substring-after(@xsi:type,':')='InterpolatedConfigurationModel'))]/Items/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(InterpolatedConfigurationModel : <sch:value-of select="$uid"/>) The InterpolatedConfigurationModel.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterpolatedConfigurationModel') or (self::Representation and substring-after(@xsi:type,':')='InterpolatedConfigurationModel'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(InterpolatedConfigurationModel : <sch:value-of select="$uid"/>) The InterpolatedConfigurationModel.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="InterpolatedConfigurationSegment"><!--(Ref to E) InterpolatedConfigurationSegment.State : MechanismState (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='InterpolatedConfigurationSegment') or (self::InterpolatedConfigurationSegment and not(@xsi:type)))]/State">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'MechanismState'] or //Representation[@uid = $uidRef and contains(' MechanismState ',substring-after(@xsi:type,':'))]">(InterpolatedConfigurationSegment : <sch:value-of select="$uid"/>) The InterpolatedConfigurationSegment.State contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type MechanismState.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="InterpolatedConfigurationSequence"/>
   <sch:pattern id="KinematicLink"><!--(Ref to E) KinematicLink.OfModel : OPTIONAL ExternalGeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='KinematicLink') or (self::Representation and substring-after(@xsi:type,':')='KinematicLink'))]/OfModel">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./OfModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExternalGeometricModel'] or //Representation[@uid = $uidRef and contains(' ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation ',substring-after(@xsi:type,':'))]">(KinematicLink : <sch:value-of select="$uid"/>) The KinematicLink.OfModel contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExternalGeometricModel.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='KinematicLink') or (self::Representation and substring-after(@xsi:type,':')='KinematicLink'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(KinematicLink : <sch:value-of select="$uid"/>) The KinematicLink.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Representation.Items : SET[1:unbounded] OF RepresentationItem (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='KinematicLink') or (self::Representation and substring-after(@xsi:type,':')='KinematicLink'))]/Items/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(KinematicLink : <sch:value-of select="$uid"/>) The KinematicLink.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='KinematicLink') or (self::Representation and substring-after(@xsi:type,':')='KinematicLink'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(KinematicLink : <sch:value-of select="$uid"/>) The KinematicLink.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="KinematicLinkToOccurrenceAssociation"><!--(Ref to E) KinematicLinkToOccurrenceAssociation.AssociatedLink : KinematicLink (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='KinematicLinkToOccurrenceAssociation') or (self::KinematicLinkToOccurrenceAssociation and not(@xsi:type)))]/AssociatedLink">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'KinematicLink'] or //Representation[@uid = $uidRef and contains(' KinematicLink ',substring-after(@xsi:type,':'))]">(KinematicLinkToOccurrenceAssociation : <sch:value-of select="$uid"/>) The KinematicLinkToOccurrenceAssociation.AssociatedLink contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type KinematicLink.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="KinematicMechanismAssociation"><!--(Ref to E) KinematicMechanismAssociation.AssociatedMechanism : Mechanism (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='KinematicMechanismAssociation') or (self::KinematicMechanismAssociation and not(@xsi:type)))]/AssociatedMechanism">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Mechanism'] or //Representation[@uid = $uidRef and contains(' Mechanism ',substring-after(@xsi:type,':'))]">(KinematicMechanismAssociation : <sch:value-of select="$uid"/>) The KinematicMechanismAssociation.AssociatedMechanism contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Mechanism.</sch:assert>
      </sch:rule>
      <!--(Ref to E) KinematicMechanismAssociation.BaseLink : KinematicLink (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='KinematicMechanismAssociation') or (self::KinematicMechanismAssociation and not(@xsi:type)))]/BaseLink">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'KinematicLink'] or //Representation[@uid = $uidRef and contains(' KinematicLink ',substring-after(@xsi:type,':'))]">(KinematicMechanismAssociation : <sch:value-of select="$uid"/>) The KinematicMechanismAssociation.BaseLink contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type KinematicLink.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="KinematicPairValue"><!--(Ref to E) KinematicPairValue.ActualPointOnCurve1 : OPTIONAL PointOnCurve (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='KinematicPairValue') or (self::RepresentationItem and substring-after(@xsi:type,':')='KinematicPairValue'))]/ActualPointOnCurve1">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ActualPointOnCurve1) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PointOnCurve'] or //RepresentationItem[@uid = $uidRef and contains(' PointOnCurve ',substring-after(@xsi:type,':'))]">(KinematicPairValue : <sch:value-of select="$uid"/>) The KinematicPairValue.ActualPointOnCurve1 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PointOnCurve.</sch:assert>
      </sch:rule>
      <!--(Ref to E) KinematicPairValue.ActualPointOnCurve2 : OPTIONAL PointOnCurve (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='KinematicPairValue') or (self::RepresentationItem and substring-after(@xsi:type,':')='KinematicPairValue'))]/ActualPointOnCurve2">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ActualPointOnCurve2) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PointOnCurve'] or //RepresentationItem[@uid = $uidRef and contains(' PointOnCurve ',substring-after(@xsi:type,':'))]">(KinematicPairValue : <sch:value-of select="$uid"/>) The KinematicPairValue.ActualPointOnCurve2 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PointOnCurve.</sch:assert>
      </sch:rule>
      <!--(Ref to E) KinematicPairValue.ActualPointOnSurface1 : OPTIONAL PointOnSurface (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='KinematicPairValue') or (self::RepresentationItem and substring-after(@xsi:type,':')='KinematicPairValue'))]/ActualPointOnSurface1">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ActualPointOnSurface1) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PointOnSurface'] or //RepresentationItem[@uid = $uidRef and contains(' PointOnSurface ',substring-after(@xsi:type,':'))]">(KinematicPairValue : <sch:value-of select="$uid"/>) The KinematicPairValue.ActualPointOnSurface1 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PointOnSurface.</sch:assert>
      </sch:rule>
      <!--(Ref to E) KinematicPairValue.ActualPointOnSurface2 : OPTIONAL PointOnSurface (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='KinematicPairValue') or (self::RepresentationItem and substring-after(@xsi:type,':')='KinematicPairValue'))]/ActualPointOnSurface2">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ActualPointOnSurface2) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PointOnSurface'] or //RepresentationItem[@uid = $uidRef and contains(' PointOnSurface ',substring-after(@xsi:type,':'))]">(KinematicPairValue : <sch:value-of select="$uid"/>) The KinematicPairValue.ActualPointOnSurface2 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PointOnSurface.</sch:assert>
      </sch:rule>
      <!--(Ref to S) KinematicPairValue.ActualRotation : OPTIONAL SimpleOrSpatialRotationSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='KinematicPairValue') or (self::RepresentationItem and substring-after(@xsi:type,':')='KinematicPairValue'))]/ActualRotation">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' RotationAboutDirection ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' RotationAboutDirection ',substring-after(@xsi:type,':'))]">(KinematicPairValue : <sch:value-of select="$uid"/>) The KinematicPairValue.ActualRotation contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of SimpleOrSpatialRotationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) KinematicPairValue.AppliesToPair : KinematicPair (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='KinematicPairValue') or (self::RepresentationItem and substring-after(@xsi:type,':')='KinematicPairValue'))]/AppliesToPair">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'KinematicPair'] or //RepresentationItem[@uid = $uidRef and contains(' KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling ',substring-after(@xsi:type,':'))]">(KinematicPairValue : <sch:value-of select="$uid"/>) The KinematicPairValue.AppliesToPair contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type KinematicPair.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="KinematicPairWithMotionCoupling"><!--(Ref to E) KinematicPairWithMotionCoupling.Pairs : LIST[1:unbounded] OF KinematicPair (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='KinematicPairWithMotionCoupling') or (self::RepresentationItem and substring-after(@xsi:type,':')='KinematicPairWithMotionCoupling'))]/Pairs/KinematicPair">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'KinematicPair'] or //RepresentationItem[@uid = $uidRef and contains(' KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling ',substring-after(@xsi:type,':'))]">(KinematicPairWithMotionCoupling : <sch:value-of select="$uid"/>) The KinematicPairWithMotionCoupling.Pairs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type KinematicPair.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="KinematicPathDefinedByNodes"><!--(Ref to E) KinematicPathDefinedByNodes.PlacementStart : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='KinematicPathDefinedByNodes') or (self::RepresentationItem and substring-after(@xsi:type,':')='KinematicPathDefinedByNodes'))]/PlacementStart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(KinematicPathDefinedByNodes : <sch:value-of select="$uid"/>) The KinematicPathDefinedByNodes.PlacementStart contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="LaidOrientationAngle"><!--(Ref to E) PlyOrientationAngle.ReinforcementDirection : ReinforcementOrientationBasis (kind=SINGLE - redefined=RepresentationRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LaidOrientationAngle') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='LaidOrientationAngle'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ReinforcementOrientationBasis'] or //Representation[@uid = $uidRef and contains(' ReinforcementOrientationBasis ',substring-after(@xsi:type,':'))]">(LaidOrientationAngle : <sch:value-of select="$uid"/>) The LaidOrientationAngle.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ReinforcementOrientationBasis.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RepresentationRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LaidOrientationAngle') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='LaidOrientationAngle'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(LaidOrientationAngle : <sch:value-of select="$uid"/>) The LaidOrientationAngle.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="LaminateTable"><!--(Ref to E) LaminateTable.Basis : SET[1:unbounded] OF ReinforcementOrientationBasis (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LaminateTable') or (self::PartView and substring-after(@xsi:type,':')='LaminateTable'))]/Basis/ReinforcementOrientationBasis">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ReinforcementOrientationBasis'] or //Representation[@uid = $uidRef and contains(' ReinforcementOrientationBasis ',substring-after(@xsi:type,':'))]">(LaminateTable : <sch:value-of select="$uid"/>) The LaminateTable.Basis contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ReinforcementOrientationBasis.</sch:assert>
      </sch:rule>
      <!--(Ref to E) LaminateTable.ResultingBoundary : PlyShape (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LaminateTable') or (self::PartView and substring-after(@xsi:type,':')='LaminateTable'))]/ResultingBoundary">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlyShape'] or //PlyShape[@uid = $uidRef]">(LaminateTable : <sch:value-of select="$uid"/>) The LaminateTable.ResultingBoundary contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlyShape.</sch:assert>
      </sch:rule>
      <!--(Ref to E) LaminateTable.ResultingSurface : Surface (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LaminateTable') or (self::PartView and substring-after(@xsi:type,':')='LaminateTable'))]/ResultingSurface">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Surface'] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(LaminateTable : <sch:value-of select="$uid"/>) The LaminateTable.ResultingSurface contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Surface.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LaminateTable') or (self::PartView and substring-after(@xsi:type,':')='LaminateTable'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(LaminateTable : <sch:value-of select="$uid"/>) The LaminateTable.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LaminateTable') or (self::PartView and substring-after(@xsi:type,':')='LaminateTable'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(LaminateTable : <sch:value-of select="$uid"/>) The LaminateTable.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LaminateTable') or (self::PartView and substring-after(@xsi:type,':')='LaminateTable'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(LaminateTable : <sch:value-of select="$uid"/>) The LaminateTable.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LaminateTable') or (self::PartView and substring-after(@xsi:type,':')='LaminateTable'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(LaminateTable : <sch:value-of select="$uid"/>) The LaminateTable.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LaminateTable') or (self::PartView and substring-after(@xsi:type,':')='LaminateTable'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(LaminateTable : <sch:value-of select="$uid"/>) The LaminateTable.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="LeaderLinePoint"/>
   <sch:pattern id="LeaderLinePointWithSurface"><!--(Ref to E) LeaderLinePointWithSurface.AssociatedSurface : FaceSurface (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LeaderLinePointWithSurface') or (self::RepresentationItem and substring-after(@xsi:type,':')='LeaderLinePointWithSurface'))]/AssociatedSurface">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'FaceSurface'] or //RepresentationItem[@uid = $uidRef and contains(' FaceSurface ',substring-after(@xsi:type,':'))]">(LeaderLinePointWithSurface : <sch:value-of select="$uid"/>) The LeaderLinePointWithSurface.AssociatedSurface contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type FaceSurface.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="LifeCycleStage"/>
   <sch:pattern id="LightSource"/>
   <sch:pattern id="LimitsAndFits"><!--(Ref to S) ValueWithUnit.Unit : UnitSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LimitsAndFits') or (self::LimitsAndFits or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::BevelAngle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Weight and substring-after(@xsi:type,':')='LimitsAndFits') or (self::RealWorldScale and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Fiber11Offset and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ModifierValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Offset and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::IndexValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::DimensionValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::UnitLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::FirstUnitSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::SecondUnitSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ToleranceValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ForcedLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::LotSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TotalThickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::VolumePercent and substring-after(@xsi:type,':')='LimitsAndFits') or (self::PlyThickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ProjectionLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Offset and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Density and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Height and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Width and substring-after(@xsi:type,':')='LimitsAndFits') or (self::FileSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::PageCount and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TotalThickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Diameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Diameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TargetLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TargetWidth and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TargetLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Thickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TwistPeriod and substring-after(@xsi:type,':')='LimitsAndFits')))]/Unit">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)] or //ExternalUnit[@uid = $uidRef] or //Unit[@uid = $uidRef]">(LimitsAndFits : <sch:value-of select="$uid"/>) The LimitsAndFits.Unit contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyValue.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LimitsAndFits') or (self::LimitsAndFits or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::BevelAngle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Weight and substring-after(@xsi:type,':')='LimitsAndFits') or (self::RealWorldScale and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Fiber11Offset and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ModifierValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Offset and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='LimitsAndFits') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='LimitsAndFits') or (self::IndexValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::DimensionValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::UnitLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::FirstUnitSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::SecondUnitSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ToleranceValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ForcedLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::LotSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MaterialValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TotalThickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::VolumePercent and substring-after(@xsi:type,':')='LimitsAndFits') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='LimitsAndFits') or (self::PlyThickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::WaitingTime and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ProjectionLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Offset and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Density and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Height and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Width and substring-after(@xsi:type,':')='LimitsAndFits') or (self::FileSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::PageCount and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TotalThickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Diameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Diameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TargetLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TargetWidth and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TargetLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Thickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TwistPeriod and substring-after(@xsi:type,':')='LimitsAndFits')))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(LimitsAndFits : <sch:value-of select="$uid"/>) The LimitsAndFits.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.Definition : OPTIONAL PropertyDefinitionSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LimitsAndFits') or (self::LimitsAndFits or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::BevelAngle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Weight and substring-after(@xsi:type,':')='LimitsAndFits') or (self::RealWorldScale and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Fiber11Offset and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ModifierValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Offset and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='LimitsAndFits') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='LimitsAndFits') or (self::IndexValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::DimensionValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::UnitLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::FirstUnitSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::SecondUnitSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ToleranceValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ForcedLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::LotSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MaterialValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TotalThickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::VolumePercent and substring-after(@xsi:type,':')='LimitsAndFits') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='LimitsAndFits') or (self::PlyThickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::WaitingTime and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ProjectionLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Offset and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Density and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Height and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Width and substring-after(@xsi:type,':')='LimitsAndFits') or (self::FileSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::PageCount and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TotalThickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Diameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Diameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TargetLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TargetWidth and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TargetLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Thickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TwistPeriod and substring-after(@xsi:type,':')='LimitsAndFits')))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionEnum) or (self::PropertyDefinitionString)">(LimitsAndFits : <sch:value-of select="$uid"/>) The LimitsAndFits.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PropertyDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.DeterminationMethod : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LimitsAndFits') or (self::LimitsAndFits or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::BevelAngle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Weight and substring-after(@xsi:type,':')='LimitsAndFits') or (self::RealWorldScale and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Fiber11Offset and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ModifierValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Offset and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='LimitsAndFits') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='LimitsAndFits') or (self::IndexValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::DimensionValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::UnitLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::FirstUnitSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::SecondUnitSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ToleranceValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ForcedLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::LotSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MaterialValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TotalThickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::VolumePercent and substring-after(@xsi:type,':')='LimitsAndFits') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='LimitsAndFits') or (self::PlyThickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::WaitingTime and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ProjectionLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Offset and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Density and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Height and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Width and substring-after(@xsi:type,':')='LimitsAndFits') or (self::FileSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::PageCount and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TotalThickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Diameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Diameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TargetLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TargetWidth and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TargetLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Thickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TwistPeriod and substring-after(@xsi:type,':')='LimitsAndFits')))]/DeterminationMethod/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(LimitsAndFits : <sch:value-of select="$uid"/>) The LimitsAndFits.DeterminationMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.Qualifiers : OPTIONAL SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LimitsAndFits') or (self::LimitsAndFits or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::BevelAngle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Weight and substring-after(@xsi:type,':')='LimitsAndFits') or (self::RealWorldScale and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Fiber11Offset and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ModifierValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Offset and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='LimitsAndFits') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='LimitsAndFits') or (self::IndexValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::DimensionValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::UnitLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::FirstUnitSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::SecondUnitSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ToleranceValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ForcedLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::LotSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MaterialValue and substring-after(@xsi:type,':')='LimitsAndFits') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TotalThickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::VolumePercent and substring-after(@xsi:type,':')='LimitsAndFits') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='LimitsAndFits') or (self::PlyThickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::WaitingTime and substring-after(@xsi:type,':')='LimitsAndFits') or (self::ProjectionLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Offset and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Quantity and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Density and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Height and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Width and substring-after(@xsi:type,':')='LimitsAndFits') or (self::FileSize and substring-after(@xsi:type,':')='LimitsAndFits') or (self::PageCount and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TotalThickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Diameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Diameter and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TargetLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TargetWidth and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TargetLength and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Thickness and substring-after(@xsi:type,':')='LimitsAndFits') or (self::Angle and substring-after(@xsi:type,':')='LimitsAndFits') or (self::TwistPeriod and substring-after(@xsi:type,':')='LimitsAndFits')))]/Qualifiers/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::ExternalTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalTypeQualifier ',@typeRef)]) or (self::PreDefinedTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PreDefinedTypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::ExternalTypeQualifier and //ExternalTypeQualifier[@uid = $uidRef]) or (self::PreDefinedTypeQualifier and //PreDefinedTypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(LimitsAndFits : <sch:value-of select="$uid"/>) The LimitsAndFits.Qualifiers contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="LineProfileTolerance"><!--(Ref to E) LineProfileTolerance.DatumSystem : OPTIONAL DatumSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LineProfileTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='LineProfileTolerance'))]/DatumSystem">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DatumSystem) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DatumSystem'] or //ShapeElement[@uid = $uidRef and contains(' DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem ',substring-after(@xsi:type,':'))]">(LineProfileTolerance : <sch:value-of select="$uid"/>) The LineProfileTolerance.DatumSystem contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DatumSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricTolerance.AppliedTo : GeometricToleranceTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LineProfileTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='LineProfileTolerance'))]/AppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //PartView[@uid = $uidRef]">(LineProfileTolerance : <sch:value-of select="$uid"/>) The LineProfileTolerance.AppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricToleranceTargetSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LineProfileTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='LineProfileTolerance'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(LineProfileTolerance : <sch:value-of select="$uid"/>) The LineProfileTolerance.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.GeometricToleranceContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LineProfileTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='LineProfileTolerance'))]/GeometricToleranceContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricToleranceContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(LineProfileTolerance : <sch:value-of select="$uid"/>) The LineProfileTolerance.GeometricToleranceContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="LinearDistance"><!--(Ref to E) LinearDistance.Orientation : OPTIONAL AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LinearDistance') or (self::GeometricDimension and substring-after(@xsi:type,':')='LinearDistance'))]/Orientation">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Orientation) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(LinearDistance : <sch:value-of select="$uid"/>) The LinearDistance.Orientation contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DimensionalLocation.Origin : ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LinearDistance') or (self::GeometricDimension and substring-after(@xsi:type,':')='LinearDistance'))]/Origin">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(LinearDistance : <sch:value-of select="$uid"/>) The LinearDistance.Origin contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DimensionalLocation.Target : ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LinearDistance') or (self::GeometricDimension and substring-after(@xsi:type,':')='LinearDistance'))]/Target">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(LinearDistance : <sch:value-of select="$uid"/>) The LinearDistance.Target contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LinearDistance') or (self::GeometricDimension and substring-after(@xsi:type,':')='LinearDistance'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(LinearDistance : <sch:value-of select="$uid"/>) The LinearDistance.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.GeometricDimensionContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LinearDistance') or (self::GeometricDimension and substring-after(@xsi:type,':')='LinearDistance'))]/GeometricDimensionContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricDimensionContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(LinearDistance : <sch:value-of select="$uid"/>) The LinearDistance.GeometricDimensionContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="LinearPath"><!--(Ref to E) PathSegment.PlacementEnd : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LinearPath') or (self::PathSegment and substring-after(@xsi:type,':')='LinearPath'))]/PlacementEnd">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(LinearPath : <sch:value-of select="$uid"/>) The LinearPath.PlacementEnd contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="LinkMotionAlongPath"><!--(Ref to E) LinkMotionAlongPath.TimeUnit : OPTIONAL Unit (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LinkMotionAlongPath') or (self::Representation and substring-after(@xsi:type,':')='LinkMotionAlongPath'))]/TimeUnit">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./TimeUnit) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Unit'] or //Unit[@uid = $uidRef]">(LinkMotionAlongPath : <sch:value-of select="$uid"/>) The LinkMotionAlongPath.TimeUnit contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Unit.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LinkMotionAlongPath') or (self::Representation and substring-after(@xsi:type,':')='LinkMotionAlongPath'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(LinkMotionAlongPath : <sch:value-of select="$uid"/>) The LinkMotionAlongPath.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Representation.Items : SET[1:unbounded] OF RepresentationItem (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LinkMotionAlongPath') or (self::Representation and substring-after(@xsi:type,':')='LinkMotionAlongPath'))]/Items/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(LinkMotionAlongPath : <sch:value-of select="$uid"/>) The LinkMotionAlongPath.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LinkMotionAlongPath') or (self::Representation and substring-after(@xsi:type,':')='LinkMotionAlongPath'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(LinkMotionAlongPath : <sch:value-of select="$uid"/>) The LinkMotionAlongPath.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="LinkMotionRelationship"><!--(Ref to E) LinkMotionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LinkMotionRelationship') or (self::LinkMotionRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(LinkMotionRelationship : <sch:value-of select="$uid"/>) The LinkMotionRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) LinkMotionRelationship.Related : ComposedOrExternalGeometricModelSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LinkMotionRelationship') or (self::LinkMotionRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ComposedGeometricModel ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation ',@typeRef)] or //Representation[@uid = $uidRef and contains(' ComposedGeometricModel ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation ',substring-after(@xsi:type,':'))]">(LinkMotionRelationship : <sch:value-of select="$uid"/>) The LinkMotionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ComposedOrExternalGeometricModelSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) LinkMotionRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LinkMotionRelationship') or (self::LinkMotionRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(LinkMotionRelationship : <sch:value-of select="$uid"/>) The LinkMotionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="LinkMotionTransformation"><!--(Ref to E) LinkMotionTransformation.TransformItem1 : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LinkMotionTransformation') or (self::LinkMotionTransformation or (self::TranformationOperator and substring-after(@xsi:type,':')='LinkMotionTransformation')))]/TransformItem1">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(LinkMotionTransformation : <sch:value-of select="$uid"/>) The LinkMotionTransformation.TransformItem1 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) LinkMotionTransformation.TransformItem2 : KinematicPathDefinedByNodes (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LinkMotionTransformation') or (self::LinkMotionTransformation or (self::TranformationOperator and substring-after(@xsi:type,':')='LinkMotionTransformation')))]/TransformItem2">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'KinematicPathDefinedByNodes'] or //RepresentationItem[@uid = $uidRef and contains(' KinematicPathDefinedByNodes ',substring-after(@xsi:type,':'))]">(LinkMotionTransformation : <sch:value-of select="$uid"/>) The LinkMotionTransformation.TransformItem2 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type KinematicPathDefinedByNodes.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="LocalizedString"/>
   <sch:pattern id="LogicalRepresentationItem"/>
   <sch:pattern id="Loop"/>
   <sch:pattern id="LotEffectivity"><!--(Ref to E) Effectivity.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LotEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='LotEffectivity'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(LotEffectivity : <sch:value-of select="$uid"/>) The LotEffectivity.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LotEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='LotEffectivity'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(LotEffectivity : <sch:value-of select="$uid"/>) The LotEffectivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Effectivity.EffectivityContext : OPTIONAL EffectivityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LotEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='LotEffectivity'))]/EffectivityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //Activity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef]">(LotEffectivity : <sch:value-of select="$uid"/>) The LotEffectivity.EffectivityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EffectivityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="LowOrderKinematicPair"><!--(Ref to E) KinematicPair.Link1 : KinematicLink (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LowOrderKinematicPair') or (self::RepresentationItem and substring-after(@xsi:type,':')='LowOrderKinematicPair'))]/Link1">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'KinematicLink'] or //Representation[@uid = $uidRef and contains(' KinematicLink ',substring-after(@xsi:type,':'))]">(LowOrderKinematicPair : <sch:value-of select="$uid"/>) The LowOrderKinematicPair.Link1 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type KinematicLink.</sch:assert>
      </sch:rule>
      <!--(Ref to E) KinematicPair.Link2 : KinematicLink (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LowOrderKinematicPair') or (self::RepresentationItem and substring-after(@xsi:type,':')='LowOrderKinematicPair'))]/Link2">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'KinematicLink'] or //Representation[@uid = $uidRef and contains(' KinematicLink ',substring-after(@xsi:type,':'))]">(LowOrderKinematicPair : <sch:value-of select="$uid"/>) The LowOrderKinematicPair.Link2 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type KinematicLink.</sch:assert>
      </sch:rule>
      <!--(Ref to E) KinematicPair.PairFrame1 : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LowOrderKinematicPair') or (self::RepresentationItem and substring-after(@xsi:type,':')='LowOrderKinematicPair'))]/PairFrame1">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(LowOrderKinematicPair : <sch:value-of select="$uid"/>) The LowOrderKinematicPair.PairFrame1 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) KinematicPair.PairFrame2 : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LowOrderKinematicPair') or (self::RepresentationItem and substring-after(@xsi:type,':')='LowOrderKinematicPair'))]/PairFrame2">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(LowOrderKinematicPair : <sch:value-of select="$uid"/>) The LowOrderKinematicPair.PairFrame2 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="LowOrderKinematicPairWithMotionCoupling"><!--(Ref to E) KinematicPair.Link1 : KinematicLink (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LowOrderKinematicPairWithMotionCoupling') or (self::RepresentationItem and substring-after(@xsi:type,':')='LowOrderKinematicPairWithMotionCoupling'))]/Link1">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'KinematicLink'] or //Representation[@uid = $uidRef and contains(' KinematicLink ',substring-after(@xsi:type,':'))]">(LowOrderKinematicPairWithMotionCoupling : <sch:value-of select="$uid"/>) The LowOrderKinematicPairWithMotionCoupling.Link1 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type KinematicLink.</sch:assert>
      </sch:rule>
      <!--(Ref to E) KinematicPair.Link2 : KinematicLink (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LowOrderKinematicPairWithMotionCoupling') or (self::RepresentationItem and substring-after(@xsi:type,':')='LowOrderKinematicPairWithMotionCoupling'))]/Link2">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'KinematicLink'] or //Representation[@uid = $uidRef and contains(' KinematicLink ',substring-after(@xsi:type,':'))]">(LowOrderKinematicPairWithMotionCoupling : <sch:value-of select="$uid"/>) The LowOrderKinematicPairWithMotionCoupling.Link2 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type KinematicLink.</sch:assert>
      </sch:rule>
      <!--(Ref to E) KinematicPair.PairFrame1 : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LowOrderKinematicPairWithMotionCoupling') or (self::RepresentationItem and substring-after(@xsi:type,':')='LowOrderKinematicPairWithMotionCoupling'))]/PairFrame1">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(LowOrderKinematicPairWithMotionCoupling : <sch:value-of select="$uid"/>) The LowOrderKinematicPairWithMotionCoupling.PairFrame1 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) KinematicPair.PairFrame2 : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='LowOrderKinematicPairWithMotionCoupling') or (self::RepresentationItem and substring-after(@xsi:type,':')='LowOrderKinematicPairWithMotionCoupling'))]/PairFrame2">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(LowOrderKinematicPairWithMotionCoupling : <sch:value-of select="$uid"/>) The LowOrderKinematicPairWithMotionCoupling.PairFrame2 contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="MakeFromRelationship"><!--(Default Value) MakeFromRelationship.RelationType : String = 'make from' (kind=SINGLE - redefined=PartViewRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MakeFromRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='MakeFromRelationship'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'make from'">(MakeFromRelationship : <sch:value-of select="$uid"/>) The MakeFromRelationship.RelationType contains the wrong value () must be 'make from'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MakeFromRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='MakeFromRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(MakeFromRelationship : <sch:value-of select="$uid"/>) The MakeFromRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.Related : PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MakeFromRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='MakeFromRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(MakeFromRelationship : <sch:value-of select="$uid"/>) The MakeFromRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MakeFromRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='MakeFromRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(MakeFromRelationship : <sch:value-of select="$uid"/>) The MakeFromRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Market"><!--(Ref to E) Market.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Market') or (self::Market and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Market : <sch:value-of select="$uid"/>) The Market.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Market.MarketSegmentType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Market') or (self::Market and not(@xsi:type)))]/MarketSegmentType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Market : <sch:value-of select="$uid"/>) The Market.MarketSegmentType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="MatedPartAssociation"><!--(Default Value) NextAssemblyOccurrenceUsage.RelationType : String = 'next assembly occurrence' (kind=SINGLE - redefined=ViewOccurrenceRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MatedPartAssociation') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='MatedPartAssociation'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'next assembly occurrence'">(MatedPartAssociation : <sch:value-of select="$uid"/>) The MatedPartAssociation.RelationType contains the wrong value () must be 'next assembly occurrence'.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssemblyOccurrenceRelationship.Placement : OPTIONAL SET[1:unbounded] OF TransformationAndAssociationSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MatedPartAssociation') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='MatedPartAssociation'))]/Placement/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::CartesianTransformation or (self::Transformation and contains(' CartesianTransformation ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)]) or (self::GeometricRepresentationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',@typeRef)]) or (self::GeometryToTopologyModelAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometryToTopologyModelAssociation ',@typeRef)]) or (self::TopologyToGeometryModelAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologyToGeometryModelAssociation ',@typeRef)]) or (self::CartesianTransformation) or (self::GeometricRepresentationRelationship and //RepresentationRelationship[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',substring-after(@xsi:type,':'))]) or (self::GeometryToTopologyModelAssociation and //RepresentationRelationship[@uid = $uidRef and contains(' GeometryToTopologyModelAssociation ',substring-after(@xsi:type,':'))]) or (self::TopologyToGeometryModelAssociation and //RepresentationRelationship[@uid = $uidRef and contains(' TopologyToGeometryModelAssociation ',substring-after(@xsi:type,':'))])">(MatedPartAssociation : <sch:value-of select="$uid"/>) The MatedPartAssociation.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of TransformationAndAssociationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ViewOccurrenceRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MatedPartAssociation') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='MatedPartAssociation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(MatedPartAssociation : <sch:value-of select="$uid"/>) The MatedPartAssociation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ViewOccurrenceRelationship.Related : DefinitionBasedOccurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MatedPartAssociation') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='MatedPartAssociation'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DefinitionBasedOccurrence'] or //Occurrence[@uid = $uidRef and contains(' DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence ',substring-after(@xsi:type,':'))]">(MatedPartAssociation : <sch:value-of select="$uid"/>) The MatedPartAssociation.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DefinitionBasedOccurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ViewOccurrenceRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MatedPartAssociation') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='MatedPartAssociation'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(MatedPartAssociation : <sch:value-of select="$uid"/>) The MatedPartAssociation.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="MatedPartRelationship"><!--(Ref to E) MatedPartRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MatedPartRelationship') or (self::MatedPartRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(MatedPartRelationship : <sch:value-of select="$uid"/>) The MatedPartRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) MatedPartRelationship.MatedShapes : OPTIONAL SET[1:unbounded] OF AssemblyShapeJoint (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MatedPartRelationship') or (self::MatedPartRelationship and not(@xsi:type)))]/MatedShapes/AssemblyShapeJoint">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../MatedShapes/AssemblyShapeJoint) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AssemblyShapeJoint'] or //ShapeElement[@uid = $uidRef and contains(' AssemblyShapeJoint ',substring-after(@xsi:type,':'))]">(MatedPartRelationship : <sch:value-of select="$uid"/>) The MatedPartRelationship.MatedShapes contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AssemblyShapeJoint.</sch:assert>
      </sch:rule>
      <!--(Ref to E) MatedPartRelationship.MatingMaterials : OPTIONAL SET[1:unbounded] OF DefinitionBasedOccurrence (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MatedPartRelationship') or (self::MatedPartRelationship and not(@xsi:type)))]/MatingMaterials/DefinitionBasedOccurrence">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../MatingMaterials/DefinitionBasedOccurrence) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DefinitionBasedOccurrence'] or //Occurrence[@uid = $uidRef and contains(' DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence ',substring-after(@xsi:type,':'))]">(MatedPartRelationship : <sch:value-of select="$uid"/>) The MatedPartRelationship.MatingMaterials contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DefinitionBasedOccurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to E) MatedPartRelationship.Related : MatedPartAssociation (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MatedPartRelationship') or (self::MatedPartRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'MatedPartAssociation'] or //ViewOccurrenceRelationship[@uid = $uidRef and contains(' MatedPartAssociation ',substring-after(@xsi:type,':'))]">(MatedPartRelationship : <sch:value-of select="$uid"/>) The MatedPartRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type MatedPartAssociation.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="MatedPartRelationship_WR1"><!--(Rule MatedPartRelationship.WR1)-->
      <sch:rule context="//MatedPartRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> MatedPartRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related MatedPart and the relating MatedPart shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="MaterialIdentification"/>
   <sch:pattern id="MaterialPropertyAssignment"><!--(Ref to E) MaterialPropertyAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MaterialPropertyAssignment') or (self::MaterialPropertyAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(MaterialPropertyAssignment : <sch:value-of select="$uid"/>) The MaterialPropertyAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) MaterialPropertyAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MaterialPropertyAssignment') or (self::MaterialPropertyAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(MaterialPropertyAssignment : <sch:value-of select="$uid"/>) The MaterialPropertyAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="MaterialPropertyDefinition"><!--(Ref to S) PropertyDefinition.AllowedUnits : OPTIONAL SET[1:unbounded] OF UnitSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MaterialPropertyDefinition') or (self::PropertyDefinition and substring-after(@xsi:type,':')='MaterialPropertyDefinition'))]/AllowedUnits/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ExternalUnit and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)]) or (self::Unit and //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)]) or (self::ExternalUnit and //ExternalUnit[@uid = $uidRef]) or (self::Unit and //Unit[@uid = $uidRef])">(MaterialPropertyDefinition : <sch:value-of select="$uid"/>) The MaterialPropertyDefinition.AllowedUnits contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyDefinition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MaterialPropertyDefinition') or (self::PropertyDefinition and substring-after(@xsi:type,':')='MaterialPropertyDefinition'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(MaterialPropertyDefinition : <sch:value-of select="$uid"/>) The MaterialPropertyDefinition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyDefinition.DefinedIn : OPTIONAL ExternalClassSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MaterialPropertyDefinition') or (self::PropertyDefinition and substring-after(@xsi:type,':')='MaterialPropertyDefinition'))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefinedIn) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExternalClassSystem'] or //ExternalClassSystem[@uid = $uidRef]">(MaterialPropertyDefinition : <sch:value-of select="$uid"/>) The MaterialPropertyDefinition.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExternalClassSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyDefinition.Definition : OPTIONAL ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MaterialPropertyDefinition') or (self::PropertyDefinition and substring-after(@xsi:type,':')='MaterialPropertyDefinition'))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(MaterialPropertyDefinition : <sch:value-of select="$uid"/>) The MaterialPropertyDefinition.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyDefinition.PropertyType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MaterialPropertyDefinition') or (self::PropertyDefinition and substring-after(@xsi:type,':')='MaterialPropertyDefinition'))]/PropertyType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(MaterialPropertyDefinition : <sch:value-of select="$uid"/>) The MaterialPropertyDefinition.PropertyType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="MaterialPropertyValue"><!--(Ref to E) MaterialPropertyValue.Definition : MaterialPropertyDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MaterialPropertyValue') or (self::MaterialPropertyValue or (self::AssignedProperty and substring-after(@xsi:type,':')='MaterialPropertyValue')))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'MaterialPropertyDefinition'] or //PropertyDefinition[@uid = $uidRef and contains(' MaterialPropertyDefinition ',substring-after(@xsi:type,':'))]">(MaterialPropertyValue : <sch:value-of select="$uid"/>) The MaterialPropertyValue.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type MaterialPropertyDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to E) MaterialPropertyValue.EnvironmentCondition : DataEnvironment (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MaterialPropertyValue') or (self::MaterialPropertyValue or (self::AssignedProperty and substring-after(@xsi:type,':')='MaterialPropertyValue')))]/EnvironmentCondition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DataEnvironment'] or //DataEnvironment[@uid = $uidRef]">(MaterialPropertyValue : <sch:value-of select="$uid"/>) The MaterialPropertyValue.EnvironmentCondition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DataEnvironment.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="MatingDefinition"><!--(Ref to S) MatingDefinition.MatingType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MatingDefinition') or (self::PartView and substring-after(@xsi:type,':')='MatingDefinition'))]/MatingType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(MatingDefinition : <sch:value-of select="$uid"/>) The MatingDefinition.MatingType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssemblyDefinition.AssemblyType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MatingDefinition') or (self::PartView and substring-after(@xsi:type,':')='MatingDefinition'))]/AssemblyType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(MatingDefinition : <sch:value-of select="$uid"/>) The MatingDefinition.AssemblyType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MatingDefinition') or (self::PartView and substring-after(@xsi:type,':')='MatingDefinition'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(MatingDefinition : <sch:value-of select="$uid"/>) The MatingDefinition.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MatingDefinition') or (self::PartView and substring-after(@xsi:type,':')='MatingDefinition'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(MatingDefinition : <sch:value-of select="$uid"/>) The MatingDefinition.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MatingDefinition') or (self::PartView and substring-after(@xsi:type,':')='MatingDefinition'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(MatingDefinition : <sch:value-of select="$uid"/>) The MatingDefinition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MatingDefinition') or (self::PartView and substring-after(@xsi:type,':')='MatingDefinition'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(MatingDefinition : <sch:value-of select="$uid"/>) The MatingDefinition.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MatingDefinition') or (self::PartView and substring-after(@xsi:type,':')='MatingDefinition'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(MatingDefinition : <sch:value-of select="$uid"/>) The MatingDefinition.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="MeasureQualification"><!--(Ref to E) MeasureQualification.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MeasureQualification') or (self::MeasureQualification and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(MeasureQualification : <sch:value-of select="$uid"/>) The MeasureQualification.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) MeasureQualification.Qualifiers : SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MeasureQualification') or (self::MeasureQualification and not(@xsi:type)))]/Qualifiers/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::ExternalTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalTypeQualifier ',@typeRef)]) or (self::PreDefinedTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PreDefinedTypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::ExternalTypeQualifier and //ExternalTypeQualifier[@uid = $uidRef]) or (self::PreDefinedTypeQualifier and //PreDefinedTypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(MeasureQualification : <sch:value-of select="$uid"/>) The MeasureQualification.Qualifiers contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="MeasuredCharacteristic"><!--(Ref to E) MeasuredCharacteristic.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MeasuredCharacteristic') or (self::MeasuredCharacteristic and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(MeasuredCharacteristic : <sch:value-of select="$uid"/>) The MeasuredCharacteristic.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) MeasuredCharacteristic.MeasureActivity : OPTIONAL MeasureActivitySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MeasuredCharacteristic') or (self::MeasuredCharacteristic and not(@xsi:type)))]/MeasureActivity">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationOccurrence ',@typeRef)] or //Activity[@uid = $uidRef] or //ProcessOperationOccurrence[@uid = $uidRef]">(MeasuredCharacteristic : <sch:value-of select="$uid"/>) The MeasuredCharacteristic.MeasureActivity contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of MeasureActivitySelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) MeasuredCharacteristic.PlannedCharacteristic : OPTIONAL PlannedCharacteristic (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MeasuredCharacteristic') or (self::MeasuredCharacteristic and not(@xsi:type)))]/PlannedCharacteristic">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./PlannedCharacteristic) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlannedCharacteristic'] or //PlannedCharacteristic[@uid = $uidRef]">(MeasuredCharacteristic : <sch:value-of select="$uid"/>) The MeasuredCharacteristic.PlannedCharacteristic contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlannedCharacteristic.</sch:assert>
      </sch:rule>
      <!--(Ref to E) MeasuredCharacteristic.TestedPart : OPTIONAL IndividualPartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MeasuredCharacteristic') or (self::MeasuredCharacteristic and not(@xsi:type)))]/TestedPart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./TestedPart) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'IndividualPartView'] or //IndividualPartView[@uid = $uidRef]">(MeasuredCharacteristic : <sch:value-of select="$uid"/>) The MeasuredCharacteristic.TestedPart contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type IndividualPartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="MeasurementPath"><!--(Ref to E) MeasurementPath.DefinedBy : Curve (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MeasurementPath') or (self::MeasurementPath or (self::UsedPath and substring-after(@xsi:type,':')='MeasurementPath') or (self::UsedPath and substring-after(@xsi:type,':')='MeasurementPath')))]/DefinedBy">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Curve'] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))]">(MeasurementPath : <sch:value-of select="$uid"/>) The MeasurementPath.DefinedBy contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Curve.</sch:assert>
      </sch:rule>
      <!--(Ref to E) MeasurementPath.DefinedIn : GeometricCoordinateSpace (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MeasurementPath') or (self::MeasurementPath or (self::UsedPath and substring-after(@xsi:type,':')='MeasurementPath') or (self::UsedPath and substring-after(@xsi:type,':')='MeasurementPath')))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricCoordinateSpace'] or //RepresentationContext[@uid = $uidRef and contains(' GeometricCoordinateSpace ',substring-after(@xsi:type,':'))]">(MeasurementPath : <sch:value-of select="$uid"/>) The MeasurementPath.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricCoordinateSpace.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Mechanism"><!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional--><!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Mechanism') or (self::Representation and substring-after(@xsi:type,':')='Mechanism'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Mechanism : <sch:value-of select="$uid"/>) The Mechanism.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Representation.Items : SET[1:unbounded] OF RepresentationItem (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Mechanism') or (self::Representation and substring-after(@xsi:type,':')='Mechanism'))]/Items/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(Mechanism : <sch:value-of select="$uid"/>) The Mechanism.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Mechanism') or (self::Representation and substring-after(@xsi:type,':')='Mechanism'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Mechanism : <sch:value-of select="$uid"/>) The Mechanism.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="MechanismState"><!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional--><!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MechanismState') or (self::Representation and substring-after(@xsi:type,':')='MechanismState'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(MechanismState : <sch:value-of select="$uid"/>) The MechanismState.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Representation.Items : SET[1:unbounded] OF RepresentationItem (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MechanismState') or (self::Representation and substring-after(@xsi:type,':')='MechanismState'))]/Items/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(MechanismState : <sch:value-of select="$uid"/>) The MechanismState.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MechanismState') or (self::Representation and substring-after(@xsi:type,':')='MechanismState'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(MechanismState : <sch:value-of select="$uid"/>) The MechanismState.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="Message"><!--(Ref to E) Message.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Message') or (self::Message and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Message : <sch:value-of select="$uid"/>) The Message.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Message.Contains : OPTIONAL SET[1:unbounded] OF MessageContentSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Message') or (self::Message and not(@xsi:type)))]/Contains/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::Approval and //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)]) or (self::Certification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Certification ',@typeRef)]) or (self::Contract and //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)]) or (self::DigitalFile and //ExternalRefBaseObject[@uid = $uidRef and contains(' DigitalFile ',@typeRef)]) or (self::Observation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::Person and //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)]) or (self::ProductConcept and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::ProductGroup and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductGroup ',@typeRef)]) or (self::Project and //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)]) or (self::SecurityClassification and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassification ',@typeRef)]) or (self::State and //ExternalRefBaseObject[@uid = $uidRef and contains(' State  StateObserved  StatePredicted ',@typeRef)]) or (self::StateDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinition ',@typeRef)]) or (self::Validation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Validation ',@typeRef)]) or (self::Verification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Verification ',@typeRef)]) or (self::WorkOrder and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrder ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::Approval and //Approval[@uid = $uidRef]) or (self::Certification and //Certification[@uid = $uidRef]) or (self::Contract and //Contract[@uid = $uidRef]) or (self::DigitalFile and //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]) or (self::Observation and //Observation[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::Person and //Person[@uid = $uidRef]) or (self::ProductConcept and //ProductConcept[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProductGroup and //ProductGroup[@uid = $uidRef]) or (self::Project and //Project[@uid = $uidRef]) or (self::SecurityClassification and //SecurityClassification[@uid = $uidRef]) or (self::State and //State[@uid = $uidRef]) or (self::StateDefinition and //StateDefinition[@uid = $uidRef]) or (self::Validation and //Validation[@uid = $uidRef]) or (self::Verification and //Verification[@uid = $uidRef]) or (self::WorkOrder and //WorkOrder[@uid = $uidRef]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef])">(Message : <sch:value-of select="$uid"/>) The Message.Contains contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of MessageContentSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Message.DefinedBy : OPTIONAL SET[1:unbounded] OF MessageDefinerSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Message') or (self::Message and not(@xsi:type)))]/DefinedBy/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef])">(Message : <sch:value-of select="$uid"/>) The Message.DefinedBy contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of MessageDefinerSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Message.ExchangeContext : OPTIONAL SET[1:unbounded] OF ExchangeContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Message') or (self::Message and not(@xsi:type)))]/ExchangeContext/ExchangeContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ExchangeContext/ExchangeContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExchangeContext'] or //ExchangeContext[@uid = $uidRef]">(Message : <sch:value-of select="$uid"/>) The Message.ExchangeContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExchangeContext.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="MessageRelationship"><!--(Ref to E) MessageRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MessageRelationship') or (self::MessageRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(MessageRelationship : <sch:value-of select="$uid"/>) The MessageRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) MessageRelationship.Related : Message (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MessageRelationship') or (self::MessageRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Message'] or //Message[@uid = $uidRef]">(MessageRelationship : <sch:value-of select="$uid"/>) The MessageRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Message.</sch:assert>
      </sch:rule>
      <!--(Ref to S) MessageRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MessageRelationship') or (self::MessageRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(MessageRelationship : <sch:value-of select="$uid"/>) The MessageRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ModelProperty"><!--(Ref to S) ModelProperty.Definition : PropertyDefinitionSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ModelProperty') or (self::ModelProperty and not(@xsi:type)))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionEnum) or (self::PropertyDefinitionString)">(ModelProperty : <sch:value-of select="$uid"/>) The ModelProperty.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PropertyDefinitionSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ModelPropertyAssignment"><!--(Ref to E) ModelPropertyAssignment.AssignedProperty : ModelProperty (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ModelPropertyAssignment') or (self::ModelPropertyAssignment and not(@xsi:type)))]/AssignedProperty">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ModelProperty'] or //ModelProperty[@uid = $uidRef]">(ModelPropertyAssignment : <sch:value-of select="$uid"/>) The ModelPropertyAssignment.AssignedProperty contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ModelProperty.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ModelPropertyAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ModelPropertyAssignment') or (self::ModelPropertyAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ModelPropertyAssignment : <sch:value-of select="$uid"/>) The ModelPropertyAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ModelPropertyAssignment.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ModelPropertyAssignment') or (self::ModelPropertyAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ModelPropertyAssignment : <sch:value-of select="$uid"/>) The ModelPropertyAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ModelPropertyAssignment.ValidityContext : OPTIONAL ValidityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ModelPropertyAssignment') or (self::ModelPropertyAssignment and not(@xsi:type)))]/ValidityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)] or //Organization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef]">(ModelPropertyAssignment : <sch:value-of select="$uid"/>) The ModelPropertyAssignment.ValidityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValidityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ModifyElement"><!--(Ref to S) ModifyElement.CurrentDesignObject : SET[1:unbounded] OF DeltaChangeManagementObjectSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ModifyElement') or (self::DeltaChangeActivity and substring-after(@xsi:type,':')='ModifyElement'))]/CurrentDesignObject/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternatePartRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternatePartRelationship ',@typeRef)]) or (self::AlternativeSolution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::AssemblyOccurrenceRelationshipSubstitution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyOccurrenceRelationshipSubstitution ',@typeRef)]) or (self::AssemblyViewRelationshipSubstitution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationshipSubstitution ',@typeRef)]) or (self::AssignmentObjectRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssignmentObjectRelationship ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementRealization and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRealization ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::BreakdownVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionRelationship ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConfiguredAssemblyEffectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConfiguredAssemblyEffectivity ',@typeRef)]) or (self::Contract and //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::DeltaChangeRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DeltaChangeRelationship ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::DocumentVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersionRelationship ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::File and //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)]) or (self::IndividualAssemblyRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualAssemblyRelationship ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialIdentification and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialIdentification ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::Occurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)]) or (self::OccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceRelationship  ReplacedUsageRelationship  SameTimeMachiningRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship  AlternatePartVersionRelationship ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::Person and //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::ProcessOperationDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinition ',@typeRef)]) or (self::ProcessOperationOccurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationOccurrence ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlan and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlan ',@typeRef)]) or (self::ProductClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::Project and //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::ProjectRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectRelationship ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (self::Representation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel  PlyAngleRepresentation  ReinforcementOrientationBasis ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersionRelationship ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategory and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategory ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusion ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::StyledModel and //ExternalRefBaseObject[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::ViewOccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternatePartRelationship and //PartRelationship[@uid = $uidRef and contains(' AlternatePartRelationship ',substring-after(@xsi:type,':'))]) or (self::AlternativeSolution and //AlternativeSolution[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::AssemblyOccurrenceRelationshipSubstitution and //AssemblyOccurrenceRelationshipSubstitution[@uid = $uidRef]) or (self::AssemblyViewRelationshipSubstitution and //AssemblyViewRelationshipSubstitution[@uid = $uidRef]) or (self::AssignmentObjectRelationship and //AssignmentObjectRelationship[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementRealization and //BreakdownElementRealization[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementVersionRelationship and //BreakdownElementVersionRelationship[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::BreakdownVersionRelationship and //BreakdownVersionRelationship[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Class and //Class[@uid = $uidRef]) or (self::Condition and //*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConfiguredAssemblyEffectivity and //ConfiguredAssemblyEffectivity[@uid = $uidRef]) or (self::Contract and //Contract[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DeltaChangeRelationship and //DeltaChangeRelationship[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::DocumentVersionRelationship and //DocumentVersionRelationship[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::Event and //Event[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef]) or (self::File and //File[@uid = $uidRef]) or (self::IndividualAssemblyRelationship and //IndividualAssemblyRelationship[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartVersionRelationship and //IndividualPartVersionRelationship[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialIdentification and //MaterialIdentification[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::Occurrence and //Occurrence[@uid = $uidRef]) or (self::OccurrenceRelationship and //OccurrenceRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartVersionRelationship and //PartVersionRelationship[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::Person and //Person[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef]) or (self::ProcessOperationDefinition and //ProcessOperationDefinition[@uid = $uidRef]) or (self::ProcessOperationOccurrence and //ProcessOperationOccurrence[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlan and //ProcessPlan[@uid = $uidRef]) or (self::ProductClass and //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::Project and //Project[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::ProjectRelationship and //ProjectRelationship[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Representation and //Representation[@uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementVersionRelationship and //RequirementVersionRelationship[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategory and //SpecificationCategory[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusion and //SpecificationInclusion[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::StyledModel and //Representation[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',substring-after(@xsi:type,':'))]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::ViewOccurrenceRelationship and //ViewOccurrenceRelationship[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef])">(ModifyElement : <sch:value-of select="$uid"/>) The ModifyElement.CurrentDesignObject contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of DeltaChangeManagementObjectSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of DeltaChange.ChangeActivities :: PartProperty) DeltaChangeActivity.ChangeSet : DeltaChange) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ModifySingleElement"><!--(Ref to S) ModifySingleElement.CurrentDesignObject : DeltaChangeManagementObjectSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ModifySingleElement') or (self::DeltaChangeActivity and substring-after(@xsi:type,':')='ModifySingleElement'))]/CurrentDesignObject">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternatePartRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyOccurrenceRelationshipSubstitution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationshipSubstitution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssignmentObjectRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRealization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConfiguredAssemblyEffectivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DeltaChangeRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualAssemblyRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceRelationship  ReplacedUsageRelationship  SameTimeMachiningRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship  AlternatePartVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlan ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel  PlyAngleRepresentation  ReinforcementOrientationBasis ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategory ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)] or //Activity[@uid = $uidRef] or //ActivityAssignment[@uid = $uidRef] or //ActivityMethod[@uid = $uidRef] or //ActivityMethodAssignment[@uid = $uidRef] or //ActivityRelationship[@uid = $uidRef] or //AddressAssignment[@uid = $uidRef] or //PartRelationship[@uid = $uidRef and contains(' AlternatePartRelationship ',substring-after(@xsi:type,':'))] or //AlternativeSolution[@uid = $uidRef] or //ApprovalAssignment[@uid = $uidRef] or //AssemblyOccurrenceRelationshipSubstitution[@uid = $uidRef] or //AssemblyViewRelationshipSubstitution[@uid = $uidRef] or //AssignmentObjectRelationship[@uid = $uidRef] or //Breakdown[@uid = $uidRef] or //BreakdownElement[@uid = $uidRef] or //BreakdownElementRealization[@uid = $uidRef] or //BreakdownElementVersion[@uid = $uidRef] or //BreakdownElementVersionRelationship[@uid = $uidRef] or //BreakdownElementView[@uid = $uidRef] or //BreakdownElementViewRelationship[@uid = $uidRef] or //BreakdownVersion[@uid = $uidRef] or //BreakdownVersionAssignment[@uid = $uidRef] or //BreakdownVersionRelationship[@uid = $uidRef] or //CertificationAssignment[@uid = $uidRef] or //Class[@uid = $uidRef] or //Condition[@uid = $uidRef] or //ConditionAssignment[@uid = $uidRef] or //ConfiguredAssemblyEffectivity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //ContractAssignment[@uid = $uidRef] or //DateAndPersonAssignment[@uid = $uidRef] or //DateTimeAssignment[@uid = $uidRef] or //DeltaChangeRelationship[@uid = $uidRef] or //Document[@uid = $uidRef] or //DocumentAssignment[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //DocumentDefinitionRelationship[@uid = $uidRef] or //DocumentVersion[@uid = $uidRef] or //DocumentVersionRelationship[@uid = $uidRef] or //Effectivity[@uid = $uidRef] or //EffectivityAssignment[@uid = $uidRef] or //Event[@uid = $uidRef] or //EventAssignment[@uid = $uidRef] or //ExternalOwlClass[@uid = $uidRef] or //File[@uid = $uidRef] or //IndividualAssemblyRelationship[@uid = $uidRef] or //IndividualPart[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //IndividualPartVersionRelationship[@uid = $uidRef] or //IndividualPartView[@uid = $uidRef] or //IndividualPartViewRelationship[@uid = $uidRef] or //InformationUsageRightAssignment[@uid = $uidRef] or //MaterialIdentification[@uid = $uidRef] or //MaterialPropertyAssignment[@uid = $uidRef] or //ModelPropertyAssignment[@uid = $uidRef] or //ObservationAssignment[@uid = $uidRef] or //ObservationConsequence[@uid = $uidRef] or //Occurrence[@uid = $uidRef] or //OccurrenceRelationship[@uid = $uidRef] or //Organization[@uid = $uidRef] or //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef] or //Part[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //PartVersionRelationship[@uid = $uidRef] or //PartView[@uid = $uidRef] or //PartViewRelationship[@uid = $uidRef] or //Person[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProcessOperationDefinition[@uid = $uidRef] or //ProcessOperationOccurrence[@uid = $uidRef] or //ProcessOperationResourceAssignment[@uid = $uidRef] or //ProcessPlan[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef] or //ProjectAssignment[@uid = $uidRef] or //ProjectRelationship[@uid = $uidRef] or //PropertyDefinitionAssignment[@uid = $uidRef] or //PropertyDefinitionRelationship[@uid = $uidRef] or //PropertyValue[@uid = $uidRef] or //PropertyValueAssignment[@uid = $uidRef] or //PropertyValueRelationship[@uid = $uidRef] or //Representation[@uid = $uidRef] or //Requirement[@uid = $uidRef] or //RequirementAssignment[@uid = $uidRef] or //RequirementVersion[@uid = $uidRef] or //RequirementVersionRelationship[@uid = $uidRef] or //RequirementView[@uid = $uidRef] or //RequirementViewRelationship[@uid = $uidRef] or //SecurityClassificationAssignment[@uid = $uidRef] or //Specification[@uid = $uidRef] or //SpecificationAssignment[@uid = $uidRef] or //SpecificationCategory[@uid = $uidRef] or //SpecificationCategoryAssignment[@uid = $uidRef] or //SpecificationConditionAssignment[@uid = $uidRef] or //SpecificationInclusion[@uid = $uidRef] or //SpecificationInclusionAssignment[@uid = $uidRef] or //Representation[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',substring-after(@xsi:type,':'))] or //TimeIntervalAssignment[@uid = $uidRef] or //ViewOccurrenceRelationship[@uid = $uidRef] or //WorkOrderAssignment[@uid = $uidRef] or //WorkRequestAssignment[@uid = $uidRef]">(ModifySingleElement : <sch:value-of select="$uid"/>) The ModifySingleElement.CurrentDesignObject contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of DeltaChangeManagementObjectSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ModifySingleElement.PreviousDesignObject : DeltaChangeManagementObjectSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ModifySingleElement') or (self::DeltaChangeActivity and substring-after(@xsi:type,':')='ModifySingleElement'))]/PreviousDesignObject">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternatePartRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyOccurrenceRelationshipSubstitution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationshipSubstitution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssignmentObjectRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRealization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConfiguredAssemblyEffectivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DeltaChangeRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualAssemblyRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceRelationship  ReplacedUsageRelationship  SameTimeMachiningRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship  AlternatePartVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlan ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel  PlyAngleRepresentation  ReinforcementOrientationBasis ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategory ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)] or //Activity[@uid = $uidRef] or //ActivityAssignment[@uid = $uidRef] or //ActivityMethod[@uid = $uidRef] or //ActivityMethodAssignment[@uid = $uidRef] or //ActivityRelationship[@uid = $uidRef] or //AddressAssignment[@uid = $uidRef] or //PartRelationship[@uid = $uidRef and contains(' AlternatePartRelationship ',substring-after(@xsi:type,':'))] or //AlternativeSolution[@uid = $uidRef] or //ApprovalAssignment[@uid = $uidRef] or //AssemblyOccurrenceRelationshipSubstitution[@uid = $uidRef] or //AssemblyViewRelationshipSubstitution[@uid = $uidRef] or //AssignmentObjectRelationship[@uid = $uidRef] or //Breakdown[@uid = $uidRef] or //BreakdownElement[@uid = $uidRef] or //BreakdownElementRealization[@uid = $uidRef] or //BreakdownElementVersion[@uid = $uidRef] or //BreakdownElementVersionRelationship[@uid = $uidRef] or //BreakdownElementView[@uid = $uidRef] or //BreakdownElementViewRelationship[@uid = $uidRef] or //BreakdownVersion[@uid = $uidRef] or //BreakdownVersionAssignment[@uid = $uidRef] or //BreakdownVersionRelationship[@uid = $uidRef] or //CertificationAssignment[@uid = $uidRef] or //Class[@uid = $uidRef] or //Condition[@uid = $uidRef] or //ConditionAssignment[@uid = $uidRef] or //ConfiguredAssemblyEffectivity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //ContractAssignment[@uid = $uidRef] or //DateAndPersonAssignment[@uid = $uidRef] or //DateTimeAssignment[@uid = $uidRef] or //DeltaChangeRelationship[@uid = $uidRef] or //Document[@uid = $uidRef] or //DocumentAssignment[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //DocumentDefinitionRelationship[@uid = $uidRef] or //DocumentVersion[@uid = $uidRef] or //DocumentVersionRelationship[@uid = $uidRef] or //Effectivity[@uid = $uidRef] or //EffectivityAssignment[@uid = $uidRef] or //Event[@uid = $uidRef] or //EventAssignment[@uid = $uidRef] or //ExternalOwlClass[@uid = $uidRef] or //File[@uid = $uidRef] or //IndividualAssemblyRelationship[@uid = $uidRef] or //IndividualPart[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //IndividualPartVersionRelationship[@uid = $uidRef] or //IndividualPartView[@uid = $uidRef] or //IndividualPartViewRelationship[@uid = $uidRef] or //InformationUsageRightAssignment[@uid = $uidRef] or //MaterialIdentification[@uid = $uidRef] or //MaterialPropertyAssignment[@uid = $uidRef] or //ModelPropertyAssignment[@uid = $uidRef] or //ObservationAssignment[@uid = $uidRef] or //ObservationConsequence[@uid = $uidRef] or //Occurrence[@uid = $uidRef] or //OccurrenceRelationship[@uid = $uidRef] or //Organization[@uid = $uidRef] or //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef] or //Part[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //PartVersionRelationship[@uid = $uidRef] or //PartView[@uid = $uidRef] or //PartViewRelationship[@uid = $uidRef] or //Person[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProcessOperationDefinition[@uid = $uidRef] or //ProcessOperationOccurrence[@uid = $uidRef] or //ProcessOperationResourceAssignment[@uid = $uidRef] or //ProcessPlan[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef] or //ProjectAssignment[@uid = $uidRef] or //ProjectRelationship[@uid = $uidRef] or //PropertyDefinitionAssignment[@uid = $uidRef] or //PropertyDefinitionRelationship[@uid = $uidRef] or //PropertyValue[@uid = $uidRef] or //PropertyValueAssignment[@uid = $uidRef] or //PropertyValueRelationship[@uid = $uidRef] or //Representation[@uid = $uidRef] or //Requirement[@uid = $uidRef] or //RequirementAssignment[@uid = $uidRef] or //RequirementVersion[@uid = $uidRef] or //RequirementVersionRelationship[@uid = $uidRef] or //RequirementView[@uid = $uidRef] or //RequirementViewRelationship[@uid = $uidRef] or //SecurityClassificationAssignment[@uid = $uidRef] or //Specification[@uid = $uidRef] or //SpecificationAssignment[@uid = $uidRef] or //SpecificationCategory[@uid = $uidRef] or //SpecificationCategoryAssignment[@uid = $uidRef] or //SpecificationConditionAssignment[@uid = $uidRef] or //SpecificationInclusion[@uid = $uidRef] or //SpecificationInclusionAssignment[@uid = $uidRef] or //Representation[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',substring-after(@xsi:type,':'))] or //TimeIntervalAssignment[@uid = $uidRef] or //ViewOccurrenceRelationship[@uid = $uidRef] or //WorkOrderAssignment[@uid = $uidRef] or //WorkRequestAssignment[@uid = $uidRef]">(ModifySingleElement : <sch:value-of select="$uid"/>) The ModifySingleElement.PreviousDesignObject contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of DeltaChangeManagementObjectSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of DeltaChange.ChangeActivities :: PartProperty) DeltaChangeActivity.ChangeSet : DeltaChange) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="MomentsOfInertia"><!--(Ref to E) MomentsOfInertia.DefinedIn : GeometricCoordinateSpace (kind=SINGLE - redefined=ShapeDependentProperty.DefinedIn)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MomentsOfInertia') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='MomentsOfInertia'))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricCoordinateSpace'] or //RepresentationContext[@uid = $uidRef and contains(' GeometricCoordinateSpace ',substring-after(@xsi:type,':'))]">(MomentsOfInertia : <sch:value-of select="$uid"/>) The MomentsOfInertia.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricCoordinateSpace.</sch:assert>
      </sch:rule>
      <!--(Ref to E) MomentsOfInertia.ReferenceAxisPlacement : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MomentsOfInertia') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='MomentsOfInertia'))]/ReferenceAxisPlacement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(MomentsOfInertia : <sch:value-of select="$uid"/>) The MomentsOfInertia.ReferenceAxisPlacement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeDependentProperty.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MomentsOfInertia') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='MomentsOfInertia'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(MomentsOfInertia : <sch:value-of select="$uid"/>) The MomentsOfInertia.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeDependentProperty.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MomentsOfInertia') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='MomentsOfInertia'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(MomentsOfInertia : <sch:value-of select="$uid"/>) The MomentsOfInertia.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeDependentProperty.ValueDetermination : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MomentsOfInertia') or (self::ShapeDependentProperty and substring-after(@xsi:type,':')='MomentsOfInertia'))]/ValueDetermination/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(MomentsOfInertia : <sch:value-of select="$uid"/>) The MomentsOfInertia.ValueDetermination contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="MotionModelAssociation"><!--(Ref to S) MotionModelAssociation.AssociatedModel : MotionModelSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='MotionModelAssociation') or (self::MotionModelAssociation and not(@xsi:type)))]/AssociatedModel">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' InterpolatedConfigurationModel ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' LinkMotionAlongPath ',@typeRef)] or //Representation[@uid = $uidRef and contains(' InterpolatedConfigurationModel ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' LinkMotionAlongPath ',substring-after(@xsi:type,':'))]">(MotionModelAssociation : <sch:value-of select="$uid"/>) The MotionModelAssociation.AssociatedModel contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of MotionModelSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="NamedSize"><!--(Ref to S) NamedSize.Size : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NamedSize') or (self::RectangularSize and substring-after(@xsi:type,':')='NamedSize'))]/Size/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(NamedSize : <sch:value-of select="$uid"/>) The NamedSize.Size contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="NextAssemblyOccurrenceUsage"><!--(Default Value) NextAssemblyOccurrenceUsage.RelationType : String = 'next assembly occurrence' (kind=SINGLE - redefined=ViewOccurrenceRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextAssemblyOccurrenceUsage') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='NextAssemblyOccurrenceUsage'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'next assembly occurrence'">(NextAssemblyOccurrenceUsage : <sch:value-of select="$uid"/>) The NextAssemblyOccurrenceUsage.RelationType contains the wrong value () must be 'next assembly occurrence'.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssemblyOccurrenceRelationship.Placement : OPTIONAL SET[1:unbounded] OF TransformationAndAssociationSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextAssemblyOccurrenceUsage') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='NextAssemblyOccurrenceUsage'))]/Placement/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::CartesianTransformation or (self::Transformation and contains(' CartesianTransformation ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)]) or (self::GeometricRepresentationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',@typeRef)]) or (self::GeometryToTopologyModelAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometryToTopologyModelAssociation ',@typeRef)]) or (self::TopologyToGeometryModelAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologyToGeometryModelAssociation ',@typeRef)]) or (self::CartesianTransformation) or (self::GeometricRepresentationRelationship and //RepresentationRelationship[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',substring-after(@xsi:type,':'))]) or (self::GeometryToTopologyModelAssociation and //RepresentationRelationship[@uid = $uidRef and contains(' GeometryToTopologyModelAssociation ',substring-after(@xsi:type,':'))]) or (self::TopologyToGeometryModelAssociation and //RepresentationRelationship[@uid = $uidRef and contains(' TopologyToGeometryModelAssociation ',substring-after(@xsi:type,':'))])">(NextAssemblyOccurrenceUsage : <sch:value-of select="$uid"/>) The NextAssemblyOccurrenceUsage.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of TransformationAndAssociationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ViewOccurrenceRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextAssemblyOccurrenceUsage') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='NextAssemblyOccurrenceUsage'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(NextAssemblyOccurrenceUsage : <sch:value-of select="$uid"/>) The NextAssemblyOccurrenceUsage.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ViewOccurrenceRelationship.Related : DefinitionBasedOccurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextAssemblyOccurrenceUsage') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='NextAssemblyOccurrenceUsage'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DefinitionBasedOccurrence'] or //Occurrence[@uid = $uidRef and contains(' DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence ',substring-after(@xsi:type,':'))]">(NextAssemblyOccurrenceUsage : <sch:value-of select="$uid"/>) The NextAssemblyOccurrenceUsage.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DefinitionBasedOccurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ViewOccurrenceRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextAssemblyOccurrenceUsage') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='NextAssemblyOccurrenceUsage'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(NextAssemblyOccurrenceUsage : <sch:value-of select="$uid"/>) The NextAssemblyOccurrenceUsage.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="NextAssemblyViewUsage"><!--(Default Value) NextAssemblyViewUsage.RelationType : String = 'next assembly view' (kind=SINGLE - redefined=PartViewRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextAssemblyViewUsage') or (self::PartViewRelationship and substring-after(@xsi:type,':')='NextAssemblyViewUsage'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'next assembly view'">(NextAssemblyViewUsage : <sch:value-of select="$uid"/>) The NextAssemblyViewUsage.RelationType contains the wrong value () must be 'next assembly view'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AssemblyViewRelationship.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextAssemblyViewUsage') or (self::PartViewRelationship and substring-after(@xsi:type,':')='NextAssemblyViewUsage'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(NextAssemblyViewUsage : <sch:value-of select="$uid"/>) The NextAssemblyViewUsage.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextAssemblyViewUsage') or (self::PartViewRelationship and substring-after(@xsi:type,':')='NextAssemblyViewUsage'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(NextAssemblyViewUsage : <sch:value-of select="$uid"/>) The NextAssemblyViewUsage.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.Related : PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextAssemblyViewUsage') or (self::PartViewRelationship and substring-after(@xsi:type,':')='NextAssemblyViewUsage'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(NextAssemblyViewUsage : <sch:value-of select="$uid"/>) The NextAssemblyViewUsage.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextAssemblyViewUsage') or (self::PartViewRelationship and substring-after(@xsi:type,':')='NextAssemblyViewUsage'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(NextAssemblyViewUsage : <sch:value-of select="$uid"/>) The NextAssemblyViewUsage.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="NextInstanceForward"><!--(Ref to S) ExternalItem.Source : OPTIONAL ExternalSourceSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextInstanceForward') or (self::NextInstanceForward or (self::ExternalItem and substring-after(@xsi:type,':')='NextInstanceForward') or (self::NextInstance and substring-after(@xsi:type,':')='NextInstanceForward') or (self::NextInstance and substring-after(@xsi:type,':')='NextInstanceForward') or (self::External and substring-after(@xsi:type,':')='NextInstanceForward')))]/Source/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DigitalFile and //ExternalRefBaseObject[@uid = $uidRef and contains(' DigitalFile ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::DigitalFile and //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]) or (self::Document and //Document[@uid = $uidRef]) or (self::IdentifierSet) or (self::Identifier) or (self::IdentifierString)">(NextInstanceForward : <sch:value-of select="$uid"/>) The NextInstanceForward.Source contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ExternalSourceSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="NextInstanceInverse"><!--(Ref to S) ExternalItem.Source : OPTIONAL ExternalSourceSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NextInstanceInverse') or (self::NextInstanceInverse or (self::ExternalItem and substring-after(@xsi:type,':')='NextInstanceInverse') or (self::NextInstance and substring-after(@xsi:type,':')='NextInstanceInverse') or (self::NextInstance and substring-after(@xsi:type,':')='NextInstanceInverse') or (self::External and substring-after(@xsi:type,':')='NextInstanceInverse')))]/Source/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DigitalFile and //ExternalRefBaseObject[@uid = $uidRef and contains(' DigitalFile ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::DigitalFile and //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]) or (self::Document and //Document[@uid = $uidRef]) or (self::IdentifierSet) or (self::Identifier) or (self::IdentifierString)">(NextInstanceInverse : <sch:value-of select="$uid"/>) The NextInstanceInverse.Source contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ExternalSourceSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Nominal3dDerivedFeature"><!--(Ref to E) Nominal3dDerivedFeature.DerivedFrom : SET[1:unbounded] OF Nominal3dFeature (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Nominal3dDerivedFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='Nominal3dDerivedFeature'))]/DerivedFrom/Nominal3dFeature">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Nominal3dFeature'] or //ShapeElement[@uid = $uidRef and contains(' Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge ',substring-after(@xsi:type,':'))]">(Nominal3dDerivedFeature : <sch:value-of select="$uid"/>) The Nominal3dDerivedFeature.DerivedFrom contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Nominal3dFeature.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Nominal3dDerivedFeature.RepresentedGeometry : Nominal3dDerivedFeatureSelect (kind=SINGLE - redefined=ShapeElement.RepresentedGeometry)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Nominal3dDerivedFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='Nominal3dDerivedFeature'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(Nominal3dDerivedFeature : <sch:value-of select="$uid"/>) The Nominal3dDerivedFeature.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of Nominal3dDerivedFeatureSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartShapeElement.PartDefinition : OPTIONAL PartShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Nominal3dDerivedFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='Nominal3dDerivedFeature'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(Nominal3dDerivedFeature : <sch:value-of select="$uid"/>) The Nominal3dDerivedFeature.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Nominal3dDerivedFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='Nominal3dDerivedFeature'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Nominal3dDerivedFeature : <sch:value-of select="$uid"/>) The Nominal3dDerivedFeature.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Nominal3dEdge"><!--(Ref to E) Nominal3dEdge.RepresentedGeometry : EdgeCurve (kind=SINGLE - redefined=Nominal3dIntegralFeature.RepresentedGeometry)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Nominal3dEdge') or (self::ShapeElement and substring-after(@xsi:type,':')='Nominal3dEdge'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'EdgeCurve'] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))]">(Nominal3dEdge : <sch:value-of select="$uid"/>) The Nominal3dEdge.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type EdgeCurve.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartShapeElement.PartDefinition : OPTIONAL PartShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Nominal3dEdge') or (self::ShapeElement and substring-after(@xsi:type,':')='Nominal3dEdge'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(Nominal3dEdge : <sch:value-of select="$uid"/>) The Nominal3dEdge.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Nominal3dEdge') or (self::ShapeElement and substring-after(@xsi:type,':')='Nominal3dEdge'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Nominal3dEdge : <sch:value-of select="$uid"/>) The Nominal3dEdge.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Nominal3dIntegralFeature"><!--(Ref to S) Nominal3dIntegralFeature.RepresentedGeometry : Nominal3dIntegralFeatureGeometrySelect (kind=SINGLE - redefined=ShapeElement.RepresentedGeometry)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Nominal3dIntegralFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='Nominal3dIntegralFeature'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))]">(Nominal3dIntegralFeature : <sch:value-of select="$uid"/>) The Nominal3dIntegralFeature.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of Nominal3dIntegralFeatureGeometrySelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartShapeElement.PartDefinition : OPTIONAL PartShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Nominal3dIntegralFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='Nominal3dIntegralFeature'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(Nominal3dIntegralFeature : <sch:value-of select="$uid"/>) The Nominal3dIntegralFeature.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Nominal3dIntegralFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='Nominal3dIntegralFeature'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Nominal3dIntegralFeature : <sch:value-of select="$uid"/>) The Nominal3dIntegralFeature.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="NonUniformZoneDefinition"><!--(Ref to E) ToleranceZoneDefinition.Boundaries : OPTIONAL SET[1:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NonUniformZoneDefinition') or (self::ToleranceZoneDefinition and substring-after(@xsi:type,':')='NonUniformZoneDefinition'))]/Boundaries/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Boundaries/ShapeElement) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(NonUniformZoneDefinition : <sch:value-of select="$uid"/>) The NonUniformZoneDefinition.Boundaries contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="NotCondition"><!--(Default Value) NotCondition.ConditionType : String = 'not' (kind=SINGLE - redefined=Condition.ConditionType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NotCondition') or (self::Condition and substring-after(@xsi:type,':')='NotCondition'))]/ConditionType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'not'">(NotCondition : <sch:value-of select="$uid"/>) The NotCondition.ConditionType contains the wrong value () must be 'not'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Condition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NotCondition') or (self::NotCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='NotCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='NotCondition')))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(NotCondition : <sch:value-of select="$uid"/>) The NotCondition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Condition.ConditionType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NotCondition') or (self::NotCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='NotCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='NotCondition')))]/ConditionType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(NotCondition : <sch:value-of select="$uid"/>) The NotCondition.ConditionType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Condition.Parameters : SET[1:unbounded] OF ParameterSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NotCondition') or (self::NotCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='NotCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='NotCondition')))]/Parameters/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ConditionParameter and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionParameter ',@typeRef)]) or (self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternativeSolutionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolutionRelationship ',@typeRef)]) or (self::Approval and //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConditionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionRelationship ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::Descriptor and //ExternalRefBaseObject[@uid = $uidRef and contains(' Descriptor ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::EffectivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::FileRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::Observation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::ObservationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::ProcessOperationDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinitionRelationship ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlanRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlanRelationship ',@typeRef)]) or (self::ProductClassRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClassRelationship ',@typeRef)]) or (self::ProductConcept and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::ProductConfigurationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkOrderRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderRelationship ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::WorkRequestRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestRelationship ',@typeRef)]) or (self::ConditionParameter) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternativeSolutionRelationship and //AlternativeSolutionRelationship[@uid = $uidRef]) or (self::Approval and //Approval[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::Condition) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConditionRelationship and //ConditionRelationship[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DateTimeString) or (self::Descriptor and //Descriptor[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::EffectivityRelationship and //EffectivityRelationship[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::FileRelationship and //FileRelationship[@uid = $uidRef]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::Observation and //Observation[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::ObservationRelationship and //ObservationRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::ProcessOperationDefinitionRelationship and //ProcessOperationDefinitionRelationship[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlanRelationship and //ProcessPlanRelationship[@uid = $uidRef]) or (self::ProductClassRelationship and //ProductClassRelationship[@uid = $uidRef]) or (self::ProductConcept and //ProductConcept[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProductConfigurationRelationship and //ProductConfigurationRelationship[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkOrderRelationship and //WorkOrderRelationship[@uid = $uidRef]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef]) or (self::WorkRequestRelationship and //WorkRequestRelationship[@uid = $uidRef])">(NotCondition : <sch:value-of select="$uid"/>) The NotCondition.Parameters contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ParameterSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="NotEqualsCondition"><!--(Default Value) NotEqualsCondition.ConditionType : String = 'not equals' (kind=SINGLE - redefined=Condition.ConditionType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NotEqualsCondition') or (self::Condition and substring-after(@xsi:type,':')='NotEqualsCondition'))]/ConditionType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'not equals'">(NotEqualsCondition : <sch:value-of select="$uid"/>) The NotEqualsCondition.ConditionType contains the wrong value () must be 'not equals'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Condition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NotEqualsCondition') or (self::NotEqualsCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='NotEqualsCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='NotEqualsCondition')))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(NotEqualsCondition : <sch:value-of select="$uid"/>) The NotEqualsCondition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Condition.ConditionType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NotEqualsCondition') or (self::NotEqualsCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='NotEqualsCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='NotEqualsCondition')))]/ConditionType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(NotEqualsCondition : <sch:value-of select="$uid"/>) The NotEqualsCondition.ConditionType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Condition.Parameters : SET[1:unbounded] OF ParameterSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NotEqualsCondition') or (self::NotEqualsCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='NotEqualsCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='NotEqualsCondition')))]/Parameters/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ConditionParameter and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionParameter ',@typeRef)]) or (self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternativeSolutionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolutionRelationship ',@typeRef)]) or (self::Approval and //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConditionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionRelationship ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::Descriptor and //ExternalRefBaseObject[@uid = $uidRef and contains(' Descriptor ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::EffectivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::FileRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::Observation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::ObservationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::ProcessOperationDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinitionRelationship ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlanRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlanRelationship ',@typeRef)]) or (self::ProductClassRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClassRelationship ',@typeRef)]) or (self::ProductConcept and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::ProductConfigurationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkOrderRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderRelationship ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::WorkRequestRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestRelationship ',@typeRef)]) or (self::ConditionParameter) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternativeSolutionRelationship and //AlternativeSolutionRelationship[@uid = $uidRef]) or (self::Approval and //Approval[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::Condition) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConditionRelationship and //ConditionRelationship[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DateTimeString) or (self::Descriptor and //Descriptor[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::EffectivityRelationship and //EffectivityRelationship[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::FileRelationship and //FileRelationship[@uid = $uidRef]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::Observation and //Observation[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::ObservationRelationship and //ObservationRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::ProcessOperationDefinitionRelationship and //ProcessOperationDefinitionRelationship[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlanRelationship and //ProcessPlanRelationship[@uid = $uidRef]) or (self::ProductClassRelationship and //ProductClassRelationship[@uid = $uidRef]) or (self::ProductConcept and //ProductConcept[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProductConfigurationRelationship and //ProductConfigurationRelationship[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkOrderRelationship and //WorkOrderRelationship[@uid = $uidRef]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef]) or (self::WorkRequestRelationship and //WorkRequestRelationship[@uid = $uidRef])">(NotEqualsCondition : <sch:value-of select="$uid"/>) The NotEqualsCondition.Parameters contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ParameterSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="NumericalContext"><!--(Ref to E) NumericalContext.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NumericalContext') or (self::NumericalContext and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(NumericalContext : <sch:value-of select="$uid"/>) The NumericalContext.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="NumericalValue"><!--(Ref to E) NumericalValue.ValueContext : OPTIONAL NumericalContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NumericalValue') or (self::NumericalValue or (self::BevelAngle and substring-after(@xsi:type,':')='NumericalValue') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='NumericalValue') or (self::Weight and substring-after(@xsi:type,':')='NumericalValue') or (self::RealWorldScale and substring-after(@xsi:type,':')='NumericalValue') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='NumericalValue') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='NumericalValue') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='NumericalValue') or (self::UnitLength and substring-after(@xsi:type,':')='NumericalValue') or (self::FirstUnitSize and substring-after(@xsi:type,':')='NumericalValue') or (self::SecondUnitSize and substring-after(@xsi:type,':')='NumericalValue') or (self::ForcedLength and substring-after(@xsi:type,':')='NumericalValue') or (self::TotalThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::VolumePercent and substring-after(@xsi:type,':')='NumericalValue') or (self::PlyThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::TotalThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::Diameter and substring-after(@xsi:type,':')='NumericalValue') or (self::Diameter and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetLength and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetWidth and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetLength and substring-after(@xsi:type,':')='NumericalValue') or (self::Thickness and substring-after(@xsi:type,':')='NumericalValue')))]/ValueContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ValueContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'NumericalContext'] or //NumericalContext[@uid = $uidRef]">(NumericalValue : <sch:value-of select="$uid"/>) The NumericalValue.ValueContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type NumericalContext.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ValueWithUnit.Unit : UnitSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NumericalValue') or (self::NumericalValue or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::BevelAngle and substring-after(@xsi:type,':')='NumericalValue') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::Weight and substring-after(@xsi:type,':')='NumericalValue') or (self::RealWorldScale and substring-after(@xsi:type,':')='NumericalValue') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='NumericalValue') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='NumericalValue') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='NumericalValue') or (self::Fiber11Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::ModifierValue and substring-after(@xsi:type,':')='NumericalValue') or (self::Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::IndexValue and substring-after(@xsi:type,':')='NumericalValue') or (self::DimensionValue and substring-after(@xsi:type,':')='NumericalValue') or (self::UnitLength and substring-after(@xsi:type,':')='NumericalValue') or (self::FirstUnitSize and substring-after(@xsi:type,':')='NumericalValue') or (self::SecondUnitSize and substring-after(@xsi:type,':')='NumericalValue') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='NumericalValue') or (self::ToleranceValue and substring-after(@xsi:type,':')='NumericalValue') or (self::ForcedLength and substring-after(@xsi:type,':')='NumericalValue') or (self::LotSize and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::TotalThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::VolumePercent and substring-after(@xsi:type,':')='NumericalValue') or (self::PlyThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::ProjectionLength and substring-after(@xsi:type,':')='NumericalValue') or (self::Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Density and substring-after(@xsi:type,':')='NumericalValue') or (self::Height and substring-after(@xsi:type,':')='NumericalValue') or (self::Width and substring-after(@xsi:type,':')='NumericalValue') or (self::FileSize and substring-after(@xsi:type,':')='NumericalValue') or (self::PageCount and substring-after(@xsi:type,':')='NumericalValue') or (self::TotalThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::Diameter and substring-after(@xsi:type,':')='NumericalValue') or (self::Diameter and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetLength and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetWidth and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetLength and substring-after(@xsi:type,':')='NumericalValue') or (self::Thickness and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::TwistPeriod and substring-after(@xsi:type,':')='NumericalValue')))]/Unit">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)] or //ExternalUnit[@uid = $uidRef] or //Unit[@uid = $uidRef]">(NumericalValue : <sch:value-of select="$uid"/>) The NumericalValue.Unit contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyValue.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NumericalValue') or (self::NumericalValue or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::BevelAngle and substring-after(@xsi:type,':')='NumericalValue') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::Weight and substring-after(@xsi:type,':')='NumericalValue') or (self::RealWorldScale and substring-after(@xsi:type,':')='NumericalValue') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='NumericalValue') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='NumericalValue') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='NumericalValue') or (self::Fiber11Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::ModifierValue and substring-after(@xsi:type,':')='NumericalValue') or (self::Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='NumericalValue') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='NumericalValue') or (self::IndexValue and substring-after(@xsi:type,':')='NumericalValue') or (self::DimensionValue and substring-after(@xsi:type,':')='NumericalValue') or (self::UnitLength and substring-after(@xsi:type,':')='NumericalValue') or (self::FirstUnitSize and substring-after(@xsi:type,':')='NumericalValue') or (self::SecondUnitSize and substring-after(@xsi:type,':')='NumericalValue') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='NumericalValue') or (self::ToleranceValue and substring-after(@xsi:type,':')='NumericalValue') or (self::ForcedLength and substring-after(@xsi:type,':')='NumericalValue') or (self::LotSize and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::MaterialValue and substring-after(@xsi:type,':')='NumericalValue') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::TotalThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::VolumePercent and substring-after(@xsi:type,':')='NumericalValue') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='NumericalValue') or (self::PlyThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::WaitingTime and substring-after(@xsi:type,':')='NumericalValue') or (self::ProjectionLength and substring-after(@xsi:type,':')='NumericalValue') or (self::Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Density and substring-after(@xsi:type,':')='NumericalValue') or (self::Height and substring-after(@xsi:type,':')='NumericalValue') or (self::Width and substring-after(@xsi:type,':')='NumericalValue') or (self::FileSize and substring-after(@xsi:type,':')='NumericalValue') or (self::PageCount and substring-after(@xsi:type,':')='NumericalValue') or (self::TotalThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::Diameter and substring-after(@xsi:type,':')='NumericalValue') or (self::Diameter and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetLength and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetWidth and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetLength and substring-after(@xsi:type,':')='NumericalValue') or (self::Thickness and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::TwistPeriod and substring-after(@xsi:type,':')='NumericalValue')))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(NumericalValue : <sch:value-of select="$uid"/>) The NumericalValue.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.Definition : OPTIONAL PropertyDefinitionSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NumericalValue') or (self::NumericalValue or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::BevelAngle and substring-after(@xsi:type,':')='NumericalValue') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::Weight and substring-after(@xsi:type,':')='NumericalValue') or (self::RealWorldScale and substring-after(@xsi:type,':')='NumericalValue') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='NumericalValue') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='NumericalValue') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='NumericalValue') or (self::Fiber11Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::ModifierValue and substring-after(@xsi:type,':')='NumericalValue') or (self::Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='NumericalValue') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='NumericalValue') or (self::IndexValue and substring-after(@xsi:type,':')='NumericalValue') or (self::DimensionValue and substring-after(@xsi:type,':')='NumericalValue') or (self::UnitLength and substring-after(@xsi:type,':')='NumericalValue') or (self::FirstUnitSize and substring-after(@xsi:type,':')='NumericalValue') or (self::SecondUnitSize and substring-after(@xsi:type,':')='NumericalValue') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='NumericalValue') or (self::ToleranceValue and substring-after(@xsi:type,':')='NumericalValue') or (self::ForcedLength and substring-after(@xsi:type,':')='NumericalValue') or (self::LotSize and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::MaterialValue and substring-after(@xsi:type,':')='NumericalValue') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::TotalThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::VolumePercent and substring-after(@xsi:type,':')='NumericalValue') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='NumericalValue') or (self::PlyThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::WaitingTime and substring-after(@xsi:type,':')='NumericalValue') or (self::ProjectionLength and substring-after(@xsi:type,':')='NumericalValue') or (self::Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Density and substring-after(@xsi:type,':')='NumericalValue') or (self::Height and substring-after(@xsi:type,':')='NumericalValue') or (self::Width and substring-after(@xsi:type,':')='NumericalValue') or (self::FileSize and substring-after(@xsi:type,':')='NumericalValue') or (self::PageCount and substring-after(@xsi:type,':')='NumericalValue') or (self::TotalThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::Diameter and substring-after(@xsi:type,':')='NumericalValue') or (self::Diameter and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetLength and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetWidth and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetLength and substring-after(@xsi:type,':')='NumericalValue') or (self::Thickness and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::TwistPeriod and substring-after(@xsi:type,':')='NumericalValue')))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionEnum) or (self::PropertyDefinitionString)">(NumericalValue : <sch:value-of select="$uid"/>) The NumericalValue.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PropertyDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.DeterminationMethod : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NumericalValue') or (self::NumericalValue or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::BevelAngle and substring-after(@xsi:type,':')='NumericalValue') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::Weight and substring-after(@xsi:type,':')='NumericalValue') or (self::RealWorldScale and substring-after(@xsi:type,':')='NumericalValue') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='NumericalValue') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='NumericalValue') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='NumericalValue') or (self::Fiber11Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::ModifierValue and substring-after(@xsi:type,':')='NumericalValue') or (self::Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='NumericalValue') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='NumericalValue') or (self::IndexValue and substring-after(@xsi:type,':')='NumericalValue') or (self::DimensionValue and substring-after(@xsi:type,':')='NumericalValue') or (self::UnitLength and substring-after(@xsi:type,':')='NumericalValue') or (self::FirstUnitSize and substring-after(@xsi:type,':')='NumericalValue') or (self::SecondUnitSize and substring-after(@xsi:type,':')='NumericalValue') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='NumericalValue') or (self::ToleranceValue and substring-after(@xsi:type,':')='NumericalValue') or (self::ForcedLength and substring-after(@xsi:type,':')='NumericalValue') or (self::LotSize and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::MaterialValue and substring-after(@xsi:type,':')='NumericalValue') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::TotalThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::VolumePercent and substring-after(@xsi:type,':')='NumericalValue') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='NumericalValue') or (self::PlyThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::WaitingTime and substring-after(@xsi:type,':')='NumericalValue') or (self::ProjectionLength and substring-after(@xsi:type,':')='NumericalValue') or (self::Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Density and substring-after(@xsi:type,':')='NumericalValue') or (self::Height and substring-after(@xsi:type,':')='NumericalValue') or (self::Width and substring-after(@xsi:type,':')='NumericalValue') or (self::FileSize and substring-after(@xsi:type,':')='NumericalValue') or (self::PageCount and substring-after(@xsi:type,':')='NumericalValue') or (self::TotalThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::Diameter and substring-after(@xsi:type,':')='NumericalValue') or (self::Diameter and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetLength and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetWidth and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetLength and substring-after(@xsi:type,':')='NumericalValue') or (self::Thickness and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::TwistPeriod and substring-after(@xsi:type,':')='NumericalValue')))]/DeterminationMethod/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(NumericalValue : <sch:value-of select="$uid"/>) The NumericalValue.DeterminationMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.Qualifiers : OPTIONAL SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='NumericalValue') or (self::NumericalValue or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::BevelAngle and substring-after(@xsi:type,':')='NumericalValue') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::Weight and substring-after(@xsi:type,':')='NumericalValue') or (self::RealWorldScale and substring-after(@xsi:type,':')='NumericalValue') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='NumericalValue') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='NumericalValue') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='NumericalValue') or (self::Fiber11Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::ModifierValue and substring-after(@xsi:type,':')='NumericalValue') or (self::Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='NumericalValue') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='NumericalValue') or (self::IndexValue and substring-after(@xsi:type,':')='NumericalValue') or (self::DimensionValue and substring-after(@xsi:type,':')='NumericalValue') or (self::UnitLength and substring-after(@xsi:type,':')='NumericalValue') or (self::FirstUnitSize and substring-after(@xsi:type,':')='NumericalValue') or (self::SecondUnitSize and substring-after(@xsi:type,':')='NumericalValue') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='NumericalValue') or (self::ToleranceValue and substring-after(@xsi:type,':')='NumericalValue') or (self::ForcedLength and substring-after(@xsi:type,':')='NumericalValue') or (self::LotSize and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::MaterialValue and substring-after(@xsi:type,':')='NumericalValue') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::TotalThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::VolumePercent and substring-after(@xsi:type,':')='NumericalValue') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='NumericalValue') or (self::PlyThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::WaitingTime and substring-after(@xsi:type,':')='NumericalValue') or (self::ProjectionLength and substring-after(@xsi:type,':')='NumericalValue') or (self::Offset and substring-after(@xsi:type,':')='NumericalValue') or (self::Quantity and substring-after(@xsi:type,':')='NumericalValue') or (self::Density and substring-after(@xsi:type,':')='NumericalValue') or (self::Height and substring-after(@xsi:type,':')='NumericalValue') or (self::Width and substring-after(@xsi:type,':')='NumericalValue') or (self::FileSize and substring-after(@xsi:type,':')='NumericalValue') or (self::PageCount and substring-after(@xsi:type,':')='NumericalValue') or (self::TotalThickness and substring-after(@xsi:type,':')='NumericalValue') or (self::Diameter and substring-after(@xsi:type,':')='NumericalValue') or (self::Diameter and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetLength and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetWidth and substring-after(@xsi:type,':')='NumericalValue') or (self::TargetLength and substring-after(@xsi:type,':')='NumericalValue') or (self::Thickness and substring-after(@xsi:type,':')='NumericalValue') or (self::Angle and substring-after(@xsi:type,':')='NumericalValue') or (self::TwistPeriod and substring-after(@xsi:type,':')='NumericalValue')))]/Qualifiers/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::ExternalTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalTypeQualifier ',@typeRef)]) or (self::PreDefinedTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PreDefinedTypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::ExternalTypeQualifier and //ExternalTypeQualifier[@uid = $uidRef]) or (self::PreDefinedTypeQualifier and //PreDefinedTypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(NumericalValue : <sch:value-of select="$uid"/>) The NumericalValue.Qualifiers contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Observation"><!--(Ref to E) Observation.AssociatedActivity : OPTIONAL ActualActivity (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Observation') or (self::Observation and not(@xsi:type)))]/AssociatedActivity">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./AssociatedActivity) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActualActivity'] or //Activity[@uid = $uidRef and contains(' ActualActivity  DirectedActualActivity ',substring-after(@xsi:type,':'))]">(Observation : <sch:value-of select="$uid"/>) The Observation.AssociatedActivity contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActualActivity.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Observation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Observation') or (self::Observation and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Observation : <sch:value-of select="$uid"/>) The Observation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Observation.ObservationContext : OPTIONAL SET[1:unbounded] OF ObservationContextSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Observation') or (self::Observation and not(@xsi:type)))]/ObservationContext/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternatePartRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternatePartRelationship ',@typeRef)]) or (self::AlternativeSolution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)]) or (self::AlternativeSolutionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolutionRelationship ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::AssemblyOccurrenceRelationshipSubstitution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyOccurrenceRelationshipSubstitution ',@typeRef)]) or (self::AssemblyViewRelationshipSubstitution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationshipSubstitution ',@typeRef)]) or (self::AssignmentObjectRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssignmentObjectRelationship ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementRealization and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRealization ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::BreakdownVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionRelationship ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConfiguredAssemblyEffectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConfiguredAssemblyEffectivity ',@typeRef)]) or (self::Contract and //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::DeltaChangeRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DeltaChangeRelationship ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::DocumentVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersionRelationship ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::EffectivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)]) or (self::Envelope and //ExternalRefBaseObject[@uid = $uidRef and contains(' Envelope ',@typeRef)]) or (self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::File and //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)]) or (self::FileRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)]) or (self::IndividualAssemblyRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualAssemblyRelationship ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialIdentification and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialIdentification ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::Message and //ExternalRefBaseObject[@uid = $uidRef and contains(' Message ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::Observation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::ObservationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)]) or (self::Occurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)]) or (self::OccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceRelationship  ReplacedUsageRelationship  SameTimeMachiningRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship  AlternatePartVersionRelationship ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::Person and //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::ProcessOperationDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinition ',@typeRef)]) or (self::ProcessOperationDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinitionRelationship ',@typeRef)]) or (self::ProcessOperationOccurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationOccurrence ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlan and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlan ',@typeRef)]) or (self::ProcessPlanRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlanRelationship ',@typeRef)]) or (self::ProductClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)]) or (self::ProductClassRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClassRelationship ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::ProductConfigurationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)]) or (self::Project and //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::ProjectRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectRelationship ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (self::Representation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel  PlyAngleRepresentation  ReinforcementOrientationBasis ',@typeRef)]) or (self::RepresentationItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' RepresentationItem  BooleanRepresentationItem  Callout  CompoundRepresentationItem  SequenceRepresentationItem  SetRepresentationItem  DateTimeRepresentationItem  DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface  ExternalRepresentationItem  ExternalTessellatedAnnotation  IntegerRepresentationItem  LogicalRepresentationItem  RationalRepresentationItem  RealRepresentationItem  StyledElement  AnnotationElement  AnnotationPlaceholderOccurrence  AnnotationPlane  OverRidingStyledElement  ContextDependentOverRidingStyledElement  StyledModelReplication  TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint  UserDefined11 ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersionRelationship ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategory and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategory ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusion ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::StyledModel and //ExternalRefBaseObject[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::ViewOccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship ',@typeRef)]) or (self::WorkOrder and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrder ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkOrderRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderRelationship ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::WorkRequestRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestRelationship ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternatePartRelationship and //PartRelationship[@uid = $uidRef and contains(' AlternatePartRelationship ',substring-after(@xsi:type,':'))]) or (self::AlternativeSolution and //AlternativeSolution[@uid = $uidRef]) or (self::AlternativeSolutionRelationship and //AlternativeSolutionRelationship[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::AssemblyOccurrenceRelationshipSubstitution and //AssemblyOccurrenceRelationshipSubstitution[@uid = $uidRef]) or (self::AssemblyViewRelationshipSubstitution and //AssemblyViewRelationshipSubstitution[@uid = $uidRef]) or (self::AssignmentObjectRelationship and //AssignmentObjectRelationship[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementRealization and //BreakdownElementRealization[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementVersionRelationship and //BreakdownElementVersionRelationship[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::BreakdownVersionRelationship and //BreakdownVersionRelationship[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Class and //Class[@uid = $uidRef]) or (self::Condition and //*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConfiguredAssemblyEffectivity and //ConfiguredAssemblyEffectivity[@uid = $uidRef]) or (self::Contract and //Contract[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DeltaChangeRelationship and //DeltaChangeRelationship[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::DocumentVersionRelationship and //DocumentVersionRelationship[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::EffectivityRelationship and //EffectivityRelationship[@uid = $uidRef]) or (self::Envelope and //Envelope[@uid = $uidRef]) or (self::Event and //Event[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef]) or (self::File and //File[@uid = $uidRef]) or (self::FileRelationship and //FileRelationship[@uid = $uidRef]) or (self::IndividualAssemblyRelationship and //IndividualAssemblyRelationship[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartVersionRelationship and //IndividualPartVersionRelationship[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialIdentification and //MaterialIdentification[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::Message and //Message[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::Observation and //Observation[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::ObservationRelationship and //ObservationRelationship[@uid = $uidRef]) or (self::Occurrence and //Occurrence[@uid = $uidRef]) or (self::OccurrenceRelationship and //OccurrenceRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartVersionRelationship and //PartVersionRelationship[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::Person and //Person[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef]) or (self::ProcessOperationDefinition and //ProcessOperationDefinition[@uid = $uidRef]) or (self::ProcessOperationDefinitionRelationship and //ProcessOperationDefinitionRelationship[@uid = $uidRef]) or (self::ProcessOperationOccurrence and //ProcessOperationOccurrence[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlan and //ProcessPlan[@uid = $uidRef]) or (self::ProcessPlanRelationship and //ProcessPlanRelationship[@uid = $uidRef]) or (self::ProductClass and //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))]) or (self::ProductClassRelationship and //ProductClassRelationship[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProductConfigurationRelationship and //ProductConfigurationRelationship[@uid = $uidRef]) or (self::Project and //Project[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::ProjectRelationship and //ProjectRelationship[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Representation and //Representation[@uid = $uidRef]) or (self::RepresentationItem and //RepresentationItem[@uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementVersionRelationship and //RequirementVersionRelationship[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategory and //SpecificationCategory[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusion and //SpecificationInclusion[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::StyledModel and //Representation[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',substring-after(@xsi:type,':'))]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::ViewOccurrenceRelationship and //ViewOccurrenceRelationship[@uid = $uidRef]) or (self::WorkOrder and //WorkOrder[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkOrderRelationship and //WorkOrderRelationship[@uid = $uidRef]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef]) or (self::WorkRequestRelationship and //WorkRequestRelationship[@uid = $uidRef])">(Observation : <sch:value-of select="$uid"/>) The Observation.ObservationContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ObservationContextSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Observation.ObservationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Observation') or (self::Observation and not(@xsi:type)))]/ObservationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Observation : <sch:value-of select="$uid"/>) The Observation.ObservationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Observation.ObservedBy : ObserverSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Observation') or (self::Observation and not(@xsi:type)))]/ObservedBy">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //DateAndPersonOrganization[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef]">(Observation : <sch:value-of select="$uid"/>) The Observation.ObservedBy contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ObserverSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Observation.Status : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Observation') or (self::Observation and not(@xsi:type)))]/Status/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Observation : <sch:value-of select="$uid"/>) The Observation.Status contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ObservationAssignment"><!--(Ref to E) ObservationAssignment.AssignedObservation : Observation (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservationAssignment') or (self::ObservationAssignment and not(@xsi:type)))]/AssignedObservation">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Observation'] or //Observation[@uid = $uidRef]">(ObservationAssignment : <sch:value-of select="$uid"/>) The ObservationAssignment.AssignedObservation contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Observation.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ObservationAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservationAssignment') or (self::ObservationAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ObservationAssignment : <sch:value-of select="$uid"/>) The ObservationAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ObservationAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservationAssignment') or (self::ObservationAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ObservationAssignment : <sch:value-of select="$uid"/>) The ObservationAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ObservationConsequence"><!--(Ref to S) ObservationConsequence.Request : ObservationConsequenceSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservationConsequence') or (self::ObservationConsequence and not(@xsi:type)))]/Request">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternatePartRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolutionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyOccurrenceRelationshipSubstitution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationshipSubstitution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssignmentObjectRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRealization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConfiguredAssemblyEffectivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DeltaChangeRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Envelope ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualAssemblyRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Message ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceRelationship  ReplacedUsageRelationship  SameTimeMachiningRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship  AlternatePartVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinitionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlan ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlanRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClassRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel  PlyAngleRepresentation  ReinforcementOrientationBasis ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RepresentationItem  BooleanRepresentationItem  Callout  CompoundRepresentationItem  SequenceRepresentationItem  SetRepresentationItem  DateTimeRepresentationItem  DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface  ExternalRepresentationItem  ExternalTessellatedAnnotation  IntegerRepresentationItem  LogicalRepresentationItem  RationalRepresentationItem  RealRepresentationItem  StyledElement  AnnotationElement  AnnotationPlaceholderOccurrence  AnnotationPlane  OverRidingStyledElement  ContextDependentOverRidingStyledElement  StyledModelReplication  TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint  UserDefined11 ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersionRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategory ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestRelationship ',@typeRef)] or //Activity[@uid = $uidRef] or //ActivityAssignment[@uid = $uidRef] or //ActivityMethod[@uid = $uidRef] or //ActivityMethodAssignment[@uid = $uidRef] or //ActivityRelationship[@uid = $uidRef] or //AddressAssignment[@uid = $uidRef] or //PartRelationship[@uid = $uidRef and contains(' AlternatePartRelationship ',substring-after(@xsi:type,':'))] or //AlternativeSolution[@uid = $uidRef] or //AlternativeSolutionRelationship[@uid = $uidRef] or //ApprovalAssignment[@uid = $uidRef] or //AssemblyOccurrenceRelationshipSubstitution[@uid = $uidRef] or //AssemblyViewRelationshipSubstitution[@uid = $uidRef] or //AssignmentObjectRelationship[@uid = $uidRef] or //Breakdown[@uid = $uidRef] or //BreakdownElement[@uid = $uidRef] or //BreakdownElementRealization[@uid = $uidRef] or //BreakdownElementVersion[@uid = $uidRef] or //BreakdownElementVersionRelationship[@uid = $uidRef] or //BreakdownElementView[@uid = $uidRef] or //BreakdownElementViewRelationship[@uid = $uidRef] or //BreakdownVersion[@uid = $uidRef] or //BreakdownVersionAssignment[@uid = $uidRef] or //BreakdownVersionRelationship[@uid = $uidRef] or //CertificationAssignment[@uid = $uidRef] or //Class[@uid = $uidRef] or //Condition[@uid = $uidRef] or //ConditionAssignment[@uid = $uidRef] or //ConfiguredAssemblyEffectivity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //ContractAssignment[@uid = $uidRef] or //DateAndPersonAssignment[@uid = $uidRef] or //DateTimeAssignment[@uid = $uidRef] or //DeltaChangeRelationship[@uid = $uidRef] or //Document[@uid = $uidRef] or //DocumentAssignment[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //DocumentDefinitionRelationship[@uid = $uidRef] or //DocumentVersion[@uid = $uidRef] or //DocumentVersionRelationship[@uid = $uidRef] or //Effectivity[@uid = $uidRef] or //EffectivityAssignment[@uid = $uidRef] or //EffectivityRelationship[@uid = $uidRef] or //Envelope[@uid = $uidRef] or //Event[@uid = $uidRef] or //EventAssignment[@uid = $uidRef] or //ExternalOwlClass[@uid = $uidRef] or //File[@uid = $uidRef] or //FileRelationship[@uid = $uidRef] or //IndividualAssemblyRelationship[@uid = $uidRef] or //IndividualPart[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //IndividualPartVersionRelationship[@uid = $uidRef] or //IndividualPartView[@uid = $uidRef] or //IndividualPartViewRelationship[@uid = $uidRef] or //InformationUsageRightAssignment[@uid = $uidRef] or //MaterialIdentification[@uid = $uidRef] or //MaterialPropertyAssignment[@uid = $uidRef] or //Message[@uid = $uidRef] or //ModelPropertyAssignment[@uid = $uidRef] or //Observation[@uid = $uidRef] or //ObservationAssignment[@uid = $uidRef] or //ObservationConsequence[@uid = $uidRef] or //ObservationRelationship[@uid = $uidRef] or //Occurrence[@uid = $uidRef] or //OccurrenceRelationship[@uid = $uidRef] or //Organization[@uid = $uidRef] or //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef] or //Part[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //PartVersionRelationship[@uid = $uidRef] or //PartView[@uid = $uidRef] or //PartViewRelationship[@uid = $uidRef] or //Person[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProcessOperationDefinition[@uid = $uidRef] or //ProcessOperationDefinitionRelationship[@uid = $uidRef] or //ProcessOperationOccurrence[@uid = $uidRef] or //ProcessOperationResourceAssignment[@uid = $uidRef] or //ProcessPlan[@uid = $uidRef] or //ProcessPlanRelationship[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductClassRelationship[@uid = $uidRef] or //ProductConfiguration[@uid = $uidRef] or //ProductConfigurationRelationship[@uid = $uidRef] or //Project[@uid = $uidRef] or //ProjectAssignment[@uid = $uidRef] or //ProjectRelationship[@uid = $uidRef] or //PropertyDefinitionAssignment[@uid = $uidRef] or //PropertyDefinitionRelationship[@uid = $uidRef] or //PropertyValue[@uid = $uidRef] or //PropertyValueAssignment[@uid = $uidRef] or //PropertyValueRelationship[@uid = $uidRef] or //Representation[@uid = $uidRef] or //RepresentationItem[@uid = $uidRef] or //Requirement[@uid = $uidRef] or //RequirementAssignment[@uid = $uidRef] or //RequirementVersion[@uid = $uidRef] or //RequirementVersionRelationship[@uid = $uidRef] or //RequirementView[@uid = $uidRef] or //RequirementViewRelationship[@uid = $uidRef] or //SecurityClassificationAssignment[@uid = $uidRef] or //Specification[@uid = $uidRef] or //SpecificationAssignment[@uid = $uidRef] or //SpecificationCategory[@uid = $uidRef] or //SpecificationCategoryAssignment[@uid = $uidRef] or //SpecificationConditionAssignment[@uid = $uidRef] or //SpecificationInclusion[@uid = $uidRef] or //SpecificationInclusionAssignment[@uid = $uidRef] or //Representation[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',substring-after(@xsi:type,':'))] or //TimeIntervalAssignment[@uid = $uidRef] or //ViewOccurrenceRelationship[@uid = $uidRef] or //WorkOrderAssignment[@uid = $uidRef] or //WorkOrderRelationship[@uid = $uidRef] or //WorkRequestAssignment[@uid = $uidRef] or //WorkRequestRelationship[@uid = $uidRef]">(ObservationConsequence : <sch:value-of select="$uid"/>) The ObservationConsequence.Request contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ObservationConsequenceSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ObservationConsequence.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservationConsequence') or (self::ObservationConsequence and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ObservationConsequence : <sch:value-of select="$uid"/>) The ObservationConsequence.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ObservationRelationship"><!--(Ref to E) ObservationRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservationRelationship') or (self::ObservationRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ObservationRelationship : <sch:value-of select="$uid"/>) The ObservationRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ObservationRelationship.Related : Observation (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservationRelationship') or (self::ObservationRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Observation'] or //Observation[@uid = $uidRef]">(ObservationRelationship : <sch:value-of select="$uid"/>) The ObservationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Observation.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ObservationRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ObservationRelationship') or (self::ObservationRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ObservationRelationship : <sch:value-of select="$uid"/>) The ObservationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ObservationRelationship_WR1"><!--(Rule ObservationRelationship.WR1)-->
      <sch:rule context="//ObservationRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> ObservationRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Observation and the relating Observation shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="OccurrenceContactFeature"><!--(Ref to S) OccurrenceContactFeature.Definition : OPTIONAL OccurrenceContactFeatureDefinitionSelect (kind=SINGLE - redefined=OccurrenceShapeElement.Definition)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceContactFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='OccurrenceContactFeature'))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartContactFeature  PartTerminal ',@typeRef)] or //ShapeFeatureDefinition[@uid = $uidRef and contains(' ContactFeatureDefinition ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartContactFeature  PartTerminal ',substring-after(@xsi:type,':'))]">(OccurrenceContactFeature : <sch:value-of select="$uid"/>) The OccurrenceContactFeature.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OccurrenceContactFeatureDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceContactFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='OccurrenceContactFeature'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(OccurrenceContactFeature : <sch:value-of select="$uid"/>) The OccurrenceContactFeature.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceContactFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='OccurrenceContactFeature'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(OccurrenceContactFeature : <sch:value-of select="$uid"/>) The OccurrenceContactFeature.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="OccurrencePlacement"><!--(Ref to E) OccurrencePlacement.PlacedInstance : SingleOccurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrencePlacement') or (self::OccurrencePlacement and not(@xsi:type)))]/PlacedInstance">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SingleOccurrence'] or //Occurrence[@uid = $uidRef and contains(' SingleOccurrence ',substring-after(@xsi:type,':'))]">(OccurrencePlacement : <sch:value-of select="$uid"/>) The OccurrencePlacement.PlacedInstance contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SingleOccurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) OccurrencePlacement.Placement : TransformationSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrencePlacement') or (self::OccurrencePlacement and not(@xsi:type)))]/Placement/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::CartesianTransformation or (self::Transformation and contains(' CartesianTransformation ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)]) or (self::GeometricRepresentationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',@typeRef)]) or (self::CartesianTransformation) or (self::GeometricRepresentationRelationship and //RepresentationRelationship[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',substring-after(@xsi:type,':'))])">(OccurrencePlacement : <sch:value-of select="$uid"/>) The OccurrencePlacement.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of TransformationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) OccurrencePlacement.ReferenceComponent : BreakdownElementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrencePlacement') or (self::OccurrencePlacement and not(@xsi:type)))]/ReferenceComponent">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'BreakdownElementView'] or //BreakdownElementView[@uid = $uidRef]">(OccurrencePlacement : <sch:value-of select="$uid"/>) The OccurrencePlacement.ReferenceComponent contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type BreakdownElementView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="OccurrenceRelationship"><!--(Ref to E) OccurrenceRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceRelationship') or (self::OccurrenceRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(OccurrenceRelationship : <sch:value-of select="$uid"/>) The OccurrenceRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) OccurrenceRelationship.Related : Occurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceRelationship') or (self::OccurrenceRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Occurrence'] or //Occurrence[@uid = $uidRef]">(OccurrenceRelationship : <sch:value-of select="$uid"/>) The OccurrenceRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Occurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) OccurrenceRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceRelationship') or (self::OccurrenceRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(OccurrenceRelationship : <sch:value-of select="$uid"/>) The OccurrenceRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="OccurrenceRelationship_WR1"><!--(Rule OccurrenceRelationship.WR1)-->
      <sch:rule context="//OccurrenceRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> OccurrenceRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Occurrence and the relating Occurrence shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="OccurrenceShapeElement"><!--(Ref to S) OccurrenceShapeElement.Definition : OPTIONAL OccurrenceShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='OccurrenceShapeElement'))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef]">(OccurrenceShapeElement : <sch:value-of select="$uid"/>) The OccurrenceShapeElement.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OccurrenceShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='OccurrenceShapeElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(OccurrenceShapeElement : <sch:value-of select="$uid"/>) The OccurrenceShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='OccurrenceShapeElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(OccurrenceShapeElement : <sch:value-of select="$uid"/>) The OccurrenceShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="OccurrenceShapeFeature"><!--(Ref to S) OccurrenceShapeFeature.Definition : OPTIONAL OccurrenceShapeFeatureDefinitionSelect (kind=SINGLE - redefined=OccurrenceShapeElement.Definition)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceShapeFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='OccurrenceShapeFeature'))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef]">(OccurrenceShapeFeature : <sch:value-of select="$uid"/>) The OccurrenceShapeFeature.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OccurrenceShapeFeatureDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceShapeFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='OccurrenceShapeFeature'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(OccurrenceShapeFeature : <sch:value-of select="$uid"/>) The OccurrenceShapeFeature.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceShapeFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='OccurrenceShapeFeature'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(OccurrenceShapeFeature : <sch:value-of select="$uid"/>) The OccurrenceShapeFeature.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="OccurrenceTerminal"><!--(Ref to E) OccurrenceTerminal.AssociatedTransportFeature : OPTIONAL OccurrenceTransportFeature (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceTerminal') or (self::ShapeElement and substring-after(@xsi:type,':')='OccurrenceTerminal'))]/AssociatedTransportFeature">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./AssociatedTransportFeature) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'OccurrenceTransportFeature'] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))]">(OccurrenceTerminal : <sch:value-of select="$uid"/>) The OccurrenceTerminal.AssociatedTransportFeature contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type OccurrenceTransportFeature.</sch:assert>
      </sch:rule>
      <!--(Ref to S) OccurrenceTerminal.Definition : OPTIONAL OccurrenceTerminalDefinitionSelect (kind=SINGLE - redefined=OccurrenceContactFeature.Definition)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceTerminal') or (self::ShapeElement and substring-after(@xsi:type,':')='OccurrenceTerminal'))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartTerminal ',@typeRef)] or //ShapeFeatureDefinition[@uid = $uidRef and contains(' ContactFeatureDefinition ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartTerminal ',substring-after(@xsi:type,':'))]">(OccurrenceTerminal : <sch:value-of select="$uid"/>) The OccurrenceTerminal.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OccurrenceTerminalDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceTerminal') or (self::ShapeElement and substring-after(@xsi:type,':')='OccurrenceTerminal'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(OccurrenceTerminal : <sch:value-of select="$uid"/>) The OccurrenceTerminal.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceTerminal') or (self::ShapeElement and substring-after(@xsi:type,':')='OccurrenceTerminal'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(OccurrenceTerminal : <sch:value-of select="$uid"/>) The OccurrenceTerminal.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="OccurrenceTransportFeature"><!--(Ref to S) OccurrenceTransportFeature.Definition : OPTIONAL OccurrenceTransportFeatureDefinitionSelect (kind=SINGLE - redefined=OccurrenceShapeElement.Definition)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceTransportFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='OccurrenceTransportFeature'))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartTransportFeature  WirePartIdentification ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))]">(OccurrenceTransportFeature : <sch:value-of select="$uid"/>) The OccurrenceTransportFeature.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OccurrenceTransportFeatureDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceTransportFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='OccurrenceTransportFeature'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(OccurrenceTransportFeature : <sch:value-of select="$uid"/>) The OccurrenceTransportFeature.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OccurrenceTransportFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='OccurrenceTransportFeature'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(OccurrenceTransportFeature : <sch:value-of select="$uid"/>) The OccurrenceTransportFeature.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="OneOfCondition"><!--(Default Value) OneOfCondition.ConditionType : String = 'one of' (kind=SINGLE - redefined=Condition.ConditionType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OneOfCondition') or (self::Condition and substring-after(@xsi:type,':')='OneOfCondition'))]/ConditionType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'one of'">(OneOfCondition : <sch:value-of select="$uid"/>) The OneOfCondition.ConditionType contains the wrong value () must be 'one of'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Condition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OneOfCondition') or (self::OneOfCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='OneOfCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='OneOfCondition')))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(OneOfCondition : <sch:value-of select="$uid"/>) The OneOfCondition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Condition.ConditionType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OneOfCondition') or (self::OneOfCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='OneOfCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='OneOfCondition')))]/ConditionType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(OneOfCondition : <sch:value-of select="$uid"/>) The OneOfCondition.ConditionType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Condition.Parameters : SET[1:unbounded] OF ParameterSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OneOfCondition') or (self::OneOfCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='OneOfCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='OneOfCondition')))]/Parameters/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ConditionParameter and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionParameter ',@typeRef)]) or (self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternativeSolutionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolutionRelationship ',@typeRef)]) or (self::Approval and //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConditionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionRelationship ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::Descriptor and //ExternalRefBaseObject[@uid = $uidRef and contains(' Descriptor ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::EffectivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::FileRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::Observation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::ObservationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::ProcessOperationDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinitionRelationship ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlanRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlanRelationship ',@typeRef)]) or (self::ProductClassRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClassRelationship ',@typeRef)]) or (self::ProductConcept and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::ProductConfigurationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkOrderRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderRelationship ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::WorkRequestRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestRelationship ',@typeRef)]) or (self::ConditionParameter) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternativeSolutionRelationship and //AlternativeSolutionRelationship[@uid = $uidRef]) or (self::Approval and //Approval[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::Condition) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConditionRelationship and //ConditionRelationship[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DateTimeString) or (self::Descriptor and //Descriptor[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::EffectivityRelationship and //EffectivityRelationship[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::FileRelationship and //FileRelationship[@uid = $uidRef]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::Observation and //Observation[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::ObservationRelationship and //ObservationRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::ProcessOperationDefinitionRelationship and //ProcessOperationDefinitionRelationship[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlanRelationship and //ProcessPlanRelationship[@uid = $uidRef]) or (self::ProductClassRelationship and //ProductClassRelationship[@uid = $uidRef]) or (self::ProductConcept and //ProductConcept[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProductConfigurationRelationship and //ProductConfigurationRelationship[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkOrderRelationship and //WorkOrderRelationship[@uid = $uidRef]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef]) or (self::WorkRequestRelationship and //WorkRequestRelationship[@uid = $uidRef])">(OneOfCondition : <sch:value-of select="$uid"/>) The OneOfCondition.Parameters contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ParameterSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="OrCondition"><!--(Default Value) OrCondition.ConditionType : String = 'or' (kind=SINGLE - redefined=Condition.ConditionType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrCondition') or (self::Condition and substring-after(@xsi:type,':')='OrCondition'))]/ConditionType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'or'">(OrCondition : <sch:value-of select="$uid"/>) The OrCondition.ConditionType contains the wrong value () must be 'or'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Condition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrCondition') or (self::OrCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='OrCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='OrCondition')))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(OrCondition : <sch:value-of select="$uid"/>) The OrCondition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Condition.ConditionType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrCondition') or (self::OrCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='OrCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='OrCondition')))]/ConditionType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(OrCondition : <sch:value-of select="$uid"/>) The OrCondition.ConditionType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Condition.Parameters : SET[1:unbounded] OF ParameterSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrCondition') or (self::OrCondition or (self::AssignedCondition and substring-after(@xsi:type,':')='OrCondition') or (self::AssignedCondition and substring-after(@xsi:type,':')='OrCondition')))]/Parameters/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ConditionParameter and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionParameter ',@typeRef)]) or (self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternativeSolutionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolutionRelationship ',@typeRef)]) or (self::Approval and //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConditionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionRelationship ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::Descriptor and //ExternalRefBaseObject[@uid = $uidRef and contains(' Descriptor ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::EffectivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::FileRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::Observation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::ObservationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::ProcessOperationDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinitionRelationship ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlanRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlanRelationship ',@typeRef)]) or (self::ProductClassRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClassRelationship ',@typeRef)]) or (self::ProductConcept and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::ProductConfigurationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkOrderRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderRelationship ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::WorkRequestRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestRelationship ',@typeRef)]) or (self::ConditionParameter) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternativeSolutionRelationship and //AlternativeSolutionRelationship[@uid = $uidRef]) or (self::Approval and //Approval[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::Condition) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConditionRelationship and //ConditionRelationship[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DateTimeString) or (self::Descriptor and //Descriptor[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::EffectivityRelationship and //EffectivityRelationship[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::FileRelationship and //FileRelationship[@uid = $uidRef]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::Observation and //Observation[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::ObservationRelationship and //ObservationRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::ProcessOperationDefinitionRelationship and //ProcessOperationDefinitionRelationship[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlanRelationship and //ProcessPlanRelationship[@uid = $uidRef]) or (self::ProductClassRelationship and //ProductClassRelationship[@uid = $uidRef]) or (self::ProductConcept and //ProductConcept[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProductConfigurationRelationship and //ProductConfigurationRelationship[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkOrderRelationship and //WorkOrderRelationship[@uid = $uidRef]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef]) or (self::WorkRequestRelationship and //WorkRequestRelationship[@uid = $uidRef])">(OrCondition : <sch:value-of select="$uid"/>) The OrCondition.Parameters contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ParameterSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Organization"><!--(Ref to E) Organization.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Organization') or (self::Organization and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Organization : <sch:value-of select="$uid"/>) The Organization.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Organization.OrganizationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Organization') or (self::Organization and not(@xsi:type)))]/OrganizationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Organization : <sch:value-of select="$uid"/>) The Organization.OrganizationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="OrganizationInContract"><!--(Ref to E) OrganizationInContract.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrganizationInContract') or (self::OrganizationInContract and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(OrganizationInContract : <sch:value-of select="$uid"/>) The OrganizationInContract.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) OrganizationInContract.ContractedOrganization : Organization (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrganizationInContract') or (self::OrganizationInContract and not(@xsi:type)))]/ContractedOrganization">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(OrganizationInContract : <sch:value-of select="$uid"/>) The OrganizationInContract.ContractedOrganization contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) OrganizationInContract.OrganizationRole : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrganizationInContract') or (self::OrganizationInContract and not(@xsi:type)))]/OrganizationRole/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(OrganizationInContract : <sch:value-of select="$uid"/>) The OrganizationInContract.OrganizationRole contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) OrganizationInContract.SignedContracts : SET[1:unbounded] OF Contract (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrganizationInContract') or (self::OrganizationInContract and not(@xsi:type)))]/SignedContracts/Contract">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Contract'] or //Contract[@uid = $uidRef]">(OrganizationInContract : <sch:value-of select="$uid"/>) The OrganizationInContract.SignedContracts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Contract.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="OrganizationOrPersonInOrganizationAssignment"><!--(Ref to S) OrganizationOrPersonInOrganizationAssignment.AssignedPersonOrOrganization : OrganizationOrPersonInOrganizationSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrganizationOrPersonInOrganizationAssignment') or (self::OrganizationOrPersonInOrganizationAssignment and not(@xsi:type)))]/AssignedPersonOrOrganization">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef]">(OrganizationOrPersonInOrganizationAssignment : <sch:value-of select="$uid"/>) The OrganizationOrPersonInOrganizationAssignment.AssignedPersonOrOrganization contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OrganizationOrPersonInOrganizationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) OrganizationOrPersonInOrganizationAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrganizationOrPersonInOrganizationAssignment') or (self::OrganizationOrPersonInOrganizationAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(OrganizationOrPersonInOrganizationAssignment : <sch:value-of select="$uid"/>) The OrganizationOrPersonInOrganizationAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) OrganizationOrPersonInOrganizationAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrganizationOrPersonInOrganizationAssignment') or (self::OrganizationOrPersonInOrganizationAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(OrganizationOrPersonInOrganizationAssignment : <sch:value-of select="$uid"/>) The OrganizationOrPersonInOrganizationAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="OrganizationRelationship"><!--(Ref to E) OrganizationRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrganizationRelationship') or (self::OrganizationRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(OrganizationRelationship : <sch:value-of select="$uid"/>) The OrganizationRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) OrganizationRelationship.Related : Organization (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrganizationRelationship') or (self::OrganizationRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(OrganizationRelationship : <sch:value-of select="$uid"/>) The OrganizationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) OrganizationRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrganizationRelationship') or (self::OrganizationRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(OrganizationRelationship : <sch:value-of select="$uid"/>) The OrganizationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="OrganizationRelationship_WR1"><!--(Rule OrganizationRelationship.WR1)-->
      <sch:rule context="//OrganizationRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> OrganizationRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Organization and the relating Organization shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="OrientedSurface"/>
   <sch:pattern id="OrientedToleranceZone"><!--(Ref to E) ToleranceZoneWithDatum.DatumReference : DatumSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrientedToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='OrientedToleranceZone'))]/DatumReference">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DatumSystem'] or //ShapeElement[@uid = $uidRef and contains(' DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem ',substring-after(@xsi:type,':'))]">(OrientedToleranceZone : <sch:value-of select="$uid"/>) The OrientedToleranceZone.DatumReference contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DatumSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DirectedOrOrientedToleranceZone.ZoneFor : SET[1:unbounded] OF DirectedOrOrientedGeometricToleranceSelect (kind=AGGREGATE - redefined=ToleranceZone.ZoneFor)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrientedToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='OrientedToleranceZone'))]/ZoneFor/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DimensionalLocation and //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)]) or (self::DimensionalSize and //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)]) or (self::LineProfileTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' LineProfileTolerance ',@typeRef)]) or (self::ParallelismTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' ParallelismTolerance ',@typeRef)]) or (self::PerpendicularityTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' PerpendicularityTolerance ',@typeRef)]) or (self::PositionTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionTolerance ',@typeRef)]) or (self::StraightnessTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' StraightnessTolerance ',@typeRef)]) or (self::SymmetryTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' SymmetryTolerance ',@typeRef)]) or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' LineProfileTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' ParallelismTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' PerpendicularityTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' PositionTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' StraightnessTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' SymmetryTolerance ',substring-after(@xsi:type,':'))]">(OrientedToleranceZone : <sch:value-of select="$uid"/>) The OrientedToleranceZone.ZoneFor contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of DirectedOrOrientedGeometricToleranceSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrientedToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='OrientedToleranceZone'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(OrientedToleranceZone : <sch:value-of select="$uid"/>) The OrientedToleranceZone.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OrientedToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='OrientedToleranceZone'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(OrientedToleranceZone : <sch:value-of select="$uid"/>) The OrientedToleranceZone.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="OrientedToleranceZone_WR1"><!--(Rule OrientedToleranceZone.WR1)--><sch:rule context="//ShapeElement[substring-after(@xsi:type,':')='OrientedToleranceZone']"> <sch:let name="uid" value="@uid"/> <sch:assert test="(./Orientation != 'angular' and not(./Angle)) or (./Orientation = 'angular' and ./Angle)"> (OrientedToleranceZone <sch:value-of select="$uid"/>) An angle value shall only be specified if and only if the orientation is of type angular. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="OrientedToleranceZone_WR2"><!--(Rule OrientedToleranceZone.WR2)--><sch:rule context="//ShapeElement[substring-after(@xsi:type,':')='OrientedToleranceZone']/Angle"> <sch:let name="uid" value="../@uid"/> <sch:let name="unitRef" value="./Unit/@uidRef"/> <sch:assert test="//Unit[@uid=$unitRef]/Quantity/ClassString ='plane angle'">(OrientedToleranceZone <sch:value-of select="$uid"/>) The unit of Angle shall be a plane angle measure unit. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="OverRidingStyledElement"><!--(Ref to E) OverRidingStyledElement.OverRiddenElement : StyledElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OverRidingStyledElement') or (self::RepresentationItem and substring-after(@xsi:type,':')='OverRidingStyledElement'))]/OverRiddenElement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StyledElement'] or //RepresentationItem[@uid = $uidRef and contains(' StyledElement  AnnotationElement  AnnotationPlaceholderOccurrence  AnnotationPlane  OverRidingStyledElement  ContextDependentOverRidingStyledElement ',substring-after(@xsi:type,':'))]">(OverRidingStyledElement : <sch:value-of select="$uid"/>) The OverRidingStyledElement.OverRiddenElement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StyledElement.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StyledElement.Element : StyledElementTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='OverRidingStyledElement') or (self::RepresentationItem and substring-after(@xsi:type,':')='OverRidingStyledElement'))]/Element">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel  PlyAngleRepresentation  ReinforcementOrientationBasis ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef]">(OverRidingStyledElement : <sch:value-of select="$uid"/>) The OverRidingStyledElement.Element contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of StyledElementTargetSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ParallelOffset"><!--(Ref to E) ParallelOffset.DerivedFrom : ShapeElement (kind=SINGLE - redefined=DerivedShapeElement.DerivedFrom)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ParallelOffset') or (self::ShapeElement and substring-after(@xsi:type,':')='ParallelOffset'))]/DerivedFrom">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="count(../../DerivedFrom/ShapeElement) = 1">(ParallelOffset : <sch:value-of select="$uid"/>) The ParallelOffset.DerivedFrom contains wrong number of element must be 1.</sch:assert>
      </sch:rule>
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ParallelOffset') or (self::ShapeElement and substring-after(@xsi:type,':')='ParallelOffset'))]/DerivedFrom/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(ParallelOffset : <sch:value-of select="$uid"/>) The ParallelOffset.DerivedFrom contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ParallelOffset') or (self::ShapeElement and substring-after(@xsi:type,':')='ParallelOffset'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ParallelOffset : <sch:value-of select="$uid"/>) The ParallelOffset.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ParallelOffset') or (self::ShapeElement and substring-after(@xsi:type,':')='ParallelOffset'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(ParallelOffset : <sch:value-of select="$uid"/>) The ParallelOffset.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ParallelismTolerance"><!--(Ref to E) ParallelismTolerance.DatumSystem : DatumSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ParallelismTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='ParallelismTolerance'))]/DatumSystem">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DatumSystem'] or //ShapeElement[@uid = $uidRef and contains(' DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem ',substring-after(@xsi:type,':'))]">(ParallelismTolerance : <sch:value-of select="$uid"/>) The ParallelismTolerance.DatumSystem contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DatumSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricTolerance.AppliedTo : GeometricToleranceTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ParallelismTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='ParallelismTolerance'))]/AppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //PartView[@uid = $uidRef]">(ParallelismTolerance : <sch:value-of select="$uid"/>) The ParallelismTolerance.AppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricToleranceTargetSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ParallelismTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='ParallelismTolerance'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ParallelismTolerance : <sch:value-of select="$uid"/>) The ParallelismTolerance.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.GeometricToleranceContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ParallelismTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='ParallelismTolerance'))]/GeometricToleranceContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricToleranceContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(ParallelismTolerance : <sch:value-of select="$uid"/>) The ParallelismTolerance.GeometricToleranceContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Part"><!--(Ref to E) Part.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Part') or (self::Part and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Part : <sch:value-of select="$uid"/>) The Part.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Part.PartTypes : SET[1:unbounded] OF PartClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Part') or (self::Part and not(@xsi:type)))]/PartTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef]) or (self::PartCategoryEnum)">(Part : <sch:value-of select="$uid"/>) The Part.PartTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartConnectivityDefinition"><!--(Ref to S) PartConnectivityDefinition.ConnectedTerminals : SET[2:unbounded] OF ConnectedTerminalSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartConnectivityDefinition') or (self::ShapeElement and substring-after(@xsi:type,':')='PartConnectivityDefinition'))]/ConnectedTerminals/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::OccurrenceTerminal and //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal ',@typeRef)]) or (self::PartTerminal and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartTerminal ',@typeRef)]) or (self::OccurrenceTerminal and //ShapeElement[@uid = $uidRef and contains(' OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal ',substring-after(@xsi:type,':'))]) or (self::PartTerminal and //ShapeElement[@uid = $uidRef and contains(' PartTerminal ',substring-after(@xsi:type,':'))])">(PartConnectivityDefinition : <sch:value-of select="$uid"/>) The PartConnectivityDefinition.ConnectedTerminals contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ConnectedTerminalSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartShapeElement.PartDefinition : OPTIONAL PartShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartConnectivityDefinition') or (self::ShapeElement and substring-after(@xsi:type,':')='PartConnectivityDefinition'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(PartConnectivityDefinition : <sch:value-of select="$uid"/>) The PartConnectivityDefinition.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartConnectivityDefinition') or (self::ShapeElement and substring-after(@xsi:type,':')='PartConnectivityDefinition'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PartConnectivityDefinition : <sch:value-of select="$uid"/>) The PartConnectivityDefinition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartConnectivityDefinition') or (self::ShapeElement and substring-after(@xsi:type,':')='PartConnectivityDefinition'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(PartConnectivityDefinition : <sch:value-of select="$uid"/>) The PartConnectivityDefinition.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartContactFeature"><!--(Ref to S) PartContactFeature.PartDefinition : OPTIONAL PartContactFeatureDefinitionSelect (kind=SINGLE - redefined=PartShapeElement.PartDefinition)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartContactFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='PartContactFeature'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ShapeFeatureDefinition[@uid = $uidRef and contains(' ContactFeatureDefinition ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))]">(PartContactFeature : <sch:value-of select="$uid"/>) The PartContactFeature.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartContactFeatureDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartContactFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='PartContactFeature'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PartContactFeature : <sch:value-of select="$uid"/>) The PartContactFeature.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartContactFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='PartContactFeature'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(PartContactFeature : <sch:value-of select="$uid"/>) The PartContactFeature.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartContactFeatureFitRelationship"><!--(Ref to S) PartContactFeatureFitRelationship.Definition : OPTIONAL PartContactFeatureFitRelationshipDefinitionSelect (kind=SINGLE - redefined=PartFeatureFitRelationship.Definition)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartContactFeatureFitRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='PartContactFeatureFitRelationship'))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef and contains(' ContactFeatureDefinitionFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))]">(PartContactFeatureFitRelationship : <sch:value-of select="$uid"/>) The PartContactFeatureFitRelationship.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartContactFeatureFitRelationshipDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartContactFeatureFitRelationship.FitParent : OPTIONAL PartContactFeatureFitRelationship (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartContactFeatureFitRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='PartContactFeatureFitRelationship'))]/FitParent">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./FitParent) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartContactFeatureFitRelationship'] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))]">(PartContactFeatureFitRelationship : <sch:value-of select="$uid"/>) The PartContactFeatureFitRelationship.FitParent contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartContactFeatureFitRelationship.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartContactFeatureFitRelationship.Related : PartContactFeature (kind=SINGLE - redefined=PartShapeElementRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartContactFeatureFitRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='PartContactFeatureFitRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartContactFeature'] or //ShapeElement[@uid = $uidRef and contains(' PartContactFeature  PartTerminal ',substring-after(@xsi:type,':'))]">(PartContactFeatureFitRelationship : <sch:value-of select="$uid"/>) The PartContactFeatureFitRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartContactFeature.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElementRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartContactFeatureFitRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='PartContactFeatureFitRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PartContactFeatureFitRelationship : <sch:value-of select="$uid"/>) The PartContactFeatureFitRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElementRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartContactFeatureFitRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='PartContactFeatureFitRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PartContactFeatureFitRelationship : <sch:value-of select="$uid"/>) The PartContactFeatureFitRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElementRelationship.RepresentedGeometry : OPTIONAL RepresentationItem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartContactFeatureFitRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='PartContactFeatureFitRelationship'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./RepresentedGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(PartContactFeatureFitRelationship : <sch:value-of select="$uid"/>) The PartContactFeatureFitRelationship.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartFeature"><!--(Ref to S) PartShapeElement.PartDefinition : OPTIONAL PartShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='PartFeature'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(PartFeature : <sch:value-of select="$uid"/>) The PartFeature.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='PartFeature'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PartFeature : <sch:value-of select="$uid"/>) The PartFeature.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='PartFeature'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(PartFeature : <sch:value-of select="$uid"/>) The PartFeature.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartFeatureFitRelationship"><!--(Ref to S) PartFeatureFitRelationship.Definition : OPTIONAL PartFeatureFitRelationshipDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartFeatureFitRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='PartFeatureFitRelationship'))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',substring-after(@xsi:type,':'))]">(PartFeatureFitRelationship : <sch:value-of select="$uid"/>) The PartFeatureFitRelationship.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartFeatureFitRelationshipDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartFeatureFitRelationship.Related : PartFeature (kind=SINGLE - redefined=PartShapeElementRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartFeatureFitRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='PartFeatureFitRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartFeature'] or //ShapeElement[@uid = $uidRef and contains(' PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))]">(PartFeatureFitRelationship : <sch:value-of select="$uid"/>) The PartFeatureFitRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartFeature.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElementRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartFeatureFitRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='PartFeatureFitRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PartFeatureFitRelationship : <sch:value-of select="$uid"/>) The PartFeatureFitRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElementRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartFeatureFitRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='PartFeatureFitRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PartFeatureFitRelationship : <sch:value-of select="$uid"/>) The PartFeatureFitRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElementRelationship.RepresentedGeometry : OPTIONAL RepresentationItem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartFeatureFitRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='PartFeatureFitRelationship'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./RepresentedGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(PartFeatureFitRelationship : <sch:value-of select="$uid"/>) The PartFeatureFitRelationship.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartRelationship"><!--(Ref to E) PartRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartRelationship') or (self::PartRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PartRelationship : <sch:value-of select="$uid"/>) The PartRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartRelationship.Related : Part (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartRelationship') or (self::PartRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Part'] or //Part[@uid = $uidRef]">(PartRelationship : <sch:value-of select="$uid"/>) The PartRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Part.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartRelationship') or (self::PartRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PartRelationship : <sch:value-of select="$uid"/>) The PartRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartRelationship_WR1"><!--(Rule PartRelationship.WR1)-->
      <sch:rule context="//PartRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> PartRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Part and the relating Part shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartShapeElement"><!--(Ref to S) PartShapeElement.PartDefinition : OPTIONAL PartShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='PartShapeElement'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(PartShapeElement : <sch:value-of select="$uid"/>) The PartShapeElement.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='PartShapeElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PartShapeElement : <sch:value-of select="$uid"/>) The PartShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='PartShapeElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(PartShapeElement : <sch:value-of select="$uid"/>) The PartShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartShapeElementRelationship"><!--(Ref to E) PartShapeElementRelationship.Related : PartShapeElement (kind=SINGLE - redefined=ShapeElementRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartShapeElementRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='PartShapeElementRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartShapeElement'] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))]">(PartShapeElementRelationship : <sch:value-of select="$uid"/>) The PartShapeElementRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElementRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartShapeElementRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='PartShapeElementRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PartShapeElementRelationship : <sch:value-of select="$uid"/>) The PartShapeElementRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElementRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartShapeElementRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='PartShapeElementRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PartShapeElementRelationship : <sch:value-of select="$uid"/>) The PartShapeElementRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElementRelationship.RepresentedGeometry : OPTIONAL RepresentationItem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartShapeElementRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='PartShapeElementRelationship'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./RepresentedGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(PartShapeElementRelationship : <sch:value-of select="$uid"/>) The PartShapeElementRelationship.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartTerminal"><!--(Ref to E) PartTerminal.AssociatedTransportFeature : OPTIONAL PartTransportFeature (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartTerminal') or (self::ShapeElement and substring-after(@xsi:type,':')='PartTerminal'))]/AssociatedTransportFeature">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./AssociatedTransportFeature) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartTransportFeature'] or //ShapeElement[@uid = $uidRef and contains(' PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))]">(PartTerminal : <sch:value-of select="$uid"/>) The PartTerminal.AssociatedTransportFeature contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartTransportFeature.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartContactFeature.PartDefinition : OPTIONAL PartContactFeatureDefinitionSelect (kind=SINGLE - redefined=PartShapeElement.PartDefinition)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartTerminal') or (self::ShapeElement and substring-after(@xsi:type,':')='PartTerminal'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ShapeFeatureDefinition[@uid = $uidRef and contains(' ContactFeatureDefinition ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))]">(PartTerminal : <sch:value-of select="$uid"/>) The PartTerminal.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartContactFeatureDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartTerminal') or (self::ShapeElement and substring-after(@xsi:type,':')='PartTerminal'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PartTerminal : <sch:value-of select="$uid"/>) The PartTerminal.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartTerminal') or (self::ShapeElement and substring-after(@xsi:type,':')='PartTerminal'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(PartTerminal : <sch:value-of select="$uid"/>) The PartTerminal.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartToIndividualPartAssociation"><!--(Ref to E) PartToIndividualPartAssociation.AssociatedIndividualPart : IndividualPart (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartToIndividualPartAssociation') or (self::PartToIndividualPartAssociation and not(@xsi:type)))]/AssociatedIndividualPart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'IndividualPart'] or //IndividualPart[@uid = $uidRef]">(PartToIndividualPartAssociation : <sch:value-of select="$uid"/>) The PartToIndividualPartAssociation.AssociatedIndividualPart contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type IndividualPart.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartToIndividualPartAssociation.AssociatedPart : Part (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartToIndividualPartAssociation') or (self::PartToIndividualPartAssociation and not(@xsi:type)))]/AssociatedPart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Part'] or //Part[@uid = $uidRef]">(PartToIndividualPartAssociation : <sch:value-of select="$uid"/>) The PartToIndividualPartAssociation.AssociatedPart contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Part.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartToIndividualPartAssociation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartToIndividualPartAssociation') or (self::PartToIndividualPartAssociation and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PartToIndividualPartAssociation : <sch:value-of select="$uid"/>) The PartToIndividualPartAssociation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartToIndividualPartAssociation.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartToIndividualPartAssociation') or (self::PartToIndividualPartAssociation and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PartToIndividualPartAssociation : <sch:value-of select="$uid"/>) The PartToIndividualPartAssociation.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartTransportFeature"><!--(Ref to S) PartShapeElement.PartDefinition : OPTIONAL PartShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartTransportFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='PartTransportFeature'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(PartTransportFeature : <sch:value-of select="$uid"/>) The PartTransportFeature.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartTransportFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='PartTransportFeature'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PartTransportFeature : <sch:value-of select="$uid"/>) The PartTransportFeature.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartTransportFeature') or (self::ShapeElement and substring-after(@xsi:type,':')='PartTransportFeature'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(PartTransportFeature : <sch:value-of select="$uid"/>) The PartTransportFeature.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartVersion"><!--(Ref to E) PartVersion.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartVersion') or (self::PartVersion and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PartVersion : <sch:value-of select="$uid"/>) The PartVersion.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Inverse of ProductDesignAssociation.AssociatedDesign :: ReferenceProperty) PartVersion.CorrespondingProductConfigurations : OPTIONAL SET[1:unbounded] OF ProductDesignAssociation) => no rule needed when PartProperty or Optional-->
      <!--(Inverse of Part.Versions :: PartProperty) PartVersion.VersionOf : Part) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="PartVersionRelationship"><!--(Ref to E) PartVersionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartVersionRelationship') or (self::PartVersionRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PartVersionRelationship : <sch:value-of select="$uid"/>) The PartVersionRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartVersionRelationship.Related : PartVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartVersionRelationship') or (self::PartVersionRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartVersion'] or //PartVersion[@uid = $uidRef]">(PartVersionRelationship : <sch:value-of select="$uid"/>) The PartVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartVersionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartVersionRelationship') or (self::PartVersionRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PartVersionRelationship : <sch:value-of select="$uid"/>) The PartVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartVersionRelationship_WR1"><!--(Rule PartVersionRelationship.WR1)-->
      <sch:rule context="//PartVersionRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> PartVersionRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related PartVersion and the relating PartVersion shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartVersionToIndividualPartVersionAssociation"><!--(Ref to E) PartVersionToIndividualPartVersionAssociation.AssociatedIndividualPart : IndividualPartVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartVersionToIndividualPartVersionAssociation') or (self::PartVersionToIndividualPartVersionAssociation and not(@xsi:type)))]/AssociatedIndividualPart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'IndividualPartVersion'] or //IndividualPartVersion[@uid = $uidRef]">(PartVersionToIndividualPartVersionAssociation : <sch:value-of select="$uid"/>) The PartVersionToIndividualPartVersionAssociation.AssociatedIndividualPart contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type IndividualPartVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartVersionToIndividualPartVersionAssociation.AssociatedPart : PartVersionOrProductConfigurationSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartVersionToIndividualPartVersionAssociation') or (self::PartVersionToIndividualPartVersionAssociation and not(@xsi:type)))]/AssociatedPart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)] or //PartVersion[@uid = $uidRef] or //ProductConfiguration[@uid = $uidRef]">(PartVersionToIndividualPartVersionAssociation : <sch:value-of select="$uid"/>) The PartVersionToIndividualPartVersionAssociation.AssociatedPart contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartVersionOrProductConfigurationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartVersionToIndividualPartVersionAssociation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartVersionToIndividualPartVersionAssociation') or (self::PartVersionToIndividualPartVersionAssociation and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PartVersionToIndividualPartVersionAssociation : <sch:value-of select="$uid"/>) The PartVersionToIndividualPartVersionAssociation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartVersionToIndividualPartVersionAssociation.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartVersionToIndividualPartVersionAssociation') or (self::PartVersionToIndividualPartVersionAssociation and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PartVersionToIndividualPartVersionAssociation : <sch:value-of select="$uid"/>) The PartVersionToIndividualPartVersionAssociation.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartView"><!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartView') or (self::PartView and not(@xsi:type)))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(PartView : <sch:value-of select="$uid"/>) The PartView.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartView') or (self::PartView and not(@xsi:type)))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(PartView : <sch:value-of select="$uid"/>) The PartView.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartView') or (self::PartView and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PartView : <sch:value-of select="$uid"/>) The PartView.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartView') or (self::PartView and not(@xsi:type)))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(PartView : <sch:value-of select="$uid"/>) The PartView.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartView') or (self::PartView and not(@xsi:type)))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(PartView : <sch:value-of select="$uid"/>) The PartView.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="PartView_WR1"><!--(Rule PartView.WR1)-->
      <sch:rule context="//PartView"> <sch:let name="uid" value="@uid"/> <sch:assert test="not(AuxiliaryGeometry) or DefiningGeometry"> PartView WR1 Error on entity <sch:value-of select="$uid"/>: the AuxiliaryGeometry can only exist if the DefiningGeometry exists. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartViewRelationship"><!--(Ref to E) PartViewRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartViewRelationship') or (self::PartViewRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PartViewRelationship : <sch:value-of select="$uid"/>) The PartViewRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.Related : PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartViewRelationship') or (self::PartViewRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(PartViewRelationship : <sch:value-of select="$uid"/>) The PartViewRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartViewRelationship') or (self::PartViewRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PartViewRelationship : <sch:value-of select="$uid"/>) The PartViewRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartViewRelationship_WR1"><!--(Rule PartViewRelationship.WR1)-->
      <sch:rule context="//PartViewRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> PartViewRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related PartView and the relating PartView shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="PartViewToIndividualPartViewAssociation"><!--(Ref to E) PartViewToIndividualPartViewAssociation.AssociatedIndividualPart : IndividualPartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartViewToIndividualPartViewAssociation') or (self::PartViewToIndividualPartViewAssociation and not(@xsi:type)))]/AssociatedIndividualPart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'IndividualPartView'] or //IndividualPartView[@uid = $uidRef]">(PartViewToIndividualPartViewAssociation : <sch:value-of select="$uid"/>) The PartViewToIndividualPartViewAssociation.AssociatedIndividualPart contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type IndividualPartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewToIndividualPartViewAssociation.AssociatedPart : PartViewOrProductConfigurationSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartViewToIndividualPartViewAssociation') or (self::PartViewToIndividualPartViewAssociation and not(@xsi:type)))]/AssociatedPart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)] or //PartView[@uid = $uidRef] or //ProductConfiguration[@uid = $uidRef]">(PartViewToIndividualPartViewAssociation : <sch:value-of select="$uid"/>) The PartViewToIndividualPartViewAssociation.AssociatedPart contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartViewOrProductConfigurationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewToIndividualPartViewAssociation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartViewToIndividualPartViewAssociation') or (self::PartViewToIndividualPartViewAssociation and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PartViewToIndividualPartViewAssociation : <sch:value-of select="$uid"/>) The PartViewToIndividualPartViewAssociation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewToIndividualPartViewAssociation.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PartViewToIndividualPartViewAssociation') or (self::PartViewToIndividualPartViewAssociation and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PartViewToIndividualPartViewAssociation : <sch:value-of select="$uid"/>) The PartViewToIndividualPartViewAssociation.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Path"><!--(Ref to E) Path.EdgeList : LIST[1:unbounded] OF Edge (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Path') or (self::RepresentationItem and substring-after(@xsi:type,':')='Path'))]/EdgeList/Edge">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Edge'] or //RepresentationItem[@uid = $uidRef and contains(' Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge ',substring-after(@xsi:type,':'))]">(Path : <sch:value-of select="$uid"/>) The Path.EdgeList contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Edge.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Pcurve"/>
   <sch:pattern id="PercentageLaminateTable"><!--(Ref to E) LaminateTable.Basis : SET[1:unbounded] OF ReinforcementOrientationBasis (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PercentageLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='PercentageLaminateTable'))]/Basis/ReinforcementOrientationBasis">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ReinforcementOrientationBasis'] or //Representation[@uid = $uidRef and contains(' ReinforcementOrientationBasis ',substring-after(@xsi:type,':'))]">(PercentageLaminateTable : <sch:value-of select="$uid"/>) The PercentageLaminateTable.Basis contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ReinforcementOrientationBasis.</sch:assert>
      </sch:rule>
      <!--(Ref to E) LaminateTable.ResultingBoundary : PlyShape (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PercentageLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='PercentageLaminateTable'))]/ResultingBoundary">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlyShape'] or //PlyShape[@uid = $uidRef]">(PercentageLaminateTable : <sch:value-of select="$uid"/>) The PercentageLaminateTable.ResultingBoundary contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlyShape.</sch:assert>
      </sch:rule>
      <!--(Ref to E) LaminateTable.ResultingSurface : Surface (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PercentageLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='PercentageLaminateTable'))]/ResultingSurface">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Surface'] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(PercentageLaminateTable : <sch:value-of select="$uid"/>) The PercentageLaminateTable.ResultingSurface contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Surface.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PercentageLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='PercentageLaminateTable'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(PercentageLaminateTable : <sch:value-of select="$uid"/>) The PercentageLaminateTable.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PercentageLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='PercentageLaminateTable'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(PercentageLaminateTable : <sch:value-of select="$uid"/>) The PercentageLaminateTable.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PercentageLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='PercentageLaminateTable'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PercentageLaminateTable : <sch:value-of select="$uid"/>) The PercentageLaminateTable.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PercentageLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='PercentageLaminateTable'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(PercentageLaminateTable : <sch:value-of select="$uid"/>) The PercentageLaminateTable.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PercentageLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='PercentageLaminateTable'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(PercentageLaminateTable : <sch:value-of select="$uid"/>) The PercentageLaminateTable.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="PercentagePly"><!--(Ref to E) PercentagePly.MakeupAndProperties : OPTIONAL ZoneStructuralMakeup (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PercentagePly') or (self::PercentagePly and not(@xsi:type)))]/MakeupAndProperties">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./MakeupAndProperties) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ZoneStructuralMakeup'] or //PartView[@uid = $uidRef and contains(' ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',substring-after(@xsi:type,':'))]">(PercentagePly : <sch:value-of select="$uid"/>) The PercentagePly.MakeupAndProperties contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ZoneStructuralMakeup.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PercentagePly.Material : StockMaterial (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PercentagePly') or (self::PercentagePly and not(@xsi:type)))]/Material">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StockMaterial'] or //StockMaterial[@uid = $uidRef]">(PercentagePly : <sch:value-of select="$uid"/>) The PercentagePly.Material contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StockMaterial.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PercentagePly.StrengthOrientation : OPTIONAL PlyOrientationAngle (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PercentagePly') or (self::PercentagePly and not(@xsi:type)))]/StrengthOrientation">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./StrengthOrientation) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlyOrientationAngle'] or //RepresentationRelationship[@uid = $uidRef and contains(' PlyOrientationAngle  DrapedOrientationAngle  LaidOrientationAngle ',substring-after(@xsi:type,':'))]">(PercentagePly : <sch:value-of select="$uid"/>) The PercentagePly.StrengthOrientation contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlyOrientationAngle.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PerpendicularTo"><!--(Ref to E) PerpendicularTo.DerivedFrom : ShapeElement (kind=SINGLE - redefined=DerivedShapeElement.DerivedFrom)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PerpendicularTo') or (self::ShapeElement and substring-after(@xsi:type,':')='PerpendicularTo'))]/DerivedFrom">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="count(../../DerivedFrom/ShapeElement) = 1">(PerpendicularTo : <sch:value-of select="$uid"/>) The PerpendicularTo.DerivedFrom contains wrong number of element must be 1.</sch:assert>
      </sch:rule>
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PerpendicularTo') or (self::ShapeElement and substring-after(@xsi:type,':')='PerpendicularTo'))]/DerivedFrom/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(PerpendicularTo : <sch:value-of select="$uid"/>) The PerpendicularTo.DerivedFrom contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PerpendicularTo') or (self::ShapeElement and substring-after(@xsi:type,':')='PerpendicularTo'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PerpendicularTo : <sch:value-of select="$uid"/>) The PerpendicularTo.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PerpendicularTo') or (self::ShapeElement and substring-after(@xsi:type,':')='PerpendicularTo'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(PerpendicularTo : <sch:value-of select="$uid"/>) The PerpendicularTo.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PerpendicularityTolerance"><!--(Ref to E) PerpendicularityTolerance.DatumSystem : DatumSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PerpendicularityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='PerpendicularityTolerance'))]/DatumSystem">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DatumSystem'] or //ShapeElement[@uid = $uidRef and contains(' DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem ',substring-after(@xsi:type,':'))]">(PerpendicularityTolerance : <sch:value-of select="$uid"/>) The PerpendicularityTolerance.DatumSystem contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DatumSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricTolerance.AppliedTo : GeometricToleranceTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PerpendicularityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='PerpendicularityTolerance'))]/AppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //PartView[@uid = $uidRef]">(PerpendicularityTolerance : <sch:value-of select="$uid"/>) The PerpendicularityTolerance.AppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricToleranceTargetSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PerpendicularityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='PerpendicularityTolerance'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PerpendicularityTolerance : <sch:value-of select="$uid"/>) The PerpendicularityTolerance.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.GeometricToleranceContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PerpendicularityTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='PerpendicularityTolerance'))]/GeometricToleranceContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricToleranceContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(PerpendicularityTolerance : <sch:value-of select="$uid"/>) The PerpendicularityTolerance.GeometricToleranceContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Person"><!--(Ref to E) Person.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Person') or (self::Person and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Person : <sch:value-of select="$uid"/>) The Person.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Rule for inverse of PersonInOrganization.AssociatedPerson :: ReferenceProperty) Person.AssociatedOrganizations : SET[1:unbounded] OF PersonInOrganization)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Person') or (self::Person))]">
         <sch:let name="uid" value="./@uid"/>
         <sch:assert test="//PersonInOrganization/AssociatedPerson[@uidRef = $uid]">(Person : <sch:value-of select="$uid"/>) The Person.AssociatedOrganizations inverse rule must be referenced by PersonInOrganization.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PersonInOrganization"><!--(Ref to E) PersonInOrganization.AssociatedOrganization : Organization (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonInOrganization') or (self::PersonInOrganization and not(@xsi:type)))]/AssociatedOrganization">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(PersonInOrganization : <sch:value-of select="$uid"/>) The PersonInOrganization.AssociatedOrganization contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PersonInOrganization.AssociatedPerson : Person (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonInOrganization') or (self::PersonInOrganization and not(@xsi:type)))]/AssociatedPerson">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Person'] or //Person[@uid = $uidRef]">(PersonInOrganization : <sch:value-of select="$uid"/>) The PersonInOrganization.AssociatedPerson contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Person.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PersonInOrganization.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonInOrganization') or (self::PersonInOrganization and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PersonInOrganization : <sch:value-of select="$uid"/>) The PersonInOrganization.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PersonInOrganization.PersonRole : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonInOrganization') or (self::PersonInOrganization and not(@xsi:type)))]/PersonRole/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PersonInOrganization : <sch:value-of select="$uid"/>) The PersonInOrganization.PersonRole contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PersonInOrganizationRelationship"><!--(Ref to E) PersonInOrganizationRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonInOrganizationRelationship') or (self::PersonInOrganizationRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PersonInOrganizationRelationship : <sch:value-of select="$uid"/>) The PersonInOrganizationRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PersonInOrganizationRelationship.Related : PersonInOrganization (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonInOrganizationRelationship') or (self::PersonInOrganizationRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PersonInOrganization'] or //PersonInOrganization[@uid = $uidRef]">(PersonInOrganizationRelationship : <sch:value-of select="$uid"/>) The PersonInOrganizationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PersonInOrganization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PersonInOrganizationRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PersonInOrganizationRelationship') or (self::PersonInOrganizationRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PersonInOrganizationRelationship : <sch:value-of select="$uid"/>) The PersonInOrganizationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PersonInOrganizationRelationship_WR1"><!--(Rule PersonInOrganizationRelationship.WR1)-->
      <sch:rule context="//PersonInOrganizationRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> PersonInOrganizationRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related PersonInOrganization and the relating PersonInOrganization shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="PhysicalBreakdown"><!--(Default Value) PhysicalBreakdown.BreakdownType : String = 'physical' (kind=SINGLE - redefined=Breakdown.BreakdownType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PhysicalBreakdown') or (self::Breakdown and substring-after(@xsi:type,':')='PhysicalBreakdown'))]/BreakdownType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'physical'">(PhysicalBreakdown : <sch:value-of select="$uid"/>) The PhysicalBreakdown.BreakdownType contains the wrong value () must be 'physical'.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Breakdown.BreakdownType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PhysicalBreakdown') or (self::Breakdown and substring-after(@xsi:type,':')='PhysicalBreakdown'))]/BreakdownType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PhysicalBreakdown : <sch:value-of select="$uid"/>) The PhysicalBreakdown.BreakdownType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Breakdown.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PhysicalBreakdown') or (self::Breakdown and substring-after(@xsi:type,':')='PhysicalBreakdown'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PhysicalBreakdown : <sch:value-of select="$uid"/>) The PhysicalBreakdown.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PhysicalDocumentDefinition"><!--(Ref to E) PhysicalDocumentDefinition.Components : OPTIONAL SET[1:unbounded] OF Hardcopy (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PhysicalDocumentDefinition') or (self::DocumentDefinition and substring-after(@xsi:type,':')='PhysicalDocumentDefinition'))]/Components/Hardcopy">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Components/Hardcopy) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Hardcopy'] or //File[@uid = $uidRef and contains(' Hardcopy ',substring-after(@xsi:type,':'))]">(PhysicalDocumentDefinition : <sch:value-of select="$uid"/>) The PhysicalDocumentDefinition.Components contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Hardcopy.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DocumentDefinition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PhysicalDocumentDefinition') or (self::DocumentDefinition and substring-after(@xsi:type,':')='PhysicalDocumentDefinition'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PhysicalDocumentDefinition : <sch:value-of select="$uid"/>) The PhysicalDocumentDefinition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DocumentDefinition.DocumentCreation : OPTIONAL CreationProperty (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PhysicalDocumentDefinition') or (self::DocumentDefinition and substring-after(@xsi:type,':')='PhysicalDocumentDefinition'))]/DocumentCreation">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DocumentCreation) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'CreationProperty'] or //CreationProperty[@uid = $uidRef]">(PhysicalDocumentDefinition : <sch:value-of select="$uid"/>) The PhysicalDocumentDefinition.DocumentCreation contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type CreationProperty.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DocumentDefinition.DocumentFormat : OPTIONAL SET[1:unbounded] OF FormatProperty (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PhysicalDocumentDefinition') or (self::DocumentDefinition and substring-after(@xsi:type,':')='PhysicalDocumentDefinition'))]/DocumentFormat/FormatProperty">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../DocumentFormat/FormatProperty) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'FormatProperty'] or //FormatProperty[@uid = $uidRef]">(PhysicalDocumentDefinition : <sch:value-of select="$uid"/>) The PhysicalDocumentDefinition.DocumentFormat contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type FormatProperty.</sch:assert>
      </sch:rule>
      <!--(Inverse of DocumentVersion.Views :: PartProperty) DocumentDefinition.ViewOf : DocumentVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="PlanarBox"><!--(Ref to E) PlanarBox.Placement : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlanarBox') or (self::RepresentationItem and substring-after(@xsi:type,':')='PlanarBox'))]/Placement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(PlanarBox : <sch:value-of select="$uid"/>) The PlanarBox.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Plane"><!--(Ref to E) Plane.Position : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Plane') or (self::RepresentationItem and substring-after(@xsi:type,':')='Plane'))]/Position">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(Plane : <sch:value-of select="$uid"/>) The Plane.Position contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PlaneShapeElement"><!--(Ref to E) PlaneShapeElement.RepresentedGeometry : Plane (kind=SINGLE - redefined=ShapeElement.RepresentedGeometry)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlaneShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='PlaneShapeElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Plane'] or //RepresentationItem[@uid = $uidRef and contains(' Plane ',substring-after(@xsi:type,':'))]">(PlaneShapeElement : <sch:value-of select="$uid"/>) The PlaneShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Plane.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlaneShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='PlaneShapeElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PlaneShapeElement : <sch:value-of select="$uid"/>) The PlaneShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PlannedActivity"><!--(Ref to S) PlannedActivity.PlannedEndDate : OPTIONAL PeriodOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='PlannedActivity'))]/PlannedEndDate/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::DateTimeString) or (self::Duration) or (self::Event and //Event[@uid = $uidRef])">(PlannedActivity : <sch:value-of select="$uid"/>) The PlannedActivity.PlannedEndDate contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PeriodOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PlannedActivity.PlannedStartDate : OPTIONAL EventOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='PlannedActivity'))]/PlannedStartDate/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(PlannedActivity : <sch:value-of select="$uid"/>) The PlannedActivity.PlannedStartDate contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EventOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Activity.ActivityType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='PlannedActivity'))]/ActivityType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PlannedActivity : <sch:value-of select="$uid"/>) The PlannedActivity.ActivityType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.ChosenMethod : OPTIONAL ActivityMethod (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='PlannedActivity'))]/ChosenMethod">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ChosenMethod) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(PlannedActivity : <sch:value-of select="$uid"/>) The PlannedActivity.ChosenMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='PlannedActivity'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PlannedActivity : <sch:value-of select="$uid"/>) The PlannedActivity.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='PlannedActivity'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(PlannedActivity : <sch:value-of select="$uid"/>) The PlannedActivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.PossibleMethods : OPTIONAL SET[1:unbounded] OF ActivityMethod (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='PlannedActivity'))]/PossibleMethods/ActivityMethod">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../PossibleMethods/ActivityMethod) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ActivityMethod'] or //ActivityMethod[@uid = $uidRef]">(PlannedActivity : <sch:value-of select="$uid"/>) The PlannedActivity.PossibleMethods contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ActivityMethod.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Activity.Status : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='PlannedActivity'))]/Status/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PlannedActivity : <sch:value-of select="$uid"/>) The PlannedActivity.Status contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Activity.SupplyingOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlannedActivity') or (self::Activity and substring-after(@xsi:type,':')='PlannedActivity'))]/SupplyingOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../SupplyingOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(PlannedActivity : <sch:value-of select="$uid"/>) The PlannedActivity.SupplyingOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PlannedCharacteristic"/>
   <sch:pattern id="PlannedIndividualPart"><!--(Ref to E) IndividualPartVersion.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlannedIndividualPart') or (self::IndividualPartVersion and substring-after(@xsi:type,':')='PlannedIndividualPart'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PlannedIndividualPart : <sch:value-of select="$uid"/>) The PlannedIndividualPart.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Inverse of IndividualPart.Versions :: PartProperty) IndividualPartVersion.VersionOf : IndividualPart) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="Ply"><!--(Ref to E) Ply.Constituents : OPTIONAL LIST[1:unbounded] OF PlyPiece (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Ply') or (self::PartView and substring-after(@xsi:type,':')='Ply'))]/Constituents/PlyPiece">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Constituents/PlyPiece) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlyPiece'] or //PartView[@uid = $uidRef and contains(' PlyPiece ',substring-after(@xsi:type,':'))]">(Ply : <sch:value-of select="$uid"/>) The Ply.Constituents contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlyPiece.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Ply.MaterialOrientation : PlyOrientationAngle (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Ply') or (self::PartView and substring-after(@xsi:type,':')='Ply'))]/MaterialOrientation">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlyOrientationAngle'] or //RepresentationRelationship[@uid = $uidRef and contains(' PlyOrientationAngle  DrapedOrientationAngle  LaidOrientationAngle ',substring-after(@xsi:type,':'))]">(Ply : <sch:value-of select="$uid"/>) The Ply.MaterialOrientation contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlyOrientationAngle.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Ply.MaterialType : StockMaterial (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Ply') or (self::PartView and substring-after(@xsi:type,':')='Ply'))]/MaterialType">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StockMaterial'] or //StockMaterial[@uid = $uidRef]">(Ply : <sch:value-of select="$uid"/>) The Ply.MaterialType contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StockMaterial.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Ply.PlyShape : OPTIONAL PlyShape (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Ply') or (self::PartView and substring-after(@xsi:type,':')='Ply'))]/PlyShape">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./PlyShape) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlyShape'] or //PlyShape[@uid = $uidRef]">(Ply : <sch:value-of select="$uid"/>) The Ply.PlyShape contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlyShape.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Ply') or (self::PartView and substring-after(@xsi:type,':')='Ply'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(Ply : <sch:value-of select="$uid"/>) The Ply.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Ply') or (self::PartView and substring-after(@xsi:type,':')='Ply'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(Ply : <sch:value-of select="$uid"/>) The Ply.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Ply') or (self::PartView and substring-after(@xsi:type,':')='Ply'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Ply : <sch:value-of select="$uid"/>) The Ply.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Ply') or (self::PartView and substring-after(@xsi:type,':')='Ply'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(Ply : <sch:value-of select="$uid"/>) The Ply.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Ply') or (self::PartView and substring-after(@xsi:type,':')='Ply'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(Ply : <sch:value-of select="$uid"/>) The Ply.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="PlyAngleRepresentation"><!--(Ref to E) PlyAngleRepresentation.Items : RepresentationItem (kind=SINGLE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyAngleRepresentation') or (self::Representation and substring-after(@xsi:type,':')='PlyAngleRepresentation'))]/Items">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="count(../../Items/RepresentationItem) = 1">(PlyAngleRepresentation : <sch:value-of select="$uid"/>) The PlyAngleRepresentation.Items contains wrong number of element must be 1.</sch:assert>
      </sch:rule>
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyAngleRepresentation') or (self::Representation and substring-after(@xsi:type,':')='PlyAngleRepresentation'))]/Items/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(PlyAngleRepresentation : <sch:value-of select="$uid"/>) The PlyAngleRepresentation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyAngleRepresentation') or (self::Representation and substring-after(@xsi:type,':')='PlyAngleRepresentation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PlyAngleRepresentation : <sch:value-of select="$uid"/>) The PlyAngleRepresentation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyAngleRepresentation') or (self::Representation and substring-after(@xsi:type,':')='PlyAngleRepresentation'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PlyAngleRepresentation : <sch:value-of select="$uid"/>) The PlyAngleRepresentation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="PlyLaminate"><!--(Ref to S) PlyLaminate.PlyLaminateShape : OPTIONAL PlyLaminateShapeSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminate') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminate'))]/PlyLaminateShape">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalAdvancedBrepShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalCsgShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalCurveSweptSolidShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalElementaryBrepShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalFacetedBrepShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalTessellatedShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ThreeDGeometrySet ',@typeRef)] or //Representation[@uid = $uidRef and contains(' CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalAdvancedBrepShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalCsgShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalCurveSweptSolidShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalElementaryBrepShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalFacetedBrepShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalTessellatedShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ThreeDGeometrySet ',substring-after(@xsi:type,':'))]">(PlyLaminate : <sch:value-of select="$uid"/>) The PlyLaminate.PlyLaminateShape contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PlyLaminateShapeSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PlyLaminate.PlyTable : PlyLaminateTable (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminate') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminate'))]/PlyTable">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlyLaminateTable'] or //PartView[@uid = $uidRef and contains(' PlyLaminateTable ',substring-after(@xsi:type,':'))]">(PlyLaminate : <sch:value-of select="$uid"/>) The PlyLaminate.PlyTable contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlyLaminateTable.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminate') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminate'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(PlyLaminate : <sch:value-of select="$uid"/>) The PlyLaminate.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminate') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminate'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(PlyLaminate : <sch:value-of select="$uid"/>) The PlyLaminate.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminate') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminate'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PlyLaminate : <sch:value-of select="$uid"/>) The PlyLaminate.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminate') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminate'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(PlyLaminate : <sch:value-of select="$uid"/>) The PlyLaminate.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminate') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminate'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(PlyLaminate : <sch:value-of select="$uid"/>) The PlyLaminate.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="PlyLaminateSequenceDefinition"><!--(Ref to E) PlyLaminateSequenceDefinition.PliesInSequence : SET[1:unbounded] OF Ply (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminateSequenceDefinition') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminateSequenceDefinition'))]/PliesInSequence/Ply">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Ply'] or //PartView[@uid = $uidRef and contains(' Ply ',substring-after(@xsi:type,':'))]">(PlyLaminateSequenceDefinition : <sch:value-of select="$uid"/>) The PlyLaminateSequenceDefinition.PliesInSequence contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Ply.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminateSequenceDefinition') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminateSequenceDefinition'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(PlyLaminateSequenceDefinition : <sch:value-of select="$uid"/>) The PlyLaminateSequenceDefinition.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminateSequenceDefinition') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminateSequenceDefinition'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(PlyLaminateSequenceDefinition : <sch:value-of select="$uid"/>) The PlyLaminateSequenceDefinition.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminateSequenceDefinition') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminateSequenceDefinition'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PlyLaminateSequenceDefinition : <sch:value-of select="$uid"/>) The PlyLaminateSequenceDefinition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminateSequenceDefinition') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminateSequenceDefinition'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(PlyLaminateSequenceDefinition : <sch:value-of select="$uid"/>) The PlyLaminateSequenceDefinition.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminateSequenceDefinition') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminateSequenceDefinition'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(PlyLaminateSequenceDefinition : <sch:value-of select="$uid"/>) The PlyLaminateSequenceDefinition.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="PlyLaminateTable"><!--(Ref to E) PlyLaminateTable.Sequence : LIST[2:unbounded] OF PlyLaminateSequenceDefinition (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminateTable'))]/Sequence/PlyLaminateSequenceDefinition">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlyLaminateSequenceDefinition'] or //PartView[@uid = $uidRef and contains(' PlyLaminateSequenceDefinition ',substring-after(@xsi:type,':'))]">(PlyLaminateTable : <sch:value-of select="$uid"/>) The PlyLaminateTable.Sequence contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlyLaminateSequenceDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to E) LaminateTable.Basis : SET[1:unbounded] OF ReinforcementOrientationBasis (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminateTable'))]/Basis/ReinforcementOrientationBasis">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ReinforcementOrientationBasis'] or //Representation[@uid = $uidRef and contains(' ReinforcementOrientationBasis ',substring-after(@xsi:type,':'))]">(PlyLaminateTable : <sch:value-of select="$uid"/>) The PlyLaminateTable.Basis contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ReinforcementOrientationBasis.</sch:assert>
      </sch:rule>
      <!--(Ref to E) LaminateTable.ResultingBoundary : PlyShape (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminateTable'))]/ResultingBoundary">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlyShape'] or //PlyShape[@uid = $uidRef]">(PlyLaminateTable : <sch:value-of select="$uid"/>) The PlyLaminateTable.ResultingBoundary contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlyShape.</sch:assert>
      </sch:rule>
      <!--(Ref to E) LaminateTable.ResultingSurface : Surface (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminateTable'))]/ResultingSurface">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Surface'] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(PlyLaminateTable : <sch:value-of select="$uid"/>) The PlyLaminateTable.ResultingSurface contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Surface.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminateTable'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(PlyLaminateTable : <sch:value-of select="$uid"/>) The PlyLaminateTable.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminateTable'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(PlyLaminateTable : <sch:value-of select="$uid"/>) The PlyLaminateTable.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminateTable'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PlyLaminateTable : <sch:value-of select="$uid"/>) The PlyLaminateTable.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminateTable'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(PlyLaminateTable : <sch:value-of select="$uid"/>) The PlyLaminateTable.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='PlyLaminateTable'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(PlyLaminateTable : <sch:value-of select="$uid"/>) The PlyLaminateTable.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="PlyPiece"><!--(Ref to E) PlyPiece.PlyPieceShape : OPTIONAL PlyShape (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyPiece') or (self::PartView and substring-after(@xsi:type,':')='PlyPiece'))]/PlyPieceShape">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./PlyPieceShape) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlyShape'] or //PlyShape[@uid = $uidRef]">(PlyPiece : <sch:value-of select="$uid"/>) The PlyPiece.PlyPieceShape contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlyShape.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyPiece') or (self::PartView and substring-after(@xsi:type,':')='PlyPiece'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(PlyPiece : <sch:value-of select="$uid"/>) The PlyPiece.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyPiece') or (self::PartView and substring-after(@xsi:type,':')='PlyPiece'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(PlyPiece : <sch:value-of select="$uid"/>) The PlyPiece.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyPiece') or (self::PartView and substring-after(@xsi:type,':')='PlyPiece'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PlyPiece : <sch:value-of select="$uid"/>) The PlyPiece.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyPiece') or (self::PartView and substring-after(@xsi:type,':')='PlyPiece'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(PlyPiece : <sch:value-of select="$uid"/>) The PlyPiece.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyPiece') or (self::PartView and substring-after(@xsi:type,':')='PlyPiece'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(PlyPiece : <sch:value-of select="$uid"/>) The PlyPiece.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="PlyShape"><!--(Ref to E) PlyShape.Basis : OPTIONAL PlyShape (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyShape') or (self::PlyShape and not(@xsi:type)))]/Basis">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Basis) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlyShape'] or //PlyShape[@uid = $uidRef]">(PlyShape : <sch:value-of select="$uid"/>) The PlyShape.Basis contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlyShape.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PlyShape.DefiningModel : PlyLaminateShapeSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PlyShape') or (self::PlyShape and not(@xsi:type)))]/DefiningModel">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalAdvancedBrepShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalCsgShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalCurveSweptSolidShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalElementaryBrepShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalFacetedBrepShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalTessellatedShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ThreeDGeometrySet ',@typeRef)] or //Representation[@uid = $uidRef and contains(' CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalAdvancedBrepShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalCsgShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalCurveSweptSolidShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalElementaryBrepShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalFacetedBrepShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalTessellatedShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ThreeDGeometrySet ',substring-after(@xsi:type,':'))]">(PlyShape : <sch:value-of select="$uid"/>) The PlyShape.DefiningModel contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PlyLaminateShapeSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Point"/>
   <sch:pattern id="PointAndVector"><!--(Ref to E) PointAndVector.Location : Point (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PointAndVector') or (self::RepresentationItem and substring-after(@xsi:type,':')='PointAndVector'))]/Location">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Point'] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))]">(PointAndVector : <sch:value-of select="$uid"/>) The PointAndVector.Location contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Point.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PointAndVector.Vector : SET[1:2] OF Direction (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PointAndVector') or (self::RepresentationItem and substring-after(@xsi:type,':')='PointAndVector'))]/Vector/Direction">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Direction'] or //RepresentationItem[@uid = $uidRef and contains(' Direction ',substring-after(@xsi:type,':'))]">(PointAndVector : <sch:value-of select="$uid"/>) The PointAndVector.Vector contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Direction.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PointArray"><!--(Ref to E) PointArray.Directions : SET[1:unbounded] OF PointAndVector (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PointArray') or (self::RepresentationItem and substring-after(@xsi:type,':')='PointArray'))]/Directions/PointAndVector">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PointAndVector'] or //RepresentationItem[@uid = $uidRef and contains(' PointAndVector ',substring-after(@xsi:type,':'))]">(PointArray : <sch:value-of select="$uid"/>) The PointArray.Directions contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PointAndVector.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PointOnCurve"><!--(Ref to E) PointOnCurve.BasicCurve : Curve (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PointOnCurve') or (self::RepresentationItem and substring-after(@xsi:type,':')='PointOnCurve'))]/BasicCurve">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Curve'] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))]">(PointOnCurve : <sch:value-of select="$uid"/>) The PointOnCurve.BasicCurve contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Curve.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PointOnSurface"><!--(Ref to E) PointOnSurface.BasicSurface : Surface (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PointOnSurface') or (self::RepresentationItem and substring-after(@xsi:type,':')='PointOnSurface'))]/BasicSurface">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Surface'] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(PointOnSurface : <sch:value-of select="$uid"/>) The PointOnSurface.BasicSurface contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Surface.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PointOnSurface.Parameter : ExternalRepresentationItem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PointOnSurface') or (self::RepresentationItem and substring-after(@xsi:type,':')='PointOnSurface'))]/Parameter">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExternalRepresentationItem'] or //RepresentationItem[@uid = $uidRef and contains(' ExternalRepresentationItem  ExternalTessellatedAnnotation ',substring-after(@xsi:type,':'))]">(PointOnSurface : <sch:value-of select="$uid"/>) The PointOnSurface.Parameter contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExternalRepresentationItem.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PointShapeElement"><!--(Ref to E) PointShapeElement.RepresentedGeometry : Point (kind=SINGLE - redefined=ShapeElement.RepresentedGeometry)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PointShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='PointShapeElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Point'] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))]">(PointShapeElement : <sch:value-of select="$uid"/>) The PointShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Point.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PointShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='PointShapeElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PointShapeElement : <sch:value-of select="$uid"/>) The PointShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PointToPointPath"><!--(Ref to E) PathSegment.PlacementEnd : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PointToPointPath') or (self::PathSegment and substring-after(@xsi:type,':')='PointToPointPath'))]/PlacementEnd">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(PointToPointPath : <sch:value-of select="$uid"/>) The PointToPointPath.PlacementEnd contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PointZoneShape"><!--(Ref to S) PointZoneShape.Location : PointSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PointZoneShape') or (self::ZoneStructuralMakeupShapeRepresentation and substring-after(@xsi:type,':')='PointZoneShape'))]/Location">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DegeneratePcurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PointOnCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PointOnSurface ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' DegeneratePcurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' PointOnCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' PointOnSurface ',substring-after(@xsi:type,':'))]">(PointZoneShape : <sch:value-of select="$uid"/>) The PointZoneShape.Location contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PointSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Polar11"><!--(Ref to E) Polar11.Placement : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Polar11') or (self::RepresentationItem and substring-after(@xsi:type,':')='Polar11'))]/Placement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(Polar11 : <sch:value-of select="$uid"/>) The Polar11.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PositionTolerance"><!--(Ref to E) PositionTolerance.DatumSystem : OPTIONAL DatumSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PositionTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='PositionTolerance'))]/DatumSystem">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DatumSystem) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DatumSystem'] or //ShapeElement[@uid = $uidRef and contains(' DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem ',substring-after(@xsi:type,':'))]">(PositionTolerance : <sch:value-of select="$uid"/>) The PositionTolerance.DatumSystem contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DatumSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricTolerance.AppliedTo : GeometricToleranceTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PositionTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='PositionTolerance'))]/AppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //PartView[@uid = $uidRef]">(PositionTolerance : <sch:value-of select="$uid"/>) The PositionTolerance.AppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricToleranceTargetSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PositionTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='PositionTolerance'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PositionTolerance : <sch:value-of select="$uid"/>) The PositionTolerance.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.GeometricToleranceContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PositionTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='PositionTolerance'))]/GeometricToleranceContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricToleranceContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(PositionTolerance : <sch:value-of select="$uid"/>) The PositionTolerance.GeometricToleranceContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PreDefinedColour"/>
   <sch:pattern id="PreDefinedTypeQualifier"><!--(Ref to S) PreDefinedTypeQualifier.Name : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PreDefinedTypeQualifier') or (self::PreDefinedTypeQualifier and not(@xsi:type)))]/Name/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PreDefinedTypeQualifier : <sch:value-of select="$uid"/>) The PreDefinedTypeQualifier.Name contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PrecisionQualifier"/>
   <sch:pattern id="PredefinedCurveFont"/>
   <sch:pattern id="ProcessOperationDefinition"><!--(Ref to E) ProcessOperationDefinition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationDefinition') or (self::ProcessOperationDefinition and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProcessOperationDefinition : <sch:value-of select="$uid"/>) The ProcessOperationDefinition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProcessOperationDefinition.ProcessType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationDefinition') or (self::ProcessOperationDefinition and not(@xsi:type)))]/ProcessType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProcessOperationDefinition : <sch:value-of select="$uid"/>) The ProcessOperationDefinition.ProcessType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProcessOperationDefinitionRelationship"><!--(Ref to E) ProcessOperationDefinitionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationDefinitionRelationship') or (self::ProcessOperationDefinitionRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProcessOperationDefinitionRelationship : <sch:value-of select="$uid"/>) The ProcessOperationDefinitionRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProcessOperationDefinitionRelationship.Related : ProcessOperationDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationDefinitionRelationship') or (self::ProcessOperationDefinitionRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ProcessOperationDefinition'] or //ProcessOperationDefinition[@uid = $uidRef]">(ProcessOperationDefinitionRelationship : <sch:value-of select="$uid"/>) The ProcessOperationDefinitionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ProcessOperationDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProcessOperationDefinitionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationDefinitionRelationship') or (self::ProcessOperationDefinitionRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProcessOperationDefinitionRelationship : <sch:value-of select="$uid"/>) The ProcessOperationDefinitionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProcessOperationDefinitionRelationship_WR1"><!--(Rule ProcessOperationDefinitionRelationship.WR1)-->
      <sch:rule context="//ProcessOperationDefinitionRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> ProcessOperationDefinitionRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related ProcessOperationDefinition and the relating ProcessOperationDefinition shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProcessOperationInputOrOutput"><!--(Ref to E) ProcessOperationInputOrOutput.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationInputOrOutput') or (self::ProcessOperationInputOrOutput and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProcessOperationInputOrOutput : <sch:value-of select="$uid"/>) The ProcessOperationInputOrOutput.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProcessOperationInputOrOutput.ConcernedShapes : OPTIONAL SET[1:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationInputOrOutput') or (self::ProcessOperationInputOrOutput and not(@xsi:type)))]/ConcernedShapes/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedShapes/ShapeElement) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(ProcessOperationInputOrOutput : <sch:value-of select="$uid"/>) The ProcessOperationInputOrOutput.ConcernedShapes contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProcessOperationInputOrOutput.Element : ProcessOperationInputOrOutputSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationInputOrOutput') or (self::ProcessOperationInputOrOutput and not(@xsi:type)))]/Element">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ViewOccurrenceRelationship[@uid = $uidRef and contains(' AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage ',substring-after(@xsi:type,':'))] or //PartViewRelationship[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',substring-after(@xsi:type,':'))] or //Occurrence[@uid = $uidRef] or //PartView[@uid = $uidRef]">(ProcessOperationInputOrOutput : <sch:value-of select="$uid"/>) The ProcessOperationInputOrOutput.Element contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProcessOperationInputOrOutputSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProcessOperationInputOrOutput.Placement : OPTIONAL GeometricRepresentationRelationshipWithPlacementTransformation (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationInputOrOutput') or (self::ProcessOperationInputOrOutput and not(@xsi:type)))]/Placement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Placement) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricRepresentationRelationshipWithPlacementTransformation'] or //RepresentationRelationship[@uid = $uidRef and contains(' GeometricRepresentationRelationshipWithPlacementTransformation ',substring-after(@xsi:type,':'))]">(ProcessOperationInputOrOutput : <sch:value-of select="$uid"/>) The ProcessOperationInputOrOutput.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricRepresentationRelationshipWithPlacementTransformation.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProcessOperationInputOrOutput.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationInputOrOutput') or (self::ProcessOperationInputOrOutput and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProcessOperationInputOrOutput : <sch:value-of select="$uid"/>) The ProcessOperationInputOrOutput.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProcessOperationOccurrence"><!--(Ref to E) ProcessOperationOccurrence.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationOccurrence') or (self::ProcessOperationOccurrence and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProcessOperationOccurrence : <sch:value-of select="$uid"/>) The ProcessOperationOccurrence.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProcessOperationOccurrence.DefinedIn : OPTIONAL GeometricCoordinateSpace (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationOccurrence') or (self::ProcessOperationOccurrence and not(@xsi:type)))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefinedIn) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricCoordinateSpace'] or //RepresentationContext[@uid = $uidRef and contains(' GeometricCoordinateSpace ',substring-after(@xsi:type,':'))]">(ProcessOperationOccurrence : <sch:value-of select="$uid"/>) The ProcessOperationOccurrence.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricCoordinateSpace.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProcessOperationOccurrence.Definition : ProcessOperationDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationOccurrence') or (self::ProcessOperationOccurrence and not(@xsi:type)))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ProcessOperationDefinition'] or //ProcessOperationDefinition[@uid = $uidRef]">(ProcessOperationOccurrence : <sch:value-of select="$uid"/>) The ProcessOperationOccurrence.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ProcessOperationDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProcessOperationOccurrenceRelationship"><!--(Ref to E) ProcessOperationOccurrenceRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationOccurrenceRelationship') or (self::ProcessOperationOccurrenceRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProcessOperationOccurrenceRelationship : <sch:value-of select="$uid"/>) The ProcessOperationOccurrenceRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProcessOperationOccurrenceRelationship.Related : ProcessOperationOccurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationOccurrenceRelationship') or (self::ProcessOperationOccurrenceRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ProcessOperationOccurrence'] or //ProcessOperationOccurrence[@uid = $uidRef]">(ProcessOperationOccurrenceRelationship : <sch:value-of select="$uid"/>) The ProcessOperationOccurrenceRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ProcessOperationOccurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProcessOperationOccurrenceRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationOccurrenceRelationship') or (self::ProcessOperationOccurrenceRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProcessOperationOccurrenceRelationship : <sch:value-of select="$uid"/>) The ProcessOperationOccurrenceRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProcessOperationOccurrenceRelationship_WR1"><!--(Rule ProcessOperationOccurrenceRelationship.WR1)-->
      <sch:rule context="//ProcessOperationOccurrenceRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> ProcessOperationOccurrenceRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related ProcessOperationOccurrence and the relating ProcessOperationOccurrence shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProcessOperationResourceAssignment"><!--(Ref to S) ProcessOperationResourceAssignment.AssignedResource : ProcessOperationResourceAssignmentSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationResourceAssignment') or (self::ProcessOperationResourceAssignment and not(@xsi:type)))]/AssignedResource">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)] or //BreakdownElement[@uid = $uidRef] or //IndividualPartView[@uid = $uidRef] or //Occurrence[@uid = $uidRef] or //PartView[@uid = $uidRef] or //RequirementView[@uid = $uidRef]">(ProcessOperationResourceAssignment : <sch:value-of select="$uid"/>) The ProcessOperationResourceAssignment.AssignedResource contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProcessOperationResourceAssignmentSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProcessOperationResourceAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationResourceAssignment') or (self::ProcessOperationResourceAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProcessOperationResourceAssignment : <sch:value-of select="$uid"/>) The ProcessOperationResourceAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProcessOperationResourceAssignment.Placement : OPTIONAL GeometricRepresentationRelationshipWithPlacementTransformation (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessOperationResourceAssignment') or (self::ProcessOperationResourceAssignment and not(@xsi:type)))]/Placement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Placement) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricRepresentationRelationshipWithPlacementTransformation'] or //RepresentationRelationship[@uid = $uidRef and contains(' GeometricRepresentationRelationshipWithPlacementTransformation ',substring-after(@xsi:type,':'))]">(ProcessOperationResourceAssignment : <sch:value-of select="$uid"/>) The ProcessOperationResourceAssignment.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricRepresentationRelationshipWithPlacementTransformation.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProcessPlan"><!--(Ref to E) ProcessPlan.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessPlan') or (self::ProcessPlan and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProcessPlan : <sch:value-of select="$uid"/>) The ProcessPlan.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProcessPlan.ProducedOutputs : OPTIONAL SET[1:unbounded] OF PartVersion (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessPlan') or (self::ProcessPlan and not(@xsi:type)))]/ProducedOutputs/PartVersion">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ProducedOutputs/PartVersion) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartVersion'] or //PartVersion[@uid = $uidRef]">(ProcessPlan : <sch:value-of select="$uid"/>) The ProcessPlan.ProducedOutputs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartVersion.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProcessPlanRelationship"><!--(Ref to E) ProcessPlanRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessPlanRelationship') or (self::ProcessPlanRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProcessPlanRelationship : <sch:value-of select="$uid"/>) The ProcessPlanRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProcessPlanRelationship.Related : ProcessPlan (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessPlanRelationship') or (self::ProcessPlanRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ProcessPlan'] or //ProcessPlan[@uid = $uidRef]">(ProcessPlanRelationship : <sch:value-of select="$uid"/>) The ProcessPlanRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ProcessPlan.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProcessPlanRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessPlanRelationship') or (self::ProcessPlanRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProcessPlanRelationship : <sch:value-of select="$uid"/>) The ProcessPlanRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProcessPlanRelationship_WR1"><!--(Rule ProcessPlanRelationship.WR1)-->
      <sch:rule context="//ProcessPlanRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> ProcessPlanRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related ProcessPlan and the relating ProcessPlan shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProcessStateRelationship"><!--(Default Value) ProcessStateRelationship.RelationType : String = 'process state' (kind=SINGLE - redefined=PartViewRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessStateRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='ProcessStateRelationship'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'process state'">(ProcessStateRelationship : <sch:value-of select="$uid"/>) The ProcessStateRelationship.RelationType contains the wrong value () must be 'process state'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessStateRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='ProcessStateRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProcessStateRelationship : <sch:value-of select="$uid"/>) The ProcessStateRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.Related : PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessStateRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='ProcessStateRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(ProcessStateRelationship : <sch:value-of select="$uid"/>) The ProcessStateRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessStateRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='ProcessStateRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProcessStateRelationship : <sch:value-of select="$uid"/>) The ProcessStateRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProcessedCore"><!--(Ref to E) ProcessedCore.AddedMaterial : OPTIONAL LIST[1:unbounded] OF Ply (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessedCore') or (self::PartView and substring-after(@xsi:type,':')='ProcessedCore'))]/AddedMaterial/Ply">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AddedMaterial/Ply) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Ply'] or //PartView[@uid = $uidRef and contains(' Ply ',substring-after(@xsi:type,':'))]">(ProcessedCore : <sch:value-of select="$uid"/>) The ProcessedCore.AddedMaterial contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Ply.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProcessedCore.CellDirection : PlyOrientationAngle (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessedCore') or (self::PartView and substring-after(@xsi:type,':')='ProcessedCore'))]/CellDirection">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlyOrientationAngle'] or //RepresentationRelationship[@uid = $uidRef and contains(' PlyOrientationAngle  DrapedOrientationAngle  LaidOrientationAngle ',substring-after(@xsi:type,':'))]">(ProcessedCore : <sch:value-of select="$uid"/>) The ProcessedCore.CellDirection contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlyOrientationAngle.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProcessedCore.MadeFromProcessedCore : OPTIONAL SET[1:unbounded] OF ProcessedCore (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessedCore') or (self::PartView and substring-after(@xsi:type,':')='ProcessedCore'))]/MadeFromProcessedCore/ProcessedCore">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../MadeFromProcessedCore/ProcessedCore) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ProcessedCore'] or //PartView[@uid = $uidRef and contains(' ProcessedCore ',substring-after(@xsi:type,':'))]">(ProcessedCore : <sch:value-of select="$uid"/>) The ProcessedCore.MadeFromProcessedCore contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ProcessedCore.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProcessedCore.MadeFromStock : StockMaterial (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessedCore') or (self::PartView and substring-after(@xsi:type,':')='ProcessedCore'))]/MadeFromStock">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StockMaterial'] or //StockMaterial[@uid = $uidRef]">(ProcessedCore : <sch:value-of select="$uid"/>) The ProcessedCore.MadeFromStock contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StockMaterial.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProcessedCore.ProcessedCoreShape : OPTIONAL CoreShapeSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessedCore') or (self::PartView and substring-after(@xsi:type,':')='ProcessedCore'))]/ProcessedCoreShape">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' BeveledSheetRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalAdvancedBrepShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalFacetedBrepShapeRepresentation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalTessellatedShapeRepresentation ',@typeRef)] or //Representation[@uid = $uidRef and contains(' BeveledSheetRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalAdvancedBrepShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalFacetedBrepShapeRepresentation ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef and contains(' ExternalTessellatedShapeRepresentation ',substring-after(@xsi:type,':'))]">(ProcessedCore : <sch:value-of select="$uid"/>) The ProcessedCore.ProcessedCoreShape contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of CoreShapeSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessedCore') or (self::PartView and substring-after(@xsi:type,':')='ProcessedCore'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(ProcessedCore : <sch:value-of select="$uid"/>) The ProcessedCore.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessedCore') or (self::PartView and substring-after(@xsi:type,':')='ProcessedCore'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(ProcessedCore : <sch:value-of select="$uid"/>) The ProcessedCore.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessedCore') or (self::PartView and substring-after(@xsi:type,':')='ProcessedCore'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProcessedCore : <sch:value-of select="$uid"/>) The ProcessedCore.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessedCore') or (self::PartView and substring-after(@xsi:type,':')='ProcessedCore'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(ProcessedCore : <sch:value-of select="$uid"/>) The ProcessedCore.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProcessedCore') or (self::PartView and substring-after(@xsi:type,':')='ProcessedCore'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(ProcessedCore : <sch:value-of select="$uid"/>) The ProcessedCore.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ProductClass"><!--(Ref to S) ProductClass.LevelType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductClass') or (self::ProductConcept and substring-after(@xsi:type,':')='ProductClass'))]/LevelType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProductClass : <sch:value-of select="$uid"/>) The ProductClass.LevelType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductClass.Scope : OPTIONAL Part (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductClass') or (self::ProductConcept and substring-after(@xsi:type,':')='ProductClass'))]/Scope">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Scope) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Part'] or //Part[@uid = $uidRef]">(ProductClass : <sch:value-of select="$uid"/>) The ProductClass.Scope contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Part.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductConcept.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductClass') or (self::ProductConcept and substring-after(@xsi:type,':')='ProductClass'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProductClass : <sch:value-of select="$uid"/>) The ProductClass.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductConcept.TargetMarket : OPTIONAL Market (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductClass') or (self::ProductConcept and substring-after(@xsi:type,':')='ProductClass'))]/TargetMarket">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./TargetMarket) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Market'] or //Market[@uid = $uidRef]">(ProductClass : <sch:value-of select="$uid"/>) The ProductClass.TargetMarket contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Market.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductClassRelationship"><!--(Ref to E) ProductClassRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductClassRelationship') or (self::ProductClassRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProductClassRelationship : <sch:value-of select="$uid"/>) The ProductClassRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductClassRelationship.Related : ProductClass (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductClassRelationship') or (self::ProductClassRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ProductClass'] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))]">(ProductClassRelationship : <sch:value-of select="$uid"/>) The ProductClassRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ProductClass.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProductClassRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductClassRelationship') or (self::ProductClassRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProductClassRelationship : <sch:value-of select="$uid"/>) The ProductClassRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductClassRelationship_WR1"><!--(Rule ProductClassRelationship.WR1)-->
      <sch:rule context="//ProductClassRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> ProductClassRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related ProductClass and the relating ProductClass shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductConcept"><!--(Ref to E) ProductConcept.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductConcept') or (self::ProductConcept and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProductConcept : <sch:value-of select="$uid"/>) The ProductConcept.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductConcept.TargetMarket : OPTIONAL Market (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductConcept') or (self::ProductConcept and not(@xsi:type)))]/TargetMarket">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./TargetMarket) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Market'] or //Market[@uid = $uidRef]">(ProductConcept : <sch:value-of select="$uid"/>) The ProductConcept.TargetMarket contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Market.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductConfiguration"><!--(Ref to E) ProductConfiguration.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductConfiguration') or (self::ProductConfiguration and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProductConfiguration : <sch:value-of select="$uid"/>) The ProductConfiguration.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductConfiguration.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductConfiguration') or (self::ProductConfiguration and not(@xsi:type)))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(ProductConfiguration : <sch:value-of select="$uid"/>) The ProductConfiguration.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductConfiguration.DefiningSpecifications : OPTIONAL SET[1:unbounded] OF Specification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductConfiguration') or (self::ProductConfiguration and not(@xsi:type)))]/DefiningSpecifications/Specification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../DefiningSpecifications/Specification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Specification'] or //Specification[@uid = $uidRef]">(ProductConfiguration : <sch:value-of select="$uid"/>) The ProductConfiguration.DefiningSpecifications contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Specification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductConfigurationRelationship"><!--(Ref to E) ProductConfigurationRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductConfigurationRelationship') or (self::ProductConfigurationRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProductConfigurationRelationship : <sch:value-of select="$uid"/>) The ProductConfigurationRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductConfigurationRelationship.Related : ProductConfiguration (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductConfigurationRelationship') or (self::ProductConfigurationRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ProductConfiguration'] or //ProductConfiguration[@uid = $uidRef]">(ProductConfigurationRelationship : <sch:value-of select="$uid"/>) The ProductConfigurationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ProductConfiguration.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProductConfigurationRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductConfigurationRelationship') or (self::ProductConfigurationRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProductConfigurationRelationship : <sch:value-of select="$uid"/>) The ProductConfigurationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductConfigurationRelationship_WR1"><!--(Rule ProductConfigurationRelationship.WR1)-->
      <sch:rule context="//ProductConfigurationRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> ProductConfigurationRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related ProductConfiguration and the relating ProductConfiguration shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductDesignAssociation"><!--(Ref to E) ProductDesignAssociation.AssociatedDesign : PartVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductDesignAssociation') or (self::ProductDesignAssociation and not(@xsi:type)))]/AssociatedDesign">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartVersion'] or //PartVersion[@uid = $uidRef]">(ProductDesignAssociation : <sch:value-of select="$uid"/>) The ProductDesignAssociation.AssociatedDesign contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductDesignAssociation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductDesignAssociation') or (self::ProductDesignAssociation and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProductDesignAssociation : <sch:value-of select="$uid"/>) The ProductDesignAssociation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductGroup"><!--(Ref to E) ProductGroup.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductGroup') or (self::ProductGroup and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProductGroup : <sch:value-of select="$uid"/>) The ProductGroup.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductGroupMembership"><!--(Ref to S) ProductGroupMembership.Member : ProductGroupMembershipSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductGroupMembership') or (self::ProductGroupMembership and not(@xsi:type)))]/Member">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductGroup ',@typeRef)] or //IndividualPart[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //Part[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //ProductConcept[@uid = $uidRef] or //ProductGroup[@uid = $uidRef]">(ProductGroupMembership : <sch:value-of select="$uid"/>) The ProductGroupMembership.Member contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProductGroupMembershipSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductGroupRelationship"><!--(Ref to E) ProductGroupRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductGroupRelationship') or (self::ProductGroupRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProductGroupRelationship : <sch:value-of select="$uid"/>) The ProductGroupRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductGroupRelationship.Related : ProductGroup (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductGroupRelationship') or (self::ProductGroupRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ProductGroup'] or //ProductGroup[@uid = $uidRef]">(ProductGroupRelationship : <sch:value-of select="$uid"/>) The ProductGroupRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ProductGroup.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProductGroupRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductGroupRelationship') or (self::ProductGroupRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProductGroupRelationship : <sch:value-of select="$uid"/>) The ProductGroupRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductPlannedToRealized"><!--(Ref to E) ProductPlannedToRealized.Related : RealizedIndividualPart (kind=SINGLE - redefined=IndividualPartVersionRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductPlannedToRealized') or (self::IndividualPartVersionRelationship and substring-after(@xsi:type,':')='ProductPlannedToRealized'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RealizedIndividualPart'] or //IndividualPartVersion[@uid = $uidRef and contains(' RealizedIndividualPart ',substring-after(@xsi:type,':'))]">(ProductPlannedToRealized : <sch:value-of select="$uid"/>) The ProductPlannedToRealized.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RealizedIndividualPart.</sch:assert>
      </sch:rule>
      <!--(Ref to E) IndividualPartVersionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductPlannedToRealized') or (self::IndividualPartVersionRelationship and substring-after(@xsi:type,':')='ProductPlannedToRealized'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProductPlannedToRealized : <sch:value-of select="$uid"/>) The ProductPlannedToRealized.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) IndividualPartVersionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductPlannedToRealized') or (self::IndividualPartVersionRelationship and substring-after(@xsi:type,':')='ProductPlannedToRealized'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProductPlannedToRealized : <sch:value-of select="$uid"/>) The ProductPlannedToRealized.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductStructureKinematicPathAssociation"><!--(Ref to E) ProductStructureKinematicPathAssociation.AssociatedMotionPath : KinematicPathDefinedByNodes (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductStructureKinematicPathAssociation') or (self::ProductStructureKinematicPathAssociation and not(@xsi:type)))]/AssociatedMotionPath">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'KinematicPathDefinedByNodes'] or //RepresentationItem[@uid = $uidRef and contains(' KinematicPathDefinedByNodes ',substring-after(@xsi:type,':'))]">(ProductStructureKinematicPathAssociation : <sch:value-of select="$uid"/>) The ProductStructureKinematicPathAssociation.AssociatedMotionPath contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type KinematicPathDefinedByNodes.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductStructureKinematicPathAssociation.AssociatedMotionRepresentation : LinkMotionAlongPath (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductStructureKinematicPathAssociation') or (self::ProductStructureKinematicPathAssociation and not(@xsi:type)))]/AssociatedMotionRepresentation">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'LinkMotionAlongPath'] or //Representation[@uid = $uidRef and contains(' LinkMotionAlongPath ',substring-after(@xsi:type,':'))]">(ProductStructureKinematicPathAssociation : <sch:value-of select="$uid"/>) The ProductStructureKinematicPathAssociation.AssociatedMotionRepresentation contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type LinkMotionAlongPath.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductStructureKinematicPathAssociation.Substructure : OPTIONAL SpecifiedOccurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductStructureKinematicPathAssociation') or (self::ProductStructureKinematicPathAssociation and not(@xsi:type)))]/Substructure">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Substructure) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SpecifiedOccurrence'] or //Occurrence[@uid = $uidRef and contains(' SpecifiedOccurrence ',substring-after(@xsi:type,':'))]">(ProductStructureKinematicPathAssociation : <sch:value-of select="$uid"/>) The ProductStructureKinematicPathAssociation.Substructure contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SpecifiedOccurrence.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProductStructureLinkMotionAssociation"><!--(Ref to E) ProductStructureLinkMotionAssociation.AssociatedMotion : LinkMotionRelationship (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductStructureLinkMotionAssociation') or (self::ProductStructureLinkMotionAssociation and not(@xsi:type)))]/AssociatedMotion">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'LinkMotionRelationship'] or //LinkMotionRelationship[@uid = $uidRef]">(ProductStructureLinkMotionAssociation : <sch:value-of select="$uid"/>) The ProductStructureLinkMotionAssociation.AssociatedMotion contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type LinkMotionRelationship.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProductStructureLinkMotionAssociation.Substructure : OPTIONAL SpecifiedOccurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProductStructureLinkMotionAssociation') or (self::ProductStructureLinkMotionAssociation and not(@xsi:type)))]/Substructure">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Substructure) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SpecifiedOccurrence'] or //Occurrence[@uid = $uidRef and contains(' SpecifiedOccurrence ',substring-after(@xsi:type,':'))]">(ProductStructureLinkMotionAssociation : <sch:value-of select="$uid"/>) The ProductStructureLinkMotionAssociation.Substructure contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SpecifiedOccurrence.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Project"><!--(Ref to E) Project.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Project') or (self::Project and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Project : <sch:value-of select="$uid"/>) The Project.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Project.PlannedEndDate : OPTIONAL PeriodOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Project') or (self::Project and not(@xsi:type)))]/PlannedEndDate/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::DateTimeString) or (self::Duration) or (self::Event and //Event[@uid = $uidRef])">(Project : <sch:value-of select="$uid"/>) The Project.PlannedEndDate contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PeriodOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Project.PlannedStartDate : OPTIONAL EventOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Project') or (self::Project and not(@xsi:type)))]/PlannedStartDate/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(Project : <sch:value-of select="$uid"/>) The Project.PlannedStartDate contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EventOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Project.ResponsibleOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Project') or (self::Project and not(@xsi:type)))]/ResponsibleOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ResponsibleOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(Project : <sch:value-of select="$uid"/>) The Project.ResponsibleOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProjectAssignment"><!--(Ref to E) ProjectAssignment.AssignedProject : Project (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProjectAssignment') or (self::ProjectAssignment and not(@xsi:type)))]/AssignedProject">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Project'] or //Project[@uid = $uidRef]">(ProjectAssignment : <sch:value-of select="$uid"/>) The ProjectAssignment.AssignedProject contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Project.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProjectAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProjectAssignment') or (self::ProjectAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProjectAssignment : <sch:value-of select="$uid"/>) The ProjectAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProjectAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProjectAssignment') or (self::ProjectAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProjectAssignment : <sch:value-of select="$uid"/>) The ProjectAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProjectRelationship"><!--(Ref to E) ProjectRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProjectRelationship') or (self::ProjectRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProjectRelationship : <sch:value-of select="$uid"/>) The ProjectRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProjectRelationship.Related : Project (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProjectRelationship') or (self::ProjectRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Project'] or //Project[@uid = $uidRef]">(ProjectRelationship : <sch:value-of select="$uid"/>) The ProjectRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Project.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProjectRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProjectRelationship') or (self::ProjectRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProjectRelationship : <sch:value-of select="$uid"/>) The ProjectRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProjectRelationship_WR1"><!--(Rule ProjectRelationship.WR1)-->
      <sch:rule context="//ProjectRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> ProjectRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Project and the relating Project shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProjectedZoneDefinition"><!--(Ref to E) ProjectedZoneDefinition.ProjectionEnd : ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProjectedZoneDefinition') or (self::ToleranceZoneDefinition and substring-after(@xsi:type,':')='ProjectedZoneDefinition'))]/ProjectionEnd">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(ProjectedZoneDefinition : <sch:value-of select="$uid"/>) The ProjectedZoneDefinition.ProjectionEnd contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ToleranceZoneDefinition.Boundaries : OPTIONAL SET[1:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProjectedZoneDefinition') or (self::ToleranceZoneDefinition and substring-after(@xsi:type,':')='ProjectedZoneDefinition'))]/Boundaries/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Boundaries/ShapeElement) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(ProjectedZoneDefinition : <sch:value-of select="$uid"/>) The ProjectedZoneDefinition.Boundaries contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProjectedZoneDefinition_WR1"><!--(Rule ProjectedZoneDefinition.WR1)--><sch:rule context="//ToleranceZoneDefinition[substring-after(@xsi:type,':')='ProjectedZoneDefinition']/ProjectionLength"> <sch:let name="uid" value="../@uid"/> <sch:let name="unitRef" value="./Unit/@uidRef"/> <sch:assert test="//Unit[@uid=$unitRef]/Quantity/ClassString ='length'">(ProjectedZoneDefinition <sch:value-of select="$uid"/>) The unit of ProjectionLength shall be a length measure unit. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="ProjectedZoneDefinitionWithOffset"><!--(Ref to E) ProjectedZoneDefinition.ProjectionEnd : ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProjectedZoneDefinitionWithOffset') or (self::ToleranceZoneDefinition and substring-after(@xsi:type,':')='ProjectedZoneDefinitionWithOffset'))]/ProjectionEnd">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(ProjectedZoneDefinitionWithOffset : <sch:value-of select="$uid"/>) The ProjectedZoneDefinitionWithOffset.ProjectionEnd contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ToleranceZoneDefinition.Boundaries : OPTIONAL SET[1:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProjectedZoneDefinitionWithOffset') or (self::ToleranceZoneDefinition and substring-after(@xsi:type,':')='ProjectedZoneDefinitionWithOffset'))]/Boundaries/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Boundaries/ShapeElement) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(ProjectedZoneDefinitionWithOffset : <sch:value-of select="$uid"/>) The ProjectedZoneDefinitionWithOffset.Boundaries contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProjectedZoneDefinitionWithOffset_WR1"><!--(Rule ProjectedZoneDefinitionWithOffset.WR1)--><sch:rule context="//ToleranceZoneDefinition[substring-after(@xsi:type,':')='ProjectedZoneDefinitionWithOffset']/Offset"> <sch:let name="uid" value="../@uid"/> <sch:let name="unitRef" value="./Unit/@uidRef"/> <sch:assert test="//Unit[@uid=$unitRef]/Quantity/ClassString ='length'">(ProjectedZoneDefinitionWithOffset <sch:value-of select="$uid"/>) The unit of Offset shall be a length measure unit. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="PromissoryAssemblyOccurrenceUsage"><!--(Default Value) PromissoryAssemblyOccurrenceUsage.RelationType : String = 'promissory assembly occurrence' (kind=SINGLE - redefined=ViewOccurrenceRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PromissoryAssemblyOccurrenceUsage') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='PromissoryAssemblyOccurrenceUsage'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'promissory assembly occurrence'">(PromissoryAssemblyOccurrenceUsage : <sch:value-of select="$uid"/>) The PromissoryAssemblyOccurrenceUsage.RelationType contains the wrong value () must be 'promissory assembly occurrence'.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssemblyOccurrenceRelationship.Placement : OPTIONAL SET[1:unbounded] OF TransformationAndAssociationSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PromissoryAssemblyOccurrenceUsage') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='PromissoryAssemblyOccurrenceUsage'))]/Placement/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::CartesianTransformation or (self::Transformation and contains(' CartesianTransformation ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)]) or (self::GeometricRepresentationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',@typeRef)]) or (self::GeometryToTopologyModelAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometryToTopologyModelAssociation ',@typeRef)]) or (self::TopologyToGeometryModelAssociation and //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologyToGeometryModelAssociation ',@typeRef)]) or (self::CartesianTransformation) or (self::GeometricRepresentationRelationship and //RepresentationRelationship[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',substring-after(@xsi:type,':'))]) or (self::GeometryToTopologyModelAssociation and //RepresentationRelationship[@uid = $uidRef and contains(' GeometryToTopologyModelAssociation ',substring-after(@xsi:type,':'))]) or (self::TopologyToGeometryModelAssociation and //RepresentationRelationship[@uid = $uidRef and contains(' TopologyToGeometryModelAssociation ',substring-after(@xsi:type,':'))])">(PromissoryAssemblyOccurrenceUsage : <sch:value-of select="$uid"/>) The PromissoryAssemblyOccurrenceUsage.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of TransformationAndAssociationSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ViewOccurrenceRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PromissoryAssemblyOccurrenceUsage') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='PromissoryAssemblyOccurrenceUsage'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PromissoryAssemblyOccurrenceUsage : <sch:value-of select="$uid"/>) The PromissoryAssemblyOccurrenceUsage.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ViewOccurrenceRelationship.Related : DefinitionBasedOccurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PromissoryAssemblyOccurrenceUsage') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='PromissoryAssemblyOccurrenceUsage'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DefinitionBasedOccurrence'] or //Occurrence[@uid = $uidRef and contains(' DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence ',substring-after(@xsi:type,':'))]">(PromissoryAssemblyOccurrenceUsage : <sch:value-of select="$uid"/>) The PromissoryAssemblyOccurrenceUsage.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DefinitionBasedOccurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ViewOccurrenceRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PromissoryAssemblyOccurrenceUsage') or (self::ViewOccurrenceRelationship and substring-after(@xsi:type,':')='PromissoryAssemblyOccurrenceUsage'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PromissoryAssemblyOccurrenceUsage : <sch:value-of select="$uid"/>) The PromissoryAssemblyOccurrenceUsage.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PromissoryAssemblyViewUsage"><!--(Default Value) PromissoryAssemblyViewUsage.RelationType : String = 'promissory assembly view' (kind=SINGLE - redefined=PartViewRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PromissoryAssemblyViewUsage') or (self::PartViewRelationship and substring-after(@xsi:type,':')='PromissoryAssemblyViewUsage'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'promissory assembly view'">(PromissoryAssemblyViewUsage : <sch:value-of select="$uid"/>) The PromissoryAssemblyViewUsage.RelationType contains the wrong value () must be 'promissory assembly view'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AssemblyViewRelationship.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PromissoryAssemblyViewUsage') or (self::PartViewRelationship and substring-after(@xsi:type,':')='PromissoryAssemblyViewUsage'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(PromissoryAssemblyViewUsage : <sch:value-of select="$uid"/>) The PromissoryAssemblyViewUsage.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PromissoryAssemblyViewUsage') or (self::PartViewRelationship and substring-after(@xsi:type,':')='PromissoryAssemblyViewUsage'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PromissoryAssemblyViewUsage : <sch:value-of select="$uid"/>) The PromissoryAssemblyViewUsage.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.Related : PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PromissoryAssemblyViewUsage') or (self::PartViewRelationship and substring-after(@xsi:type,':')='PromissoryAssemblyViewUsage'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(PromissoryAssemblyViewUsage : <sch:value-of select="$uid"/>) The PromissoryAssemblyViewUsage.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PromissoryAssemblyViewUsage') or (self::PartViewRelationship and substring-after(@xsi:type,':')='PromissoryAssemblyViewUsage'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PromissoryAssemblyViewUsage : <sch:value-of select="$uid"/>) The PromissoryAssemblyViewUsage.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyDefinition"><!--(Ref to S) PropertyDefinition.AllowedUnits : OPTIONAL SET[1:unbounded] OF UnitSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinition') or (self::PropertyDefinition and not(@xsi:type)))]/AllowedUnits/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ExternalUnit and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)]) or (self::Unit and //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)]) or (self::ExternalUnit and //ExternalUnit[@uid = $uidRef]) or (self::Unit and //Unit[@uid = $uidRef])">(PropertyDefinition : <sch:value-of select="$uid"/>) The PropertyDefinition.AllowedUnits contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyDefinition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinition') or (self::PropertyDefinition and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PropertyDefinition : <sch:value-of select="$uid"/>) The PropertyDefinition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyDefinition.DefinedIn : OPTIONAL ExternalClassSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinition') or (self::PropertyDefinition and not(@xsi:type)))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefinedIn) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExternalClassSystem'] or //ExternalClassSystem[@uid = $uidRef]">(PropertyDefinition : <sch:value-of select="$uid"/>) The PropertyDefinition.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExternalClassSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyDefinition.Definition : OPTIONAL ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinition') or (self::PropertyDefinition and not(@xsi:type)))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(PropertyDefinition : <sch:value-of select="$uid"/>) The PropertyDefinition.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyDefinition.PropertyType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinition') or (self::PropertyDefinition and not(@xsi:type)))]/PropertyType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PropertyDefinition : <sch:value-of select="$uid"/>) The PropertyDefinition.PropertyType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyDefinitionAssignment"><!--(Ref to S) PropertyDefinitionAssignment.AllowedUnits : OPTIONAL SET[1:unbounded] OF UnitSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinitionAssignment') or (self::PropertyDefinitionAssignment and not(@xsi:type)))]/AllowedUnits/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ExternalUnit and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)]) or (self::Unit and //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)]) or (self::ExternalUnit and //ExternalUnit[@uid = $uidRef]) or (self::Unit and //Unit[@uid = $uidRef])">(PropertyDefinitionAssignment : <sch:value-of select="$uid"/>) The PropertyDefinitionAssignment.AllowedUnits contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyDefinitionAssignment.AssignedPropertyDefinition : PropertyDefinitionSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinitionAssignment') or (self::PropertyDefinitionAssignment and not(@xsi:type)))]/AssignedPropertyDefinition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionEnum) or (self::PropertyDefinitionString)">(PropertyDefinitionAssignment : <sch:value-of select="$uid"/>) The PropertyDefinitionAssignment.AssignedPropertyDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PropertyDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyDefinitionAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinitionAssignment') or (self::PropertyDefinitionAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PropertyDefinitionAssignment : <sch:value-of select="$uid"/>) The PropertyDefinitionAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyDefinitionAssignment.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinitionAssignment') or (self::PropertyDefinitionAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PropertyDefinitionAssignment : <sch:value-of select="$uid"/>) The PropertyDefinitionAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyDefinitionAssignmentRelationship"><!--(Ref to E) PropertyDefinitionAssignmentRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinitionAssignmentRelationship') or (self::PropertyDefinitionAssignmentRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PropertyDefinitionAssignmentRelationship : <sch:value-of select="$uid"/>) The PropertyDefinitionAssignmentRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyDefinitionAssignmentRelationship.Related : PropertyDefinitionAssignment (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinitionAssignmentRelationship') or (self::PropertyDefinitionAssignmentRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinitionAssignment'] or //PropertyDefinitionAssignment[@uid = $uidRef]">(PropertyDefinitionAssignmentRelationship : <sch:value-of select="$uid"/>) The PropertyDefinitionAssignmentRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinitionAssignment.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyDefinitionAssignmentRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinitionAssignmentRelationship') or (self::PropertyDefinitionAssignmentRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PropertyDefinitionAssignmentRelationship : <sch:value-of select="$uid"/>) The PropertyDefinitionAssignmentRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyDefinitionAssignmentRelationship_WR1"><!--(Rule PropertyDefinitionAssignmentRelationship.WR1)-->
      <sch:rule context="//PropertyDefinitionAssignmentRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> PropertyDefinitionAssignmentRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related PropertyDefinitionAssignment and the relating PropertyDefinitionAssignment shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyDefinitionRelationship"><!--(Ref to E) PropertyDefinitionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinitionRelationship') or (self::PropertyDefinitionRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PropertyDefinitionRelationship : <sch:value-of select="$uid"/>) The PropertyDefinitionRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyDefinitionRelationship.Related : PropertyDefinitionSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinitionRelationship') or (self::PropertyDefinitionRelationship and not(@xsi:type)))]/Related/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionEnum) or (self::PropertyDefinitionString)">(PropertyDefinitionRelationship : <sch:value-of select="$uid"/>) The PropertyDefinitionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PropertyDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyDefinitionRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyDefinitionRelationship') or (self::PropertyDefinitionRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PropertyDefinitionRelationship : <sch:value-of select="$uid"/>) The PropertyDefinitionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyDefinitionRelationship_WR1"><!--(Rule PropertyDefinitionRelationship.WR1)-->
      <sch:rule context="//PropertyDefinitionRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> PropertyDefinitionRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related PropertyDefinition and the relating PropertyDefinition shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyValueAssignment"><!--(Ref to E) PropertyValueAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyValueAssignment') or (self::PropertyValueAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PropertyValueAssignment : <sch:value-of select="$uid"/>) The PropertyValueAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValueAssignment.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyValueAssignment') or (self::PropertyValueAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PropertyValueAssignment : <sch:value-of select="$uid"/>) The PropertyValueAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyValueAssignment.ValueAssignmentContext : OPTIONAL PropertyDefinitionAssignment (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyValueAssignment') or (self::PropertyValueAssignment and not(@xsi:type)))]/ValueAssignmentContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ValueAssignmentContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyDefinitionAssignment'] or //PropertyDefinitionAssignment[@uid = $uidRef]">(PropertyValueAssignment : <sch:value-of select="$uid"/>) The PropertyValueAssignment.ValueAssignmentContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyDefinitionAssignment.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyValueAssignmentRelationship"><!--(Ref to E) PropertyValueAssignmentRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyValueAssignmentRelationship') or (self::PropertyValueAssignmentRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PropertyValueAssignmentRelationship : <sch:value-of select="$uid"/>) The PropertyValueAssignmentRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyValueAssignmentRelationship.Related : PropertyValueAssignment (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyValueAssignmentRelationship') or (self::PropertyValueAssignmentRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyValueAssignment'] or //PropertyValueAssignment[@uid = $uidRef]">(PropertyValueAssignmentRelationship : <sch:value-of select="$uid"/>) The PropertyValueAssignmentRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyValueAssignment.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValueAssignmentRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyValueAssignmentRelationship') or (self::PropertyValueAssignmentRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PropertyValueAssignmentRelationship : <sch:value-of select="$uid"/>) The PropertyValueAssignmentRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyValueAssignmentRelationship_WR1"><!--(Rule PropertyValueAssignmentRelationship.WR1)-->
      <sch:rule context="//PropertyValueAssignmentRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> PropertyValueAssignmentRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related PropertyValueAssignment and the relating PropertyValueAssignment shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyValueRelationship"><!--(Ref to E) PropertyValueRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyValueRelationship') or (self::PropertyValueRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(PropertyValueRelationship : <sch:value-of select="$uid"/>) The PropertyValueRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyValueRelationship.Related : PropertyValue (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyValueRelationship') or (self::PropertyValueRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PropertyValue'] or //PropertyValue[@uid = $uidRef] or //*[@uid = $uidRef and (self::Quantity or self::BevelAngle or self::VerticalProfileHeight or self::Angle or self::Weight or self::RealWorldScale or self::MaxCrossSectionDiameter or self::MinCrossSectionDiameter or self::MinimumBendRadius or self::Fiber11Offset or self::ModifierValue or self::Offset or self::Angle or self::Angle or self::Quantity or self::RequiredCharacteristic or self::AnalysedCharacteristic or self::IndexValue or self::DimensionValue or self::UnitLength or self::FirstUnitSize or self::SecondUnitSize or self::UnequallyDisposedToleranceZoneDisplacement or self::ToleranceValue or self::ForcedLength or self::LotSize or self::Quantity or self::MaterialValue or self::MeasuredCharacteristics or self::Angle or self::TotalThickness or self::VolumePercent or self::PlannedCharacteristics or self::PlyThickness or self::WaitingTime or self::ProjectionLength or self::Offset or self::Quantity or self::Density or self::Height or self::Width or self::FileSize or self::PageCount or self::TotalThickness or self::Diameter or self::Diameter or self::TargetLength or self::TargetWidth or self::TargetLength or self::Thickness or self::Angle or self::TwistPeriod)]">(PropertyValueRelationship : <sch:value-of select="$uid"/>) The PropertyValueRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PropertyValue.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValueRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='PropertyValueRelationship') or (self::PropertyValueRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(PropertyValueRelationship : <sch:value-of select="$uid"/>) The PropertyValueRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="PropertyValueRelationship_WR1"><!--(Rule PropertyValueRelationship.WR1)-->
      <sch:rule context="//PropertyValueRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> PropertyValueRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related PropertyValue and the relating PropertyValue shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="Proxy"><!--(Ref to S) Proxy.Individual : ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Proxy') or (self::Proxy or (self::SameAs and substring-after(@xsi:type,':')='Proxy') or (self::SameAs and substring-after(@xsi:type,':')='Proxy') or (self::SameAs and substring-after(@xsi:type,':')='Proxy')))]/Individual/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(Proxy : <sch:value-of select="$uid"/>) The Proxy.Individual contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProxyRelationship"><!--(Ref to E) ProxyRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProxyRelationship') or (self::ProxyRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ProxyRelationship : <sch:value-of select="$uid"/>) The ProxyRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ProxyRelationship.Related : Proxy (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProxyRelationship') or (self::ProxyRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Proxy'] or //Proxy[@uid = $uidRef] or //*[@uid = $uidRef and (self::SameAs or self::SameAs or self::SameAs)]">(ProxyRelationship : <sch:value-of select="$uid"/>) The ProxyRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Proxy.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ProxyRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ProxyRelationship') or (self::ProxyRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ProxyRelationship : <sch:value-of select="$uid"/>) The ProxyRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ProxyRelationship_WR1"><!--(Rule ProxyRelationship.WR1)-->
      <sch:rule context="//ProxyRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> ProxyRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Proxy and the relating Proxy shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="QualitativeUncertainty"/>
   <sch:pattern id="QuantifiedOccurrence"><!--(Ref to E) Occurrence.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='QuantifiedOccurrence') or (self::Occurrence and substring-after(@xsi:type,':')='QuantifiedOccurrence'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(QuantifiedOccurrence : <sch:value-of select="$uid"/>) The QuantifiedOccurrence.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Occurrence.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='QuantifiedOccurrence') or (self::Occurrence and substring-after(@xsi:type,':')='QuantifiedOccurrence'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(QuantifiedOccurrence : <sch:value-of select="$uid"/>) The QuantifiedOccurrence.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="QuantifiedOccurrence_WR1"><!--(Rule QuantifiedOccurrence.WR1)--> <sch:rule context="//Occurrence[substring-after(@xsi:type,':')= 'QuantifiedOccurrence']"> <sch:let name="uid" value="@uid"/> <sch:assert test="Quantity or Criterion"> QuantifiedOccurrence WR1 Error on entity <sch:value-of select="$uid"/>: either Quantity or Criterion or both shall be defined. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="RadialSize"><!--(Ref to E) DimensionalSize.IsAppliedTo : ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RadialSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='RadialSize'))]/IsAppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(RadialSize : <sch:value-of select="$uid"/>) The RadialSize.IsAppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RadialSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='RadialSize'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(RadialSize : <sch:value-of select="$uid"/>) The RadialSize.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.GeometricDimensionContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RadialSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='RadialSize'))]/GeometricDimensionContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricDimensionContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(RadialSize : <sch:value-of select="$uid"/>) The RadialSize.GeometricDimensionContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RationalRepresentationItem"/>
   <sch:pattern id="RealRepresentationItem"/>
   <sch:pattern id="RealizedIndividualPart"><!--(Ref to E) IndividualPartVersion.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RealizedIndividualPart') or (self::IndividualPartVersion and substring-after(@xsi:type,':')='RealizedIndividualPart'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(RealizedIndividualPart : <sch:value-of select="$uid"/>) The RealizedIndividualPart.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Inverse of IndividualPart.Versions :: PartProperty) IndividualPartVersion.VersionOf : IndividualPart) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="RectangularSize"/>
   <sch:pattern id="RectangularTrimmedSurface"/>
   <sch:pattern id="ReinforcementOrientationBasis"><!--(Ref to S) ReinforcementOrientationBasis.Basis11Direction : DirectionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReinforcementOrientationBasis') or (self::Representation and substring-after(@xsi:type,':')='ReinforcementOrientationBasis'))]/Basis11Direction">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Cartesian11 ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve11 ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Cylindrical11 ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Direction ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PointArray ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Polar11 ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' UserDefined11 ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' Cartesian11 ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve11 ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Cylindrical11 ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Direction ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' PointArray ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Polar11 ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' UserDefined11 ',substring-after(@xsi:type,':'))]">(ReinforcementOrientationBasis : <sch:value-of select="$uid"/>) The ReinforcementOrientationBasis.Basis11Direction contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of DirectionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ReinforcementOrientationBasis.CoordinateSpace : GeometricCoordinateSpace (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReinforcementOrientationBasis') or (self::Representation and substring-after(@xsi:type,':')='ReinforcementOrientationBasis'))]/CoordinateSpace">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricCoordinateSpace'] or //RepresentationContext[@uid = $uidRef and contains(' GeometricCoordinateSpace ',substring-after(@xsi:type,':'))]">(ReinforcementOrientationBasis : <sch:value-of select="$uid"/>) The ReinforcementOrientationBasis.CoordinateSpace contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricCoordinateSpace.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ReinforcementOrientationBasis.Placement : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReinforcementOrientationBasis') or (self::Representation and substring-after(@xsi:type,':')='ReinforcementOrientationBasis'))]/Placement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(ReinforcementOrientationBasis : <sch:value-of select="$uid"/>) The ReinforcementOrientationBasis.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Rule for inverse of LaminateTable.Basis :: ReferenceProperty) ReinforcementOrientationBasis.Table : LaminateTable)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReinforcementOrientationBasis') or (self::Representation and substring-after(@xsi:type,':')='ReinforcementOrientationBasis'))]">
         <sch:let name="uid" value="./@uid"/>
         <sch:assert test="//PartView[contains(' LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',substring-after(@xsi:type,':'))]/Basis/ReinforcementOrientationBasis[@uidRef = $uid]">(ReinforcementOrientationBasis : <sch:value-of select="$uid"/>) The ReinforcementOrientationBasis.Table inverse rule must be referenced by LaminateTable.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReinforcementOrientationBasis') or (self::Representation and substring-after(@xsi:type,':')='ReinforcementOrientationBasis'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ReinforcementOrientationBasis : <sch:value-of select="$uid"/>) The ReinforcementOrientationBasis.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Representation.Items : SET[1:unbounded] OF RepresentationItem (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReinforcementOrientationBasis') or (self::Representation and substring-after(@xsi:type,':')='ReinforcementOrientationBasis'))]/Items/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(ReinforcementOrientationBasis : <sch:value-of select="$uid"/>) The ReinforcementOrientationBasis.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReinforcementOrientationBasis') or (self::Representation and substring-after(@xsi:type,':')='ReinforcementOrientationBasis'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ReinforcementOrientationBasis : <sch:value-of select="$uid"/>) The ReinforcementOrientationBasis.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ReplacedPartViewRelationship"><!--(Default Value) ReplacedPartViewRelationship.RelationType : String = 'replaced part view' (kind=SINGLE - redefined=PartViewRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReplacedPartViewRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='ReplacedPartViewRelationship'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'replaced part view'">(ReplacedPartViewRelationship : <sch:value-of select="$uid"/>) The ReplacedPartViewRelationship.RelationType contains the wrong value () must be 'replaced part view'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReplacedPartViewRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='ReplacedPartViewRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ReplacedPartViewRelationship : <sch:value-of select="$uid"/>) The ReplacedPartViewRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.Related : PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReplacedPartViewRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='ReplacedPartViewRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(ReplacedPartViewRelationship : <sch:value-of select="$uid"/>) The ReplacedPartViewRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReplacedPartViewRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='ReplacedPartViewRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ReplacedPartViewRelationship : <sch:value-of select="$uid"/>) The ReplacedPartViewRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ReplacedUsageRelationship"><!--(Ref to S) ReplacedUsageRelationship.UsageContext : OccurrenceUsageContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReplacedUsageRelationship') or (self::OccurrenceRelationship and substring-after(@xsi:type,':')='ReplacedUsageRelationship'))]/UsageContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRealization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationInputOrOutput ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship ',@typeRef)] or //BreakdownElementRealization[@uid = $uidRef] or //ProcessOperationInputOrOutput[@uid = $uidRef] or //ViewOccurrenceRelationship[@uid = $uidRef]">(ReplacedUsageRelationship : <sch:value-of select="$uid"/>) The ReplacedUsageRelationship.UsageContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OccurrenceUsageContextSelect.</sch:assert>
      </sch:rule>
      <!--(Default Value) ReplacedUsageRelationship.RelationType : String = 'replaced usage' (kind=SINGLE - redefined=OccurrenceRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReplacedUsageRelationship') or (self::OccurrenceRelationship and substring-after(@xsi:type,':')='ReplacedUsageRelationship'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'replaced usage'">(ReplacedUsageRelationship : <sch:value-of select="$uid"/>) The ReplacedUsageRelationship.RelationType contains the wrong value () must be 'replaced usage'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) OccurrenceRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReplacedUsageRelationship') or (self::OccurrenceRelationship and substring-after(@xsi:type,':')='ReplacedUsageRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ReplacedUsageRelationship : <sch:value-of select="$uid"/>) The ReplacedUsageRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) OccurrenceRelationship.Related : Occurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReplacedUsageRelationship') or (self::OccurrenceRelationship and substring-after(@xsi:type,':')='ReplacedUsageRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Occurrence'] or //Occurrence[@uid = $uidRef]">(ReplacedUsageRelationship : <sch:value-of select="$uid"/>) The ReplacedUsageRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Occurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) OccurrenceRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ReplacedUsageRelationship') or (self::OccurrenceRelationship and substring-after(@xsi:type,':')='ReplacedUsageRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ReplacedUsageRelationship : <sch:value-of select="$uid"/>) The ReplacedUsageRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Representation"><!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Representation') or (self::Representation and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Representation : <sch:value-of select="$uid"/>) The Representation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Representation.Items : SET[1:unbounded] OF RepresentationItem (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Representation') or (self::Representation and not(@xsi:type)))]/Items/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(Representation : <sch:value-of select="$uid"/>) The Representation.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Representation') or (self::Representation and not(@xsi:type)))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Representation : <sch:value-of select="$uid"/>) The Representation.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="RepresentationContext"><!--(Ref to E) RepresentationContext.Accuracies : OPTIONAL SET[1:unbounded] OF MeasureQualification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RepresentationContext') or (self::RepresentationContext and not(@xsi:type)))]/Accuracies/MeasureQualification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Accuracies/MeasureQualification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'MeasureQualification'] or //MeasureQualification[@uid = $uidRef]">(RepresentationContext : <sch:value-of select="$uid"/>) The RepresentationContext.Accuracies contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type MeasureQualification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RepresentationContext.Units : OPTIONAL SET[1:unbounded] OF Unit (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RepresentationContext') or (self::RepresentationContext and not(@xsi:type)))]/Units/Unit">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Units/Unit) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Unit'] or //Unit[@uid = $uidRef]">(RepresentationContext : <sch:value-of select="$uid"/>) The RepresentationContext.Units contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Unit.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Requirement"><!--(Ref to E) Requirement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Requirement') or (self::Requirement and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Requirement : <sch:value-of select="$uid"/>) The Requirement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementAssignment"><!--(Ref to E) RequirementAssignment.AssignedRequirement : RequirementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementAssignment') or (self::RequirementAssignment and not(@xsi:type)))]/AssignedRequirement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementView'] or //RequirementView[@uid = $uidRef]">(RequirementAssignment : <sch:value-of select="$uid"/>) The RequirementAssignment.AssignedRequirement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementView.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RequirementAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementAssignment') or (self::RequirementAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(RequirementAssignment : <sch:value-of select="$uid"/>) The RequirementAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RequirementAssignment.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementAssignment') or (self::RequirementAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RequirementAssignment : <sch:value-of select="$uid"/>) The RequirementAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementCollectionRelationship"><!--(Default Value) RequirementCollectionRelationship.RelationType : OPTIONAL String = 'collection' (kind=SINGLE - redefined=RequirementViewRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementCollectionRelationship') or (self::RequirementViewRelationship and substring-after(@xsi:type,':')='RequirementCollectionRelationship'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="count(./RelationType) = 0 or ClassString/text() = 'collection'">(RequirementCollectionRelationship : <sch:value-of select="$uid"/>) The RequirementCollectionRelationship.RelationType contains the wrong value () must be 'collection'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RequirementViewRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementCollectionRelationship') or (self::RequirementViewRelationship and substring-after(@xsi:type,':')='RequirementCollectionRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(RequirementCollectionRelationship : <sch:value-of select="$uid"/>) The RequirementCollectionRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RequirementViewRelationship.Related : RequirementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementCollectionRelationship') or (self::RequirementViewRelationship and substring-after(@xsi:type,':')='RequirementCollectionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementView'] or //RequirementView[@uid = $uidRef]">(RequirementCollectionRelationship : <sch:value-of select="$uid"/>) The RequirementCollectionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RequirementViewRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementCollectionRelationship') or (self::RequirementViewRelationship and substring-after(@xsi:type,':')='RequirementCollectionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RequirementCollectionRelationship : <sch:value-of select="$uid"/>) The RequirementCollectionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementDecompositionRelationship"><!--(Default Value) RequirementDecompositionRelationship.RelationType : OPTIONAL String = 'decomposition' (kind=SINGLE - redefined=RequirementViewRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementDecompositionRelationship') or (self::RequirementViewRelationship and substring-after(@xsi:type,':')='RequirementDecompositionRelationship'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="count(./RelationType) = 0 or ClassString/text() = 'decomposition'">(RequirementDecompositionRelationship : <sch:value-of select="$uid"/>) The RequirementDecompositionRelationship.RelationType contains the wrong value () must be 'decomposition'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RequirementViewRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementDecompositionRelationship') or (self::RequirementViewRelationship and substring-after(@xsi:type,':')='RequirementDecompositionRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(RequirementDecompositionRelationship : <sch:value-of select="$uid"/>) The RequirementDecompositionRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RequirementViewRelationship.Related : RequirementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementDecompositionRelationship') or (self::RequirementViewRelationship and substring-after(@xsi:type,':')='RequirementDecompositionRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementView'] or //RequirementView[@uid = $uidRef]">(RequirementDecompositionRelationship : <sch:value-of select="$uid"/>) The RequirementDecompositionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RequirementViewRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementDecompositionRelationship') or (self::RequirementViewRelationship and substring-after(@xsi:type,':')='RequirementDecompositionRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RequirementDecompositionRelationship : <sch:value-of select="$uid"/>) The RequirementDecompositionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementRelationship"><!--(Ref to E) RequirementRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementRelationship') or (self::RequirementRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(RequirementRelationship : <sch:value-of select="$uid"/>) The RequirementRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RequirementRelationship.Related : Requirement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementRelationship') or (self::RequirementRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Requirement'] or //Requirement[@uid = $uidRef]">(RequirementRelationship : <sch:value-of select="$uid"/>) The RequirementRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Requirement.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RequirementRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementRelationship') or (self::RequirementRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RequirementRelationship : <sch:value-of select="$uid"/>) The RequirementRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementRelationship_WR1"><!--(Rule RequirementRelationship.WR1)-->
      <sch:rule context="//RequirementRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> RequirementRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related Requirement and the relating Requirement shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementSatisfactionAssertion"><!--(Ref to E) RequirementSatisfactionAssertion.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementSatisfactionAssertion') or (self::RequirementSatisfactionAssertion and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(RequirementSatisfactionAssertion : <sch:value-of select="$uid"/>) The RequirementSatisfactionAssertion.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RequirementSatisfactionAssertion.RelatedAssignment : OPTIONAL RequirementAssignment (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementSatisfactionAssertion') or (self::RequirementSatisfactionAssertion and not(@xsi:type)))]/RelatedAssignment">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./RelatedAssignment) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementAssignment'] or //RequirementAssignment[@uid = $uidRef]">(RequirementSatisfactionAssertion : <sch:value-of select="$uid"/>) The RequirementSatisfactionAssertion.RelatedAssignment contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementAssignment.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RequirementSatisfactionAssertion.SatisfiedBy : RequirementAssignmentSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementSatisfactionAssertion') or (self::RequirementSatisfactionAssertion and not(@xsi:type)))]/SatisfiedBy">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternatePartRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyOccurrenceRelationshipSubstitution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationshipSubstitution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRealization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricDimension  DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance  DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricTolerance  AngularityTolerance  CircularRunoutTolerance  CoaxialityTolerance  ConcentricityTolerance  CylindricityTolerance  FlatnessTolerance  LineProfileTolerance  ParallelismTolerance  PerpendicularityTolerance  PositionTolerance  RoundnessTolerance  StraightnessTolerance  SurfaceProfileTolerance  SymmetryTolerance  TotalRunoutTolerance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeElement  AxisPlacementShapeElement  CoatingLayer  CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement  ContactingFeature  Datum  DatumFeature  DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem  DatumTarget  PlacedTarget  TargetCircle  TargetCircularCurve  TargetPoint  TargetRectangle  TargetStraightLine  TargetArea  TargetCurve  DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent  OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification  PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification  PlaneShapeElement  PointShapeElement  ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement  ToleranceZone  DirectedOrOrientedToleranceZone  AffectedPlaneToleranceZone  ToleranceZoneWithDatum  DirectedToleranceZone  DirectionFeatureToleranceZone  OrientedToleranceZone ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)] or //ActivityMethod[@uid = $uidRef] or //ActivityMethodAssignment[@uid = $uidRef] or //PartRelationship[@uid = $uidRef and contains(' AlternatePartRelationship ',substring-after(@xsi:type,':'))] or //AlternativeSolution[@uid = $uidRef] or //ViewOccurrenceRelationship[@uid = $uidRef and contains(' AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage ',substring-after(@xsi:type,':'))] or //AssemblyOccurrenceRelationshipSubstitution[@uid = $uidRef] or //PartViewRelationship[@uid = $uidRef and contains(' AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage ',substring-after(@xsi:type,':'))] or //AssemblyViewRelationshipSubstitution[@uid = $uidRef] or //Breakdown[@uid = $uidRef] or //BreakdownElement[@uid = $uidRef] or //BreakdownElementRealization[@uid = $uidRef] or //BreakdownElementRelationship[@uid = $uidRef] or //BreakdownElementVersion[@uid = $uidRef] or //BreakdownElementView[@uid = $uidRef] or //BreakdownVersion[@uid = $uidRef] or //Document[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //DocumentVersion[@uid = $uidRef] or //GeometricDimension[@uid = $uidRef] or //GeometricTolerance[@uid = $uidRef] or //IndividualPart[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //IndividualPartView[@uid = $uidRef] or //Observation[@uid = $uidRef] or //Part[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //PartView[@uid = $uidRef] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef] or //Requirement[@uid = $uidRef] or //RequirementVersion[@uid = $uidRef] or //RequirementView[@uid = $uidRef] or //ShapeElement[@uid = $uidRef] or //WorkRequest[@uid = $uidRef]">(RequirementSatisfactionAssertion : <sch:value-of select="$uid"/>) The RequirementSatisfactionAssertion.SatisfiedBy contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of RequirementAssignmentSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementSource"><!--(Ref to E) RequirementSource.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementSource') or (self::RequirementSource and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(RequirementSource : <sch:value-of select="$uid"/>) The RequirementSource.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RequirementSource.Source : RequirementSourceSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementSource') or (self::RequirementSource and not(@xsi:type)))]/Source">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricDimension  DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance  DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricTolerance  AngularityTolerance  CircularRunoutTolerance  CoaxialityTolerance  ConcentricityTolerance  CylindricityTolerance  FlatnessTolerance  LineProfileTolerance  ParallelismTolerance  PerpendicularityTolerance  PositionTolerance  RoundnessTolerance  StraightnessTolerance  SurfaceProfileTolerance  SymmetryTolerance  TotalRunoutTolerance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeElement  AxisPlacementShapeElement  CoatingLayer  CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement  ContactingFeature  Datum  DatumFeature  DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem  DatumTarget  PlacedTarget  TargetCircle  TargetCircularCurve  TargetPoint  TargetRectangle  TargetStraightLine  TargetArea  TargetCurve  DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent  OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification  PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification  PlaneShapeElement  PointShapeElement  ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement  ToleranceZone  DirectedOrOrientedToleranceZone  AffectedPlaneToleranceZone  ToleranceZoneWithDatum  DirectedToleranceZone  DirectionFeatureToleranceZone  OrientedToleranceZone ',@typeRef)] or //Activity[@uid = $uidRef] or //ActivityMethod[@uid = $uidRef] or //ActivityMethodAssignment[@uid = $uidRef] or //AlternativeSolution[@uid = $uidRef] or //Breakdown[@uid = $uidRef] or //BreakdownElement[@uid = $uidRef] or //BreakdownElementVersion[@uid = $uidRef] or //BreakdownElementView[@uid = $uidRef] or //BreakdownVersion[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Document[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //DocumentVersion[@uid = $uidRef] or //GeometricDimension[@uid = $uidRef] or //GeometricTolerance[@uid = $uidRef] or //IndividualPart[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //IndividualPartView[@uid = $uidRef] or //Organization[@uid = $uidRef] or //Part[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //PartView[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //Project[@uid = $uidRef] or //Requirement[@uid = $uidRef] or //RequirementVersion[@uid = $uidRef] or //RequirementView[@uid = $uidRef] or //ShapeElement[@uid = $uidRef]">(RequirementSource : <sch:value-of select="$uid"/>) The RequirementSource.Source contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of RequirementSourceSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementTracingRelationship"><!--(Default Value) RequirementTracingRelationship.RelationType : OPTIONAL String = 'tracing' (kind=SINGLE - redefined=RequirementViewRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementTracingRelationship') or (self::RequirementViewRelationship and substring-after(@xsi:type,':')='RequirementTracingRelationship'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="count(./RelationType) = 0 or ClassString/text() = 'tracing'">(RequirementTracingRelationship : <sch:value-of select="$uid"/>) The RequirementTracingRelationship.RelationType contains the wrong value () must be 'tracing'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RequirementViewRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementTracingRelationship') or (self::RequirementViewRelationship and substring-after(@xsi:type,':')='RequirementTracingRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(RequirementTracingRelationship : <sch:value-of select="$uid"/>) The RequirementTracingRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RequirementViewRelationship.Related : RequirementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementTracingRelationship') or (self::RequirementViewRelationship and substring-after(@xsi:type,':')='RequirementTracingRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementView'] or //RequirementView[@uid = $uidRef]">(RequirementTracingRelationship : <sch:value-of select="$uid"/>) The RequirementTracingRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RequirementViewRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementTracingRelationship') or (self::RequirementViewRelationship and substring-after(@xsi:type,':')='RequirementTracingRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RequirementTracingRelationship : <sch:value-of select="$uid"/>) The RequirementTracingRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementVersion"><!--(Ref to E) RequirementVersion.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementVersion') or (self::RequirementVersion and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(RequirementVersion : <sch:value-of select="$uid"/>) The RequirementVersion.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Inverse of Requirement.Versions :: PartProperty) RequirementVersion.VersionOf : Requirement) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="RequirementVersionRelationship"><!--(Ref to E) RequirementVersionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementVersionRelationship') or (self::RequirementVersionRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(RequirementVersionRelationship : <sch:value-of select="$uid"/>) The RequirementVersionRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RequirementVersionRelationship.Related : RequirementVersion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementVersionRelationship') or (self::RequirementVersionRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementVersion'] or //RequirementVersion[@uid = $uidRef]">(RequirementVersionRelationship : <sch:value-of select="$uid"/>) The RequirementVersionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementVersion.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RequirementVersionRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementVersionRelationship') or (self::RequirementVersionRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RequirementVersionRelationship : <sch:value-of select="$uid"/>) The RequirementVersionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementVersionRelationship_WR1"><!--(Rule RequirementVersionRelationship.WR1)-->
      <sch:rule context="//RequirementVersionRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> RequirementVersionRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related RequirementVersion and the relating RequirementVersion shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementView"><!--(Ref to E) RequirementView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementView') or (self::RequirementView and not(@xsi:type)))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(RequirementView : <sch:value-of select="$uid"/>) The RequirementView.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RequirementView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementView') or (self::RequirementView and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(RequirementView : <sch:value-of select="$uid"/>) The RequirementView.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RequirementView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementView') or (self::RequirementView and not(@xsi:type)))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(RequirementView : <sch:value-of select="$uid"/>) The RequirementView.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of RequirementVersion.Views :: PartProperty) RequirementView.ViewOf : RequirementVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="RequirementViewRelationship"><!--(Ref to E) RequirementViewRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementViewRelationship') or (self::RequirementViewRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(RequirementViewRelationship : <sch:value-of select="$uid"/>) The RequirementViewRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RequirementViewRelationship.Related : RequirementView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementViewRelationship') or (self::RequirementViewRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementView'] or //RequirementView[@uid = $uidRef]">(RequirementViewRelationship : <sch:value-of select="$uid"/>) The RequirementViewRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RequirementViewRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RequirementViewRelationship') or (self::RequirementViewRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(RequirementViewRelationship : <sch:value-of select="$uid"/>) The RequirementViewRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RequirementViewRelationship_WR1"><!--(Rule RequirementViewRelationship.WR1)-->
      <sch:rule context="//RequirementViewRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> RequirementViewRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related RequirementView and the relating RequirementView shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="RetentionPeriod"><!--(Ref to E) RetentionPeriod.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RetentionPeriod') or (self::RetentionPeriod and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(RetentionPeriod : <sch:value-of select="$uid"/>) The RetentionPeriod.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RetentionPeriod.EarliestEnd : PeriodOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RetentionPeriod') or (self::RetentionPeriod and not(@xsi:type)))]/EarliestEnd/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::DateTimeString) or (self::Duration) or (self::Event and //Event[@uid = $uidRef])">(RetentionPeriod : <sch:value-of select="$uid"/>) The RetentionPeriod.EarliestEnd contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PeriodOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RetentionPeriod.LatestEnd : PeriodOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RetentionPeriod') or (self::RetentionPeriod and not(@xsi:type)))]/LatestEnd/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::DateTimeString) or (self::Duration) or (self::Event and //Event[@uid = $uidRef])">(RetentionPeriod : <sch:value-of select="$uid"/>) The RetentionPeriod.LatestEnd contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PeriodOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) RetentionPeriod.Start : EventOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RetentionPeriod') or (self::RetentionPeriod and not(@xsi:type)))]/Start/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(RetentionPeriod : <sch:value-of select="$uid"/>) The RetentionPeriod.Start contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EventOrDateSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RotationAboutDirection"><!--(Ref to E) RotationAboutDirection.DirectionOfAxis : Direction (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RotationAboutDirection') or (self::RepresentationItem and substring-after(@xsi:type,':')='RotationAboutDirection'))]/DirectionOfAxis">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Direction'] or //RepresentationItem[@uid = $uidRef and contains(' Direction ',substring-after(@xsi:type,':'))]">(RotationAboutDirection : <sch:value-of select="$uid"/>) The RotationAboutDirection.DirectionOfAxis contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Direction.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="RoundnessTolerance"><!--(Ref to S) GeometricTolerance.AppliedTo : GeometricToleranceTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RoundnessTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='RoundnessTolerance'))]/AppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //PartView[@uid = $uidRef]">(RoundnessTolerance : <sch:value-of select="$uid"/>) The RoundnessTolerance.AppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricToleranceTargetSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RoundnessTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='RoundnessTolerance'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(RoundnessTolerance : <sch:value-of select="$uid"/>) The RoundnessTolerance.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.GeometricToleranceContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='RoundnessTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='RoundnessTolerance'))]/GeometricToleranceContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricToleranceContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(RoundnessTolerance : <sch:value-of select="$uid"/>) The RoundnessTolerance.GeometricToleranceContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SameTimeMachiningRelationship"><!--(Ref to S) SameTimeMachiningRelationship.Placement : OPTIONAL TransformationSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SameTimeMachiningRelationship') or (self::OccurrenceRelationship and substring-after(@xsi:type,':')='SameTimeMachiningRelationship'))]/Placement/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::CartesianTransformation or (self::Transformation and contains(' CartesianTransformation ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)]) or (self::GeometricRepresentationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',@typeRef)]) or (self::CartesianTransformation) or (self::GeometricRepresentationRelationship and //RepresentationRelationship[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',substring-after(@xsi:type,':'))])">(SameTimeMachiningRelationship : <sch:value-of select="$uid"/>) The SameTimeMachiningRelationship.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of TransformationSelect.</sch:assert>
      </sch:rule>
      <!--(Default Value) SameTimeMachiningRelationship.RelationType : String = 'same time machining' (kind=SINGLE - redefined=OccurrenceRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SameTimeMachiningRelationship') or (self::OccurrenceRelationship and substring-after(@xsi:type,':')='SameTimeMachiningRelationship'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'same time machining'">(SameTimeMachiningRelationship : <sch:value-of select="$uid"/>) The SameTimeMachiningRelationship.RelationType contains the wrong value () must be 'same time machining'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) OccurrenceRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SameTimeMachiningRelationship') or (self::OccurrenceRelationship and substring-after(@xsi:type,':')='SameTimeMachiningRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SameTimeMachiningRelationship : <sch:value-of select="$uid"/>) The SameTimeMachiningRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) OccurrenceRelationship.Related : Occurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SameTimeMachiningRelationship') or (self::OccurrenceRelationship and substring-after(@xsi:type,':')='SameTimeMachiningRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Occurrence'] or //Occurrence[@uid = $uidRef]">(SameTimeMachiningRelationship : <sch:value-of select="$uid"/>) The SameTimeMachiningRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Occurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) OccurrenceRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SameTimeMachiningRelationship') or (self::OccurrenceRelationship and substring-after(@xsi:type,':')='SameTimeMachiningRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SameTimeMachiningRelationship : <sch:value-of select="$uid"/>) The SameTimeMachiningRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SecurityClassification"><!--(Ref to E) SecurityClassification.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SecurityClassification') or (self::SecurityClassification and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SecurityClassification : <sch:value-of select="$uid"/>) The SecurityClassification.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) SecurityClassification.Level : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SecurityClassification') or (self::SecurityClassification and not(@xsi:type)))]/Level/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SecurityClassification : <sch:value-of select="$uid"/>) The SecurityClassification.Level contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SecurityClassificationAssignment"><!--(Ref to E) SecurityClassificationAssignment.AssignedSecurityClassification : SecurityClassification (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SecurityClassificationAssignment') or (self::SecurityClassificationAssignment and not(@xsi:type)))]/AssignedSecurityClassification">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SecurityClassification'] or //SecurityClassification[@uid = $uidRef]">(SecurityClassificationAssignment : <sch:value-of select="$uid"/>) The SecurityClassificationAssignment.AssignedSecurityClassification contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SecurityClassification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) SecurityClassificationAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SecurityClassificationAssignment') or (self::SecurityClassificationAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SecurityClassificationAssignment : <sch:value-of select="$uid"/>) The SecurityClassificationAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) SecurityClassificationAssignment.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SecurityClassificationAssignment') or (self::SecurityClassificationAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SecurityClassificationAssignment : <sch:value-of select="$uid"/>) The SecurityClassificationAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SequenceRepresentationItem"><!--(Ref to E) SequenceRepresentationItem.RepresentedValue : LIST[1:unbounded] OF RepresentationItem (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SequenceRepresentationItem') or (self::RepresentationItem and substring-after(@xsi:type,':')='SequenceRepresentationItem'))]/RepresentedValue/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(SequenceRepresentationItem : <sch:value-of select="$uid"/>) The SequenceRepresentationItem.RepresentedValue contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SerialEffectivity"><!--(Ref to E) Effectivity.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SerialEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='SerialEffectivity'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SerialEffectivity : <sch:value-of select="$uid"/>) The SerialEffectivity.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SerialEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='SerialEffectivity'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(SerialEffectivity : <sch:value-of select="$uid"/>) The SerialEffectivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Effectivity.EffectivityContext : OPTIONAL EffectivityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SerialEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='SerialEffectivity'))]/EffectivityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //Activity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef]">(SerialEffectivity : <sch:value-of select="$uid"/>) The SerialEffectivity.EffectivityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EffectivityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SetMembership"><!--(Ref to S) SetMembership.Member : ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SetMembership') or (self::SetMembership and not(@xsi:type)))]/Member/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(SetMembership : <sch:value-of select="$uid"/>) The SetMembership.Member contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SetRepresentationItem"><!--(Ref to E) SetRepresentationItem.RepresentedValue : SET[1:unbounded] OF RepresentationItem (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SetRepresentationItem') or (self::RepresentationItem and substring-after(@xsi:type,':')='SetRepresentationItem'))]/RepresentedValue/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(SetRepresentationItem : <sch:value-of select="$uid"/>) The SetRepresentationItem.RepresentedValue contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ShapeElement"><!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeElement') or (self::ShapeElement and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ShapeElement : <sch:value-of select="$uid"/>) The ShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeElement') or (self::ShapeElement and not(@xsi:type)))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(ShapeElement : <sch:value-of select="$uid"/>) The ShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ShapeElementRelationship"><!--(Ref to E) ShapeElementRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeElementRelationship') or (self::ShapeElementRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ShapeElementRelationship : <sch:value-of select="$uid"/>) The ShapeElementRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElementRelationship.Related : ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeElementRelationship') or (self::ShapeElementRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(ShapeElementRelationship : <sch:value-of select="$uid"/>) The ShapeElementRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElementRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeElementRelationship') or (self::ShapeElementRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ShapeElementRelationship : <sch:value-of select="$uid"/>) The ShapeElementRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElementRelationship.RepresentedGeometry : OPTIONAL RepresentationItem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeElementRelationship') or (self::ShapeElementRelationship and not(@xsi:type)))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./RepresentedGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(ShapeElementRelationship : <sch:value-of select="$uid"/>) The ShapeElementRelationship.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ShapeElementRelationship_WR1"><!--(Rule ShapeElementRelationship.WR1)-->
      <sch:rule context="//ShapeElementRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> ShapeElementRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related ShapeElement and the relating ShapeElement shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="ShapeFeatureDefinition"><!--(Ref to E) ShapeFeatureDefinition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinition') or (self::ShapeFeatureDefinition and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ShapeFeatureDefinition : <sch:value-of select="$uid"/>) The ShapeFeatureDefinition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeFeatureDefinition.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinition') or (self::ShapeFeatureDefinition and not(@xsi:type)))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(ShapeFeatureDefinition : <sch:value-of select="$uid"/>) The ShapeFeatureDefinition.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ShapeFeatureDefinitionElement"><!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionElement') or (self::ShapeElement and substring-after(@xsi:type,':')='ShapeFeatureDefinitionElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ShapeFeatureDefinitionElement : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionElement') or (self::ShapeElement and substring-after(@xsi:type,':')='ShapeFeatureDefinitionElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(ShapeFeatureDefinitionElement : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ShapeFeatureDefinitionElementRelationship"><!--(Ref to S) ShapeFeatureDefinitionElementRelationship.ParentRelationship : OPTIONAL ShapeFeatureDefinitionOrElementRelationshipSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionElementRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='ShapeFeatureDefinitionElementRelationship'))]/ParentRelationship">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(ShapeFeatureDefinitionElementRelationship : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionElementRelationship.ParentRelationship contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeFeatureDefinitionOrElementRelationshipSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeFeatureDefinitionElementRelationship.Related : ShapeFeatureDefinitionElement (kind=SINGLE - redefined=ShapeElementRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionElementRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='ShapeFeatureDefinitionElementRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeFeatureDefinitionElement'] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))]">(ShapeFeatureDefinitionElementRelationship : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionElementRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeFeatureDefinitionElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElementRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionElementRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='ShapeFeatureDefinitionElementRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ShapeFeatureDefinitionElementRelationship : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionElementRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElementRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionElementRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='ShapeFeatureDefinitionElementRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ShapeFeatureDefinitionElementRelationship : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionElementRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElementRelationship.RepresentedGeometry : OPTIONAL RepresentationItem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionElementRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='ShapeFeatureDefinitionElementRelationship'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./RepresentedGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(ShapeFeatureDefinitionElementRelationship : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionElementRelationship.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ShapeFeatureDefinitionFitRelationship"><!--(Ref to E) ShapeFeatureDefinitionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionFitRelationship') or (self::ShapeFeatureDefinitionRelationship and substring-after(@xsi:type,':')='ShapeFeatureDefinitionFitRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ShapeFeatureDefinitionFitRelationship : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionFitRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeFeatureDefinitionRelationship.Related : ShapeFeatureDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionFitRelationship') or (self::ShapeFeatureDefinitionRelationship and substring-after(@xsi:type,':')='ShapeFeatureDefinitionFitRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeFeatureDefinition'] or //ShapeFeatureDefinition[@uid = $uidRef]">(ShapeFeatureDefinitionFitRelationship : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionFitRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeFeatureDefinition.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ShapeFeatureDefinitionOccurrenceElement"><!--(Ref to S) ShapeFeatureDefinitionOccurrenceElement.Definition : ShapeFeatureDefinitionOrElementSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElement') or (self::ShapeElement and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElement'))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))]">(ShapeFeatureDefinitionOccurrenceElement : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionOccurrenceElement.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeFeatureDefinitionOrElementSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElement') or (self::ShapeElement and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ShapeFeatureDefinitionOccurrenceElement : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionOccurrenceElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElement') or (self::ShapeElement and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(ShapeFeatureDefinitionOccurrenceElement : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionOccurrenceElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ShapeFeatureDefinitionOccurrenceElementRelationship"><!--(Ref to S) ShapeFeatureDefinitionOccurrenceElementRelationship.Definition : OPTIONAL ShapeFeatureDefinitionOrElementRelationshipSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElementRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElementRelationship'))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(ShapeFeatureDefinitionOccurrenceElementRelationship : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionOccurrenceElementRelationship.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeFeatureDefinitionOrElementRelationshipSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeFeatureDefinitionOccurrenceElementRelationship.Related : ShapeFeatureDefinitionOccurrenceElement (kind=SINGLE - redefined=ShapeFeatureDefinitionElementRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElementRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElementRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeFeatureDefinitionOccurrenceElement'] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))]">(ShapeFeatureDefinitionOccurrenceElementRelationship : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionOccurrenceElementRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeFeatureDefinitionOccurrenceElement.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeFeatureDefinitionElementRelationship.ParentRelationship : OPTIONAL ShapeFeatureDefinitionOrElementRelationshipSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElementRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElementRelationship'))]/ParentRelationship">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(ShapeFeatureDefinitionOccurrenceElementRelationship : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionOccurrenceElementRelationship.ParentRelationship contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeFeatureDefinitionOrElementRelationshipSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElementRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElementRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElementRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ShapeFeatureDefinitionOccurrenceElementRelationship : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionOccurrenceElementRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElementRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElementRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElementRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ShapeFeatureDefinitionOccurrenceElementRelationship : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionOccurrenceElementRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElementRelationship.RepresentedGeometry : OPTIONAL RepresentationItem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElementRelationship') or (self::ShapeElementRelationship and substring-after(@xsi:type,':')='ShapeFeatureDefinitionOccurrenceElementRelationship'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./RepresentedGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(ShapeFeatureDefinitionOccurrenceElementRelationship : <sch:value-of select="$uid"/>) The ShapeFeatureDefinitionOccurrenceElementRelationship.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SingleOccurrence"><!--(Ref to E) Occurrence.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SingleOccurrence') or (self::Occurrence and substring-after(@xsi:type,':')='SingleOccurrence'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SingleOccurrence : <sch:value-of select="$uid"/>) The SingleOccurrence.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Occurrence.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SingleOccurrence') or (self::Occurrence and substring-after(@xsi:type,':')='SingleOccurrence'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(SingleOccurrence : <sch:value-of select="$uid"/>) The SingleOccurrence.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SizeProperty"/>
   <sch:pattern id="SmearedMaterial"><!--(Ref to E) LaminateTable.Basis : SET[1:unbounded] OF ReinforcementOrientationBasis (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SmearedMaterial') or (self::PartView and substring-after(@xsi:type,':')='SmearedMaterial'))]/Basis/ReinforcementOrientationBasis">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ReinforcementOrientationBasis'] or //Representation[@uid = $uidRef and contains(' ReinforcementOrientationBasis ',substring-after(@xsi:type,':'))]">(SmearedMaterial : <sch:value-of select="$uid"/>) The SmearedMaterial.Basis contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ReinforcementOrientationBasis.</sch:assert>
      </sch:rule>
      <!--(Ref to E) LaminateTable.ResultingBoundary : PlyShape (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SmearedMaterial') or (self::PartView and substring-after(@xsi:type,':')='SmearedMaterial'))]/ResultingBoundary">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlyShape'] or //PlyShape[@uid = $uidRef]">(SmearedMaterial : <sch:value-of select="$uid"/>) The SmearedMaterial.ResultingBoundary contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlyShape.</sch:assert>
      </sch:rule>
      <!--(Ref to E) LaminateTable.ResultingSurface : Surface (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SmearedMaterial') or (self::PartView and substring-after(@xsi:type,':')='SmearedMaterial'))]/ResultingSurface">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Surface'] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(SmearedMaterial : <sch:value-of select="$uid"/>) The SmearedMaterial.ResultingSurface contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Surface.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SmearedMaterial') or (self::PartView and substring-after(@xsi:type,':')='SmearedMaterial'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(SmearedMaterial : <sch:value-of select="$uid"/>) The SmearedMaterial.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SmearedMaterial') or (self::PartView and substring-after(@xsi:type,':')='SmearedMaterial'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(SmearedMaterial : <sch:value-of select="$uid"/>) The SmearedMaterial.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SmearedMaterial') or (self::PartView and substring-after(@xsi:type,':')='SmearedMaterial'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SmearedMaterial : <sch:value-of select="$uid"/>) The SmearedMaterial.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SmearedMaterial') or (self::PartView and substring-after(@xsi:type,':')='SmearedMaterial'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(SmearedMaterial : <sch:value-of select="$uid"/>) The SmearedMaterial.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SmearedMaterial') or (self::PartView and substring-after(@xsi:type,':')='SmearedMaterial'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(SmearedMaterial : <sch:value-of select="$uid"/>) The SmearedMaterial.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="Specification"><!--(Ref to E) Specification.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Specification') or (self::Specification and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Specification : <sch:value-of select="$uid"/>) The Specification.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SpecificationAssignment"><!--(Ref to E) SpecificationAssignment.AssignedSpecification : Specification (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationAssignment') or (self::SpecificationAssignment and not(@xsi:type)))]/AssignedSpecification">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Specification'] or //Specification[@uid = $uidRef]">(SpecificationAssignment : <sch:value-of select="$uid"/>) The SpecificationAssignment.AssignedSpecification contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Specification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) SpecificationAssignment.AssociationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationAssignment') or (self::SpecificationAssignment and not(@xsi:type)))]/AssociationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SpecificationAssignment : <sch:value-of select="$uid"/>) The SpecificationAssignment.AssociationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) SpecificationAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationAssignment') or (self::SpecificationAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SpecificationAssignment : <sch:value-of select="$uid"/>) The SpecificationAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SpecificationCategory"><!--(Ref to E) SpecificationCategory.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationCategory') or (self::SpecificationCategory and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SpecificationCategory : <sch:value-of select="$uid"/>) The SpecificationCategory.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SpecificationCategoryAssignment"><!--(Ref to E) SpecificationCategoryAssignment.AssignedCategory : SpecificationCategory (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationCategoryAssignment') or (self::SpecificationCategoryAssignment and not(@xsi:type)))]/AssignedCategory">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SpecificationCategory'] or //SpecificationCategory[@uid = $uidRef]">(SpecificationCategoryAssignment : <sch:value-of select="$uid"/>) The SpecificationCategoryAssignment.AssignedCategory contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SpecificationCategory.</sch:assert>
      </sch:rule>
      <!--(Ref to E) SpecificationCategoryAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationCategoryAssignment') or (self::SpecificationCategoryAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SpecificationCategoryAssignment : <sch:value-of select="$uid"/>) The SpecificationCategoryAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SpecificationCategoryHierarchy"><!--(Ref to E) SpecificationCategoryHierarchy.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationCategoryHierarchy') or (self::SpecificationCategoryHierarchy and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SpecificationCategoryHierarchy : <sch:value-of select="$uid"/>) The SpecificationCategoryHierarchy.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) SpecificationCategoryHierarchy.SubCategory : SpecificationCategory (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationCategoryHierarchy') or (self::SpecificationCategoryHierarchy and not(@xsi:type)))]/SubCategory">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SpecificationCategory'] or //SpecificationCategory[@uid = $uidRef]">(SpecificationCategoryHierarchy : <sch:value-of select="$uid"/>) The SpecificationCategoryHierarchy.SubCategory contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SpecificationCategory.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SpecificationConditionAssignment"><!--(Ref to E) SpecificationConditionAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationConditionAssignment') or (self::SpecificationConditionAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SpecificationConditionAssignment : <sch:value-of select="$uid"/>) The SpecificationConditionAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) SpecificationConditionAssignment.ConditionType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationConditionAssignment') or (self::SpecificationConditionAssignment and not(@xsi:type)))]/ConditionType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SpecificationConditionAssignment : <sch:value-of select="$uid"/>) The SpecificationConditionAssignment.ConditionType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SpecificationInclusion"><!--(Ref to E) SpecificationInclusion.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationInclusion') or (self::SpecificationInclusion and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SpecificationInclusion : <sch:value-of select="$uid"/>) The SpecificationInclusion.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) SpecificationInclusion.IfCondition : ConditionParameterSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationInclusion') or (self::SpecificationInclusion and not(@xsi:type)))]/IfCondition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternativeSolutionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolutionRelationship ',@typeRef)]) or (self::Approval and //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConditionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionRelationship ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::Descriptor and //ExternalRefBaseObject[@uid = $uidRef and contains(' Descriptor ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::EffectivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::FileRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::Observation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::ObservationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::ProcessOperationDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinitionRelationship ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlanRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlanRelationship ',@typeRef)]) or (self::ProductClassRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClassRelationship ',@typeRef)]) or (self::ProductConcept and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::ProductConfigurationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkOrderRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderRelationship ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::WorkRequestRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestRelationship ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternativeSolutionRelationship and //AlternativeSolutionRelationship[@uid = $uidRef]) or (self::Approval and //Approval[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::Condition) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConditionRelationship and //ConditionRelationship[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DateTimeString) or (self::Descriptor and //Descriptor[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::EffectivityRelationship and //EffectivityRelationship[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::FileRelationship and //FileRelationship[@uid = $uidRef]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::Observation and //Observation[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::ObservationRelationship and //ObservationRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::ProcessOperationDefinitionRelationship and //ProcessOperationDefinitionRelationship[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlanRelationship and //ProcessPlanRelationship[@uid = $uidRef]) or (self::ProductClassRelationship and //ProductClassRelationship[@uid = $uidRef]) or (self::ProductConcept and //ProductConcept[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProductConfigurationRelationship and //ProductConfigurationRelationship[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkOrderRelationship and //WorkOrderRelationship[@uid = $uidRef]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef]) or (self::WorkRequestRelationship and //WorkRequestRelationship[@uid = $uidRef])">(SpecificationInclusion : <sch:value-of select="$uid"/>) The SpecificationInclusion.IfCondition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ConditionParameterSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) SpecificationInclusion.IncludedSpecification : ConditionParameterSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationInclusion') or (self::SpecificationInclusion and not(@xsi:type)))]/IncludedSpecification/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternativeSolutionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolutionRelationship ',@typeRef)]) or (self::Approval and //ExternalRefBaseObject[@uid = $uidRef and contains(' Approval ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Classification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Classification ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConditionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionRelationship ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::Descriptor and //ExternalRefBaseObject[@uid = $uidRef and contains(' Descriptor ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::EffectivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::FileRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)]) or (self::Identifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' Identifier ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::Observation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::ObservationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::ProcessOperationDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinitionRelationship ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlanRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlanRelationship ',@typeRef)]) or (self::ProductClassRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClassRelationship ',@typeRef)]) or (self::ProductConcept and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConcept  ProductClass ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::ProductConfigurationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkOrderRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderRelationship ',@typeRef)]) or (self::WorkRequest and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::WorkRequestRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestRelationship ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternativeSolutionRelationship and //AlternativeSolutionRelationship[@uid = $uidRef]) or (self::Approval and //Approval[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Classification and //Classification[@uid = $uidRef]) or (self::Condition) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConditionRelationship and //ConditionRelationship[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DateTimeString) or (self::Descriptor and //Descriptor[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::EffectivityRelationship and //EffectivityRelationship[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::FileRelationship and //FileRelationship[@uid = $uidRef]) or (self::Identifier and //Identifier[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::Observation and //Observation[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::ObservationRelationship and //ObservationRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::ProcessOperationDefinitionRelationship and //ProcessOperationDefinitionRelationship[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlanRelationship and //ProcessPlanRelationship[@uid = $uidRef]) or (self::ProductClassRelationship and //ProductClassRelationship[@uid = $uidRef]) or (self::ProductConcept and //ProductConcept[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProductConfigurationRelationship and //ProductConfigurationRelationship[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkOrderRelationship and //WorkOrderRelationship[@uid = $uidRef]) or (self::WorkRequest and //WorkRequest[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef]) or (self::WorkRequestRelationship and //WorkRequestRelationship[@uid = $uidRef])">(SpecificationInclusion : <sch:value-of select="$uid"/>) The SpecificationInclusion.IncludedSpecification contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ConditionParameterSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SpecificationInclusionAssignment"><!--(Ref to E) SpecificationInclusionAssignment.AssignedInclusion : SpecificationInclusion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationInclusionAssignment') or (self::SpecificationInclusionAssignment and not(@xsi:type)))]/AssignedInclusion">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'SpecificationInclusion'] or //SpecificationInclusion[@uid = $uidRef]">(SpecificationInclusionAssignment : <sch:value-of select="$uid"/>) The SpecificationInclusionAssignment.AssignedInclusion contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type SpecificationInclusion.</sch:assert>
      </sch:rule>
      <!--(Ref to E) SpecificationInclusionAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecificationInclusionAssignment') or (self::SpecificationInclusionAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SpecificationInclusionAssignment : <sch:value-of select="$uid"/>) The SpecificationInclusionAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SpecifiedOccurrence"><!--(Ref to E) SpecifiedOccurrence.UpperUsage : Occurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecifiedOccurrence') or (self::Occurrence and substring-after(@xsi:type,':')='SpecifiedOccurrence'))]/UpperUsage">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Occurrence'] or //Occurrence[@uid = $uidRef]">(SpecifiedOccurrence : <sch:value-of select="$uid"/>) The SpecifiedOccurrence.UpperUsage contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Occurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Occurrence.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecifiedOccurrence') or (self::Occurrence and substring-after(@xsi:type,':')='SpecifiedOccurrence'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SpecifiedOccurrence : <sch:value-of select="$uid"/>) The SpecifiedOccurrence.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Occurrence.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SpecifiedOccurrence') or (self::Occurrence and substring-after(@xsi:type,':')='SpecifiedOccurrence'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(SpecifiedOccurrence : <sch:value-of select="$uid"/>) The SpecifiedOccurrence.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StandardUncertainty"/>
   <sch:pattern id="State"><!--(Ref to E) State.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='State') or (self::State and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(State : <sch:value-of select="$uid"/>) The State.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateAssignment"><!--(Ref to E) StateAssignment.AssignedState : State (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateAssignment') or (self::StateAssignment and not(@xsi:type)))]/AssignedState">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'State'] or //State[@uid = $uidRef]">(StateAssignment : <sch:value-of select="$uid"/>) The StateAssignment.AssignedState contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type State.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StateAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateAssignment') or (self::StateAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateAssignment : <sch:value-of select="$uid"/>) The StateAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateAssignment.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateAssignment') or (self::StateAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateAssignment : <sch:value-of select="$uid"/>) The StateAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateCauseEffect"><!--(Ref to E) StateRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateCauseEffect') or (self::StateRelationship and substring-after(@xsi:type,':')='StateCauseEffect'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateCauseEffect : <sch:value-of select="$uid"/>) The StateCauseEffect.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StateRelationship.Related : State (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateCauseEffect') or (self::StateRelationship and substring-after(@xsi:type,':')='StateCauseEffect'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'State'] or //State[@uid = $uidRef]">(StateCauseEffect : <sch:value-of select="$uid"/>) The StateCauseEffect.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type State.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateCauseEffect') or (self::StateRelationship and substring-after(@xsi:type,':')='StateCauseEffect'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateCauseEffect : <sch:value-of select="$uid"/>) The StateCauseEffect.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateComposition"><!--(Ref to E) StateRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateComposition') or (self::StateRelationship and substring-after(@xsi:type,':')='StateComposition'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateComposition : <sch:value-of select="$uid"/>) The StateComposition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StateRelationship.Related : State (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateComposition') or (self::StateRelationship and substring-after(@xsi:type,':')='StateComposition'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'State'] or //State[@uid = $uidRef]">(StateComposition : <sch:value-of select="$uid"/>) The StateComposition.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type State.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateComposition') or (self::StateRelationship and substring-after(@xsi:type,':')='StateComposition'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateComposition : <sch:value-of select="$uid"/>) The StateComposition.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinition"><!--(Ref to E) StateDefinition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinition') or (self::StateDefinition and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateDefinition : <sch:value-of select="$uid"/>) The StateDefinition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateDefinition.Definition : ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinition') or (self::StateDefinition and not(@xsi:type)))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(StateDefinition : <sch:value-of select="$uid"/>) The StateDefinition.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionAssignment"><!--(Ref to E) StateDefinitionAssignment.AssignedStateDefinition : StateDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionAssignment') or (self::StateDefinitionAssignment and not(@xsi:type)))]/AssignedStateDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionAssignment : <sch:value-of select="$uid"/>) The StateDefinitionAssignment.AssignedStateDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StateDefinitionAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionAssignment') or (self::StateDefinitionAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateDefinitionAssignment : <sch:value-of select="$uid"/>) The StateDefinitionAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateDefinitionAssignment.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionAssignment') or (self::StateDefinitionAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateDefinitionAssignment : <sch:value-of select="$uid"/>) The StateDefinitionAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionCauseEffect"><!--(Ref to E) StateDefinitionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionCauseEffect') or (self::StateDefinitionRelationship and substring-after(@xsi:type,':')='StateDefinitionCauseEffect'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateDefinitionCauseEffect : <sch:value-of select="$uid"/>) The StateDefinitionCauseEffect.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StateDefinitionRelationship.Related : StateDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionCauseEffect') or (self::StateDefinitionRelationship and substring-after(@xsi:type,':')='StateDefinitionCauseEffect'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionCauseEffect : <sch:value-of select="$uid"/>) The StateDefinitionCauseEffect.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateDefinitionRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionCauseEffect') or (self::StateDefinitionRelationship and substring-after(@xsi:type,':')='StateDefinitionCauseEffect'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateDefinitionCauseEffect : <sch:value-of select="$uid"/>) The StateDefinitionCauseEffect.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionComposition"><!--(Ref to E) StateDefinitionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionComposition') or (self::StateDefinitionRelationship and substring-after(@xsi:type,':')='StateDefinitionComposition'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateDefinitionComposition : <sch:value-of select="$uid"/>) The StateDefinitionComposition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StateDefinitionRelationship.Related : StateDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionComposition') or (self::StateDefinitionRelationship and substring-after(@xsi:type,':')='StateDefinitionComposition'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionComposition : <sch:value-of select="$uid"/>) The StateDefinitionComposition.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateDefinitionRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionComposition') or (self::StateDefinitionRelationship and substring-after(@xsi:type,':')='StateDefinitionComposition'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateDefinitionComposition : <sch:value-of select="$uid"/>) The StateDefinitionComposition.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionConfirmedAssignment"><!--(Ref to E) StateDefinitionStateAssignment.AssignedStateDefinition : StateDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionConfirmedAssignment') or (self::StateDefinitionStateAssignment and substring-after(@xsi:type,':')='StateDefinitionConfirmedAssignment'))]/AssignedStateDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionConfirmedAssignment : <sch:value-of select="$uid"/>) The StateDefinitionConfirmedAssignment.AssignedStateDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StateDefinitionStateAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionConfirmedAssignment') or (self::StateDefinitionStateAssignment and substring-after(@xsi:type,':')='StateDefinitionConfirmedAssignment'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateDefinitionConfirmedAssignment : <sch:value-of select="$uid"/>) The StateDefinitionConfirmedAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateDefinitionStateAssignment.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionConfirmedAssignment') or (self::StateDefinitionStateAssignment and substring-after(@xsi:type,':')='StateDefinitionConfirmedAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateDefinitionConfirmedAssignment : <sch:value-of select="$uid"/>) The StateDefinitionConfirmedAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionHypothesisAssignment"><!--(Ref to E) StateDefinitionStateAssignment.AssignedStateDefinition : StateDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionHypothesisAssignment') or (self::StateDefinitionStateAssignment and substring-after(@xsi:type,':')='StateDefinitionHypothesisAssignment'))]/AssignedStateDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionHypothesisAssignment : <sch:value-of select="$uid"/>) The StateDefinitionHypothesisAssignment.AssignedStateDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StateDefinitionStateAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionHypothesisAssignment') or (self::StateDefinitionStateAssignment and substring-after(@xsi:type,':')='StateDefinitionHypothesisAssignment'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateDefinitionHypothesisAssignment : <sch:value-of select="$uid"/>) The StateDefinitionHypothesisAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateDefinitionStateAssignment.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionHypothesisAssignment') or (self::StateDefinitionStateAssignment and substring-after(@xsi:type,':')='StateDefinitionHypothesisAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateDefinitionHypothesisAssignment : <sch:value-of select="$uid"/>) The StateDefinitionHypothesisAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionPredictedAssignment"><!--(Ref to E) StateDefinitionStateAssignment.AssignedStateDefinition : StateDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionPredictedAssignment') or (self::StateDefinitionStateAssignment and substring-after(@xsi:type,':')='StateDefinitionPredictedAssignment'))]/AssignedStateDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionPredictedAssignment : <sch:value-of select="$uid"/>) The StateDefinitionPredictedAssignment.AssignedStateDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StateDefinitionStateAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionPredictedAssignment') or (self::StateDefinitionStateAssignment and substring-after(@xsi:type,':')='StateDefinitionPredictedAssignment'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateDefinitionPredictedAssignment : <sch:value-of select="$uid"/>) The StateDefinitionPredictedAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateDefinitionStateAssignment.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionPredictedAssignment') or (self::StateDefinitionStateAssignment and substring-after(@xsi:type,':')='StateDefinitionPredictedAssignment'))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateDefinitionPredictedAssignment : <sch:value-of select="$uid"/>) The StateDefinitionPredictedAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionRelationship"><!--(Ref to E) StateDefinitionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionRelationship') or (self::StateDefinitionRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateDefinitionRelationship : <sch:value-of select="$uid"/>) The StateDefinitionRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StateDefinitionRelationship.Related : StateDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionRelationship') or (self::StateDefinitionRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionRelationship : <sch:value-of select="$uid"/>) The StateDefinitionRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateDefinitionRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionRelationship') or (self::StateDefinitionRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateDefinitionRelationship : <sch:value-of select="$uid"/>) The StateDefinitionRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionStateAssignment"><!--(Ref to E) StateDefinitionStateAssignment.AssignedStateDefinition : StateDefinition (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionStateAssignment') or (self::StateDefinitionStateAssignment and not(@xsi:type)))]/AssignedStateDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionStateAssignment : <sch:value-of select="$uid"/>) The StateDefinitionStateAssignment.AssignedStateDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StateDefinitionStateAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionStateAssignment') or (self::StateDefinitionStateAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateDefinitionStateAssignment : <sch:value-of select="$uid"/>) The StateDefinitionStateAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateDefinitionStateAssignment.Role : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionStateAssignment') or (self::StateDefinitionStateAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateDefinitionStateAssignment : <sch:value-of select="$uid"/>) The StateDefinitionStateAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionStateAssignmentRelationship"><!--(Ref to E) StateDefinitionStateAssignmentRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionStateAssignmentRelationship') or (self::StateDefinitionStateAssignmentRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateDefinitionStateAssignmentRelationship : <sch:value-of select="$uid"/>) The StateDefinitionStateAssignmentRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StateDefinitionStateAssignmentRelationship.Related : StateDefinitionStateAssignment (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionStateAssignmentRelationship') or (self::StateDefinitionStateAssignmentRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinitionStateAssignment'] or //StateDefinitionStateAssignment[@uid = $uidRef]">(StateDefinitionStateAssignmentRelationship : <sch:value-of select="$uid"/>) The StateDefinitionStateAssignmentRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinitionStateAssignment.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateDefinitionStateAssignmentRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionStateAssignmentRelationship') or (self::StateDefinitionStateAssignmentRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateDefinitionStateAssignmentRelationship : <sch:value-of select="$uid"/>) The StateDefinitionStateAssignmentRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateDefinitionTransition"><!--(Ref to E) StateDefinitionTransition.StartState : StateDefinition (kind=SINGLE - redefined=StateDefinitionRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionTransition') or (self::StateDefinitionRelationship and substring-after(@xsi:type,':')='StateDefinitionTransition'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinition'] or //StateDefinition[@uid = $uidRef]">(StateDefinitionTransition : <sch:value-of select="$uid"/>) The StateDefinitionTransition.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinition.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StateDefinitionRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionTransition') or (self::StateDefinitionRelationship and substring-after(@xsi:type,':')='StateDefinitionTransition'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateDefinitionTransition : <sch:value-of select="$uid"/>) The StateDefinitionTransition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateDefinitionRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateDefinitionTransition') or (self::StateDefinitionRelationship and substring-after(@xsi:type,':')='StateDefinitionTransition'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateDefinitionTransition : <sch:value-of select="$uid"/>) The StateDefinitionTransition.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateHypothesisToConfirmationRelationship"><!--(Ref to E) StateHypothesisToConfirmationRelationship.HypothesizedState : StateDefinitionHypothesisAssignment (kind=SINGLE - redefined=StateDefinitionStateAssignmentRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateHypothesisToConfirmationRelationship') or (self::StateDefinitionStateAssignmentRelationship and substring-after(@xsi:type,':')='StateHypothesisToConfirmationRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateDefinitionHypothesisAssignment'] or //StateDefinitionStateAssignment[@uid = $uidRef and contains(' StateDefinitionHypothesisAssignment ',substring-after(@xsi:type,':'))]">(StateHypothesisToConfirmationRelationship : <sch:value-of select="$uid"/>) The StateHypothesisToConfirmationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateDefinitionHypothesisAssignment.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StateDefinitionStateAssignmentRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateHypothesisToConfirmationRelationship') or (self::StateDefinitionStateAssignmentRelationship and substring-after(@xsi:type,':')='StateHypothesisToConfirmationRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateHypothesisToConfirmationRelationship : <sch:value-of select="$uid"/>) The StateHypothesisToConfirmationRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateDefinitionStateAssignmentRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateHypothesisToConfirmationRelationship') or (self::StateDefinitionStateAssignmentRelationship and substring-after(@xsi:type,':')='StateHypothesisToConfirmationRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateHypothesisToConfirmationRelationship : <sch:value-of select="$uid"/>) The StateHypothesisToConfirmationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateObserved"><!--(Ref to E) State.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateObserved') or (self::State and substring-after(@xsi:type,':')='StateObserved'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateObserved : <sch:value-of select="$uid"/>) The StateObserved.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StatePredicted"><!--(Ref to E) State.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StatePredicted') or (self::State and substring-after(@xsi:type,':')='StatePredicted'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StatePredicted : <sch:value-of select="$uid"/>) The StatePredicted.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StatePredictedToObserved"><!--(Ref to E) StatePredictedToObserved.Related : StateObserved (kind=SINGLE - redefined=StateRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StatePredictedToObserved') or (self::StateRelationship and substring-after(@xsi:type,':')='StatePredictedToObserved'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StateObserved'] or //State[@uid = $uidRef and contains(' StateObserved ',substring-after(@xsi:type,':'))]">(StatePredictedToObserved : <sch:value-of select="$uid"/>) The StatePredictedToObserved.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StateObserved.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StateRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StatePredictedToObserved') or (self::StateRelationship and substring-after(@xsi:type,':')='StatePredictedToObserved'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StatePredictedToObserved : <sch:value-of select="$uid"/>) The StatePredictedToObserved.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StatePredictedToObserved') or (self::StateRelationship and substring-after(@xsi:type,':')='StatePredictedToObserved'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StatePredictedToObserved : <sch:value-of select="$uid"/>) The StatePredictedToObserved.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateRelationship"><!--(Ref to E) StateRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateRelationship') or (self::StateRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateRelationship : <sch:value-of select="$uid"/>) The StateRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StateRelationship.Related : State (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateRelationship') or (self::StateRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'State'] or //State[@uid = $uidRef]">(StateRelationship : <sch:value-of select="$uid"/>) The StateRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type State.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateRelationship') or (self::StateRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateRelationship : <sch:value-of select="$uid"/>) The StateRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StateTransition"><!--(Ref to E) StateTransition.StartState : State (kind=SINGLE - redefined=StateRelationship.Related)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateTransition') or (self::StateRelationship and substring-after(@xsi:type,':')='StateTransition'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'State'] or //State[@uid = $uidRef]">(StateTransition : <sch:value-of select="$uid"/>) The StateTransition.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type State.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StateRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateTransition') or (self::StateRelationship and substring-after(@xsi:type,':')='StateTransition'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StateTransition : <sch:value-of select="$uid"/>) The StateTransition.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StateRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StateTransition') or (self::StateRelationship and substring-after(@xsi:type,':')='StateTransition'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StateTransition : <sch:value-of select="$uid"/>) The StateTransition.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StockMaterial"><!--(Ref to E) StockMaterial.ReferenceDirection : OPTIONAL Direction (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StockMaterial') or (self::StockMaterial and not(@xsi:type)))]/ReferenceDirection">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ReferenceDirection) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Direction'] or //RepresentationItem[@uid = $uidRef and contains(' Direction ',substring-after(@xsi:type,':'))]">(StockMaterial : <sch:value-of select="$uid"/>) The StockMaterial.ReferenceDirection contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Direction.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StraightnessTolerance"><!--(Ref to S) GeometricTolerance.AppliedTo : GeometricToleranceTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StraightnessTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='StraightnessTolerance'))]/AppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //PartView[@uid = $uidRef]">(StraightnessTolerance : <sch:value-of select="$uid"/>) The StraightnessTolerance.AppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricToleranceTargetSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StraightnessTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='StraightnessTolerance'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StraightnessTolerance : <sch:value-of select="$uid"/>) The StraightnessTolerance.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.GeometricToleranceContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StraightnessTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='StraightnessTolerance'))]/GeometricToleranceContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricToleranceContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(StraightnessTolerance : <sch:value-of select="$uid"/>) The StraightnessTolerance.GeometricToleranceContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StringValue"><!--(Ref to E) PropertyValue.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StringValue') or (self::StringValue or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::BevelAngle and substring-after(@xsi:type,':')='StringValue') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::Weight and substring-after(@xsi:type,':')='StringValue') or (self::RealWorldScale and substring-after(@xsi:type,':')='StringValue') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='StringValue') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='StringValue') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='StringValue') or (self::Fiber11Offset and substring-after(@xsi:type,':')='StringValue') or (self::ModifierValue and substring-after(@xsi:type,':')='StringValue') or (self::Offset and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='StringValue') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='StringValue') or (self::IndexValue and substring-after(@xsi:type,':')='StringValue') or (self::DimensionValue and substring-after(@xsi:type,':')='StringValue') or (self::UnitLength and substring-after(@xsi:type,':')='StringValue') or (self::FirstUnitSize and substring-after(@xsi:type,':')='StringValue') or (self::SecondUnitSize and substring-after(@xsi:type,':')='StringValue') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='StringValue') or (self::ToleranceValue and substring-after(@xsi:type,':')='StringValue') or (self::ForcedLength and substring-after(@xsi:type,':')='StringValue') or (self::LotSize and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::MaterialValue and substring-after(@xsi:type,':')='StringValue') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::TotalThickness and substring-after(@xsi:type,':')='StringValue') or (self::VolumePercent and substring-after(@xsi:type,':')='StringValue') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='StringValue') or (self::PlyThickness and substring-after(@xsi:type,':')='StringValue') or (self::WaitingTime and substring-after(@xsi:type,':')='StringValue') or (self::ProjectionLength and substring-after(@xsi:type,':')='StringValue') or (self::Offset and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::Density and substring-after(@xsi:type,':')='StringValue') or (self::Height and substring-after(@xsi:type,':')='StringValue') or (self::Width and substring-after(@xsi:type,':')='StringValue') or (self::FileSize and substring-after(@xsi:type,':')='StringValue') or (self::PageCount and substring-after(@xsi:type,':')='StringValue') or (self::TotalThickness and substring-after(@xsi:type,':')='StringValue') or (self::Diameter and substring-after(@xsi:type,':')='StringValue') or (self::Diameter and substring-after(@xsi:type,':')='StringValue') or (self::TargetLength and substring-after(@xsi:type,':')='StringValue') or (self::TargetWidth and substring-after(@xsi:type,':')='StringValue') or (self::TargetLength and substring-after(@xsi:type,':')='StringValue') or (self::Thickness and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::TwistPeriod and substring-after(@xsi:type,':')='StringValue')))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(StringValue : <sch:value-of select="$uid"/>) The StringValue.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.Definition : OPTIONAL PropertyDefinitionSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StringValue') or (self::StringValue or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::BevelAngle and substring-after(@xsi:type,':')='StringValue') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::Weight and substring-after(@xsi:type,':')='StringValue') or (self::RealWorldScale and substring-after(@xsi:type,':')='StringValue') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='StringValue') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='StringValue') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='StringValue') or (self::Fiber11Offset and substring-after(@xsi:type,':')='StringValue') or (self::ModifierValue and substring-after(@xsi:type,':')='StringValue') or (self::Offset and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='StringValue') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='StringValue') or (self::IndexValue and substring-after(@xsi:type,':')='StringValue') or (self::DimensionValue and substring-after(@xsi:type,':')='StringValue') or (self::UnitLength and substring-after(@xsi:type,':')='StringValue') or (self::FirstUnitSize and substring-after(@xsi:type,':')='StringValue') or (self::SecondUnitSize and substring-after(@xsi:type,':')='StringValue') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='StringValue') or (self::ToleranceValue and substring-after(@xsi:type,':')='StringValue') or (self::ForcedLength and substring-after(@xsi:type,':')='StringValue') or (self::LotSize and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::MaterialValue and substring-after(@xsi:type,':')='StringValue') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::TotalThickness and substring-after(@xsi:type,':')='StringValue') or (self::VolumePercent and substring-after(@xsi:type,':')='StringValue') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='StringValue') or (self::PlyThickness and substring-after(@xsi:type,':')='StringValue') or (self::WaitingTime and substring-after(@xsi:type,':')='StringValue') or (self::ProjectionLength and substring-after(@xsi:type,':')='StringValue') or (self::Offset and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::Density and substring-after(@xsi:type,':')='StringValue') or (self::Height and substring-after(@xsi:type,':')='StringValue') or (self::Width and substring-after(@xsi:type,':')='StringValue') or (self::FileSize and substring-after(@xsi:type,':')='StringValue') or (self::PageCount and substring-after(@xsi:type,':')='StringValue') or (self::TotalThickness and substring-after(@xsi:type,':')='StringValue') or (self::Diameter and substring-after(@xsi:type,':')='StringValue') or (self::Diameter and substring-after(@xsi:type,':')='StringValue') or (self::TargetLength and substring-after(@xsi:type,':')='StringValue') or (self::TargetWidth and substring-after(@xsi:type,':')='StringValue') or (self::TargetLength and substring-after(@xsi:type,':')='StringValue') or (self::Thickness and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::TwistPeriod and substring-after(@xsi:type,':')='StringValue')))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionEnum) or (self::PropertyDefinitionString)">(StringValue : <sch:value-of select="$uid"/>) The StringValue.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PropertyDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.DeterminationMethod : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StringValue') or (self::StringValue or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::BevelAngle and substring-after(@xsi:type,':')='StringValue') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::Weight and substring-after(@xsi:type,':')='StringValue') or (self::RealWorldScale and substring-after(@xsi:type,':')='StringValue') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='StringValue') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='StringValue') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='StringValue') or (self::Fiber11Offset and substring-after(@xsi:type,':')='StringValue') or (self::ModifierValue and substring-after(@xsi:type,':')='StringValue') or (self::Offset and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='StringValue') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='StringValue') or (self::IndexValue and substring-after(@xsi:type,':')='StringValue') or (self::DimensionValue and substring-after(@xsi:type,':')='StringValue') or (self::UnitLength and substring-after(@xsi:type,':')='StringValue') or (self::FirstUnitSize and substring-after(@xsi:type,':')='StringValue') or (self::SecondUnitSize and substring-after(@xsi:type,':')='StringValue') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='StringValue') or (self::ToleranceValue and substring-after(@xsi:type,':')='StringValue') or (self::ForcedLength and substring-after(@xsi:type,':')='StringValue') or (self::LotSize and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::MaterialValue and substring-after(@xsi:type,':')='StringValue') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::TotalThickness and substring-after(@xsi:type,':')='StringValue') or (self::VolumePercent and substring-after(@xsi:type,':')='StringValue') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='StringValue') or (self::PlyThickness and substring-after(@xsi:type,':')='StringValue') or (self::WaitingTime and substring-after(@xsi:type,':')='StringValue') or (self::ProjectionLength and substring-after(@xsi:type,':')='StringValue') or (self::Offset and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::Density and substring-after(@xsi:type,':')='StringValue') or (self::Height and substring-after(@xsi:type,':')='StringValue') or (self::Width and substring-after(@xsi:type,':')='StringValue') or (self::FileSize and substring-after(@xsi:type,':')='StringValue') or (self::PageCount and substring-after(@xsi:type,':')='StringValue') or (self::TotalThickness and substring-after(@xsi:type,':')='StringValue') or (self::Diameter and substring-after(@xsi:type,':')='StringValue') or (self::Diameter and substring-after(@xsi:type,':')='StringValue') or (self::TargetLength and substring-after(@xsi:type,':')='StringValue') or (self::TargetWidth and substring-after(@xsi:type,':')='StringValue') or (self::TargetLength and substring-after(@xsi:type,':')='StringValue') or (self::Thickness and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::TwistPeriod and substring-after(@xsi:type,':')='StringValue')))]/DeterminationMethod/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(StringValue : <sch:value-of select="$uid"/>) The StringValue.DeterminationMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.Qualifiers : OPTIONAL SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StringValue') or (self::StringValue or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::BevelAngle and substring-after(@xsi:type,':')='StringValue') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::Weight and substring-after(@xsi:type,':')='StringValue') or (self::RealWorldScale and substring-after(@xsi:type,':')='StringValue') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='StringValue') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='StringValue') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='StringValue') or (self::Fiber11Offset and substring-after(@xsi:type,':')='StringValue') or (self::ModifierValue and substring-after(@xsi:type,':')='StringValue') or (self::Offset and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='StringValue') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='StringValue') or (self::IndexValue and substring-after(@xsi:type,':')='StringValue') or (self::DimensionValue and substring-after(@xsi:type,':')='StringValue') or (self::UnitLength and substring-after(@xsi:type,':')='StringValue') or (self::FirstUnitSize and substring-after(@xsi:type,':')='StringValue') or (self::SecondUnitSize and substring-after(@xsi:type,':')='StringValue') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='StringValue') or (self::ToleranceValue and substring-after(@xsi:type,':')='StringValue') or (self::ForcedLength and substring-after(@xsi:type,':')='StringValue') or (self::LotSize and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::MaterialValue and substring-after(@xsi:type,':')='StringValue') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::TotalThickness and substring-after(@xsi:type,':')='StringValue') or (self::VolumePercent and substring-after(@xsi:type,':')='StringValue') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='StringValue') or (self::PlyThickness and substring-after(@xsi:type,':')='StringValue') or (self::WaitingTime and substring-after(@xsi:type,':')='StringValue') or (self::ProjectionLength and substring-after(@xsi:type,':')='StringValue') or (self::Offset and substring-after(@xsi:type,':')='StringValue') or (self::Quantity and substring-after(@xsi:type,':')='StringValue') or (self::Density and substring-after(@xsi:type,':')='StringValue') or (self::Height and substring-after(@xsi:type,':')='StringValue') or (self::Width and substring-after(@xsi:type,':')='StringValue') or (self::FileSize and substring-after(@xsi:type,':')='StringValue') or (self::PageCount and substring-after(@xsi:type,':')='StringValue') or (self::TotalThickness and substring-after(@xsi:type,':')='StringValue') or (self::Diameter and substring-after(@xsi:type,':')='StringValue') or (self::Diameter and substring-after(@xsi:type,':')='StringValue') or (self::TargetLength and substring-after(@xsi:type,':')='StringValue') or (self::TargetWidth and substring-after(@xsi:type,':')='StringValue') or (self::TargetLength and substring-after(@xsi:type,':')='StringValue') or (self::Thickness and substring-after(@xsi:type,':')='StringValue') or (self::Angle and substring-after(@xsi:type,':')='StringValue') or (self::TwistPeriod and substring-after(@xsi:type,':')='StringValue')))]/Qualifiers/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::ExternalTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalTypeQualifier ',@typeRef)]) or (self::PreDefinedTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PreDefinedTypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::ExternalTypeQualifier and //ExternalTypeQualifier[@uid = $uidRef]) or (self::PreDefinedTypeQualifier and //PreDefinedTypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(StringValue : <sch:value-of select="$uid"/>) The StringValue.Qualifiers contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StyledElement"><!--(Ref to S) StyledElement.Element : StyledElementTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StyledElement') or (self::RepresentationItem and substring-after(@xsi:type,':')='StyledElement'))]/Element">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel  PlyAngleRepresentation  ReinforcementOrientationBasis ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //Representation[@uid = $uidRef]">(StyledElement : <sch:value-of select="$uid"/>) The StyledElement.Element contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of StyledElementTargetSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="StyledModelReplication"><!--(Ref to E) StyledModelReplication.ReplicatedModel : StyledModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StyledModelReplication') or (self::RepresentationItem and substring-after(@xsi:type,':')='StyledModelReplication'))]/ReplicatedModel">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'StyledModel'] or //Representation[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',substring-after(@xsi:type,':'))]">(StyledModelReplication : <sch:value-of select="$uid"/>) The StyledModelReplication.ReplicatedModel contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type StyledModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) StyledModelReplication.Source : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StyledModelReplication') or (self::RepresentationItem and substring-after(@xsi:type,':')='StyledModelReplication'))]/Source">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(StyledModelReplication : <sch:value-of select="$uid"/>) The StyledModelReplication.Source contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to S) StyledModelReplication.Target : GeometricMappingTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='StyledModelReplication') or (self::RepresentationItem and substring-after(@xsi:type,':')='StyledModelReplication'))]/Target">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))] or //CartesianTransformation[@uid = $uidRef]">(StyledModelReplication : <sch:value-of select="$uid"/>) The StyledModelReplication.Target contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricMappingTargetSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SubEdge"><!--(Ref to E) SubEdge.ParentEdge : Edge (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SubEdge') or (self::RepresentationItem and substring-after(@xsi:type,':')='SubEdge'))]/ParentEdge">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Edge'] or //RepresentationItem[@uid = $uidRef and contains(' Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge ',substring-after(@xsi:type,':'))]">(SubEdge : <sch:value-of select="$uid"/>) The SubEdge.ParentEdge contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Edge.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Edge.EdgeEnd : Vertex (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SubEdge') or (self::RepresentationItem and substring-after(@xsi:type,':')='SubEdge'))]/EdgeEnd">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Vertex'] or //RepresentationItem[@uid = $uidRef and contains(' Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(SubEdge : <sch:value-of select="$uid"/>) The SubEdge.EdgeEnd contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Vertex.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Edge.EdgeStart : Vertex (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SubEdge') or (self::RepresentationItem and substring-after(@xsi:type,':')='SubEdge'))]/EdgeStart">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Vertex'] or //RepresentationItem[@uid = $uidRef and contains(' Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(SubEdge : <sch:value-of select="$uid"/>) The SubEdge.EdgeStart contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Vertex.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SubsetMember"><!--(Ref to S) SubsetMember.Subset : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SubsetMember') or (self::SubsetMember and not(@xsi:type)))]/Subset/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SubsetMember : <sch:value-of select="$uid"/>) The SubsetMember.Subset contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SuppliedObjectRelationship"><!--(Ref to E) SuppliedObjectRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SuppliedObjectRelationship') or (self::SuppliedObjectRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SuppliedObjectRelationship : <sch:value-of select="$uid"/>) The SuppliedObjectRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) SuppliedObjectRelationship.Related : SuppliedObjectSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SuppliedObjectRelationship') or (self::SuppliedObjectRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ClassAttribute ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionalConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConfiguredAssemblyEffectivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalClassSystem ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' FormatProperty ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationRight  Copyright ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRight ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlan ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel  PlyAngleRepresentation  ReinforcementOrientationBasis ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementSatisfactionAssertion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategory ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrder ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequest ',@typeRef)] or //Activity[@uid = $uidRef] or //ActivityMethod[@uid = $uidRef] or //AlternativeSolution[@uid = $uidRef] or //Breakdown[@uid = $uidRef] or //BreakdownElement[@uid = $uidRef] or //BreakdownElementVersion[@uid = $uidRef] or //BreakdownElementView[@uid = $uidRef] or //BreakdownVersion[@uid = $uidRef] or //Class[@uid = $uidRef] or //ClassAttribute[@uid = $uidRef] or //Condition[@uid = $uidRef] or //Effectivity[@uid = $uidRef and contains(' ConditionalConfiguration ',substring-after(@xsi:type,':'))] or //ConfiguredAssemblyEffectivity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Document[@uid = $uidRef] or //DocumentDefinition[@uid = $uidRef] or //DocumentVersion[@uid = $uidRef] or //Effectivity[@uid = $uidRef] or //Event[@uid = $uidRef] or //ExternalClassSystem[@uid = $uidRef] or //ExternalOwlClass[@uid = $uidRef] or //File[@uid = $uidRef] or //FormatProperty[@uid = $uidRef] or //IndividualPartView[@uid = $uidRef] or //InformationRight[@uid = $uidRef] or //InformationUsageRight[@uid = $uidRef] or //MaterialIdentification[@uid = $uidRef] or //Observation[@uid = $uidRef] or //Occurrence[@uid = $uidRef] or //Organization[@uid = $uidRef] or //Part[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //PartView[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProcessOperationDefinition[@uid = $uidRef] or //ProcessPlan[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef] or //Representation[@uid = $uidRef] or //Requirement[@uid = $uidRef] or //RequirementSatisfactionAssertion[@uid = $uidRef] or //RequirementVersion[@uid = $uidRef] or //RequirementView[@uid = $uidRef] or //SecurityClassification[@uid = $uidRef] or //Specification[@uid = $uidRef] or //SpecificationCategory[@uid = $uidRef] or //SpecificationInclusion[@uid = $uidRef] or //WorkOrder[@uid = $uidRef] or //WorkRequest[@uid = $uidRef]">(SuppliedObjectRelationship : <sch:value-of select="$uid"/>) The SuppliedObjectRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of SuppliedObjectSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SupplierSolution"><!--(Ref to E) SupplierSolution.Supplier : Organization (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SupplierSolution') or (self::AlternativeSolution and substring-after(@xsi:type,':')='SupplierSolution'))]/Supplier">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(SupplierSolution : <sch:value-of select="$uid"/>) The SupplierSolution.Supplier contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AlternativeSolution.BaseElement : BreakdownElementOrAlternativeSolutionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SupplierSolution') or (self::AlternativeSolution and substring-after(@xsi:type,':')='SupplierSolution'))]/BaseElement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //AlternativeSolution[@uid = $uidRef] or //BreakdownElement[@uid = $uidRef]">(SupplierSolution : <sch:value-of select="$uid"/>) The SupplierSolution.BaseElement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of BreakdownElementOrAlternativeSolutionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AlternativeSolution.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SupplierSolution') or (self::AlternativeSolution and substring-after(@xsi:type,':')='SupplierSolution'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SupplierSolution : <sch:value-of select="$uid"/>) The SupplierSolution.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Surface"/>
   <sch:pattern id="SurfaceCondition"><!--(Ref to E) SurfaceCondition.DefinedIn : DigitalFile (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SurfaceCondition') or (self::SurfaceCondition and not(@xsi:type)))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DigitalFile'] or //File[@uid = $uidRef and contains(' DigitalFile ',substring-after(@xsi:type,':'))]">(SurfaceCondition : <sch:value-of select="$uid"/>) The SurfaceCondition.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DigitalFile.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SurfaceCurve"/>
   <sch:pattern id="SurfaceProfileTolerance"><!--(Ref to E) SurfaceProfileTolerance.DatumSystem : OPTIONAL DatumSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SurfaceProfileTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='SurfaceProfileTolerance'))]/DatumSystem">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DatumSystem) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DatumSystem'] or //ShapeElement[@uid = $uidRef and contains(' DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem ',substring-after(@xsi:type,':'))]">(SurfaceProfileTolerance : <sch:value-of select="$uid"/>) The SurfaceProfileTolerance.DatumSystem contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DatumSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricTolerance.AppliedTo : GeometricToleranceTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SurfaceProfileTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='SurfaceProfileTolerance'))]/AppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //PartView[@uid = $uidRef]">(SurfaceProfileTolerance : <sch:value-of select="$uid"/>) The SurfaceProfileTolerance.AppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricToleranceTargetSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SurfaceProfileTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='SurfaceProfileTolerance'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SurfaceProfileTolerance : <sch:value-of select="$uid"/>) The SurfaceProfileTolerance.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.GeometricToleranceContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SurfaceProfileTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='SurfaceProfileTolerance'))]/GeometricToleranceContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricToleranceContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(SurfaceProfileTolerance : <sch:value-of select="$uid"/>) The SurfaceProfileTolerance.GeometricToleranceContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SurfaceWithDirection"><!--(Ref to E) SurfaceWithDirection.DefiningSurface : Surface (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SurfaceWithDirection') or (self::SurfaceWithDirection or (self::BaseSurface and substring-after(@xsi:type,':')='SurfaceWithDirection')))]/DefiningSurface">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Surface'] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(SurfaceWithDirection : <sch:value-of select="$uid"/>) The SurfaceWithDirection.DefiningSurface contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Surface.</sch:assert>
      </sch:rule>
      <!--(Ref to E) SurfaceWithDirection.MaterialDirection : Direction (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SurfaceWithDirection') or (self::SurfaceWithDirection or (self::BaseSurface and substring-after(@xsi:type,':')='SurfaceWithDirection')))]/MaterialDirection">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Direction'] or //RepresentationItem[@uid = $uidRef and contains(' Direction ',substring-after(@xsi:type,':'))]">(SurfaceWithDirection : <sch:value-of select="$uid"/>) The SurfaceWithDirection.MaterialDirection contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Direction.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SymmetryTolerance"><!--(Ref to E) SymmetryTolerance.DatumSystem : DatumSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SymmetryTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='SymmetryTolerance'))]/DatumSystem">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DatumSystem'] or //ShapeElement[@uid = $uidRef and contains(' DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem ',substring-after(@xsi:type,':'))]">(SymmetryTolerance : <sch:value-of select="$uid"/>) The SymmetryTolerance.DatumSystem contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DatumSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricTolerance.AppliedTo : GeometricToleranceTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SymmetryTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='SymmetryTolerance'))]/AppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //PartView[@uid = $uidRef]">(SymmetryTolerance : <sch:value-of select="$uid"/>) The SymmetryTolerance.AppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricToleranceTargetSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SymmetryTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='SymmetryTolerance'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SymmetryTolerance : <sch:value-of select="$uid"/>) The SymmetryTolerance.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.GeometricToleranceContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SymmetryTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='SymmetryTolerance'))]/GeometricToleranceContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricToleranceContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(SymmetryTolerance : <sch:value-of select="$uid"/>) The SymmetryTolerance.GeometricToleranceContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="SystemBreakdown"><!--(Default Value) SystemBreakdown.BreakdownType : String = 'system' (kind=SINGLE - redefined=Breakdown.BreakdownType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SystemBreakdown') or (self::Breakdown and substring-after(@xsi:type,':')='SystemBreakdown'))]/BreakdownType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'system'">(SystemBreakdown : <sch:value-of select="$uid"/>) The SystemBreakdown.BreakdownType contains the wrong value () must be 'system'.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Breakdown.BreakdownType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SystemBreakdown') or (self::Breakdown and substring-after(@xsi:type,':')='SystemBreakdown'))]/BreakdownType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(SystemBreakdown : <sch:value-of select="$uid"/>) The SystemBreakdown.BreakdownType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Breakdown.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='SystemBreakdown') or (self::Breakdown and substring-after(@xsi:type,':')='SystemBreakdown'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(SystemBreakdown : <sch:value-of select="$uid"/>) The SystemBreakdown.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Tangent"><!--(Ref to E) Tangent.DerivedFrom : ShapeElement (kind=SINGLE - redefined=DerivedShapeElement.DerivedFrom)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Tangent') or (self::ShapeElement and substring-after(@xsi:type,':')='Tangent'))]/DerivedFrom">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="count(../../DerivedFrom/ShapeElement) = 1">(Tangent : <sch:value-of select="$uid"/>) The Tangent.DerivedFrom contains wrong number of element must be 1.</sch:assert>
      </sch:rule>
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Tangent') or (self::ShapeElement and substring-after(@xsi:type,':')='Tangent'))]/DerivedFrom/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(Tangent : <sch:value-of select="$uid"/>) The Tangent.DerivedFrom contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Tangent') or (self::ShapeElement and substring-after(@xsi:type,':')='Tangent'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Tangent : <sch:value-of select="$uid"/>) The Tangent.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Tangent') or (self::ShapeElement and substring-after(@xsi:type,':')='Tangent'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(Tangent : <sch:value-of select="$uid"/>) The Tangent.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TargetArea"><!--(Ref to E) TargetArea.IsDefinedBy : ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetArea') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetArea'))]/IsDefinedBy">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(TargetArea : <sch:value-of select="$uid"/>) The TargetArea.IsDefinedBy contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DatumTarget.MovementDirection : OPTIONAL Direction (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetArea') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetArea'))]/MovementDirection">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./MovementDirection) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Direction'] or //RepresentationItem[@uid = $uidRef and contains(' Direction ',substring-after(@xsi:type,':'))]">(TargetArea : <sch:value-of select="$uid"/>) The TargetArea.MovementDirection contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Direction.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DatumTarget.TargetFeature : OPTIONAL ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetArea') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetArea'))]/TargetFeature">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./TargetFeature) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(TargetArea : <sch:value-of select="$uid"/>) The TargetArea.TargetFeature contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Default Value) DatumTarget.ProductDefinitional : Boolean = 'true' (kind=SINGLE - redefined=ShapeElement.ProductDefinitional)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetArea') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetArea'))]/ProductDefinitional">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="text() = 'true'">(TargetArea : <sch:value-of select="$uid"/>) The TargetArea.ProductDefinitional contains the wrong value () must be 'true'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetArea') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetArea'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(TargetArea : <sch:value-of select="$uid"/>) The TargetArea.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetArea') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetArea'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(TargetArea : <sch:value-of select="$uid"/>) The TargetArea.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TargetCircle"><!--(Ref to E) PlacedTarget.DefinedIn : GeometricCoordinateSpace (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCircle') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCircle'))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricCoordinateSpace'] or //RepresentationContext[@uid = $uidRef and contains(' GeometricCoordinateSpace ',substring-after(@xsi:type,':'))]">(TargetCircle : <sch:value-of select="$uid"/>) The TargetCircle.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricCoordinateSpace.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PlacedTarget.ParameterReference : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCircle') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCircle'))]/ParameterReference">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(TargetCircle : <sch:value-of select="$uid"/>) The TargetCircle.ParameterReference contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DatumTarget.MovementDirection : OPTIONAL Direction (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCircle') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCircle'))]/MovementDirection">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./MovementDirection) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Direction'] or //RepresentationItem[@uid = $uidRef and contains(' Direction ',substring-after(@xsi:type,':'))]">(TargetCircle : <sch:value-of select="$uid"/>) The TargetCircle.MovementDirection contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Direction.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DatumTarget.TargetFeature : OPTIONAL ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCircle') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCircle'))]/TargetFeature">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./TargetFeature) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(TargetCircle : <sch:value-of select="$uid"/>) The TargetCircle.TargetFeature contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Default Value) DatumTarget.ProductDefinitional : Boolean = 'true' (kind=SINGLE - redefined=ShapeElement.ProductDefinitional)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCircle') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCircle'))]/ProductDefinitional">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="text() = 'true'">(TargetCircle : <sch:value-of select="$uid"/>) The TargetCircle.ProductDefinitional contains the wrong value () must be 'true'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCircle') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCircle'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(TargetCircle : <sch:value-of select="$uid"/>) The TargetCircle.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCircle') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCircle'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(TargetCircle : <sch:value-of select="$uid"/>) The TargetCircle.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TargetCircularCurve"><!--(Ref to E) PlacedTarget.DefinedIn : GeometricCoordinateSpace (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCircularCurve') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCircularCurve'))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricCoordinateSpace'] or //RepresentationContext[@uid = $uidRef and contains(' GeometricCoordinateSpace ',substring-after(@xsi:type,':'))]">(TargetCircularCurve : <sch:value-of select="$uid"/>) The TargetCircularCurve.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricCoordinateSpace.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PlacedTarget.ParameterReference : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCircularCurve') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCircularCurve'))]/ParameterReference">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(TargetCircularCurve : <sch:value-of select="$uid"/>) The TargetCircularCurve.ParameterReference contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DatumTarget.MovementDirection : OPTIONAL Direction (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCircularCurve') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCircularCurve'))]/MovementDirection">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./MovementDirection) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Direction'] or //RepresentationItem[@uid = $uidRef and contains(' Direction ',substring-after(@xsi:type,':'))]">(TargetCircularCurve : <sch:value-of select="$uid"/>) The TargetCircularCurve.MovementDirection contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Direction.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DatumTarget.TargetFeature : OPTIONAL ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCircularCurve') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCircularCurve'))]/TargetFeature">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./TargetFeature) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(TargetCircularCurve : <sch:value-of select="$uid"/>) The TargetCircularCurve.TargetFeature contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Default Value) DatumTarget.ProductDefinitional : Boolean = 'true' (kind=SINGLE - redefined=ShapeElement.ProductDefinitional)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCircularCurve') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCircularCurve'))]/ProductDefinitional">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="text() = 'true'">(TargetCircularCurve : <sch:value-of select="$uid"/>) The TargetCircularCurve.ProductDefinitional contains the wrong value () must be 'true'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCircularCurve') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCircularCurve'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(TargetCircularCurve : <sch:value-of select="$uid"/>) The TargetCircularCurve.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCircularCurve') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCircularCurve'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(TargetCircularCurve : <sch:value-of select="$uid"/>) The TargetCircularCurve.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TargetCurve"><!--(Ref to E) TargetCurve.IsDefinedBy : ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCurve') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCurve'))]/IsDefinedBy">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(TargetCurve : <sch:value-of select="$uid"/>) The TargetCurve.IsDefinedBy contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DatumTarget.MovementDirection : OPTIONAL Direction (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCurve') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCurve'))]/MovementDirection">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./MovementDirection) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Direction'] or //RepresentationItem[@uid = $uidRef and contains(' Direction ',substring-after(@xsi:type,':'))]">(TargetCurve : <sch:value-of select="$uid"/>) The TargetCurve.MovementDirection contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Direction.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DatumTarget.TargetFeature : OPTIONAL ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCurve') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCurve'))]/TargetFeature">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./TargetFeature) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(TargetCurve : <sch:value-of select="$uid"/>) The TargetCurve.TargetFeature contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Default Value) DatumTarget.ProductDefinitional : Boolean = 'true' (kind=SINGLE - redefined=ShapeElement.ProductDefinitional)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCurve') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCurve'))]/ProductDefinitional">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="text() = 'true'">(TargetCurve : <sch:value-of select="$uid"/>) The TargetCurve.ProductDefinitional contains the wrong value () must be 'true'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCurve') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCurve'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(TargetCurve : <sch:value-of select="$uid"/>) The TargetCurve.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetCurve') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetCurve'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(TargetCurve : <sch:value-of select="$uid"/>) The TargetCurve.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TargetPoint"><!--(Ref to E) PlacedTarget.DefinedIn : GeometricCoordinateSpace (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetPoint') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetPoint'))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricCoordinateSpace'] or //RepresentationContext[@uid = $uidRef and contains(' GeometricCoordinateSpace ',substring-after(@xsi:type,':'))]">(TargetPoint : <sch:value-of select="$uid"/>) The TargetPoint.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricCoordinateSpace.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PlacedTarget.ParameterReference : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetPoint') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetPoint'))]/ParameterReference">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(TargetPoint : <sch:value-of select="$uid"/>) The TargetPoint.ParameterReference contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DatumTarget.MovementDirection : OPTIONAL Direction (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetPoint') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetPoint'))]/MovementDirection">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./MovementDirection) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Direction'] or //RepresentationItem[@uid = $uidRef and contains(' Direction ',substring-after(@xsi:type,':'))]">(TargetPoint : <sch:value-of select="$uid"/>) The TargetPoint.MovementDirection contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Direction.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DatumTarget.TargetFeature : OPTIONAL ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetPoint') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetPoint'))]/TargetFeature">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./TargetFeature) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(TargetPoint : <sch:value-of select="$uid"/>) The TargetPoint.TargetFeature contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Default Value) DatumTarget.ProductDefinitional : Boolean = 'true' (kind=SINGLE - redefined=ShapeElement.ProductDefinitional)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetPoint') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetPoint'))]/ProductDefinitional">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="text() = 'true'">(TargetPoint : <sch:value-of select="$uid"/>) The TargetPoint.ProductDefinitional contains the wrong value () must be 'true'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetPoint') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetPoint'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(TargetPoint : <sch:value-of select="$uid"/>) The TargetPoint.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetPoint') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetPoint'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(TargetPoint : <sch:value-of select="$uid"/>) The TargetPoint.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TargetRectangle"><!--(Ref to E) PlacedTarget.DefinedIn : GeometricCoordinateSpace (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetRectangle') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetRectangle'))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricCoordinateSpace'] or //RepresentationContext[@uid = $uidRef and contains(' GeometricCoordinateSpace ',substring-after(@xsi:type,':'))]">(TargetRectangle : <sch:value-of select="$uid"/>) The TargetRectangle.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricCoordinateSpace.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PlacedTarget.ParameterReference : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetRectangle') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetRectangle'))]/ParameterReference">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(TargetRectangle : <sch:value-of select="$uid"/>) The TargetRectangle.ParameterReference contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DatumTarget.MovementDirection : OPTIONAL Direction (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetRectangle') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetRectangle'))]/MovementDirection">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./MovementDirection) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Direction'] or //RepresentationItem[@uid = $uidRef and contains(' Direction ',substring-after(@xsi:type,':'))]">(TargetRectangle : <sch:value-of select="$uid"/>) The TargetRectangle.MovementDirection contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Direction.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DatumTarget.TargetFeature : OPTIONAL ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetRectangle') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetRectangle'))]/TargetFeature">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./TargetFeature) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(TargetRectangle : <sch:value-of select="$uid"/>) The TargetRectangle.TargetFeature contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Default Value) DatumTarget.ProductDefinitional : Boolean = 'true' (kind=SINGLE - redefined=ShapeElement.ProductDefinitional)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetRectangle') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetRectangle'))]/ProductDefinitional">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="text() = 'true'">(TargetRectangle : <sch:value-of select="$uid"/>) The TargetRectangle.ProductDefinitional contains the wrong value () must be 'true'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetRectangle') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetRectangle'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(TargetRectangle : <sch:value-of select="$uid"/>) The TargetRectangle.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetRectangle') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetRectangle'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(TargetRectangle : <sch:value-of select="$uid"/>) The TargetRectangle.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TargetStraightLine"><!--(Ref to E) PlacedTarget.DefinedIn : GeometricCoordinateSpace (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetStraightLine') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetStraightLine'))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricCoordinateSpace'] or //RepresentationContext[@uid = $uidRef and contains(' GeometricCoordinateSpace ',substring-after(@xsi:type,':'))]">(TargetStraightLine : <sch:value-of select="$uid"/>) The TargetStraightLine.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricCoordinateSpace.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PlacedTarget.ParameterReference : AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetStraightLine') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetStraightLine'))]/ParameterReference">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(TargetStraightLine : <sch:value-of select="$uid"/>) The TargetStraightLine.ParameterReference contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DatumTarget.MovementDirection : OPTIONAL Direction (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetStraightLine') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetStraightLine'))]/MovementDirection">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./MovementDirection) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Direction'] or //RepresentationItem[@uid = $uidRef and contains(' Direction ',substring-after(@xsi:type,':'))]">(TargetStraightLine : <sch:value-of select="$uid"/>) The TargetStraightLine.MovementDirection contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Direction.</sch:assert>
      </sch:rule>
      <!--(Ref to E) DatumTarget.TargetFeature : OPTIONAL ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetStraightLine') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetStraightLine'))]/TargetFeature">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./TargetFeature) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(TargetStraightLine : <sch:value-of select="$uid"/>) The TargetStraightLine.TargetFeature contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Default Value) DatumTarget.ProductDefinitional : Boolean = 'true' (kind=SINGLE - redefined=ShapeElement.ProductDefinitional)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetStraightLine') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetStraightLine'))]/ProductDefinitional">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="text() = 'true'">(TargetStraightLine : <sch:value-of select="$uid"/>) The TargetStraightLine.ProductDefinitional contains the wrong value () must be 'true'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetStraightLine') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetStraightLine'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(TargetStraightLine : <sch:value-of select="$uid"/>) The TargetStraightLine.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TargetStraightLine') or (self::ShapeElement and substring-after(@xsi:type,':')='TargetStraightLine'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(TargetStraightLine : <sch:value-of select="$uid"/>) The TargetStraightLine.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TechnicalSolution"><!--(Ref to S) AlternativeSolution.BaseElement : BreakdownElementOrAlternativeSolutionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TechnicalSolution') or (self::AlternativeSolution and substring-after(@xsi:type,':')='TechnicalSolution'))]/BaseElement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)] or //AlternativeSolution[@uid = $uidRef] or //BreakdownElement[@uid = $uidRef]">(TechnicalSolution : <sch:value-of select="$uid"/>) The TechnicalSolution.BaseElement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of BreakdownElementOrAlternativeSolutionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) AlternativeSolution.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TechnicalSolution') or (self::AlternativeSolution and substring-after(@xsi:type,':')='TechnicalSolution'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(TechnicalSolution : <sch:value-of select="$uid"/>) The TechnicalSolution.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TextStyle"><!--(Ref to E) TextStyle.MirrorPlacement : OPTIONAL AxisPlacement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TextStyle') or (self::TextStyle and not(@xsi:type)))]/MirrorPlacement">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./MirrorPlacement) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'AxisPlacement'] or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]">(TextStyle : <sch:value-of select="$uid"/>) The TextStyle.MirrorPlacement contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type AxisPlacement.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ThicknessLaminateTable"><!--(Ref to S) ThicknessLaminateTable.TableComponents : LIST[2:unbounded] OF ThicknessLaminateTableComponentSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThicknessLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='ThicknessLaminateTable'))]/TableComponents/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::FilamentLaminate and //ExternalRefBaseObject[@uid = $uidRef and contains(' FilamentLaminate ',@typeRef)]) or (self::Ply and //ExternalRefBaseObject[@uid = $uidRef and contains(' Ply ',@typeRef)]) or (self::ProcessedCore and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessedCore ',@typeRef)]) or (self::FilamentLaminate and //PartView[@uid = $uidRef and contains(' FilamentLaminate ',substring-after(@xsi:type,':'))]) or (self::Ply and //PartView[@uid = $uidRef and contains(' Ply ',substring-after(@xsi:type,':'))]) or (self::ProcessedCore and //PartView[@uid = $uidRef and contains(' ProcessedCore ',substring-after(@xsi:type,':'))])">(ThicknessLaminateTable : <sch:value-of select="$uid"/>) The ThicknessLaminateTable.TableComponents contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ThicknessLaminateTableComponentSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) LaminateTable.Basis : SET[1:unbounded] OF ReinforcementOrientationBasis (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThicknessLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='ThicknessLaminateTable'))]/Basis/ReinforcementOrientationBasis">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ReinforcementOrientationBasis'] or //Representation[@uid = $uidRef and contains(' ReinforcementOrientationBasis ',substring-after(@xsi:type,':'))]">(ThicknessLaminateTable : <sch:value-of select="$uid"/>) The ThicknessLaminateTable.Basis contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ReinforcementOrientationBasis.</sch:assert>
      </sch:rule>
      <!--(Ref to E) LaminateTable.ResultingBoundary : PlyShape (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThicknessLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='ThicknessLaminateTable'))]/ResultingBoundary">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PlyShape'] or //PlyShape[@uid = $uidRef]">(ThicknessLaminateTable : <sch:value-of select="$uid"/>) The ThicknessLaminateTable.ResultingBoundary contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PlyShape.</sch:assert>
      </sch:rule>
      <!--(Ref to E) LaminateTable.ResultingSurface : Surface (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThicknessLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='ThicknessLaminateTable'))]/ResultingSurface">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Surface'] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(ThicknessLaminateTable : <sch:value-of select="$uid"/>) The ThicknessLaminateTable.ResultingSurface contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Surface.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThicknessLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='ThicknessLaminateTable'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(ThicknessLaminateTable : <sch:value-of select="$uid"/>) The ThicknessLaminateTable.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThicknessLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='ThicknessLaminateTable'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(ThicknessLaminateTable : <sch:value-of select="$uid"/>) The ThicknessLaminateTable.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThicknessLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='ThicknessLaminateTable'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ThicknessLaminateTable : <sch:value-of select="$uid"/>) The ThicknessLaminateTable.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThicknessLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='ThicknessLaminateTable'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(ThicknessLaminateTable : <sch:value-of select="$uid"/>) The ThicknessLaminateTable.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThicknessLaminateTable') or (self::PartView and substring-after(@xsi:type,':')='ThicknessLaminateTable'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(ThicknessLaminateTable : <sch:value-of select="$uid"/>) The ThicknessLaminateTable.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ThicknessSize"><!--(Ref to E) DimensionalSize.IsAppliedTo : ShapeElement (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThicknessSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='ThicknessSize'))]/IsAppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(ThicknessSize : <sch:value-of select="$uid"/>) The ThicknessSize.IsAppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThicknessSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='ThicknessSize'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ThicknessSize : <sch:value-of select="$uid"/>) The ThicknessSize.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricDimension.GeometricDimensionContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThicknessSize') or (self::GeometricDimension and substring-after(@xsi:type,':')='ThicknessSize'))]/GeometricDimensionContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricDimensionContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(ThicknessSize : <sch:value-of select="$uid"/>) The ThicknessSize.GeometricDimensionContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ThicknessSizeDimension"/>
   <sch:pattern id="ThreeDGeometrySet"><!--(Ref to S) ThreeDGeometrySet.BasisRole : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThreeDGeometrySet') or (self::Representation and substring-after(@xsi:type,':')='ThreeDGeometrySet'))]/BasisRole/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ThreeDGeometrySet : <sch:value-of select="$uid"/>) The ThreeDGeometrySet.BasisRole contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ThreeDGeometrySet.BasisSurface : Surface (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThreeDGeometrySet') or (self::Representation and substring-after(@xsi:type,':')='ThreeDGeometrySet'))]/BasisSurface">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Surface'] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))]">(ThreeDGeometrySet : <sch:value-of select="$uid"/>) The ThreeDGeometrySet.BasisSurface contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Surface.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ThreeDGeometrySet.DefiningBoundary : SET[1:unbounded] OF Curve (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThreeDGeometrySet') or (self::Representation and substring-after(@xsi:type,':')='ThreeDGeometrySet'))]/DefiningBoundary/Curve">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Curve'] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))]">(ThreeDGeometrySet : <sch:value-of select="$uid"/>) The ThreeDGeometrySet.DefiningBoundary contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Curve.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ThreeDGeometrySet.ThreeDGeometry : ExternalGeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThreeDGeometrySet') or (self::Representation and substring-after(@xsi:type,':')='ThreeDGeometrySet'))]/ThreeDGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExternalGeometricModel'] or //Representation[@uid = $uidRef and contains(' ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation ',substring-after(@xsi:type,':'))]">(ThreeDGeometrySet : <sch:value-of select="$uid"/>) The ThreeDGeometrySet.ThreeDGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExternalGeometricModel.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThreeDGeometrySet') or (self::Representation and substring-after(@xsi:type,':')='ThreeDGeometrySet'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ThreeDGeometrySet : <sch:value-of select="$uid"/>) The ThreeDGeometrySet.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Representation.Items : SET[1:unbounded] OF RepresentationItem (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThreeDGeometrySet') or (self::Representation and substring-after(@xsi:type,':')='ThreeDGeometrySet'))]/Items/RepresentationItem">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RepresentationItem'] or //RepresentationItem[@uid = $uidRef]">(ThreeDGeometrySet : <sch:value-of select="$uid"/>) The ThreeDGeometrySet.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RepresentationItem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ThreeDGeometrySet') or (self::Representation and substring-after(@xsi:type,':')='ThreeDGeometrySet'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ThreeDGeometrySet : <sch:value-of select="$uid"/>) The ThreeDGeometrySet.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="TimeInterval"/>
   <sch:pattern id="TimeIntervalAssignment"><!--(Ref to E) TimeIntervalAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalAssignment') or (self::TimeIntervalAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(TimeIntervalAssignment : <sch:value-of select="$uid"/>) The TimeIntervalAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) TimeIntervalAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalAssignment') or (self::TimeIntervalAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(TimeIntervalAssignment : <sch:value-of select="$uid"/>) The TimeIntervalAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TimeIntervalEffectivity"><!--(Ref to S) DatedEffectivity.EndDefinition : OPTIONAL EventOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='TimeIntervalEffectivity'))]/EndDefinition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(TimeIntervalEffectivity : <sch:value-of select="$uid"/>) The TimeIntervalEffectivity.EndDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EventOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DatedEffectivity.StartDefinition : OPTIONAL EventOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='TimeIntervalEffectivity'))]/StartDefinition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(TimeIntervalEffectivity : <sch:value-of select="$uid"/>) The TimeIntervalEffectivity.StartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EventOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='TimeIntervalEffectivity'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(TimeIntervalEffectivity : <sch:value-of select="$uid"/>) The TimeIntervalEffectivity.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='TimeIntervalEffectivity'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(TimeIntervalEffectivity : <sch:value-of select="$uid"/>) The TimeIntervalEffectivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Effectivity.EffectivityContext : OPTIONAL EffectivityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='TimeIntervalEffectivity'))]/EffectivityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //Activity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef]">(TimeIntervalEffectivity : <sch:value-of select="$uid"/>) The TimeIntervalEffectivity.EffectivityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EffectivityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TimeIntervalRelationship"><!--(Ref to E) TimeIntervalRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalRelationship') or (self::TimeIntervalRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(TimeIntervalRelationship : <sch:value-of select="$uid"/>) The TimeIntervalRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) TimeIntervalRelationship.Related : TimeInterval (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalRelationship') or (self::TimeIntervalRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'TimeInterval'] or //TimeInterval[@uid = $uidRef] or //*[@uid = $uidRef and (self::AssignedTimeInterval)]">(TimeIntervalRelationship : <sch:value-of select="$uid"/>) The TimeIntervalRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type TimeInterval.</sch:assert>
      </sch:rule>
      <!--(Ref to S) TimeIntervalRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalRelationship') or (self::TimeIntervalRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(TimeIntervalRelationship : <sch:value-of select="$uid"/>) The TimeIntervalRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TimeIntervalRelationship_WR1"><!--(Rule TimeIntervalRelationship.WR1)-->
      <sch:rule context="//TimeIntervalRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> TimeIntervalRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related TimeInterval and the relating TimeInterval shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="TimeIntervalWithBounds"><!--(Ref to S) TimeIntervalWithBounds.PrimaryBound : OPTIONAL EventOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalWithBounds') or (self::TimeInterval and substring-after(@xsi:type,':')='TimeIntervalWithBounds'))]/PrimaryBound/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(TimeIntervalWithBounds : <sch:value-of select="$uid"/>) The TimeIntervalWithBounds.PrimaryBound contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EventOrDateSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) TimeIntervalWithBounds.SecondaryBound : OPTIONAL EventOrDateSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TimeIntervalWithBounds') or (self::TimeInterval and substring-after(@xsi:type,':')='TimeIntervalWithBounds'))]/SecondaryBound/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::DateTimeString) or (self::Event and //Event[@uid = $uidRef])">(TimeIntervalWithBounds : <sch:value-of select="$uid"/>) The TimeIntervalWithBounds.SecondaryBound contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EventOrDateSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TimeIntervalWithId"/>
   <sch:pattern id="ToleranceZone"><!--(Ref to S) ToleranceZone.ZoneFor : SET[1:unbounded] OF ToleranceZoneTargetSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='ToleranceZone'))]/ZoneFor/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DimensionalLocation and //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)]) or (self::DimensionalSize and //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)]) or (self::GeneralDatumReference and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeneralDatumReference  DatumReferenceCompartment  DatumReferenceElement ',@typeRef)]) or (self::GeometricTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricTolerance  AngularityTolerance  CircularRunoutTolerance  CoaxialityTolerance  ConcentricityTolerance  CylindricityTolerance  FlatnessTolerance  LineProfileTolerance  ParallelismTolerance  PerpendicularityTolerance  PositionTolerance  RoundnessTolerance  StraightnessTolerance  SurfaceProfileTolerance  SymmetryTolerance  TotalRunoutTolerance ',@typeRef)]) or (self::DimensionalLocation and //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))]) or (self::DimensionalSize and //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))]) or (self::GeneralDatumReference and //GeneralDatumReference[@uid = $uidRef]) or (self::GeometricTolerance and //GeometricTolerance[@uid = $uidRef])">(ToleranceZone : <sch:value-of select="$uid"/>) The ToleranceZone.ZoneFor contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ToleranceZoneTargetSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='ToleranceZone'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ToleranceZone : <sch:value-of select="$uid"/>) The ToleranceZone.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ToleranceZone') or (self::ShapeElement and substring-after(@xsi:type,':')='ToleranceZone'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(ToleranceZone : <sch:value-of select="$uid"/>) The ToleranceZone.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ToleranceZoneDefinition"><!--(Ref to E) ToleranceZoneDefinition.Boundaries : OPTIONAL SET[1:unbounded] OF ShapeElement (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ToleranceZoneDefinition') or (self::ToleranceZoneDefinition and not(@xsi:type)))]/Boundaries/ShapeElement">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../Boundaries/ShapeElement) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ShapeElement'] or //ShapeElement[@uid = $uidRef]">(ToleranceZoneDefinition : <sch:value-of select="$uid"/>) The ToleranceZoneDefinition.Boundaries contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ShapeElement.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ToleranceZoneWithDatum"><!--(Ref to E) ToleranceZoneWithDatum.DatumReference : DatumSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ToleranceZoneWithDatum') or (self::ShapeElement and substring-after(@xsi:type,':')='ToleranceZoneWithDatum'))]/DatumReference">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DatumSystem'] or //ShapeElement[@uid = $uidRef and contains(' DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem ',substring-after(@xsi:type,':'))]">(ToleranceZoneWithDatum : <sch:value-of select="$uid"/>) The ToleranceZoneWithDatum.DatumReference contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DatumSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) DirectedOrOrientedToleranceZone.ZoneFor : SET[1:unbounded] OF DirectedOrOrientedGeometricToleranceSelect (kind=AGGREGATE - redefined=ToleranceZone.ZoneFor)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ToleranceZoneWithDatum') or (self::ShapeElement and substring-after(@xsi:type,':')='ToleranceZoneWithDatum'))]/ZoneFor/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::DimensionalLocation and //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)]) or (self::DimensionalSize and //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)]) or (self::LineProfileTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' LineProfileTolerance ',@typeRef)]) or (self::ParallelismTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' ParallelismTolerance ',@typeRef)]) or (self::PerpendicularityTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' PerpendicularityTolerance ',@typeRef)]) or (self::PositionTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' PositionTolerance ',@typeRef)]) or (self::StraightnessTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' StraightnessTolerance ',@typeRef)]) or (self::SymmetryTolerance and //ExternalRefBaseObject[@uid = $uidRef and contains(' SymmetryTolerance ',@typeRef)]) or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' LineProfileTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' ParallelismTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' PerpendicularityTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' PositionTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' StraightnessTolerance ',substring-after(@xsi:type,':'))] or //GeometricTolerance[@uid = $uidRef and contains(' SymmetryTolerance ',substring-after(@xsi:type,':'))]">(ToleranceZoneWithDatum : <sch:value-of select="$uid"/>) The ToleranceZoneWithDatum.ZoneFor contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of DirectedOrOrientedGeometricToleranceSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ToleranceZoneWithDatum') or (self::ShapeElement and substring-after(@xsi:type,':')='ToleranceZoneWithDatum'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ToleranceZoneWithDatum : <sch:value-of select="$uid"/>) The ToleranceZoneWithDatum.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ToleranceZoneWithDatum') or (self::ShapeElement and substring-after(@xsi:type,':')='ToleranceZoneWithDatum'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(ToleranceZoneWithDatum : <sch:value-of select="$uid"/>) The ToleranceZoneWithDatum.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ToolAttachmentPointFrame"/>
   <sch:pattern id="ToolCentrePointFrame"/>
   <sch:pattern id="ToolPartRelationship"><!--(Ref to S) ToolPartRelationship.Placement : OPTIONAL TransformationSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ToolPartRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='ToolPartRelationship'))]/Placement/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::CartesianTransformation or (self::Transformation and contains(' CartesianTransformation ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)]) or (self::GeometricRepresentationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',@typeRef)]) or (self::CartesianTransformation) or (self::GeometricRepresentationRelationship and //RepresentationRelationship[@uid = $uidRef and contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',substring-after(@xsi:type,':'))])">(ToolPartRelationship : <sch:value-of select="$uid"/>) The ToolPartRelationship.Placement contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of TransformationSelect.</sch:assert>
      </sch:rule>
      <!--(Default Value) ToolPartRelationship.RelationType : String = 'tool part' (kind=SINGLE - redefined=PartViewRelationship.RelationType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ToolPartRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='ToolPartRelationship'))]/RelationType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'tool part'">(ToolPartRelationship : <sch:value-of select="$uid"/>) The ToolPartRelationship.RelationType contains the wrong value () must be 'tool part'.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ToolPartRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='ToolPartRelationship'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ToolPartRelationship : <sch:value-of select="$uid"/>) The ToolPartRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartViewRelationship.Related : PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ToolPartRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='ToolPartRelationship'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(ToolPartRelationship : <sch:value-of select="$uid"/>) The ToolPartRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartViewRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ToolPartRelationship') or (self::PartViewRelationship and substring-after(@xsi:type,':')='ToolPartRelationship'))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ToolPartRelationship : <sch:value-of select="$uid"/>) The ToolPartRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TopologyToGeometryModelAssociation"><!--(Ref to S) TopologyToGeometryModelAssociation.Origin : LIST[1:unbounded] OF TopologyAssociationItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TopologyToGeometryModelAssociation') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='TopologyToGeometryModelAssociation'))]/Origin/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Edge and //ExternalRefBaseObject[@uid = $uidRef and contains(' Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge ',@typeRef)]) or (self::Path and //ExternalRefBaseObject[@uid = $uidRef and contains(' Path ',@typeRef)]) or (self::Vertex and //ExternalRefBaseObject[@uid = $uidRef and contains(' Vertex  VertexPoint ',@typeRef)]) or (self::Edge and //RepresentationItem[@uid = $uidRef and contains(' Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge ',substring-after(@xsi:type,':'))]) or (self::Path and //RepresentationItem[@uid = $uidRef and contains(' Path ',substring-after(@xsi:type,':'))]) or (self::Vertex and //RepresentationItem[@uid = $uidRef and contains(' Vertex  VertexPoint ',substring-after(@xsi:type,':'))])">(TopologyToGeometryModelAssociation : <sch:value-of select="$uid"/>) The TopologyToGeometryModelAssociation.Origin contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of TopologyAssociationItemSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) TopologyToGeometryModelAssociation.Target : LIST[1:unbounded] OF GeometryAssociationItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TopologyToGeometryModelAssociation') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='TopologyToGeometryModelAssociation'))]/Target/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::AxisPlacement and //ExternalRefBaseObject[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',@typeRef)]) or (self::CartesianPoint and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface ',@typeRef)]) or (self::Curve and //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)]) or (self::EdgeCurve and //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)]) or (self::ExternalRepresentationItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalRepresentationItem  ExternalTessellatedAnnotation ',@typeRef)]) or (self::VertexPoint and //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)]) or (self::AxisPlacement and //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))]) or (self::CartesianPoint and //RepresentationItem[@uid = $uidRef and contains(' CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface ',substring-after(@xsi:type,':'))]) or (self::Curve and //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))]) or (self::EdgeCurve and //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))]) or (self::ExternalRepresentationItem and //RepresentationItem[@uid = $uidRef and contains(' ExternalRepresentationItem  ExternalTessellatedAnnotation ',substring-after(@xsi:type,':'))]) or (self::VertexPoint and //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))])">(TopologyToGeometryModelAssociation : <sch:value-of select="$uid"/>) The TopologyToGeometryModelAssociation.Target contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometryAssociationItemSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RepresentationRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TopologyToGeometryModelAssociation') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='TopologyToGeometryModelAssociation'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(TopologyToGeometryModelAssociation : <sch:value-of select="$uid"/>) The TopologyToGeometryModelAssociation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) RepresentationRelationship.Related : Representation (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TopologyToGeometryModelAssociation') or (self::RepresentationRelationship and substring-after(@xsi:type,':')='TopologyToGeometryModelAssociation'))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Representation'] or //Representation[@uid = $uidRef]">(TopologyToGeometryModelAssociation : <sch:value-of select="$uid"/>) The TopologyToGeometryModelAssociation.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Representation.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TotalRunoutTolerance"><!--(Ref to E) TotalRunoutTolerance.DatumSystem : DatumSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TotalRunoutTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='TotalRunoutTolerance'))]/DatumSystem">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DatumSystem'] or //ShapeElement[@uid = $uidRef and contains(' DatumSystem  DatumSystemWithAssociatedModelCoordinateSystem ',substring-after(@xsi:type,':'))]">(TotalRunoutTolerance : <sch:value-of select="$uid"/>) The TotalRunoutTolerance.DatumSystem contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DatumSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) GeometricTolerance.AppliedTo : GeometricToleranceTargetSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TotalRunoutTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='TotalRunoutTolerance'))]/AppliedTo">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' CompositeShapeElement  CompositeGroupShapeElement  CompositeUnitShapeElement  ContinuousShapeElement  AllAroundShapeElement  AllAroundShapeElementAlongCollectionPlane  BetweenShapeElement ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' DerivedShapeElement  Apex  CentreOfSymmetry  Extension  GeometricAlignment  GeometricContact  GeometricIntersection  ParallelOffset  PerpendicularTo  Tangent ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalLocation  AngularLocation  CurvedDistance  LinearDistance ',substring-after(@xsi:type,':'))] or //GeometricDimension[@uid = $uidRef and contains(' DimensionalSize  AngularSize  CurvedSize  DiameterSize  EdgeOfUndefinedShapeSize  RadialSize  ThicknessSize ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //PartView[@uid = $uidRef]">(TotalRunoutTolerance : <sch:value-of select="$uid"/>) The TotalRunoutTolerance.AppliedTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of GeometricToleranceTargetSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TotalRunoutTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='TotalRunoutTolerance'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(TotalRunoutTolerance : <sch:value-of select="$uid"/>) The TotalRunoutTolerance.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) GeometricTolerance.GeometricToleranceContext : OPTIONAL PartView (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TotalRunoutTolerance') or (self::GeometricTolerance and substring-after(@xsi:type,':')='TotalRunoutTolerance'))]/GeometricToleranceContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./GeometricToleranceContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'PartView'] or //PartView[@uid = $uidRef]">(TotalRunoutTolerance : <sch:value-of select="$uid"/>) The TotalRunoutTolerance.GeometricToleranceContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type PartView.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="TotalRunoutTolerance_WR1"><!--(Rule TotalRunoutTolerance.WR1)--><sch:rule context="//GeometricTolerance[substring-after(@xsi:type,':')='TotalRunoutTolerance']/Angle"> <sch:let name="uid" value="../@uid"/> <sch:let name="unitRef" value="./Unit/@uidRef"/> <sch:assert test="//Unit[@uid=$unitRef]/Quantity/ClassString ='plane angle'">(TotalRunoutTolerance <sch:value-of select="$uid"/>) The unit of Angle shall be a plane angle measure unit. </sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="TransformedGeometricModel"><!--(Ref to S) TransformedGeometricModel.Items : SET[1:unbounded] OF AxisPlacementOrTransformationSelect (kind=AGGREGATE - redefined=Representation.Items)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TransformedGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='TransformedGeometricModel'))]/Items/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::AxisPlacement and //ExternalRefBaseObject[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',@typeRef)]) or (*[(self::CartesianTransformation or (self::Transformation and contains(' CartesianTransformation ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' CartesianTransformation ',@typeRef)]) or //RepresentationItem[@uid = $uidRef and contains(' AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame ',substring-after(@xsi:type,':'))] or //*[(self::CartesianTransformation or (self::Transformation and contains(' CartesianTransformation ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]">(TransformedGeometricModel : <sch:value-of select="$uid"/>) The TransformedGeometricModel.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of AxisPlacementOrTransformationSelect.</sch:assert>
      </sch:rule>
      <!--(Rule for inverse of GeometricRepresentationRelationship.Related :: ReferenceProperty) TransformedGeometricModel.DerivedFrom : GeometricRepresentationRelationship)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TransformedGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='TransformedGeometricModel'))]">
         <sch:let name="uid" value="./@uid"/>
         <sch:assert test="//RepresentationRelationship[contains(' GeometricRepresentationRelationship  GeneralGeometricRepresentationRelationship  GeometricRepresentationRelationshipWithCartesianTransformation  GeometricRepresentationRelationshipWithPlacementTransformation  GeometricRepresentationRelationshipWithSameCoordinateSpace ',substring-after(@xsi:type,':'))]/Related[@uidRef = $uid]">(TransformedGeometricModel : <sch:value-of select="$uid"/>) The TransformedGeometricModel.DerivedFrom inverse rule must be referenced by GeometricRepresentationRelationship.</sch:assert>
      </sch:rule>
      <!--(Inverse of GeometricCoordinateSpace.Representations :: PartProperty) GeometricRepresentation.ContextOfItems : GeometricCoordinateSpace) => no rule needed when PartProperty or Optional-->
      <!--(Ref to E) Representation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TransformedGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='TransformedGeometricModel'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(TransformedGeometricModel : <sch:value-of select="$uid"/>) The TransformedGeometricModel.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Representation.RepresentationTypes : OPTIONAL SET[1:unbounded] OF ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TransformedGeometricModel') or (self::Representation and substring-after(@xsi:type,':')='TransformedGeometricModel'))]/RepresentationTypes/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(TransformedGeometricModel : <sch:value-of select="$uid"/>) The TransformedGeometricModel.RepresentationTypes contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of RepresentationContext.Representations :: PartProperty) Representation.ContextOfItems : RepresentationContext) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="TrimmedCurve"/>
   <sch:pattern id="TwistedCrossSectionalGroupShapeElement"><!--(Ref to S) CrossSectionalGroupShapeElement.Items : SET[1:unbounded] OF CrossSectionalConstituentElementSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TwistedCrossSectionalGroupShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='TwistedCrossSectionalGroupShapeElement'))]/Items/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::CrossSectionalOccurrenceShapeElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' CrossSectionalOccurrenceShapeElement ',@typeRef)]) or (self::CrossSectionalPartShapeElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement ',@typeRef)]) or (self::CrossSectionalOccurrenceShapeElement and //ShapeElement[@uid = $uidRef and contains(' CrossSectionalOccurrenceShapeElement ',substring-after(@xsi:type,':'))]) or (self::CrossSectionalPartShapeElement and //ShapeElement[@uid = $uidRef and contains(' CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement ',substring-after(@xsi:type,':'))])">(TwistedCrossSectionalGroupShapeElement : <sch:value-of select="$uid"/>) The TwistedCrossSectionalGroupShapeElement.Items contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of CrossSectionalConstituentElementSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartShapeElement.PartDefinition : OPTIONAL PartShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TwistedCrossSectionalGroupShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='TwistedCrossSectionalGroupShapeElement'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(TwistedCrossSectionalGroupShapeElement : <sch:value-of select="$uid"/>) The TwistedCrossSectionalGroupShapeElement.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TwistedCrossSectionalGroupShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='TwistedCrossSectionalGroupShapeElement'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(TwistedCrossSectionalGroupShapeElement : <sch:value-of select="$uid"/>) The TwistedCrossSectionalGroupShapeElement.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='TwistedCrossSectionalGroupShapeElement') or (self::ShapeElement and substring-after(@xsi:type,':')='TwistedCrossSectionalGroupShapeElement'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(TwistedCrossSectionalGroupShapeElement : <sch:value-of select="$uid"/>) The TwistedCrossSectionalGroupShapeElement.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="UncertaintyQualifier"/>
   <sch:pattern id="Unit"><!--(Ref to S) Unit.Kind : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Unit') or (self::Unit and not(@xsi:type)))]/Kind/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Unit : <sch:value-of select="$uid"/>) The Unit.Kind contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Unit.Name : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Unit') or (self::Unit and not(@xsi:type)))]/Name/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Unit : <sch:value-of select="$uid"/>) The Unit.Name contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Unit.Prefix : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Unit') or (self::Unit and not(@xsi:type)))]/Prefix/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Unit : <sch:value-of select="$uid"/>) The Unit.Prefix contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Unit.Quantity : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Unit') or (self::Unit and not(@xsi:type)))]/Quantity/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(Unit : <sch:value-of select="$uid"/>) The Unit.Quantity contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="UserDefined11"/>
   <sch:pattern id="UserDefinedColour"/>
   <sch:pattern id="UserDefinedColour_WR3"><!--(Rule UserDefinedColour.WR3)--><sch:rule context="//Colour[ @uid and substring-after(@xsi:type,':')='UserDefinedColour']/Blue"> <sch:let name="uid" value="../@uid"/> <sch:let name="blue" value="."/> <sch:assert test="(xs:decimal($blue) ge 0.0) and (xs:decimal($blue) le 1.0)">(UserDefinedColour.WR3: <sch:value-of select="$uid"/>) the intensity of the blue component (<sch:value-of select="$blue"/>) shall be a real number between 0.0 and 1.0., inclusive.</sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="UserDefinedColour_WR1"><!--(Rule UserDefinedColour.WR1)--><sch:rule context="//Colour[ @uid and substring-after(@xsi:type,':')='UserDefinedColour']/Red"> <sch:let name="uid" value="../@uid"/> <sch:let name="red" value="."/> <sch:assert test="(xs:decimal($red) ge 0.0) and (xs:decimal($red) le 1.0)">(UserDefinedColour.WR1: <sch:value-of select="$uid"/>) the intensity of the red component (<sch:value-of select="$red"/>) shall be a real number between 0.0 and 1.0., inclusive.</sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="UserDefinedColour_WR2"><!--(Rule UserDefinedColour.WR2)--><sch:rule context="//Colour[ @uid and substring-after(@xsi:type,':')='UserDefinedColour']/Green"> <sch:let name="uid" value="../@uid"/> <sch:let name="green" value="."/> <sch:assert test="(xs:decimal($green) ge 0.0) and (xs:decimal($green) le 1.0)">(UserDefinedColour.WR2: <sch:value-of select="$uid"/>) the intensity of the green component (<sch:value-of select="$green"/>) shall be a real number between 0.0 and 1.0., inclusive.</sch:assert> </sch:rule></sch:pattern>
   <sch:pattern id="Validation"><!--(Ref to E) Validation.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Validation') or (self::Validation and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Validation : <sch:value-of select="$uid"/>) The Validation.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Validation.ValidatedBy : OPTIONAL SET[1:unbounded] OF Evidence (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Validation') or (self::Validation and not(@xsi:type)))]/ValidatedBy/Evidence">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ValidatedBy/Evidence) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Evidence'] or //Evidence[@uid = $uidRef]">(Validation : <sch:value-of select="$uid"/>) The Validation.ValidatedBy contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Evidence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Validation.Validates : ValidationSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Validation') or (self::Validation and not(@xsi:type)))]/Validates">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' StateDefinition ',@typeRef)] or //ActivityMethod[@uid = $uidRef] or //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //StateDefinition[@uid = $uidRef]">(Validation : <sch:value-of select="$uid"/>) The Validation.Validates contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValidationSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ValueFormatTypeQualifier"><!--(Ref to S) ValueFormatTypeQualifier.ValueFormatType : ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueFormatTypeQualifier') or (self::ValueFormatTypeQualifier and not(@xsi:type)))]/ValueFormatType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(ValueFormatTypeQualifier : <sch:value-of select="$uid"/>) The ValueFormatTypeQualifier.ValueFormatType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ValueLimit"><!--(Ref to S) ValueLimit.Qualifier : TypeQualifierSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueLimit') or (self::PropertyValue and substring-after(@xsi:type,':')='ValueLimit'))]/Qualifier">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalTypeQualifier ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PreDefinedTypeQualifier ',@typeRef)] or //ExternalTypeQualifier[@uid = $uidRef] or //PreDefinedTypeQualifier[@uid = $uidRef]">(ValueLimit : <sch:value-of select="$uid"/>) The ValueLimit.Qualifier contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of TypeQualifierSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) NumericalValue.ValueContext : OPTIONAL NumericalContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueLimit') or (self::ValueLimit or (self::BevelAngle and substring-after(@xsi:type,':')='ValueLimit') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueLimit') or (self::Weight and substring-after(@xsi:type,':')='ValueLimit') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueLimit') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueLimit') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueLimit') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueLimit') or (self::UnitLength and substring-after(@xsi:type,':')='ValueLimit') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueLimit') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueLimit') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueLimit') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueLimit') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::Diameter and substring-after(@xsi:type,':')='ValueLimit') or (self::Diameter and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetLength and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetLength and substring-after(@xsi:type,':')='ValueLimit') or (self::Thickness and substring-after(@xsi:type,':')='ValueLimit')))]/ValueContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./ValueContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'NumericalContext'] or //NumericalContext[@uid = $uidRef]">(ValueLimit : <sch:value-of select="$uid"/>) The ValueLimit.ValueContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type NumericalContext.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ValueWithUnit.Unit : UnitSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueLimit') or (self::ValueLimit or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueLimit') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::Weight and substring-after(@xsi:type,':')='ValueLimit') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueLimit') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueLimit') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueLimit') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueLimit') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueLimit') or (self::Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::IndexValue and substring-after(@xsi:type,':')='ValueLimit') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueLimit') or (self::UnitLength and substring-after(@xsi:type,':')='ValueLimit') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueLimit') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueLimit') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueLimit') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueLimit') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueLimit') or (self::LotSize and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueLimit') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueLimit') or (self::Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Density and substring-after(@xsi:type,':')='ValueLimit') or (self::Height and substring-after(@xsi:type,':')='ValueLimit') or (self::Width and substring-after(@xsi:type,':')='ValueLimit') or (self::FileSize and substring-after(@xsi:type,':')='ValueLimit') or (self::PageCount and substring-after(@xsi:type,':')='ValueLimit') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::Diameter and substring-after(@xsi:type,':')='ValueLimit') or (self::Diameter and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetLength and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetLength and substring-after(@xsi:type,':')='ValueLimit') or (self::Thickness and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueLimit')))]/Unit">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)] or //ExternalUnit[@uid = $uidRef] or //Unit[@uid = $uidRef]">(ValueLimit : <sch:value-of select="$uid"/>) The ValueLimit.Unit contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyValue.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueLimit') or (self::ValueLimit or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueLimit') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::Weight and substring-after(@xsi:type,':')='ValueLimit') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueLimit') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueLimit') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueLimit') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueLimit') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueLimit') or (self::Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueLimit') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueLimit') or (self::IndexValue and substring-after(@xsi:type,':')='ValueLimit') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueLimit') or (self::UnitLength and substring-after(@xsi:type,':')='ValueLimit') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueLimit') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueLimit') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueLimit') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueLimit') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueLimit') or (self::LotSize and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueLimit') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueLimit') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueLimit') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueLimit') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueLimit') or (self::Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Density and substring-after(@xsi:type,':')='ValueLimit') or (self::Height and substring-after(@xsi:type,':')='ValueLimit') or (self::Width and substring-after(@xsi:type,':')='ValueLimit') or (self::FileSize and substring-after(@xsi:type,':')='ValueLimit') or (self::PageCount and substring-after(@xsi:type,':')='ValueLimit') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::Diameter and substring-after(@xsi:type,':')='ValueLimit') or (self::Diameter and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetLength and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetLength and substring-after(@xsi:type,':')='ValueLimit') or (self::Thickness and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueLimit')))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ValueLimit : <sch:value-of select="$uid"/>) The ValueLimit.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.Definition : OPTIONAL PropertyDefinitionSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueLimit') or (self::ValueLimit or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueLimit') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::Weight and substring-after(@xsi:type,':')='ValueLimit') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueLimit') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueLimit') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueLimit') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueLimit') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueLimit') or (self::Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueLimit') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueLimit') or (self::IndexValue and substring-after(@xsi:type,':')='ValueLimit') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueLimit') or (self::UnitLength and substring-after(@xsi:type,':')='ValueLimit') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueLimit') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueLimit') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueLimit') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueLimit') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueLimit') or (self::LotSize and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueLimit') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueLimit') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueLimit') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueLimit') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueLimit') or (self::Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Density and substring-after(@xsi:type,':')='ValueLimit') or (self::Height and substring-after(@xsi:type,':')='ValueLimit') or (self::Width and substring-after(@xsi:type,':')='ValueLimit') or (self::FileSize and substring-after(@xsi:type,':')='ValueLimit') or (self::PageCount and substring-after(@xsi:type,':')='ValueLimit') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::Diameter and substring-after(@xsi:type,':')='ValueLimit') or (self::Diameter and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetLength and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetLength and substring-after(@xsi:type,':')='ValueLimit') or (self::Thickness and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueLimit')))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionEnum) or (self::PropertyDefinitionString)">(ValueLimit : <sch:value-of select="$uid"/>) The ValueLimit.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PropertyDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.DeterminationMethod : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueLimit') or (self::ValueLimit or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueLimit') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::Weight and substring-after(@xsi:type,':')='ValueLimit') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueLimit') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueLimit') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueLimit') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueLimit') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueLimit') or (self::Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueLimit') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueLimit') or (self::IndexValue and substring-after(@xsi:type,':')='ValueLimit') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueLimit') or (self::UnitLength and substring-after(@xsi:type,':')='ValueLimit') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueLimit') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueLimit') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueLimit') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueLimit') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueLimit') or (self::LotSize and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueLimit') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueLimit') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueLimit') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueLimit') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueLimit') or (self::Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Density and substring-after(@xsi:type,':')='ValueLimit') or (self::Height and substring-after(@xsi:type,':')='ValueLimit') or (self::Width and substring-after(@xsi:type,':')='ValueLimit') or (self::FileSize and substring-after(@xsi:type,':')='ValueLimit') or (self::PageCount and substring-after(@xsi:type,':')='ValueLimit') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::Diameter and substring-after(@xsi:type,':')='ValueLimit') or (self::Diameter and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetLength and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetLength and substring-after(@xsi:type,':')='ValueLimit') or (self::Thickness and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueLimit')))]/DeterminationMethod/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ValueLimit : <sch:value-of select="$uid"/>) The ValueLimit.DeterminationMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.Qualifiers : OPTIONAL SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueLimit') or (self::ValueLimit or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueLimit') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::Weight and substring-after(@xsi:type,':')='ValueLimit') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueLimit') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueLimit') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueLimit') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueLimit') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueLimit') or (self::Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueLimit') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueLimit') or (self::IndexValue and substring-after(@xsi:type,':')='ValueLimit') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueLimit') or (self::UnitLength and substring-after(@xsi:type,':')='ValueLimit') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueLimit') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueLimit') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueLimit') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueLimit') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueLimit') or (self::LotSize and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueLimit') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueLimit') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueLimit') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueLimit') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueLimit') or (self::Offset and substring-after(@xsi:type,':')='ValueLimit') or (self::Quantity and substring-after(@xsi:type,':')='ValueLimit') or (self::Density and substring-after(@xsi:type,':')='ValueLimit') or (self::Height and substring-after(@xsi:type,':')='ValueLimit') or (self::Width and substring-after(@xsi:type,':')='ValueLimit') or (self::FileSize and substring-after(@xsi:type,':')='ValueLimit') or (self::PageCount and substring-after(@xsi:type,':')='ValueLimit') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueLimit') or (self::Diameter and substring-after(@xsi:type,':')='ValueLimit') or (self::Diameter and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetLength and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueLimit') or (self::TargetLength and substring-after(@xsi:type,':')='ValueLimit') or (self::Thickness and substring-after(@xsi:type,':')='ValueLimit') or (self::Angle and substring-after(@xsi:type,':')='ValueLimit') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueLimit')))]/Qualifiers/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::ExternalTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalTypeQualifier ',@typeRef)]) or (self::PreDefinedTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PreDefinedTypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::ExternalTypeQualifier and //ExternalTypeQualifier[@uid = $uidRef]) or (self::PreDefinedTypeQualifier and //PreDefinedTypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(ValueLimit : <sch:value-of select="$uid"/>) The ValueLimit.Qualifiers contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ValueList"><!--(Ref to E) PropertyValue.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueList') or (self::ValueList or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueList') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::Weight and substring-after(@xsi:type,':')='ValueList') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueList') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueList') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueList') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueList') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueList') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueList') or (self::Offset and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueList') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueList') or (self::IndexValue and substring-after(@xsi:type,':')='ValueList') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueList') or (self::UnitLength and substring-after(@xsi:type,':')='ValueList') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueList') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueList') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueList') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueList') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueList') or (self::LotSize and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueList') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueList') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueList') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueList') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueList') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueList') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueList') or (self::Offset and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::Density and substring-after(@xsi:type,':')='ValueList') or (self::Height and substring-after(@xsi:type,':')='ValueList') or (self::Width and substring-after(@xsi:type,':')='ValueList') or (self::FileSize and substring-after(@xsi:type,':')='ValueList') or (self::PageCount and substring-after(@xsi:type,':')='ValueList') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueList') or (self::Diameter and substring-after(@xsi:type,':')='ValueList') or (self::Diameter and substring-after(@xsi:type,':')='ValueList') or (self::TargetLength and substring-after(@xsi:type,':')='ValueList') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueList') or (self::TargetLength and substring-after(@xsi:type,':')='ValueList') or (self::Thickness and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueList')))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ValueList : <sch:value-of select="$uid"/>) The ValueList.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.Definition : OPTIONAL PropertyDefinitionSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueList') or (self::ValueList or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueList') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::Weight and substring-after(@xsi:type,':')='ValueList') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueList') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueList') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueList') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueList') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueList') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueList') or (self::Offset and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueList') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueList') or (self::IndexValue and substring-after(@xsi:type,':')='ValueList') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueList') or (self::UnitLength and substring-after(@xsi:type,':')='ValueList') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueList') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueList') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueList') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueList') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueList') or (self::LotSize and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueList') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueList') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueList') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueList') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueList') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueList') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueList') or (self::Offset and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::Density and substring-after(@xsi:type,':')='ValueList') or (self::Height and substring-after(@xsi:type,':')='ValueList') or (self::Width and substring-after(@xsi:type,':')='ValueList') or (self::FileSize and substring-after(@xsi:type,':')='ValueList') or (self::PageCount and substring-after(@xsi:type,':')='ValueList') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueList') or (self::Diameter and substring-after(@xsi:type,':')='ValueList') or (self::Diameter and substring-after(@xsi:type,':')='ValueList') or (self::TargetLength and substring-after(@xsi:type,':')='ValueList') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueList') or (self::TargetLength and substring-after(@xsi:type,':')='ValueList') or (self::Thickness and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueList')))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionEnum) or (self::PropertyDefinitionString)">(ValueList : <sch:value-of select="$uid"/>) The ValueList.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PropertyDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.DeterminationMethod : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueList') or (self::ValueList or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueList') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::Weight and substring-after(@xsi:type,':')='ValueList') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueList') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueList') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueList') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueList') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueList') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueList') or (self::Offset and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueList') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueList') or (self::IndexValue and substring-after(@xsi:type,':')='ValueList') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueList') or (self::UnitLength and substring-after(@xsi:type,':')='ValueList') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueList') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueList') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueList') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueList') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueList') or (self::LotSize and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueList') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueList') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueList') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueList') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueList') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueList') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueList') or (self::Offset and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::Density and substring-after(@xsi:type,':')='ValueList') or (self::Height and substring-after(@xsi:type,':')='ValueList') or (self::Width and substring-after(@xsi:type,':')='ValueList') or (self::FileSize and substring-after(@xsi:type,':')='ValueList') or (self::PageCount and substring-after(@xsi:type,':')='ValueList') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueList') or (self::Diameter and substring-after(@xsi:type,':')='ValueList') or (self::Diameter and substring-after(@xsi:type,':')='ValueList') or (self::TargetLength and substring-after(@xsi:type,':')='ValueList') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueList') or (self::TargetLength and substring-after(@xsi:type,':')='ValueList') or (self::Thickness and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueList')))]/DeterminationMethod/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ValueList : <sch:value-of select="$uid"/>) The ValueList.DeterminationMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.Qualifiers : OPTIONAL SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueList') or (self::ValueList or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueList') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::Weight and substring-after(@xsi:type,':')='ValueList') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueList') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueList') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueList') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueList') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueList') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueList') or (self::Offset and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueList') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueList') or (self::IndexValue and substring-after(@xsi:type,':')='ValueList') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueList') or (self::UnitLength and substring-after(@xsi:type,':')='ValueList') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueList') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueList') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueList') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueList') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueList') or (self::LotSize and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueList') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueList') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueList') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueList') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueList') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueList') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueList') or (self::Offset and substring-after(@xsi:type,':')='ValueList') or (self::Quantity and substring-after(@xsi:type,':')='ValueList') or (self::Density and substring-after(@xsi:type,':')='ValueList') or (self::Height and substring-after(@xsi:type,':')='ValueList') or (self::Width and substring-after(@xsi:type,':')='ValueList') or (self::FileSize and substring-after(@xsi:type,':')='ValueList') or (self::PageCount and substring-after(@xsi:type,':')='ValueList') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueList') or (self::Diameter and substring-after(@xsi:type,':')='ValueList') or (self::Diameter and substring-after(@xsi:type,':')='ValueList') or (self::TargetLength and substring-after(@xsi:type,':')='ValueList') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueList') or (self::TargetLength and substring-after(@xsi:type,':')='ValueList') or (self::Thickness and substring-after(@xsi:type,':')='ValueList') or (self::Angle and substring-after(@xsi:type,':')='ValueList') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueList')))]/Qualifiers/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::ExternalTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalTypeQualifier ',@typeRef)]) or (self::PreDefinedTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PreDefinedTypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::ExternalTypeQualifier and //ExternalTypeQualifier[@uid = $uidRef]) or (self::PreDefinedTypeQualifier and //PreDefinedTypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(ValueList : <sch:value-of select="$uid"/>) The ValueList.Qualifiers contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ValueRange"><!--(Ref to S) ValueWithUnit.Unit : UnitSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueRange') or (self::ValueRange or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueRange') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::Weight and substring-after(@xsi:type,':')='ValueRange') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueRange') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueRange') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueRange') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueRange') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueRange') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueRange') or (self::Offset and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::IndexValue and substring-after(@xsi:type,':')='ValueRange') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueRange') or (self::UnitLength and substring-after(@xsi:type,':')='ValueRange') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueRange') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueRange') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueRange') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueRange') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueRange') or (self::LotSize and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueRange') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueRange') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueRange') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueRange') or (self::Offset and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Density and substring-after(@xsi:type,':')='ValueRange') or (self::Height and substring-after(@xsi:type,':')='ValueRange') or (self::Width and substring-after(@xsi:type,':')='ValueRange') or (self::FileSize and substring-after(@xsi:type,':')='ValueRange') or (self::PageCount and substring-after(@xsi:type,':')='ValueRange') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueRange') or (self::Diameter and substring-after(@xsi:type,':')='ValueRange') or (self::Diameter and substring-after(@xsi:type,':')='ValueRange') or (self::TargetLength and substring-after(@xsi:type,':')='ValueRange') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueRange') or (self::TargetLength and substring-after(@xsi:type,':')='ValueRange') or (self::Thickness and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueRange')))]/Unit">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)] or //ExternalUnit[@uid = $uidRef] or //Unit[@uid = $uidRef]">(ValueRange : <sch:value-of select="$uid"/>) The ValueRange.Unit contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyValue.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueRange') or (self::ValueRange or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueRange') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::Weight and substring-after(@xsi:type,':')='ValueRange') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueRange') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueRange') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueRange') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueRange') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueRange') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueRange') or (self::Offset and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueRange') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueRange') or (self::IndexValue and substring-after(@xsi:type,':')='ValueRange') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueRange') or (self::UnitLength and substring-after(@xsi:type,':')='ValueRange') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueRange') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueRange') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueRange') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueRange') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueRange') or (self::LotSize and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueRange') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueRange') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueRange') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueRange') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueRange') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueRange') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueRange') or (self::Offset and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Density and substring-after(@xsi:type,':')='ValueRange') or (self::Height and substring-after(@xsi:type,':')='ValueRange') or (self::Width and substring-after(@xsi:type,':')='ValueRange') or (self::FileSize and substring-after(@xsi:type,':')='ValueRange') or (self::PageCount and substring-after(@xsi:type,':')='ValueRange') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueRange') or (self::Diameter and substring-after(@xsi:type,':')='ValueRange') or (self::Diameter and substring-after(@xsi:type,':')='ValueRange') or (self::TargetLength and substring-after(@xsi:type,':')='ValueRange') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueRange') or (self::TargetLength and substring-after(@xsi:type,':')='ValueRange') or (self::Thickness and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueRange')))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ValueRange : <sch:value-of select="$uid"/>) The ValueRange.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.Definition : OPTIONAL PropertyDefinitionSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueRange') or (self::ValueRange or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueRange') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::Weight and substring-after(@xsi:type,':')='ValueRange') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueRange') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueRange') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueRange') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueRange') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueRange') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueRange') or (self::Offset and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueRange') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueRange') or (self::IndexValue and substring-after(@xsi:type,':')='ValueRange') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueRange') or (self::UnitLength and substring-after(@xsi:type,':')='ValueRange') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueRange') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueRange') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueRange') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueRange') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueRange') or (self::LotSize and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueRange') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueRange') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueRange') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueRange') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueRange') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueRange') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueRange') or (self::Offset and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Density and substring-after(@xsi:type,':')='ValueRange') or (self::Height and substring-after(@xsi:type,':')='ValueRange') or (self::Width and substring-after(@xsi:type,':')='ValueRange') or (self::FileSize and substring-after(@xsi:type,':')='ValueRange') or (self::PageCount and substring-after(@xsi:type,':')='ValueRange') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueRange') or (self::Diameter and substring-after(@xsi:type,':')='ValueRange') or (self::Diameter and substring-after(@xsi:type,':')='ValueRange') or (self::TargetLength and substring-after(@xsi:type,':')='ValueRange') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueRange') or (self::TargetLength and substring-after(@xsi:type,':')='ValueRange') or (self::Thickness and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueRange')))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionEnum) or (self::PropertyDefinitionString)">(ValueRange : <sch:value-of select="$uid"/>) The ValueRange.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PropertyDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.DeterminationMethod : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueRange') or (self::ValueRange or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueRange') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::Weight and substring-after(@xsi:type,':')='ValueRange') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueRange') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueRange') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueRange') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueRange') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueRange') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueRange') or (self::Offset and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueRange') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueRange') or (self::IndexValue and substring-after(@xsi:type,':')='ValueRange') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueRange') or (self::UnitLength and substring-after(@xsi:type,':')='ValueRange') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueRange') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueRange') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueRange') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueRange') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueRange') or (self::LotSize and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueRange') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueRange') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueRange') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueRange') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueRange') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueRange') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueRange') or (self::Offset and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Density and substring-after(@xsi:type,':')='ValueRange') or (self::Height and substring-after(@xsi:type,':')='ValueRange') or (self::Width and substring-after(@xsi:type,':')='ValueRange') or (self::FileSize and substring-after(@xsi:type,':')='ValueRange') or (self::PageCount and substring-after(@xsi:type,':')='ValueRange') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueRange') or (self::Diameter and substring-after(@xsi:type,':')='ValueRange') or (self::Diameter and substring-after(@xsi:type,':')='ValueRange') or (self::TargetLength and substring-after(@xsi:type,':')='ValueRange') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueRange') or (self::TargetLength and substring-after(@xsi:type,':')='ValueRange') or (self::Thickness and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueRange')))]/DeterminationMethod/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ValueRange : <sch:value-of select="$uid"/>) The ValueRange.DeterminationMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.Qualifiers : OPTIONAL SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueRange') or (self::ValueRange or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueRange') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::Weight and substring-after(@xsi:type,':')='ValueRange') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueRange') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueRange') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueRange') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueRange') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueRange') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueRange') or (self::Offset and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueRange') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueRange') or (self::IndexValue and substring-after(@xsi:type,':')='ValueRange') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueRange') or (self::UnitLength and substring-after(@xsi:type,':')='ValueRange') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueRange') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueRange') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueRange') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueRange') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueRange') or (self::LotSize and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueRange') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueRange') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueRange') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueRange') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueRange') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueRange') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueRange') or (self::Offset and substring-after(@xsi:type,':')='ValueRange') or (self::Quantity and substring-after(@xsi:type,':')='ValueRange') or (self::Density and substring-after(@xsi:type,':')='ValueRange') or (self::Height and substring-after(@xsi:type,':')='ValueRange') or (self::Width and substring-after(@xsi:type,':')='ValueRange') or (self::FileSize and substring-after(@xsi:type,':')='ValueRange') or (self::PageCount and substring-after(@xsi:type,':')='ValueRange') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueRange') or (self::Diameter and substring-after(@xsi:type,':')='ValueRange') or (self::Diameter and substring-after(@xsi:type,':')='ValueRange') or (self::TargetLength and substring-after(@xsi:type,':')='ValueRange') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueRange') or (self::TargetLength and substring-after(@xsi:type,':')='ValueRange') or (self::Thickness and substring-after(@xsi:type,':')='ValueRange') or (self::Angle and substring-after(@xsi:type,':')='ValueRange') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueRange')))]/Qualifiers/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::ExternalTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalTypeQualifier ',@typeRef)]) or (self::PreDefinedTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PreDefinedTypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::ExternalTypeQualifier and //ExternalTypeQualifier[@uid = $uidRef]) or (self::PreDefinedTypeQualifier and //PreDefinedTypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(ValueRange : <sch:value-of select="$uid"/>) The ValueRange.Qualifiers contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ValueSet"><!--(Ref to E) PropertyValue.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueSet') or (self::ValueSet or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueSet') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::Weight and substring-after(@xsi:type,':')='ValueSet') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueSet') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueSet') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueSet') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueSet') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueSet') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueSet') or (self::Offset and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueSet') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueSet') or (self::IndexValue and substring-after(@xsi:type,':')='ValueSet') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueSet') or (self::UnitLength and substring-after(@xsi:type,':')='ValueSet') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueSet') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueSet') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueSet') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueSet') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueSet') or (self::LotSize and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueSet') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueSet') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueSet') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueSet') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueSet') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueSet') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueSet') or (self::Offset and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::Density and substring-after(@xsi:type,':')='ValueSet') or (self::Height and substring-after(@xsi:type,':')='ValueSet') or (self::Width and substring-after(@xsi:type,':')='ValueSet') or (self::FileSize and substring-after(@xsi:type,':')='ValueSet') or (self::PageCount and substring-after(@xsi:type,':')='ValueSet') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueSet') or (self::Diameter and substring-after(@xsi:type,':')='ValueSet') or (self::Diameter and substring-after(@xsi:type,':')='ValueSet') or (self::TargetLength and substring-after(@xsi:type,':')='ValueSet') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueSet') or (self::TargetLength and substring-after(@xsi:type,':')='ValueSet') or (self::Thickness and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueSet')))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ValueSet : <sch:value-of select="$uid"/>) The ValueSet.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.Definition : OPTIONAL PropertyDefinitionSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueSet') or (self::ValueSet or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueSet') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::Weight and substring-after(@xsi:type,':')='ValueSet') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueSet') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueSet') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueSet') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueSet') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueSet') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueSet') or (self::Offset and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueSet') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueSet') or (self::IndexValue and substring-after(@xsi:type,':')='ValueSet') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueSet') or (self::UnitLength and substring-after(@xsi:type,':')='ValueSet') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueSet') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueSet') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueSet') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueSet') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueSet') or (self::LotSize and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueSet') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueSet') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueSet') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueSet') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueSet') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueSet') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueSet') or (self::Offset and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::Density and substring-after(@xsi:type,':')='ValueSet') or (self::Height and substring-after(@xsi:type,':')='ValueSet') or (self::Width and substring-after(@xsi:type,':')='ValueSet') or (self::FileSize and substring-after(@xsi:type,':')='ValueSet') or (self::PageCount and substring-after(@xsi:type,':')='ValueSet') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueSet') or (self::Diameter and substring-after(@xsi:type,':')='ValueSet') or (self::Diameter and substring-after(@xsi:type,':')='ValueSet') or (self::TargetLength and substring-after(@xsi:type,':')='ValueSet') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueSet') or (self::TargetLength and substring-after(@xsi:type,':')='ValueSet') or (self::Thickness and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueSet')))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionEnum) or (self::PropertyDefinitionString)">(ValueSet : <sch:value-of select="$uid"/>) The ValueSet.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PropertyDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.DeterminationMethod : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueSet') or (self::ValueSet or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueSet') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::Weight and substring-after(@xsi:type,':')='ValueSet') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueSet') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueSet') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueSet') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueSet') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueSet') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueSet') or (self::Offset and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueSet') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueSet') or (self::IndexValue and substring-after(@xsi:type,':')='ValueSet') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueSet') or (self::UnitLength and substring-after(@xsi:type,':')='ValueSet') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueSet') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueSet') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueSet') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueSet') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueSet') or (self::LotSize and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueSet') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueSet') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueSet') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueSet') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueSet') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueSet') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueSet') or (self::Offset and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::Density and substring-after(@xsi:type,':')='ValueSet') or (self::Height and substring-after(@xsi:type,':')='ValueSet') or (self::Width and substring-after(@xsi:type,':')='ValueSet') or (self::FileSize and substring-after(@xsi:type,':')='ValueSet') or (self::PageCount and substring-after(@xsi:type,':')='ValueSet') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueSet') or (self::Diameter and substring-after(@xsi:type,':')='ValueSet') or (self::Diameter and substring-after(@xsi:type,':')='ValueSet') or (self::TargetLength and substring-after(@xsi:type,':')='ValueSet') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueSet') or (self::TargetLength and substring-after(@xsi:type,':')='ValueSet') or (self::Thickness and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueSet')))]/DeterminationMethod/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ValueSet : <sch:value-of select="$uid"/>) The ValueSet.DeterminationMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.Qualifiers : OPTIONAL SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueSet') or (self::ValueSet or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueSet') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::Weight and substring-after(@xsi:type,':')='ValueSet') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueSet') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueSet') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueSet') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueSet') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueSet') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueSet') or (self::Offset and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueSet') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueSet') or (self::IndexValue and substring-after(@xsi:type,':')='ValueSet') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueSet') or (self::UnitLength and substring-after(@xsi:type,':')='ValueSet') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueSet') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueSet') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueSet') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueSet') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueSet') or (self::LotSize and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueSet') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueSet') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueSet') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueSet') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueSet') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueSet') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueSet') or (self::Offset and substring-after(@xsi:type,':')='ValueSet') or (self::Quantity and substring-after(@xsi:type,':')='ValueSet') or (self::Density and substring-after(@xsi:type,':')='ValueSet') or (self::Height and substring-after(@xsi:type,':')='ValueSet') or (self::Width and substring-after(@xsi:type,':')='ValueSet') or (self::FileSize and substring-after(@xsi:type,':')='ValueSet') or (self::PageCount and substring-after(@xsi:type,':')='ValueSet') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueSet') or (self::Diameter and substring-after(@xsi:type,':')='ValueSet') or (self::Diameter and substring-after(@xsi:type,':')='ValueSet') or (self::TargetLength and substring-after(@xsi:type,':')='ValueSet') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueSet') or (self::TargetLength and substring-after(@xsi:type,':')='ValueSet') or (self::Thickness and substring-after(@xsi:type,':')='ValueSet') or (self::Angle and substring-after(@xsi:type,':')='ValueSet') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueSet')))]/Qualifiers/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::ExternalTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalTypeQualifier ',@typeRef)]) or (self::PreDefinedTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PreDefinedTypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::ExternalTypeQualifier and //ExternalTypeQualifier[@uid = $uidRef]) or (self::PreDefinedTypeQualifier and //PreDefinedTypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(ValueSet : <sch:value-of select="$uid"/>) The ValueSet.Qualifiers contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ValueWithTolerances"><!--(Ref to S) ValueWithUnit.Unit : UnitSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ValueWithTolerances or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Weight and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::IndexValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::UnitLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::LotSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Density and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Height and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Width and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::FileSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::PageCount and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Diameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Diameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TargetLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TargetLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Thickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueWithTolerances')))]/Unit">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)] or //ExternalUnit[@uid = $uidRef] or //Unit[@uid = $uidRef]">(ValueWithTolerances : <sch:value-of select="$uid"/>) The ValueWithTolerances.Unit contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyValue.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ValueWithTolerances or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Weight and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::IndexValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::UnitLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::LotSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Density and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Height and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Width and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::FileSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::PageCount and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Diameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Diameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TargetLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TargetLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Thickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueWithTolerances')))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ValueWithTolerances : <sch:value-of select="$uid"/>) The ValueWithTolerances.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.Definition : OPTIONAL PropertyDefinitionSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ValueWithTolerances or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Weight and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::IndexValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::UnitLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::LotSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Density and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Height and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Width and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::FileSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::PageCount and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Diameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Diameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TargetLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TargetLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Thickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueWithTolerances')))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PropertyDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinition  MaterialPropertyDefinition  WireColourBasedIdentificationCode ',@typeRef)]) or (self::PropertyDefinition and //PropertyDefinition[@uid = $uidRef]) or (self::PropertyDefinitionEnum) or (self::PropertyDefinitionString)">(ValueWithTolerances : <sch:value-of select="$uid"/>) The ValueWithTolerances.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PropertyDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.DeterminationMethod : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ValueWithTolerances or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Weight and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::IndexValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::UnitLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::LotSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Density and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Height and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Width and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::FileSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::PageCount and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Diameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Diameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TargetLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TargetLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Thickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueWithTolerances')))]/DeterminationMethod/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ValueWithTolerances : <sch:value-of select="$uid"/>) The ValueWithTolerances.DeterminationMethod contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyValue.Qualifiers : OPTIONAL SET[1:unbounded] OF ValueQualifierSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ValueWithTolerances or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::BevelAngle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::VerticalProfileHeight and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Weight and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::RealWorldScale and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MaxCrossSectionDiameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MinCrossSectionDiameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MinimumBendRadius and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Fiber11Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ModifierValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::RequiredCharacteristic and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::AnalysedCharacteristic and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::IndexValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::DimensionValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::UnitLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::FirstUnitSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::SecondUnitSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::UnequallyDisposedToleranceZoneDisplacement and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ToleranceValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ForcedLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::LotSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MaterialValue and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::MeasuredCharacteristics and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::VolumePercent and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::PlannedCharacteristics and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::PlyThickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::WaitingTime and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::ProjectionLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Offset and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Quantity and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Density and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Height and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Width and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::FileSize and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::PageCount and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TotalThickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Diameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Diameter and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TargetLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TargetWidth and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TargetLength and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Thickness and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::Angle and substring-after(@xsi:type,':')='ValueWithTolerances') or (self::TwistPeriod and substring-after(@xsi:type,':')='ValueWithTolerances')))]/Qualifiers/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::PrecisionQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PrecisionQualifier ',@typeRef)]) or (self::ExternalTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalTypeQualifier ',@typeRef)]) or (self::PreDefinedTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' PreDefinedTypeQualifier ',@typeRef)]) or (self::UncertaintyQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' UncertaintyQualifier  QualitativeUncertainty  StandardUncertainty  ExpandedUncertainty ',@typeRef)]) or (self::ValueFormatTypeQualifier and //ExternalRefBaseObject[@uid = $uidRef and contains(' ValueFormatTypeQualifier ',@typeRef)]) or (self::PrecisionQualifier and //PrecisionQualifier[@uid = $uidRef]) or (self::ExternalTypeQualifier and //ExternalTypeQualifier[@uid = $uidRef]) or (self::PreDefinedTypeQualifier and //PreDefinedTypeQualifier[@uid = $uidRef]) or (self::UncertaintyQualifier and //UncertaintyQualifier[@uid = $uidRef]) or (self::ValueFormatTypeQualifier and //ValueFormatTypeQualifier[@uid = $uidRef])">(ValueWithTolerances : <sch:value-of select="$uid"/>) The ValueWithTolerances.Qualifiers contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ValueQualifierSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Verification"><!--(Ref to E) Verification.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Verification') or (self::Verification and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(Verification : <sch:value-of select="$uid"/>) The Verification.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Verification.VerifiedBy : OPTIONAL SET[1:unbounded] OF Evidence (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Verification') or (self::Verification and not(@xsi:type)))]/VerifiedBy/Evidence">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../VerifiedBy/Evidence) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Evidence'] or //Evidence[@uid = $uidRef]">(Verification : <sch:value-of select="$uid"/>) The Verification.VerifiedBy contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Evidence.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Verification.Verifies : RequirementSatisfactionAssertion (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='Verification') or (self::Verification and not(@xsi:type)))]/Verifies">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'RequirementSatisfactionAssertion'] or //RequirementSatisfactionAssertion[@uid = $uidRef]">(Verification : <sch:value-of select="$uid"/>) The Verification.Verifies contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type RequirementSatisfactionAssertion.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="VerificationRelationship"><!--(Ref to E) VerificationRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='VerificationRelationship') or (self::VerificationRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(VerificationRelationship : <sch:value-of select="$uid"/>) The VerificationRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) VerificationRelationship.Related : Verification (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='VerificationRelationship') or (self::VerificationRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Verification'] or //Verification[@uid = $uidRef]">(VerificationRelationship : <sch:value-of select="$uid"/>) The VerificationRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Verification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) VerificationRelationship.RelationType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='VerificationRelationship') or (self::VerificationRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(VerificationRelationship : <sch:value-of select="$uid"/>) The VerificationRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="VersionBranchEffectivity"><!--(Ref to S) VersionBranchEffectivity.EndVersion : OPTIONAL VersionedObjectSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='VersionBranchEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='VersionBranchEffectivity'))]/EndVersion">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlan ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)] or //AlternativeSolution[@uid = $uidRef] or //BreakdownElementVersion[@uid = $uidRef] or //BreakdownVersion[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //ProcessOperationDefinition[@uid = $uidRef] or //ProcessPlan[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //RequirementVersion[@uid = $uidRef]">(VersionBranchEffectivity : <sch:value-of select="$uid"/>) The VersionBranchEffectivity.EndVersion contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of VersionedObjectSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) VersionBranchEffectivity.StartVersion : VersionedObjectSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='VersionBranchEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='VersionBranchEffectivity'))]/StartVersion">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlan ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)] or //AlternativeSolution[@uid = $uidRef] or //BreakdownElementVersion[@uid = $uidRef] or //BreakdownVersion[@uid = $uidRef] or //IndividualPartVersion[@uid = $uidRef] or //PartVersion[@uid = $uidRef] or //ProcessOperationDefinition[@uid = $uidRef] or //ProcessPlan[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //RequirementVersion[@uid = $uidRef]">(VersionBranchEffectivity : <sch:value-of select="$uid"/>) The VersionBranchEffectivity.StartVersion contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of VersionedObjectSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='VersionBranchEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='VersionBranchEffectivity'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(VersionBranchEffectivity : <sch:value-of select="$uid"/>) The VersionBranchEffectivity.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Effectivity.ConcernedOrganizations : OPTIONAL SET[1:unbounded] OF Organization (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='VersionBranchEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='VersionBranchEffectivity'))]/ConcernedOrganizations/Organization">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ConcernedOrganizations/Organization) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Organization'] or //Organization[@uid = $uidRef]">(VersionBranchEffectivity : <sch:value-of select="$uid"/>) The VersionBranchEffectivity.ConcernedOrganizations contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Organization.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Effectivity.EffectivityContext : OPTIONAL EffectivityContextSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='VersionBranchEffectivity') or (self::Effectivity and substring-after(@xsi:type,':')='VersionBranchEffectivity'))]/EffectivityContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)] or //Activity[@uid = $uidRef] or //Contract[@uid = $uidRef] or //Organization[@uid = $uidRef] or //PersonInOrganization[@uid = $uidRef] or //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))] or //ProductConfiguration[@uid = $uidRef] or //Project[@uid = $uidRef]">(VersionBranchEffectivity : <sch:value-of select="$uid"/>) The VersionBranchEffectivity.EffectivityContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of EffectivityContextSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="Vertex"/>
   <sch:pattern id="VertexPoint"><!--(Ref to E) VertexPoint.VertexGeometry : Point (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='VertexPoint') or (self::RepresentationItem and substring-after(@xsi:type,':')='VertexPoint'))]/VertexGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Point'] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))]">(VertexPoint : <sch:value-of select="$uid"/>) The VertexPoint.VertexGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Point.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ViewContext"><!--(Ref to S) ViewContext.ApplicationDomain : ApplicationDomainSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ViewContext') or (self::ViewContext and not(@xsi:type)))]/ApplicationDomain/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ApplicationDomain and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApplicationDomain ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ApplicationDomain and //ApplicationDomain[@uid = $uidRef]) or (self::PredefinedApplicationDomainEnum) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalItem and //*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(ViewContext : <sch:value-of select="$uid"/>) The ViewContext.ApplicationDomain contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ApplicationDomainSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ViewContext.LifeCycleStage : LifeCycleStageSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ViewContext') or (self::ViewContext and not(@xsi:type)))]/LifeCycleStage/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::LifeCycleStage and //ExternalRefBaseObject[@uid = $uidRef and contains(' LifeCycleStage ',@typeRef)]) or (*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Proxy ',@typeRef)]) or (*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::LifeCycleStage and //LifeCycleStage[@uid = $uidRef]) or (self::Proxy and //*[(self::Proxy or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SameAs and contains(' Proxy ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalItem and //*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(ViewContext : <sch:value-of select="$uid"/>) The ViewContext.LifeCycleStage contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of LifeCycleStageSelect.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartView.AdditionalContexts :: ReferenceProperty) ViewContext.AdditionalView : OPTIONAL SET[1:unbounded] OF PartView) => no rule needed when PartProperty or Optional-->
      <!--(Inverse of PartView.InitialContext :: ReferenceProperty) ViewContext.InitialView : OPTIONAL SET[1:unbounded] OF PartView) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="ViewOccurrenceRelationship"><!--(Ref to E) ViewOccurrenceRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ViewOccurrenceRelationship') or (self::ViewOccurrenceRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ViewOccurrenceRelationship : <sch:value-of select="$uid"/>) The ViewOccurrenceRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ViewOccurrenceRelationship.Related : DefinitionBasedOccurrence (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ViewOccurrenceRelationship') or (self::ViewOccurrenceRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'DefinitionBasedOccurrence'] or //Occurrence[@uid = $uidRef and contains(' DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence ',substring-after(@xsi:type,':'))]">(ViewOccurrenceRelationship : <sch:value-of select="$uid"/>) The ViewOccurrenceRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type DefinitionBasedOccurrence.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ViewOccurrenceRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ViewOccurrenceRelationship') or (self::ViewOccurrenceRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ViewOccurrenceRelationship : <sch:value-of select="$uid"/>) The ViewOccurrenceRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WireColourBasedIdentificationCode"><!--(Ref to S) PropertyDefinition.AllowedUnits : OPTIONAL SET[1:unbounded] OF UnitSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WireColourBasedIdentificationCode') or (self::PropertyDefinition and substring-after(@xsi:type,':')='WireColourBasedIdentificationCode'))]/AllowedUnits/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::ExternalUnit and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalUnit ',@typeRef)]) or (self::Unit and //ExternalRefBaseObject[@uid = $uidRef and contains(' Unit ',@typeRef)]) or (self::ExternalUnit and //ExternalUnit[@uid = $uidRef]) or (self::Unit and //Unit[@uid = $uidRef])">(WireColourBasedIdentificationCode : <sch:value-of select="$uid"/>) The WireColourBasedIdentificationCode.AllowedUnits contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of UnitSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyDefinition.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WireColourBasedIdentificationCode') or (self::PropertyDefinition and substring-after(@xsi:type,':')='WireColourBasedIdentificationCode'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(WireColourBasedIdentificationCode : <sch:value-of select="$uid"/>) The WireColourBasedIdentificationCode.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PropertyDefinition.DefinedIn : OPTIONAL ExternalClassSystem (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WireColourBasedIdentificationCode') or (self::PropertyDefinition and substring-after(@xsi:type,':')='WireColourBasedIdentificationCode'))]/DefinedIn">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefinedIn) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ExternalClassSystem'] or //ExternalClassSystem[@uid = $uidRef]">(WireColourBasedIdentificationCode : <sch:value-of select="$uid"/>) The WireColourBasedIdentificationCode.DefinedIn contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ExternalClassSystem.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyDefinition.Definition : OPTIONAL ProxyItemSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WireColourBasedIdentificationCode') or (self::PropertyDefinition and substring-after(@xsi:type,':')='WireColourBasedIdentificationCode'))]/Definition/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',@typeRef)]) or (self::ExternalOwlObject and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlObject ',@typeRef)]) or (self::ExternalItem and //*[(self::ExternalItem or (self::ExternalItem and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::NextInstance and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::External and contains(' ExternalItem  ExternalEntityInstance  NextInstanceForward  NextInstanceInverse ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ExternalOwlObject and //ExternalOwlObject[@uid = $uidRef]) or (self::ProxyString)">(WireColourBasedIdentificationCode : <sch:value-of select="$uid"/>) The WireColourBasedIdentificationCode.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ProxyItemSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PropertyDefinition.PropertyType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WireColourBasedIdentificationCode') or (self::PropertyDefinition and substring-after(@xsi:type,':')='WireColourBasedIdentificationCode'))]/PropertyType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(WireColourBasedIdentificationCode : <sch:value-of select="$uid"/>) The WireColourBasedIdentificationCode.PropertyType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WireOccurrence"><!--(Ref to E) Occurrence.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WireOccurrence') or (self::Occurrence and substring-after(@xsi:type,':')='WireOccurrence'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(WireOccurrence : <sch:value-of select="$uid"/>) The WireOccurrence.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Occurrence.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WireOccurrence') or (self::Occurrence and substring-after(@xsi:type,':')='WireOccurrence'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(WireOccurrence : <sch:value-of select="$uid"/>) The WireOccurrence.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WireOccurrenceIdentification"><!--(Ref to E) WireOccurrenceIdentification.Code : OPTIONAL WireColourBasedIdentificationCode (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WireOccurrenceIdentification') or (self::ShapeElement and substring-after(@xsi:type,':')='WireOccurrenceIdentification'))]/Code">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Code) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'WireColourBasedIdentificationCode'] or //PropertyDefinition[@uid = $uidRef and contains(' WireColourBasedIdentificationCode ',substring-after(@xsi:type,':'))]">(WireOccurrenceIdentification : <sch:value-of select="$uid"/>) The WireOccurrenceIdentification.Code contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type WireColourBasedIdentificationCode.</sch:assert>
      </sch:rule>
      <!--(Ref to S) OccurrenceTransportFeature.Definition : OPTIONAL OccurrenceTransportFeatureDefinitionSelect (kind=SINGLE - redefined=OccurrenceShapeElement.Definition)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WireOccurrenceIdentification') or (self::ShapeElement and substring-after(@xsi:type,':')='WireOccurrenceIdentification'))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartTransportFeature  WirePartIdentification ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))]">(WireOccurrenceIdentification : <sch:value-of select="$uid"/>) The WireOccurrenceIdentification.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OccurrenceTransportFeatureDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WireOccurrenceIdentification') or (self::ShapeElement and substring-after(@xsi:type,':')='WireOccurrenceIdentification'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(WireOccurrenceIdentification : <sch:value-of select="$uid"/>) The WireOccurrenceIdentification.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WireOccurrenceIdentification') or (self::ShapeElement and substring-after(@xsi:type,':')='WireOccurrenceIdentification'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(WireOccurrenceIdentification : <sch:value-of select="$uid"/>) The WireOccurrenceIdentification.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WireOccurrenceTerminal"><!--(Ref to E) WireOccurrenceTerminal.AssociatedTransportFeature : WireOccurrenceIdentification (kind=SINGLE - redefined=OccurrenceTerminal.AssociatedTransportFeature)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WireOccurrenceTerminal') or (self::ShapeElement and substring-after(@xsi:type,':')='WireOccurrenceTerminal'))]/AssociatedTransportFeature">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'WireOccurrenceIdentification'] or //ShapeElement[@uid = $uidRef and contains(' WireOccurrenceIdentification ',substring-after(@xsi:type,':'))]">(WireOccurrenceTerminal : <sch:value-of select="$uid"/>) The WireOccurrenceTerminal.AssociatedTransportFeature contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type WireOccurrenceIdentification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) OccurrenceTerminal.Definition : OPTIONAL OccurrenceTerminalDefinitionSelect (kind=SINGLE - redefined=OccurrenceContactFeature.Definition)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WireOccurrenceTerminal') or (self::ShapeElement and substring-after(@xsi:type,':')='WireOccurrenceTerminal'))]/Definition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartTerminal ',@typeRef)] or //ShapeFeatureDefinition[@uid = $uidRef and contains(' ContactFeatureDefinition ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartTerminal ',substring-after(@xsi:type,':'))]">(WireOccurrenceTerminal : <sch:value-of select="$uid"/>) The WireOccurrenceTerminal.Definition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of OccurrenceTerminalDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WireOccurrenceTerminal') or (self::ShapeElement and substring-after(@xsi:type,':')='WireOccurrenceTerminal'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(WireOccurrenceTerminal : <sch:value-of select="$uid"/>) The WireOccurrenceTerminal.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WireOccurrenceTerminal') or (self::ShapeElement and substring-after(@xsi:type,':')='WireOccurrenceTerminal'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(WireOccurrenceTerminal : <sch:value-of select="$uid"/>) The WireOccurrenceTerminal.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WirePartIdentification"><!--(Ref to E) WirePartIdentification.Code : OPTIONAL WireColourBasedIdentificationCode (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WirePartIdentification') or (self::ShapeElement and substring-after(@xsi:type,':')='WirePartIdentification'))]/Code">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Code) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'WireColourBasedIdentificationCode'] or //PropertyDefinition[@uid = $uidRef and contains(' WireColourBasedIdentificationCode ',substring-after(@xsi:type,':'))]">(WirePartIdentification : <sch:value-of select="$uid"/>) The WirePartIdentification.Code contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type WireColourBasedIdentificationCode.</sch:assert>
      </sch:rule>
      <!--(Ref to S) PartShapeElement.PartDefinition : OPTIONAL PartShapeElementDefinitionSelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WirePartIdentification') or (self::ShapeElement and substring-after(@xsi:type,':')='WirePartIdentification'))]/PartDefinition">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinition  ContactFeatureDefinition ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ShapeFeatureDefinitionRelationship  ShapeFeatureDefinitionFitRelationship  ContactFeatureDefinitionFitRelationship ',@typeRef)] or //ShapeElement[@uid = $uidRef and contains(' OccurrenceShapeElement  OccurrenceShapeFeature  CrossSectionalOccurrenceShapeElement  OccurrenceContactFeature  OccurrenceTerminal  CableOccurrenceTerminal  CableOccurrenceTerminalLocationGroup  WireOccurrenceTerminal  OccurrenceTransportFeature  WireOccurrenceIdentification ',substring-after(@xsi:type,':'))] or //ShapeElement[@uid = $uidRef and contains(' PartShapeElement  AssemblyShapeConstraint  AssemblyShapeJoint  ComponentPathShapeElement  CrossSectionalPartShapeElement  CrossSectionalAlternativePartShapeElement  CrossSectionalGroupShapeElement  CrossSectionalGroupShapeElementWithLacing  CrossSectionalGroupShapeElementWithTubularCover  TwistedCrossSectionalGroupShapeElement  HarnessNode  HarnessSegment  Nominal3dFeature  Nominal3dDerivedFeature  Nominal3dIntegralFeature  Nominal3dEdge  PartConnectivityDefinition  PartFeature  PartContactFeature  PartTerminal  PartTransportFeature  WirePartIdentification ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' PartShapeElementRelationship  PartFeatureFitRelationship  PartContactFeatureFitRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinition[@uid = $uidRef] or //ShapeElement[@uid = $uidRef and contains(' ShapeFeatureDefinitionElement  ShapeFeatureDefinitionOccurrenceElement ',substring-after(@xsi:type,':'))] or //ShapeElementRelationship[@uid = $uidRef and contains(' ShapeFeatureDefinitionElementRelationship  ShapeFeatureDefinitionOccurrenceElementRelationship ',substring-after(@xsi:type,':'))] or //ShapeFeatureDefinitionRelationship[@uid = $uidRef]">(WirePartIdentification : <sch:value-of select="$uid"/>) The WirePartIdentification.PartDefinition contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of PartShapeElementDefinitionSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) ShapeElement.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WirePartIdentification') or (self::ShapeElement and substring-after(@xsi:type,':')='WirePartIdentification'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(WirePartIdentification : <sch:value-of select="$uid"/>) The WirePartIdentification.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) ShapeElement.RepresentedGeometry : OPTIONAL ShapeElementRepresentedGeometrySelect (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WirePartIdentification') or (self::ShapeElement and substring-after(@xsi:type,':')='WirePartIdentification'))]/RepresentedGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' AdvancedFace ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' ConnectedFaceSet ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' EdgeLoop ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' VertexPoint ',@typeRef)] or //ExternalRefBaseObject[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',@typeRef)] or //RepresentationItem[@uid = $uidRef and contains(' DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' Surface  OrientedSurface  Plane  RectangularTrimmedSurface ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' AdvancedFace ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' ConnectedFaceSet ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeCurve  EdgeBoundedCurveWithLength ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' EdgeLoop ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' VertexPoint ',substring-after(@xsi:type,':'))] or //RepresentationItem[@uid = $uidRef and contains(' TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint ',substring-after(@xsi:type,':'))]">(WirePartIdentification : <sch:value-of select="$uid"/>) The WirePartIdentification.RepresentedGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ShapeElementRepresentedGeometrySelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WiringHarnessAssemblyDesign"><!--(Ref to E) WiringHarnessAssemblyDesign.Topology : OPTIONAL EdgeBasedTopologicalRepresentationWithLengthConstraint (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WiringHarnessAssemblyDesign') or (self::PartView and substring-after(@xsi:type,':')='WiringHarnessAssemblyDesign'))]/Topology">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./Topology) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'EdgeBasedTopologicalRepresentationWithLengthConstraint'] or //Representation[@uid = $uidRef and contains(' EdgeBasedTopologicalRepresentationWithLengthConstraint ',substring-after(@xsi:type,':'))]">(WiringHarnessAssemblyDesign : <sch:value-of select="$uid"/>) The WiringHarnessAssemblyDesign.Topology contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type EdgeBasedTopologicalRepresentationWithLengthConstraint.</sch:assert>
      </sch:rule>
      <!--(Ref to S) AssemblyDefinition.AssemblyType : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WiringHarnessAssemblyDesign') or (self::PartView and substring-after(@xsi:type,':')='WiringHarnessAssemblyDesign'))]/AssemblyType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(WiringHarnessAssemblyDesign : <sch:value-of select="$uid"/>) The WiringHarnessAssemblyDesign.AssemblyType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AdditionalContexts : OPTIONAL SET[1:unbounded] OF ViewContext (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WiringHarnessAssemblyDesign') or (self::PartView and substring-after(@xsi:type,':')='WiringHarnessAssemblyDesign'))]/AdditionalContexts/ViewContext">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AdditionalContexts/ViewContext) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(WiringHarnessAssemblyDesign : <sch:value-of select="$uid"/>) The WiringHarnessAssemblyDesign.AdditionalContexts contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.AuxiliaryGeometry : OPTIONAL SET[1:unbounded] OF GeometricModel (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WiringHarnessAssemblyDesign') or (self::PartView and substring-after(@xsi:type,':')='WiringHarnessAssemblyDesign'))]/AuxiliaryGeometry/GeometricModel">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../AuxiliaryGeometry/GeometricModel) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(WiringHarnessAssemblyDesign : <sch:value-of select="$uid"/>) The WiringHarnessAssemblyDesign.AuxiliaryGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WiringHarnessAssemblyDesign') or (self::PartView and substring-after(@xsi:type,':')='WiringHarnessAssemblyDesign'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(WiringHarnessAssemblyDesign : <sch:value-of select="$uid"/>) The WiringHarnessAssemblyDesign.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.DefiningGeometry : OPTIONAL GeometricModel (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WiringHarnessAssemblyDesign') or (self::PartView and substring-after(@xsi:type,':')='WiringHarnessAssemblyDesign'))]/DefiningGeometry">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(./DefiningGeometry) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'GeometricModel'] or //Representation[@uid = $uidRef and contains(' GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel ',substring-after(@xsi:type,':'))]">(WiringHarnessAssemblyDesign : <sch:value-of select="$uid"/>) The WiringHarnessAssemblyDesign.DefiningGeometry contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type GeometricModel.</sch:assert>
      </sch:rule>
      <!--(Ref to E) PartView.InitialContext : ViewContext (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WiringHarnessAssemblyDesign') or (self::PartView and substring-after(@xsi:type,':')='WiringHarnessAssemblyDesign'))]/InitialContext">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'ViewContext'] or //ViewContext[@uid = $uidRef]">(WiringHarnessAssemblyDesign : <sch:value-of select="$uid"/>) The WiringHarnessAssemblyDesign.InitialContext contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type ViewContext.</sch:assert>
      </sch:rule>
      <!--(Inverse of PartVersion.Views :: PartProperty) PartView.ViewOf : PartVersion) => no rule needed when PartProperty or Optional-->
   </sch:pattern>
   <sch:pattern id="WorkOrder"><!--(Ref to E) WorkOrder.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkOrder') or (self::WorkOrder and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(WorkOrder : <sch:value-of select="$uid"/>) The WorkOrder.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) WorkOrder.InResponseTo : OPTIONAL SET[1:unbounded] OF WorkRequest (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkOrder') or (self::WorkOrder and not(@xsi:type)))]/InResponseTo/WorkRequest">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../InResponseTo/WorkRequest) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'WorkRequest'] or //WorkRequest[@uid = $uidRef]">(WorkOrder : <sch:value-of select="$uid"/>) The WorkOrder.InResponseTo contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type WorkRequest.</sch:assert>
      </sch:rule>
      <!--(Ref to S) WorkOrder.OrderType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkOrder') or (self::WorkOrder and not(@xsi:type)))]/OrderType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(WorkOrder : <sch:value-of select="$uid"/>) The WorkOrder.OrderType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) WorkOrder.Scope : OPTIONAL SET[1:unbounded] OF ActivityAssignmentSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkOrder') or (self::WorkOrder and not(@xsi:type)))]/Scope/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternatePartRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternatePartRelationship ',@typeRef)]) or (self::AlternativeSolution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)]) or (self::AlternativeSolutionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolutionRelationship ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::AssemblyOccurrenceRelationshipSubstitution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyOccurrenceRelationshipSubstitution ',@typeRef)]) or (self::AssemblyViewRelationshipSubstitution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationshipSubstitution ',@typeRef)]) or (self::AssignmentObjectRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssignmentObjectRelationship ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementRealization and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRealization ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::BreakdownVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionRelationship ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConfiguredAssemblyEffectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConfiguredAssemblyEffectivity ',@typeRef)]) or (self::Contract and //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::DeltaChangeRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DeltaChangeRelationship ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::DocumentVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersionRelationship ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::EffectivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)]) or (self::Envelope and //ExternalRefBaseObject[@uid = $uidRef and contains(' Envelope ',@typeRef)]) or (self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::File and //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)]) or (self::FileRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)]) or (self::IndividualAssemblyRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualAssemblyRelationship ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialIdentification and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialIdentification ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::Message and //ExternalRefBaseObject[@uid = $uidRef and contains(' Message ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::Observation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::ObservationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)]) or (self::Occurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)]) or (self::OccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceRelationship  ReplacedUsageRelationship  SameTimeMachiningRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship  AlternatePartVersionRelationship ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::Person and //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::ProcessOperationDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinition ',@typeRef)]) or (self::ProcessOperationDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinitionRelationship ',@typeRef)]) or (self::ProcessOperationOccurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationOccurrence ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlan and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlan ',@typeRef)]) or (self::ProcessPlanRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlanRelationship ',@typeRef)]) or (self::ProductClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)]) or (self::ProductClassRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClassRelationship ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::ProductConfigurationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)]) or (self::Project and //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::ProjectRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectRelationship ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (self::Representation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel  PlyAngleRepresentation  ReinforcementOrientationBasis ',@typeRef)]) or (self::RepresentationItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' RepresentationItem  BooleanRepresentationItem  Callout  CompoundRepresentationItem  SequenceRepresentationItem  SetRepresentationItem  DateTimeRepresentationItem  DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface  ExternalRepresentationItem  ExternalTessellatedAnnotation  IntegerRepresentationItem  LogicalRepresentationItem  RationalRepresentationItem  RealRepresentationItem  StyledElement  AnnotationElement  AnnotationPlaceholderOccurrence  AnnotationPlane  OverRidingStyledElement  ContextDependentOverRidingStyledElement  StyledModelReplication  TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint  UserDefined11 ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersionRelationship ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategory and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategory ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusion ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::StyledModel and //ExternalRefBaseObject[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::ViewOccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkOrderRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderRelationship ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::WorkRequestRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestRelationship ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternatePartRelationship and //PartRelationship[@uid = $uidRef and contains(' AlternatePartRelationship ',substring-after(@xsi:type,':'))]) or (self::AlternativeSolution and //AlternativeSolution[@uid = $uidRef]) or (self::AlternativeSolutionRelationship and //AlternativeSolutionRelationship[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::AssemblyOccurrenceRelationshipSubstitution and //AssemblyOccurrenceRelationshipSubstitution[@uid = $uidRef]) or (self::AssemblyViewRelationshipSubstitution and //AssemblyViewRelationshipSubstitution[@uid = $uidRef]) or (self::AssignmentObjectRelationship and //AssignmentObjectRelationship[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementRealization and //BreakdownElementRealization[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementVersionRelationship and //BreakdownElementVersionRelationship[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::BreakdownVersionRelationship and //BreakdownVersionRelationship[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Class and //Class[@uid = $uidRef]) or (self::Condition and //*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConfiguredAssemblyEffectivity and //ConfiguredAssemblyEffectivity[@uid = $uidRef]) or (self::Contract and //Contract[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DeltaChangeRelationship and //DeltaChangeRelationship[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::DocumentVersionRelationship and //DocumentVersionRelationship[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::EffectivityRelationship and //EffectivityRelationship[@uid = $uidRef]) or (self::Envelope and //Envelope[@uid = $uidRef]) or (self::Event and //Event[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef]) or (self::File and //File[@uid = $uidRef]) or (self::FileRelationship and //FileRelationship[@uid = $uidRef]) or (self::IndividualAssemblyRelationship and //IndividualAssemblyRelationship[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartVersionRelationship and //IndividualPartVersionRelationship[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialIdentification and //MaterialIdentification[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::Message and //Message[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::Observation and //Observation[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::ObservationRelationship and //ObservationRelationship[@uid = $uidRef]) or (self::Occurrence and //Occurrence[@uid = $uidRef]) or (self::OccurrenceRelationship and //OccurrenceRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartVersionRelationship and //PartVersionRelationship[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::Person and //Person[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef]) or (self::ProcessOperationDefinition and //ProcessOperationDefinition[@uid = $uidRef]) or (self::ProcessOperationDefinitionRelationship and //ProcessOperationDefinitionRelationship[@uid = $uidRef]) or (self::ProcessOperationOccurrence and //ProcessOperationOccurrence[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlan and //ProcessPlan[@uid = $uidRef]) or (self::ProcessPlanRelationship and //ProcessPlanRelationship[@uid = $uidRef]) or (self::ProductClass and //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))]) or (self::ProductClassRelationship and //ProductClassRelationship[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProductConfigurationRelationship and //ProductConfigurationRelationship[@uid = $uidRef]) or (self::Project and //Project[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::ProjectRelationship and //ProjectRelationship[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Representation and //Representation[@uid = $uidRef]) or (self::RepresentationItem and //RepresentationItem[@uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementVersionRelationship and //RequirementVersionRelationship[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategory and //SpecificationCategory[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusion and //SpecificationInclusion[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::StyledModel and //Representation[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',substring-after(@xsi:type,':'))]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::ViewOccurrenceRelationship and //ViewOccurrenceRelationship[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkOrderRelationship and //WorkOrderRelationship[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef]) or (self::WorkRequestRelationship and //WorkRequestRelationship[@uid = $uidRef])">(WorkOrder : <sch:value-of select="$uid"/>) The WorkOrder.Scope contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ActivityAssignmentSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WorkOrderAssignment"><!--(Ref to E) WorkOrderAssignment.AssignedWorkOrder : WorkOrder (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkOrderAssignment') or (self::WorkOrderAssignment and not(@xsi:type)))]/AssignedWorkOrder">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'WorkOrder'] or //WorkOrder[@uid = $uidRef]">(WorkOrderAssignment : <sch:value-of select="$uid"/>) The WorkOrderAssignment.AssignedWorkOrder contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type WorkOrder.</sch:assert>
      </sch:rule>
      <!--(Ref to E) WorkOrderAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkOrderAssignment') or (self::WorkOrderAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(WorkOrderAssignment : <sch:value-of select="$uid"/>) The WorkOrderAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) WorkOrderAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkOrderAssignment') or (self::WorkOrderAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(WorkOrderAssignment : <sch:value-of select="$uid"/>) The WorkOrderAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WorkOrderRelationship"><!--(Ref to E) WorkOrderRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkOrderRelationship') or (self::WorkOrderRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(WorkOrderRelationship : <sch:value-of select="$uid"/>) The WorkOrderRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) WorkOrderRelationship.Related : WorkOrder (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkOrderRelationship') or (self::WorkOrderRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'WorkOrder'] or //WorkOrder[@uid = $uidRef]">(WorkOrderRelationship : <sch:value-of select="$uid"/>) The WorkOrderRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type WorkOrder.</sch:assert>
      </sch:rule>
      <!--(Ref to S) WorkOrderRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkOrderRelationship') or (self::WorkOrderRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(WorkOrderRelationship : <sch:value-of select="$uid"/>) The WorkOrderRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WorkOrderRelationship_WR1"><!--(Rule WorkOrderRelationship.WR1)-->
      <sch:rule context="//WorkOrderRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> WorkOrderRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related WorkOrder and the relating WorkOrder shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="WorkRequest"><!--(Ref to E) WorkRequest.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkRequest') or (self::WorkRequest and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(WorkRequest : <sch:value-of select="$uid"/>) The WorkRequest.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) WorkRequest.RequestType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkRequest') or (self::WorkRequest and not(@xsi:type)))]/RequestType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(WorkRequest : <sch:value-of select="$uid"/>) The WorkRequest.RequestType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) WorkRequest.Scope : OPTIONAL SET[1:unbounded] OF ActivityAssignmentSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkRequest') or (self::WorkRequest and not(@xsi:type)))]/Scope/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Activity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Activity  ActualActivity  DirectedActualActivity  PlannedActivity  DirectedPlannedActivity ',@typeRef)]) or (self::ActivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityAssignment ',@typeRef)]) or (self::ActivityMethod and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethod ',@typeRef)]) or (self::ActivityMethodAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityMethodAssignment ',@typeRef)]) or (self::ActivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ActivityRelationship  ActivityHappeningRelationship ',@typeRef)]) or (self::AddressAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' AddressAssignment ',@typeRef)]) or (self::AlternatePartRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternatePartRelationship ',@typeRef)]) or (self::AlternativeSolution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolution  FinalSolution  SupplierSolution  TechnicalSolution ',@typeRef)]) or (self::AlternativeSolutionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AlternativeSolutionRelationship ',@typeRef)]) or (self::ApprovalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ApprovalAssignment  FrozenAssignment ',@typeRef)]) or (self::AssemblyOccurrenceRelationshipSubstitution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyOccurrenceRelationshipSubstitution ',@typeRef)]) or (self::AssemblyViewRelationshipSubstitution and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssemblyViewRelationshipSubstitution ',@typeRef)]) or (self::AssignmentObjectRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' AssignmentObjectRelationship ',@typeRef)]) or (self::Breakdown and //ExternalRefBaseObject[@uid = $uidRef and contains(' Breakdown  FunctionalBreakdown  PhysicalBreakdown  SystemBreakdown  ZonalBreakdown ',@typeRef)]) or (self::BreakdownElement and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElement ',@typeRef)]) or (self::BreakdownElementRealization and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementRealization ',@typeRef)]) or (self::BreakdownElementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersion ',@typeRef)]) or (self::BreakdownElementVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementVersionRelationship ',@typeRef)]) or (self::BreakdownElementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementView ',@typeRef)]) or (self::BreakdownElementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownElementViewRelationship ',@typeRef)]) or (self::BreakdownVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersion ',@typeRef)]) or (self::BreakdownVersionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionAssignment ',@typeRef)]) or (self::BreakdownVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' BreakdownVersionRelationship ',@typeRef)]) or (self::CertificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' CertificationAssignment ',@typeRef)]) or (self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',@typeRef)]) or (self::ConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConditionAssignment ',@typeRef)]) or (self::ConfiguredAssemblyEffectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' ConfiguredAssemblyEffectivity ',@typeRef)]) or (self::Contract and //ExternalRefBaseObject[@uid = $uidRef and contains(' Contract ',@typeRef)]) or (self::ContractAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ContractAssignment ',@typeRef)]) or (self::DateAndPersonAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateAndPersonAssignment ',@typeRef)]) or (self::DateTimeAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DateTimeAssignment ',@typeRef)]) or (self::DeltaChangeRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DeltaChangeRelationship ',@typeRef)]) or (self::Document and //ExternalRefBaseObject[@uid = $uidRef and contains(' Document ',@typeRef)]) or (self::DocumentAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentAssignment ',@typeRef)]) or (self::DocumentDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinition  DigitalDocumentDefinition  PhysicalDocumentDefinition ',@typeRef)]) or (self::DocumentDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentDefinitionRelationship ',@typeRef)]) or (self::DocumentVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersion ',@typeRef)]) or (self::DocumentVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' DocumentVersionRelationship ',@typeRef)]) or (self::Effectivity and //ExternalRefBaseObject[@uid = $uidRef and contains(' Effectivity  ConditionalEffectivity  ConditionalConfiguration  DatedEffectivity  TimeIntervalEffectivity  IndividualPartEffectivity  LotEffectivity  SerialEffectivity  VersionBranchEffectivity ',@typeRef)]) or (self::EffectivityAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityAssignment ',@typeRef)]) or (self::EffectivityRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' EffectivityRelationship ',@typeRef)]) or (self::Envelope and //ExternalRefBaseObject[@uid = $uidRef and contains(' Envelope ',@typeRef)]) or (self::Event and //ExternalRefBaseObject[@uid = $uidRef and contains(' Event ',@typeRef)]) or (self::EventAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' EventAssignment ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::File and //ExternalRefBaseObject[@uid = $uidRef and contains(' File  DigitalFile  Hardcopy ',@typeRef)]) or (self::FileRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' FileRelationship ',@typeRef)]) or (self::IndividualAssemblyRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualAssemblyRelationship ',@typeRef)]) or (self::IndividualPart and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPart ',@typeRef)]) or (self::IndividualPartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersion  PlannedIndividualPart  RealizedIndividualPart ',@typeRef)]) or (self::IndividualPartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartVersionRelationship  ProductPlannedToRealized ',@typeRef)]) or (self::IndividualPartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartView ',@typeRef)]) or (self::IndividualPartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' IndividualPartViewRelationship ',@typeRef)]) or (self::InformationUsageRightAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' InformationUsageRightAssignment ',@typeRef)]) or (self::MaterialIdentification and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialIdentification ',@typeRef)]) or (self::MaterialPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' MaterialPropertyAssignment ',@typeRef)]) or (self::Message and //ExternalRefBaseObject[@uid = $uidRef and contains(' Message ',@typeRef)]) or (self::ModelPropertyAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ModelPropertyAssignment ',@typeRef)]) or (self::Observation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Observation ',@typeRef)]) or (self::ObservationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationAssignment ',@typeRef)]) or (self::ObservationConsequence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationConsequence ',@typeRef)]) or (self::ObservationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ObservationRelationship ',@typeRef)]) or (self::Occurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' Occurrence  DefinitionBasedOccurrence  QuantifiedOccurrence  CableOccurrence  WireOccurrence  SingleOccurrence  SpecifiedOccurrence ',@typeRef)]) or (self::OccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' OccurrenceRelationship  ReplacedUsageRelationship  SameTimeMachiningRelationship ',@typeRef)]) or (self::Organization and //ExternalRefBaseObject[@uid = $uidRef and contains(' Organization ',@typeRef)]) or (self::OrganizationOrPersonInOrganizationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' OrganizationOrPersonInOrganizationAssignment ',@typeRef)]) or (self::Part and //ExternalRefBaseObject[@uid = $uidRef and contains(' Part ',@typeRef)]) or (self::PartVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersion ',@typeRef)]) or (self::PartVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartVersionRelationship  AlternatePartVersionRelationship ',@typeRef)]) or (self::PartView and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartView  AssemblyDefinition  MatingDefinition  WiringHarnessAssemblyDesign  CollectionDefinition  ConstituentPart  CompositeAssembly  FilamentLaminate  Ply  PlyLaminate  PlyLaminateSequenceDefinition  PlyPiece  ProcessedCore  LaminateTable  CompositeAssemblyTable  PlyLaminateTable  ZoneStructuralMakeup  PercentageLaminateTable  SmearedMaterial  ThicknessLaminateTable ',@typeRef)]) or (self::PartViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PartViewRelationship  AssemblyViewRelationship  NextAssemblyViewUsage  PromissoryAssemblyViewUsage  DefinitionalPartViewUsage  GeometricalRelationship  MakeFromRelationship  ProcessStateRelationship  ReplacedPartViewRelationship  ToolPartRelationship ',@typeRef)]) or (self::Person and //ExternalRefBaseObject[@uid = $uidRef and contains(' Person ',@typeRef)]) or (self::PersonInOrganization and //ExternalRefBaseObject[@uid = $uidRef and contains(' PersonInOrganization ',@typeRef)]) or (self::ProcessOperationDefinition and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinition ',@typeRef)]) or (self::ProcessOperationDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationDefinitionRelationship ',@typeRef)]) or (self::ProcessOperationOccurrence and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationOccurrence ',@typeRef)]) or (self::ProcessOperationResourceAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessOperationResourceAssignment ',@typeRef)]) or (self::ProcessPlan and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlan ',@typeRef)]) or (self::ProcessPlanRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProcessPlanRelationship ',@typeRef)]) or (self::ProductClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClass ',@typeRef)]) or (self::ProductClassRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductClassRelationship ',@typeRef)]) or (self::ProductConfiguration and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfiguration  EffectivityControlledProductConfiguration ',@typeRef)]) or (self::ProductConfigurationRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProductConfigurationRelationship ',@typeRef)]) or (self::Project and //ExternalRefBaseObject[@uid = $uidRef and contains(' Project ',@typeRef)]) or (self::ProjectAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectAssignment ',@typeRef)]) or (self::ProjectRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ProjectRelationship ',@typeRef)]) or (self::PropertyDefinitionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionAssignment ',@typeRef)]) or (self::PropertyDefinitionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyDefinitionRelationship ',@typeRef)]) or (*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))))] and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',@typeRef)]) or (self::PropertyValueAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueAssignment ',@typeRef)]) or (self::PropertyValueRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' PropertyValueRelationship ',@typeRef)]) or (self::Representation and //ExternalRefBaseObject[@uid = $uidRef and contains(' Representation  GeometricRepresentation  ConstituentShapeRepresentation  BeveledSheetRepresentation  CompositeSheetRepresentation  FaceBasedSheetRepresentation  GeometricSheetRepresentation  ThreeDGeometrySet  EdgeBasedTopologicalRepresentationWithLengthConstraint  GeometricModel  ComposedGeometricModel  ExternalGeometricModel  ExternalAdvancedBrepShapeRepresentation  ExternalCsgShapeRepresentation  ExternalCurveSweptSolidShapeRepresentation  ExternalEdgeBasedWireframeShapeRepresentation  ExternalElementaryBrepShapeRepresentation  ExternalFacetedBrepShapeRepresentation  ExternalGeometricallyBoundedSurfaceShapeRepresentation  ExternalGeometricallyBoundedWireframeShapeRepresentation  ExternalManifoldSurfaceShapeRepresentation  ExternalShellBasedWireframeShapeRepresentation  ExternalTessellatedShapeRepresentation  TransformedGeometricModel  InterpolatedConfigurationModel  KinematicLink  LinkMotionAlongPath  Mechanism  MechanismState  StyledModel  AnnotatedModelPresentation  ExternalStyledModel  PlyAngleRepresentation  ReinforcementOrientationBasis ',@typeRef)]) or (self::RepresentationItem and //ExternalRefBaseObject[@uid = $uidRef and contains(' RepresentationItem  BooleanRepresentationItem  Callout  CompoundRepresentationItem  SequenceRepresentationItem  SetRepresentationItem  DateTimeRepresentationItem  DetailedGeometricModelItem  AdvancedFace  AxisPlacement  ToolAttachmentPointFrame  ToolCentrePointFrame  CameraModel3D  Cartesian11  ClippingOperator  ConnectedFaceSet  Curve  BoundedCurve  BoundedCurveWithLength  CompositeCurveOnSurface  Pcurve  SurfaceCurve  TrimmedCurve  Curve11  Cylindrical11  Direction  EdgeLoop  GeometricPlaceholderSet  GeometricSet  GeometricCurveSet  BoundaryCurveSet  InterpolatedConfigurationSequence  KinematicPair  HighOrderKinematicPair  LowOrderKinematicPair  LowOrderKinematicPairWithMotionCoupling  KinematicPairValue  KinematicPairWithMotionCoupling  KinematicPathDefinedByNodes  LightSource  Loop  PlanarBox  Point  CartesianPoint  LeaderLinePoint  LeaderLinePointWithSurface  DegeneratePcurve  PointOnCurve  PointOnSurface  PointAndVector  PointArray  Polar11  RotationAboutDirection  Surface  OrientedSurface  Plane  RectangularTrimmedSurface  ExternalRepresentationItem  ExternalTessellatedAnnotation  IntegerRepresentationItem  LogicalRepresentationItem  RationalRepresentationItem  RealRepresentationItem  StyledElement  AnnotationElement  AnnotationPlaceholderOccurrence  AnnotationPlane  OverRidingStyledElement  ContextDependentOverRidingStyledElement  StyledModelReplication  TopologicalRepresentationItem  ConnectedEdgeSet  ConnectedEdgeSubSet  Edge  EdgeCurve  EdgeBoundedCurveWithLength  SubEdge  FaceSurface  Path  Vertex  VertexPoint  UserDefined11 ',@typeRef)]) or (self::Requirement and //ExternalRefBaseObject[@uid = $uidRef and contains(' Requirement ',@typeRef)]) or (self::RequirementAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementAssignment ',@typeRef)]) or (self::RequirementVersion and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersion ',@typeRef)]) or (self::RequirementVersionRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementVersionRelationship ',@typeRef)]) or (self::RequirementView and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementView ',@typeRef)]) or (self::RequirementViewRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' RequirementViewRelationship  RequirementCollectionRelationship  RequirementDecompositionRelationship  RequirementTracingRelationship ',@typeRef)]) or (self::SecurityClassificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SecurityClassificationAssignment ',@typeRef)]) or (self::Specification and //ExternalRefBaseObject[@uid = $uidRef and contains(' Specification ',@typeRef)]) or (self::SpecificationAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationAssignment ',@typeRef)]) or (self::SpecificationCategory and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategory ',@typeRef)]) or (self::SpecificationCategoryAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationCategoryAssignment ',@typeRef)]) or (self::SpecificationConditionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationConditionAssignment ',@typeRef)]) or (self::SpecificationInclusion and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusion ',@typeRef)]) or (self::SpecificationInclusionAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' SpecificationInclusionAssignment ',@typeRef)]) or (self::StyledModel and //ExternalRefBaseObject[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',@typeRef)]) or (self::TimeIntervalAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' TimeIntervalAssignment ',@typeRef)]) or (self::ViewOccurrenceRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' ViewOccurrenceRelationship  AssemblyOccurrenceRelationship  NextAssemblyOccurrenceUsage  MatedPartAssociation  PromissoryAssemblyOccurrenceUsage  CollectedPartRelationship ',@typeRef)]) or (self::WorkOrderAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderAssignment ',@typeRef)]) or (self::WorkOrderRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkOrderRelationship ',@typeRef)]) or (self::WorkRequestAssignment and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestAssignment ',@typeRef)]) or (self::WorkRequestRelationship and //ExternalRefBaseObject[@uid = $uidRef and contains(' WorkRequestRelationship ',@typeRef)]) or (self::Activity and //Activity[@uid = $uidRef]) or (self::ActivityAssignment and //ActivityAssignment[@uid = $uidRef]) or (self::ActivityMethod and //ActivityMethod[@uid = $uidRef]) or (self::ActivityMethodAssignment and //ActivityMethodAssignment[@uid = $uidRef]) or (self::ActivityRelationship and //ActivityRelationship[@uid = $uidRef]) or (self::AddressAssignment and //AddressAssignment[@uid = $uidRef]) or (self::AlternatePartRelationship and //PartRelationship[@uid = $uidRef and contains(' AlternatePartRelationship ',substring-after(@xsi:type,':'))]) or (self::AlternativeSolution and //AlternativeSolution[@uid = $uidRef]) or (self::AlternativeSolutionRelationship and //AlternativeSolutionRelationship[@uid = $uidRef]) or (self::ApprovalAssignment and //ApprovalAssignment[@uid = $uidRef]) or (self::AssemblyOccurrenceRelationshipSubstitution and //AssemblyOccurrenceRelationshipSubstitution[@uid = $uidRef]) or (self::AssemblyViewRelationshipSubstitution and //AssemblyViewRelationshipSubstitution[@uid = $uidRef]) or (self::AssignmentObjectRelationship and //AssignmentObjectRelationship[@uid = $uidRef]) or (self::Breakdown and //Breakdown[@uid = $uidRef]) or (self::BreakdownElement and //BreakdownElement[@uid = $uidRef]) or (self::BreakdownElementRealization and //BreakdownElementRealization[@uid = $uidRef]) or (self::BreakdownElementVersion and //BreakdownElementVersion[@uid = $uidRef]) or (self::BreakdownElementVersionRelationship and //BreakdownElementVersionRelationship[@uid = $uidRef]) or (self::BreakdownElementView and //BreakdownElementView[@uid = $uidRef]) or (self::BreakdownElementViewRelationship and //BreakdownElementViewRelationship[@uid = $uidRef]) or (self::BreakdownVersion and //BreakdownVersion[@uid = $uidRef]) or (self::BreakdownVersionAssignment and //BreakdownVersionAssignment[@uid = $uidRef]) or (self::BreakdownVersionRelationship and //BreakdownVersionRelationship[@uid = $uidRef]) or (self::CertificationAssignment and //CertificationAssignment[@uid = $uidRef]) or (self::Class and //Class[@uid = $uidRef]) or (self::Condition and //*[(self::Condition or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AssignedCondition and contains(' Condition  AndCondition  EqualsCondition  NotCondition  NotEqualsCondition  OneOfCondition  OrCondition ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::ConditionAssignment and //ConditionAssignment[@uid = $uidRef]) or (self::ConfiguredAssemblyEffectivity and //ConfiguredAssemblyEffectivity[@uid = $uidRef]) or (self::Contract and //Contract[@uid = $uidRef]) or (self::ContractAssignment and //ContractAssignment[@uid = $uidRef]) or (self::DateAndPersonAssignment and //DateAndPersonAssignment[@uid = $uidRef]) or (self::DateTimeAssignment and //DateTimeAssignment[@uid = $uidRef]) or (self::DeltaChangeRelationship and //DeltaChangeRelationship[@uid = $uidRef]) or (self::Document and //Document[@uid = $uidRef]) or (self::DocumentAssignment and //DocumentAssignment[@uid = $uidRef]) or (self::DocumentDefinition and //DocumentDefinition[@uid = $uidRef]) or (self::DocumentDefinitionRelationship and //DocumentDefinitionRelationship[@uid = $uidRef]) or (self::DocumentVersion and //DocumentVersion[@uid = $uidRef]) or (self::DocumentVersionRelationship and //DocumentVersionRelationship[@uid = $uidRef]) or (self::Effectivity and //Effectivity[@uid = $uidRef]) or (self::EffectivityAssignment and //EffectivityAssignment[@uid = $uidRef]) or (self::EffectivityRelationship and //EffectivityRelationship[@uid = $uidRef]) or (self::Envelope and //Envelope[@uid = $uidRef]) or (self::Event and //Event[@uid = $uidRef]) or (self::EventAssignment and //EventAssignment[@uid = $uidRef]) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef]) or (self::File and //File[@uid = $uidRef]) or (self::FileRelationship and //FileRelationship[@uid = $uidRef]) or (self::IndividualAssemblyRelationship and //IndividualAssemblyRelationship[@uid = $uidRef]) or (self::IndividualPart and //IndividualPart[@uid = $uidRef]) or (self::IndividualPartVersion and //IndividualPartVersion[@uid = $uidRef]) or (self::IndividualPartVersionRelationship and //IndividualPartVersionRelationship[@uid = $uidRef]) or (self::IndividualPartView and //IndividualPartView[@uid = $uidRef]) or (self::IndividualPartViewRelationship and //IndividualPartViewRelationship[@uid = $uidRef]) or (self::InformationUsageRightAssignment and //InformationUsageRightAssignment[@uid = $uidRef]) or (self::MaterialIdentification and //MaterialIdentification[@uid = $uidRef]) or (self::MaterialPropertyAssignment and //MaterialPropertyAssignment[@uid = $uidRef]) or (self::Message and //Message[@uid = $uidRef]) or (self::ModelPropertyAssignment and //ModelPropertyAssignment[@uid = $uidRef]) or (self::Observation and //Observation[@uid = $uidRef]) or (self::ObservationAssignment and //ObservationAssignment[@uid = $uidRef]) or (self::ObservationConsequence and //ObservationConsequence[@uid = $uidRef]) or (self::ObservationRelationship and //ObservationRelationship[@uid = $uidRef]) or (self::Occurrence and //Occurrence[@uid = $uidRef]) or (self::OccurrenceRelationship and //OccurrenceRelationship[@uid = $uidRef]) or (self::Organization and //Organization[@uid = $uidRef]) or (self::OrganizationOrPersonInOrganizationAssignment and //OrganizationOrPersonInOrganizationAssignment[@uid = $uidRef]) or (self::Part and //Part[@uid = $uidRef]) or (self::PartVersion and //PartVersion[@uid = $uidRef]) or (self::PartVersionRelationship and //PartVersionRelationship[@uid = $uidRef]) or (self::PartView and //PartView[@uid = $uidRef]) or (self::PartViewRelationship and //PartViewRelationship[@uid = $uidRef]) or (self::Person and //Person[@uid = $uidRef]) or (self::PersonInOrganization and //PersonInOrganization[@uid = $uidRef]) or (self::ProcessOperationDefinition and //ProcessOperationDefinition[@uid = $uidRef]) or (self::ProcessOperationDefinitionRelationship and //ProcessOperationDefinitionRelationship[@uid = $uidRef]) or (self::ProcessOperationOccurrence and //ProcessOperationOccurrence[@uid = $uidRef]) or (self::ProcessOperationResourceAssignment and //ProcessOperationResourceAssignment[@uid = $uidRef]) or (self::ProcessPlan and //ProcessPlan[@uid = $uidRef]) or (self::ProcessPlanRelationship and //ProcessPlanRelationship[@uid = $uidRef]) or (self::ProductClass and //ProductConcept[@uid = $uidRef and contains(' ProductClass ',substring-after(@xsi:type,':'))]) or (self::ProductClassRelationship and //ProductClassRelationship[@uid = $uidRef]) or (self::ProductConfiguration and //ProductConfiguration[@uid = $uidRef]) or (self::ProductConfigurationRelationship and //ProductConfigurationRelationship[@uid = $uidRef]) or (self::Project and //Project[@uid = $uidRef]) or (self::ProjectAssignment and //ProjectAssignment[@uid = $uidRef]) or (self::ProjectRelationship and //ProjectRelationship[@uid = $uidRef]) or (self::PropertyDefinitionAssignment and //PropertyDefinitionAssignment[@uid = $uidRef]) or (self::PropertyDefinitionRelationship and //PropertyDefinitionRelationship[@uid = $uidRef]) or (self::PropertyValue and //*[(self::PropertyValue or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::BevelAngle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VerticalProfileHeight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Weight and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RealWorldScale and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaxCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinCrossSectionDiameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MinimumBendRadius and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Fiber11Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ModifierValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::RequiredCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::AnalysedCharacteristic and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::IndexValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::DimensionValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnitLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FirstUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::SecondUnitSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::UnequallyDisposedToleranceZoneDisplacement and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ToleranceValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ForcedLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::LotSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MaterialValue and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::MeasuredCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::VolumePercent and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlannedCharacteristics and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PlyThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::WaitingTime and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::ProjectionLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Offset and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Quantity and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Density and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Height and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Width and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::FileSize and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::PageCount and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TotalThickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Diameter and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetWidth and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TargetLength and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Thickness and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::Angle and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' '))) or (self::TwistPeriod and contains(' PropertyValue  StringValue  ValueList  ValueSet  ValueWithUnit  LimitsAndFits  NumericalValue  ValueLimit  ValueRange  ValueWithTolerances ',concat(' ',substring-after(@xsi:type,':'),' ')))) and @uid = $uidRef]) or (self::PropertyValueAssignment and //PropertyValueAssignment[@uid = $uidRef]) or (self::PropertyValueRelationship and //PropertyValueRelationship[@uid = $uidRef]) or (self::Representation and //Representation[@uid = $uidRef]) or (self::RepresentationItem and //RepresentationItem[@uid = $uidRef]) or (self::Requirement and //Requirement[@uid = $uidRef]) or (self::RequirementAssignment and //RequirementAssignment[@uid = $uidRef]) or (self::RequirementVersion and //RequirementVersion[@uid = $uidRef]) or (self::RequirementVersionRelationship and //RequirementVersionRelationship[@uid = $uidRef]) or (self::RequirementView and //RequirementView[@uid = $uidRef]) or (self::RequirementViewRelationship and //RequirementViewRelationship[@uid = $uidRef]) or (self::SecurityClassificationAssignment and //SecurityClassificationAssignment[@uid = $uidRef]) or (self::Specification and //Specification[@uid = $uidRef]) or (self::SpecificationAssignment and //SpecificationAssignment[@uid = $uidRef]) or (self::SpecificationCategory and //SpecificationCategory[@uid = $uidRef]) or (self::SpecificationCategoryAssignment and //SpecificationCategoryAssignment[@uid = $uidRef]) or (self::SpecificationConditionAssignment and //SpecificationConditionAssignment[@uid = $uidRef]) or (self::SpecificationInclusion and //SpecificationInclusion[@uid = $uidRef]) or (self::SpecificationInclusionAssignment and //SpecificationInclusionAssignment[@uid = $uidRef]) or (self::StyledModel and //Representation[@uid = $uidRef and contains(' StyledModel  AnnotatedModelPresentation  ExternalStyledModel ',substring-after(@xsi:type,':'))]) or (self::TimeIntervalAssignment and //TimeIntervalAssignment[@uid = $uidRef]) or (self::ViewOccurrenceRelationship and //ViewOccurrenceRelationship[@uid = $uidRef]) or (self::WorkOrderAssignment and //WorkOrderAssignment[@uid = $uidRef]) or (self::WorkOrderRelationship and //WorkOrderRelationship[@uid = $uidRef]) or (self::WorkRequestAssignment and //WorkRequestAssignment[@uid = $uidRef]) or (self::WorkRequestRelationship and //WorkRequestRelationship[@uid = $uidRef])">(WorkRequest : <sch:value-of select="$uid"/>) The WorkRequest.Scope contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ActivityAssignmentSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to S) WorkRequest.Status : OPTIONAL ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkRequest') or (self::WorkRequest and not(@xsi:type)))]/Status/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(WorkRequest : <sch:value-of select="$uid"/>) The WorkRequest.Status contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WorkRequestAssignment"><!--(Ref to E) WorkRequestAssignment.AssignedWorkRequest : WorkRequest (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkRequestAssignment') or (self::WorkRequestAssignment and not(@xsi:type)))]/AssignedWorkRequest">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'WorkRequest'] or //WorkRequest[@uid = $uidRef]">(WorkRequestAssignment : <sch:value-of select="$uid"/>) The WorkRequestAssignment.AssignedWorkRequest contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type WorkRequest.</sch:assert>
      </sch:rule>
      <!--(Ref to E) WorkRequestAssignment.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkRequestAssignment') or (self::WorkRequestAssignment and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(WorkRequestAssignment : <sch:value-of select="$uid"/>) The WorkRequestAssignment.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to S) WorkRequestAssignment.Role : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkRequestAssignment') or (self::WorkRequestAssignment and not(@xsi:type)))]/Role/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(WorkRequestAssignment : <sch:value-of select="$uid"/>) The WorkRequestAssignment.Role contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WorkRequestRelationship"><!--(Ref to E) WorkRequestRelationship.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkRequestRelationship') or (self::WorkRequestRelationship and not(@xsi:type)))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(WorkRequestRelationship : <sch:value-of select="$uid"/>) The WorkRequestRelationship.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
      <!--(Ref to E) WorkRequestRelationship.Related : WorkRequest (kind=SINGLE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkRequestRelationship') or (self::WorkRequestRelationship and not(@xsi:type)))]/Related">
         <sch:let name="uid" value="../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="//ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'WorkRequest'] or //WorkRequest[@uid = $uidRef]">(WorkRequestRelationship : <sch:value-of select="$uid"/>) The WorkRequestRelationship.Related contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type WorkRequest.</sch:assert>
      </sch:rule>
      <!--(Ref to S) WorkRequestRelationship.RelationType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='WorkRequestRelationship') or (self::WorkRequestRelationship and not(@xsi:type)))]/RelationType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(WorkRequestRelationship : <sch:value-of select="$uid"/>) The WorkRequestRelationship.RelationType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="WorkRequestRelationship_WR1"><!--(Rule WorkRequestRelationship.WR1)-->
      <sch:rule context="//WorkRequestRelationship"> <sch:let name="uid" value="@uid"/> <sch:assert test="../@uid != Related/@uidRef"> WorkRequestRelationship WR1 Error on entity <sch:value-of select="$uid"/>: the related WorkRequest and the relating WorkRequest shall be different. </sch:assert> </sch:rule>
   </sch:pattern>
   <sch:pattern id="ZonalBreakdown"><!--(Default Value) ZonalBreakdown.BreakdownType : String = 'zonal' (kind=SINGLE - redefined=Breakdown.BreakdownType)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ZonalBreakdown') or (self::Breakdown and substring-after(@xsi:type,':')='ZonalBreakdown'))]/BreakdownType">
         <sch:let name="uid" value="../@uid"/>
         <sch:assert test="ClassString/text() = 'zonal'">(ZonalBreakdown : <sch:value-of select="$uid"/>) The ZonalBreakdown.BreakdownType contains the wrong value () must be 'zonal'.</sch:assert>
      </sch:rule>
      <!--(Ref to S) Breakdown.BreakdownType : ClassSelect (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ZonalBreakdown') or (self::Breakdown and substring-after(@xsi:type,':')='ZonalBreakdown'))]/BreakdownType/*">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="(self::Class and //ExternalRefBaseObject[@uid = $uidRef and contains(' Class ',@typeRef)]) or (self::ExternalOwlClass and //ExternalRefBaseObject[@uid = $uidRef and contains(' ExternalOwlClass ',@typeRef)]) or (self::Class and //Class[@uid = $uidRef]) or (self::ClassString) or (self::ExternalOwlClass and //ExternalOwlClass[@uid = $uidRef])">(ZonalBreakdown : <sch:value-of select="$uid"/>) The ZonalBreakdown.BreakdownType contains a bad reference (<sch:value-of select="$uidRef"/>) must be an element of ClassSelect.</sch:assert>
      </sch:rule>
      <!--(Ref to E) Breakdown.ClassifiedAs : OPTIONAL SET[1:unbounded] OF Classification (kind=AGGREGATE - redefined=false)-->
      <sch:rule context="//*[@uid and ((self::SubObject and substring-after(@xsi:type,':')='ZonalBreakdown') or (self::Breakdown and substring-after(@xsi:type,':')='ZonalBreakdown'))]/ClassifiedAs/Classification">
         <sch:let name="uid" value="../../@uid"/>
         <sch:let name="uidRef" value="./@uidRef"/>
         <sch:assert test="count(../../ClassifiedAs/Classification) = 0 or //ExternalRefBaseObject[@uid = $uidRef and @typeRef = 'Classification'] or //Classification[@uid = $uidRef]">(ZonalBreakdown : <sch:value-of select="$uid"/>) The ZonalBreakdown.ClassifiedAs contains a bad reference (<sch:value-of select="$uidRef"/>) must be of type Classification.</sch:assert>
      </sch:rule>
   </sch:pattern>
   <sch:pattern id="ZoneStructuralMakeupShapeRepresentation"/>
</sch:schema>
